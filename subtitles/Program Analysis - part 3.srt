1
00:00:00,000 --> 00:00:21,679
So, let us start with data flow analysis. So, now in data flow analysis we will start

2
00:00:21,679 --> 00:00:42,200
with four important class of optimizations. The first is what is called liveness analysis.

3
00:00:42,200 --> 00:00:49,200
The second is...

4
00:01:12,200 --> 00:01:33,200
The fourth is, we forget I will come to it later. Liveness organ, available organ, reaching

5
00:01:33,200 --> 00:01:40,200
the

6
00:01:40,200 --> 00:01:51,320
Okay, so let us first try to understand the four analysis. So, liveness analysis says

7
00:01:51,320 --> 00:01:58,079
that if I have a program for every statement I would like to figure out. So, essentially

8
00:01:58,079 --> 00:02:02,400
it says that now I can talk in terms of control flow graphs because you all understand control

9
00:02:02,400 --> 00:02:06,400
flow graphs and for the time being let us assume control flow graphs which have only

10
00:02:06,400 --> 00:02:12,640
single statements just to make our life easier. So, now in liveness analysis what I want to

11
00:02:12,640 --> 00:02:20,680
do is I want to figure out if there is an assignment to a variable x from that point

12
00:02:20,680 --> 00:02:32,319
onwards is there any future use of x or not. Right, why would I be interested to do that?

13
00:02:33,239 --> 00:02:39,120
Because if there is no further use of x along any path from x from this assignment to x

14
00:02:39,120 --> 00:02:48,919
I can simply discard this statement and that is what is called dead code elimination. Right,

15
00:02:48,919 --> 00:02:55,759
the second thing that we would like to talk about is something called reaching definition.

16
00:02:55,759 --> 00:03:04,079
So, what does reaching definition say? Reaching definition says that let us say I have a program

17
00:03:25,759 --> 00:03:39,359
So, look at this particular program. Right, so what I might be interested to figure out

18
00:03:39,359 --> 00:03:47,399
is that whenever you reach this particular basic block this particular expression x times

19
00:03:47,400 --> 00:03:57,560
y has already been computed along all paths. So, essentially it means that oh sorry this is

20
00:03:57,680 --> 00:04:24,560
available expressions. So, this is available expression. So, essentially in this case what

21
00:04:24,560 --> 00:04:34,600
we say is that this expression a star y is available. Right, what it means is why would

22
00:04:34,600 --> 00:04:44,800
I be interested in figuring out some expression is available or not. Right, so essentially for

23
00:04:44,800 --> 00:04:51,540
instance let us say you have something like z equals x star y in that case what is the

24
00:04:51,540 --> 00:05:04,140
optimization you can do? Right, so I can essentially compute I second say h equals x star y h equals

25
00:05:04,140 --> 00:05:13,220
x star y b is equal to h a is equal to h and z is equal to h. Right, so now essentially what has

26
00:05:13,220 --> 00:05:18,140
happened is instead like if you look at every path this path x star y would have been computed

27
00:05:18,139 --> 00:05:24,259
twice this path x star y would have been computed twice, but now with this optimization I am

28
00:05:24,259 --> 00:05:30,419
computing x star y only once. Right, and that temporary value I am being able to reuse multiple

29
00:05:30,419 --> 00:05:36,939
times. Right, so that is an interesting so that is available expressions.

30
00:05:48,139 --> 00:06:11,139
Right, so very busy expression says what very busy expression says that if you have a computation

31
00:06:11,139 --> 00:06:19,659
which is so it says that from this point onwards is there a computation which is happening along

32
00:06:19,659 --> 00:06:28,539
all paths like if there is a computation of x star y here also x star y here also x star y here also

33
00:06:28,539 --> 00:06:35,979
so let us say a is equal to x star y b equals x star y c equals x star y. Then again I can do

34
00:06:35,980 --> 00:06:45,740
something I can hoist up this computation of x star y here I can say h equals x star y and I

35
00:06:45,740 --> 00:06:56,460
can just assign them here. Yeah, so I come to those conditions so that that even holds for

36
00:06:56,460 --> 00:07:01,700
even the other cases I have not come to those let us just I try to understand these different

37
00:07:01,699 --> 00:07:06,019
cases but let us let us say you have talked about it so what is the condition under which it can

38
00:07:06,019 --> 00:07:16,459
happen. So x and y should be unaffected along that path so I should not be I should so these

39
00:07:16,459 --> 00:07:25,659
are modification free. Right, so there should be no updates to x or y only if that happens only then

40
00:07:25,740 --> 00:07:31,460
I can do this so that also holds for available expressions because there were expressions

41
00:07:31,460 --> 00:07:37,220
computed and I can use their values only if again along the path from where I define this

42
00:07:37,220 --> 00:07:47,060
a star b to the place where I used it there is no and reaching definition says that if you have a

43
00:07:47,060 --> 00:08:01,379
variable h equals a star b in that case I say like if you have a use later right say x equals h plus

44
00:08:01,379 --> 00:08:11,980
1 right so then I would say that the definition so essentially whenever you have so what is let's

45
00:08:11,980 --> 00:08:17,019
me just define what is the definition our definition is basically an assignment so whenever you have

46
00:08:17,019 --> 00:08:32,579
x equals b plus c this is a definition of a and these are uses of b and c right so this statement

47
00:08:32,579 --> 00:08:41,220
uses b and c so these are the b the values of b and c are being used and the value of a is being

48
00:08:41,220 --> 00:08:49,899
defined so something is being put into that box right so definition and use so if it is possible

49
00:08:49,899 --> 00:09:01,100
through any program path a definition is being so our definition can reach a certain use then I

50
00:09:01,100 --> 00:09:07,379
would say that it is a it's a reaching definition problem right so again when can it not be a

51
00:09:07,379 --> 00:09:16,299
reaching definition thing like for instance I can have so h equals 2 for instance right there

52
00:09:16,299 --> 00:09:24,299
is a update to x right then so this is a definition point of definition this is d1 this is d t right

53
00:09:24,299 --> 00:09:34,620
so the definition d1 reaches the statement s1 earlier when d2 wasn't there but once I have d2

54
00:09:34,860 --> 00:09:42,860
then the definition does not reach this location so that the reaching definition problem is that

55
00:09:42,860 --> 00:09:50,220
for every in the program or every state program we would like to figure out which are the

56
00:09:50,220 --> 00:09:56,179
definitions which are reaching but location now there may or may not be a use of that location

57
00:09:56,179 --> 00:10:01,100
that's a different matter but I would like to compute it for every program point the other

58
00:10:01,100 --> 00:10:05,259
important definition is I'll keep on using it again is this notion of a program point

59
00:10:05,259 --> 00:10:21,940
so so you have let's say a statement s1 and you have a statement s2 so a program point is a

60
00:10:21,940 --> 00:10:27,340
stable location where I can ask the state of the program so the next question is what is the state

61
00:10:27,340 --> 00:10:40,940
of a program so the state of a program is basically thus the vector containing values

62
00:10:40,940 --> 00:10:57,260
of each variable right so if you have three program variables a b and c so at every program

63
00:10:57,260 --> 00:11:01,260
point I would would like to figure out what is the value of a what is the value of b what is the

64
00:11:01,260 --> 00:11:08,500
value of c so that constitutes one state of a program and a program points are points where

65
00:11:08,500 --> 00:11:14,100
I may be interested in querying the state of a program so this for two statements s1 and s2

66
00:11:14,100 --> 00:11:20,340
the program for valid program points is this one this one and this one so it's either before

67
00:11:20,340 --> 00:11:24,980
the statement has got executed or after the statement has got executed right so whenever

68
00:11:24,980 --> 00:11:31,139
I ask you say what happens at this program at at statement s2 and you said you should tell me that

69
00:11:31,139 --> 00:11:35,860
I don't know what happens at s2 I can tell you what happens before s2 or what happens after s2

70
00:11:35,860 --> 00:11:39,539
what is the state before s2 or what is the state after s2 when the statement is running I don't

71
00:11:39,539 --> 00:11:47,620
know what's going on right so these are runtime behavior but your static analysis is also an

72
00:11:47,620 --> 00:11:52,100
approximation of the runtime behavior right so I will come up with instead of having concrete

73
00:11:52,100 --> 00:11:57,139
states of the runtime remainder I'll have abstract states which essentially say what are the

74
00:11:57,139 --> 00:12:01,779
possibilities that can happen here like for instance I can say that I do not know what is

75
00:12:01,779 --> 00:12:05,299
the value of x there but I'm sure that all the values of x will be greater than zero

76
00:12:06,019 --> 00:12:11,059
right so but that also I have to say at a program point I cannot say at instruction what happens

77
00:12:11,059 --> 00:12:14,500
doesn't really make sense right because things are changing I don't know how they're changing

78
00:12:14,500 --> 00:12:19,860
what is happening so I can only tell you what thing what happens so so whenever I query a state

79
00:12:19,860 --> 00:12:23,620
I can only query a state at a program point I cannot query a state at any other location

80
00:12:23,620 --> 00:12:34,179
so are we clear about the definition of these four statements of these four analysis okay so

81
00:12:34,179 --> 00:12:40,899
let's talk about reaching definitions let's say so how does reaching definition work so essentially

82
00:12:44,659 --> 00:12:47,299
so now how will you so what is the computation on

83
00:12:47,299 --> 00:12:52,339
so what is the set of values that you will try to output

84
00:12:57,539 --> 00:13:05,459
so so you would like to figure out that at any program point you would like to figure out the

85
00:13:05,459 --> 00:13:13,699
set of all reaching definitions so it's a set of all reaching definitions right so so the universal

86
00:13:13,700 --> 00:13:19,940
set from which you will be able to extract this particular set at a given point is the set of all

87
00:13:19,940 --> 00:13:24,900
definitions so what are the set of all definitions in the program how will you get the set of all

88
00:13:24,900 --> 00:13:31,700
definitions in the program all the assignment statements right so all the statements which

89
00:13:31,700 --> 00:13:37,700
assigned to a given variable is a definition what if there are two statements a equal to one here

90
00:13:37,700 --> 00:13:43,620
in one basic block and a equals one here in another basic block are they the same definition

91
00:13:43,620 --> 00:13:52,740
or are they different definitions now we are only doing intra-procedural analysis so they are

92
00:13:52,740 --> 00:13:59,860
everything is in the same function no they constitute different definitions so they will

93
00:13:59,860 --> 00:14:05,140
be d1 and d2 two separate definitions and it may happen that one of them reaches a program point

94
00:14:05,139 --> 00:14:10,179
but the other one does not reach this program point right for instance i may have like a equals

95
00:14:10,179 --> 00:14:21,699
three here or maybe this does not even reach this location right so so my so net let's try to

96
00:14:21,699 --> 00:14:26,980
formalize this whole business so i have my universal set here is the set of all definitions in the

97
00:14:26,980 --> 00:14:34,899
program and i can arbitrarily give names to each definition so d1 d2 d3 d4 d5 i just these are

98
00:14:34,899 --> 00:14:39,939
static names i just look at an instruction and say give it a name which is what what definition

99
00:14:43,379 --> 00:14:48,579
now can you give me some idea of how can i compute this switching definition

100
00:14:49,379 --> 00:14:56,019
how can you compute this set so when can a definition stop reaching anything else

101
00:14:58,100 --> 00:15:01,699
when it is reassigned the same variable is reassigned then it may stop

102
00:15:02,020 --> 00:15:09,060
uh like propagating further the other way it may not reach a given location is if there is no

103
00:15:09,060 --> 00:15:13,140
path that goes from this particular program point to the other program point so there is no way for

104
00:15:13,140 --> 00:15:19,620
this guy to go there right so there are two ways like it's like a car which is moving so the car

105
00:15:19,620 --> 00:15:24,740
may not be able to reach another location either if there does not exist a road which can take it

106
00:15:24,740 --> 00:15:29,860
there or somebody stops it in between right so it says no you cannot go further

107
00:15:30,259 --> 00:15:35,539
okay so now can you think of a way of computing this set of reaching definitions

108
00:15:39,460 --> 00:15:44,100
and maybe you can use the idea of how did we compute the dominators can you extend that idea

109
00:15:44,100 --> 00:15:49,060
somewhat and think of a way of doing it in a slightly more efficient manner so so let's

110
00:15:49,060 --> 00:15:53,379
let's think about the inefficient algorithm first what is the inefficient or the bad algorithm to

111
00:15:53,379 --> 00:15:54,500
compute the reaching definitions

112
00:15:54,500 --> 00:16:05,779
okay collect all um all definitions of the same variable like look for each variable

113
00:16:05,779 --> 00:16:09,779
i can figure out that if it goes to a certain set or not so let's say i give you a program

114
00:16:09,779 --> 00:16:14,179
point and i want to figure out what is the set of reaching definitions here how will you how will

115
00:16:14,179 --> 00:16:22,659
you compute it traverse it okay um then

116
00:16:34,419 --> 00:16:39,620
right so essentially one way to do that is like is basically collect all the program paths which

117
00:16:39,620 --> 00:16:49,139
are reaching from the entry point to this particular location right and for every path

118
00:16:49,139 --> 00:16:53,779
figure out which is the set of definitions reaching here and take a union over all of them

119
00:16:55,860 --> 00:17:01,860
this solution is referred to as the mop solution or the meet of all paths solution so meet means

120
00:17:01,860 --> 00:17:07,299
you are just taking a union over the solutions over different paths how do you figure out

121
00:17:07,940 --> 00:17:14,579
the solution over one path so now let's simplify our case now we take a union over all paths so

122
00:17:14,579 --> 00:17:19,859
now let's try to figure out how would you compute reaching definitions on a single path on one given

123
00:17:19,859 --> 00:17:23,779
path so how can you do that

124
00:17:30,980 --> 00:17:36,980
so let's current means the beginning entry point no the are you saying one from where it is now

125
00:17:36,980 --> 00:17:41,460
down here okay okay okay then

126
00:17:41,460 --> 00:18:05,140
Mason

127
00:18:05,140 --> 00:18:12,140
any any other ideas? Why not go forward?

128
00:18:12,140 --> 00:18:27,000
Right, but you will be able to get the whole set in one shot. Right, so you start with

129
00:18:27,000 --> 00:18:34,359
saying the set being empty, whenever I get a new, if I get a statement of the form A

130
00:18:34,359 --> 00:18:43,200
equals B plus C, what would you do? How will you update this state? I will put A in this

131
00:18:43,200 --> 00:18:52,759
set and keep on going down. Right, so if you get another A equals, like

132
00:18:53,640 --> 00:18:58,480
sorry I have to say that A was there and I will have to remember that it is like because

133
00:18:58,480 --> 00:19:02,879
it is definition D1, that is what I need to output, not A. Right, so if I get a definition

134
00:19:02,879 --> 00:19:11,200
D2 with A again, so here I will say D1 is in the set for variable A. Right, so when

135
00:19:11,200 --> 00:19:17,240
you get D2, you will have to remove this out and you say now I know that this is D2 which

136
00:19:17,240 --> 00:19:23,039
is the most recent definition of A. So when you reach here, you keep on doing it, so you

137
00:19:23,039 --> 00:19:26,839
will then you will have the most recent definitions for all variables in the program along that

138
00:19:26,839 --> 00:19:47,200
path. Can this work? So right now we are assuming there is only one path because we are thinking

139
00:19:47,200 --> 00:20:00,039
of this particular solution. But so are you convinced about this particular solution?

140
00:20:00,039 --> 00:20:18,680
Will this work? After this particular definition, after that statement, there is another definition

141
00:20:18,680 --> 00:20:28,200
A, yeah, yeah but that is another path, right, that becomes another path. So path is a sequence

142
00:20:28,200 --> 00:20:32,240
of instructions, so one path would have terminated here, the other path would have gone through

143
00:20:32,240 --> 00:20:37,880
this and come back here. So this, the problem, you can immediately see the problem here,

144
00:20:37,880 --> 00:20:42,880
there can be infinite paths. So immediately understand this solution is not going to work

145
00:20:42,880 --> 00:20:50,319
for us. But still, I mean, let us do the stupid thing first before we do something else. But

146
00:20:50,319 --> 00:20:54,680
at least we know that if given a path, we have a not so bad algorithm to compute the

147
00:20:54,680 --> 00:21:02,560
strategic definitions. Now let us try to extend this algorithm to something slightly more

148
00:21:02,559 --> 00:21:28,200
doable. So what can we do? So now let us say we have a control flow graph

149
00:21:29,039 --> 00:21:34,279
out what are the reaching definitions at this location. So at this location, maybe at this

150
00:21:34,279 --> 00:21:56,279
location. No. So this guy is not dominating it. But if there is a definition of A equals

151
00:21:56,279 --> 00:22:00,559
something that will also reach here, because there is a path through this and there is

152
00:22:00,559 --> 00:22:07,960
nobody stopping it here. Okay, so we start, so let us do a full summary once more, right.

153
00:22:07,960 --> 00:22:15,559
First, we are looking at this problem of reaching definitions. What is this problem of reaching

154
00:22:15,559 --> 00:22:21,000
definitions? The problem of reaching definition is that at any program point, I would like to

155
00:22:21,000 --> 00:22:29,960
figure out what is the set of definitions which are reaching this program point. Question was,

156
00:22:29,960 --> 00:22:37,279
what is the definition? A definition is something of the form D equals or A equals B plus C. A

157
00:22:37,279 --> 00:22:48,000
equals B plus C is a definition of A because it is assigning a value to A. Every such assignment,

158
00:22:48,000 --> 00:22:53,400
every such lexically different instruction in the program, no matter they look alike or they look

159
00:22:53,400 --> 00:23:01,519
different, constitutes a different definition. Now in my program, I can construct my universal

160
00:23:01,519 --> 00:23:08,599
set. That is a set of all definitions in the program. How? By simply collecting all the

161
00:23:08,599 --> 00:23:16,400
assignments to these, all these assignments to this in the program. So every time I get A equals

162
00:23:16,400 --> 00:23:21,600
B plus C, C equals A plus B plus A, I mean all of them I just collect and that becomes my set of

163
00:23:21,600 --> 00:23:28,880
all possible definitions. That is my universal set. Now what we want to do is, I would like to figure

164
00:23:28,880 --> 00:23:34,040
out that what are the set of definitions reaching a particular program point. Let us say this

165
00:23:34,040 --> 00:23:43,640
particular program point. How would we do that? So one solution we first figured out was a solution

166
00:23:43,640 --> 00:23:50,000
which is not even practical, but one way to do that would have been that I figure out all possible

167
00:23:50,000 --> 00:23:56,640
paths to that location from the program entry point. Along every path, every path is nothing

168
00:23:56,640 --> 00:24:02,120
but a sequence of instructions. Along every path, I collect what are the definitions which finally

169
00:24:02,120 --> 00:24:13,080
reach the final location. So how do we do that? So in the path, I start with an empty set. I say

170
00:24:13,079 --> 00:24:19,599
I do not know what all is there. Whenever I encounter a statement of the form A equals B

171
00:24:19,599 --> 00:24:35,679
plus C, then what do we do? We add this definition D1 as the new definition which may reach the final

172
00:24:35,679 --> 00:24:42,480
location. But at the same time, if this A redefines, if this particular definition redefines some other

173
00:24:42,480 --> 00:24:47,279
definition, that definition has to be removed from the set. So at every point we do two things.

174
00:24:47,279 --> 00:24:55,200
We do something called generation which is we add something to this set and we do something

175
00:24:55,200 --> 00:25:01,360
called killing which is we kill something of the set. We remove something of the set. What do we

176
00:25:01,360 --> 00:25:09,799
generate? The new definition that I encounter and what do we kill? Any existing definition to the

177
00:25:09,799 --> 00:25:19,039
same variable. So my set will always contain. So that is what this thing is. So these are the two

178
00:25:19,039 --> 00:25:28,079
steps that I have to keep on checking. What to generate and what to kill. Now can we extend?

179
00:25:28,079 --> 00:25:33,200
Now the question is instead of a sequence of statements, if we have a complex control flow,

180
00:25:33,200 --> 00:25:40,799
can we answer this question in somewhat not so expensive manner? So let us see what is the

181
00:25:40,799 --> 00:25:48,840
problem here. Till this point there is no issue at all. I can start with an empty set. Whatever

182
00:25:48,840 --> 00:25:56,080
definition is in this basic block, I add it to this set. Again I go to this particular location.

183
00:25:56,080 --> 00:26:01,200
Whatever is in this set, I generate the new instruction and if it redefines something which

184
00:26:01,200 --> 00:26:10,160
was in the previous basic block, I kill it. The problem is here. Whenever these two basic

185
00:26:10,160 --> 00:26:15,360
blocks merge at a basic block, what do I say is the reaching definition here at the entry to this

186
00:26:15,360 --> 00:26:20,440
basic block? That is just before the statement contained in this basic block. What should I do?

187
00:26:20,440 --> 00:26:29,000
I need to keep both. Excellent. Why is that? Because if there is a A equal to this and A

188
00:26:29,000 --> 00:26:33,759
equal to this, then both of them are reaching definition to this particular location. Both of

189
00:26:33,759 --> 00:26:40,880
them are reaching here. So what should I do? So I have a set here, I have a set here, so I need

190
00:26:40,880 --> 00:26:53,079
to take the union of the sets. So essentially what we do is, so one way of visualizing this

191
00:26:53,079 --> 00:27:01,519
whole business is that you can think that every definition is generating a token stamped with that

192
00:27:01,519 --> 00:27:09,220
location, the program point where it is generated. And then we leave these tokens to flow in the CFG.

193
00:27:09,220 --> 00:27:18,839
If it hits another location which has a token marked for the same variable or a statement

194
00:27:18,839 --> 00:27:24,079
which redefines the token for that variable, that token gets killed, it gets thrown out.

195
00:27:24,079 --> 00:27:30,439
Whenever it gets to a position where it can go in both the directions, either of the two

196
00:27:30,439 --> 00:27:37,279
directions, what does it do? It propagates a token in both the directions. And if there is a

197
00:27:37,279 --> 00:27:41,919
location where I have multiple arrows coming in, then I collect the tokens along all the directions.

198
00:27:41,919 --> 00:27:47,480
I keep on doing this collection of tokens and at any location what is the set of tokens I have

199
00:27:47,480 --> 00:27:52,160
becomes my set of reaching definitions. All the predecessors means how would you do it,

200
00:27:52,160 --> 00:27:59,000
how will you update this guy saying what definitions were there? So this algorithm,

201
00:27:59,000 --> 00:28:05,279
I would like to get the set of all reaching definitions at all program points, not at one

202
00:28:05,279 --> 00:28:11,460
program point. In one shot like the way we were computing dominators, we wanted to get the

203
00:28:11,460 --> 00:28:17,120
dominator tree which means I need to compute the dominators for all instructions or all

204
00:28:17,119 --> 00:28:21,919
statements. Similarly, here I would like to get the reaching definition set for all locations.

205
00:28:24,799 --> 00:28:30,199
So this algorithm is very similar to the dominator algorithm. So we compute something and extend it

206
00:28:30,199 --> 00:28:34,159
slightly for the next location, extend it slightly for the next location and keep on

207
00:28:34,159 --> 00:28:42,079
doing it till my full flow graph is full. So essentially what we do is there is a flow

208
00:28:42,079 --> 00:28:49,799
of information forward because we move from one basic block and the tokens move downwards

209
00:28:49,799 --> 00:28:57,839
and whenever we collect these tokens what we do is we take a union of them.

210
00:28:57,839 --> 00:29:14,000
Right? Okay. Do you sort of at least intuitively understand this algorithm? Can we try writing

211
00:29:14,000 --> 00:29:20,359
out or maybe it is too early but let us try. Can we try to write some equation like we

212
00:29:20,359 --> 00:29:31,359
wrote for dominators? So if I want to write the reaching definition at a node n, at a node n,

213
00:29:31,359 --> 00:29:37,719
maybe I just say it is just after the node has executed, after the statement has executed. So

214
00:29:37,720 --> 00:29:50,880
how do I write it? Right. So there are two things. So let us assume that I can say that if it is,

215
00:29:50,880 --> 00:30:11,400
let us say entry to the node, entry to n or it is exit from n. Has it become too bad? Still

216
00:30:11,400 --> 00:30:28,960
reach readable? Tell me when it is too, not very good at, let me type it here. Okay. So entry to n,

217
00:30:28,960 --> 00:30:42,840
what are we going to do? When take a union over, union over predecessors of, where p is basically

218
00:30:42,840 --> 00:30:52,440
the predecessors of n and I take this thing over the reaching definition of p. Okay. And what about

219
00:30:52,440 --> 00:31:01,320
at the exit? So now you can assume that I have the reaching definition of like n begin. You

220
00:31:01,320 --> 00:31:21,640
already have this, then how can I use it? Excellent, excellent. Do you all agree? So

221
00:31:21,640 --> 00:31:33,720
what I will do is I will just say this is RD of n begin, union the set of statements that are

222
00:31:33,720 --> 00:31:39,960
generated. So let us say I have gen of n, which is saying the set of statements generated at this

223
00:31:39,960 --> 00:31:48,520
node minus kill of n, which essentially says what are the set of definitions or did I screw it up,

224
00:31:48,519 --> 00:31:57,960
I should have done it the other way. Hoping that it will not create a problem, but still. So I just

225
00:31:57,960 --> 00:32:10,759
kill the definitions which are in this set and then union with gen. If there is self loop and

226
00:32:10,759 --> 00:32:15,759
something I do not want to screw up. This, do you sort of understand what is going on? Okay.

227
00:32:15,759 --> 00:32:22,640
Now let us come to liveness analysis. So what is liveness analysis? I would like to find out the

228
00:32:22,640 --> 00:32:35,680
set of statements which are. So again, how do I do liveness analysis? I want to find, so for any

229
00:32:35,680 --> 00:32:45,600
location. So now let us look at liveness analysis. So again recap what is liveness analysis? So

230
00:32:45,600 --> 00:32:53,880
liveness analysis is that at any program point, I would like to find out that what are the set

231
00:32:53,880 --> 00:33:12,600
of variables which have a use in the future. So in this case, what is my universal set? Set of all?

232
00:33:12,600 --> 00:33:22,360
No, this is liveness analysis. So liveness analysis tells me liveness analysis. It just

233
00:33:22,359 --> 00:33:30,699
says what are the variables which are live at a given location. Set of all variables. So this is

234
00:33:30,699 --> 00:33:42,199
set of all variables. And what I want to figure out is that which of these variables have a use

235
00:33:42,200 --> 00:34:00,680
in the future. How can I do this analysis? How can I set it up? Till the end. Till the end. So it has no future

236
00:34:00,680 --> 00:34:07,039
use. It means that I can, like for instance, as I said, we can do dead code elimination. Like if there

237
00:34:07,039 --> 00:34:13,119
is a definition of a variable and it has no further use, then that is dead code and I can delete it.

238
00:34:13,119 --> 00:34:22,239
Yeah, so to begin with, we will not care about that I am going to use it in dead code elimination.

239
00:34:22,239 --> 00:34:26,159
When we are doing the analysis, we should not worry about what the optimizations. We just ask

240
00:34:26,159 --> 00:34:31,820
a question and we should be able to answer that question. Right now the question is that what are

241
00:34:31,820 --> 00:34:37,980
the variables which are live from this location. Yes, I want to find out what variables like,

242
00:34:37,980 --> 00:34:46,400
what are the set of variables which have a future use. See available expressions. Come to available

243
00:34:46,400 --> 00:34:55,620
expressions or, okay. So let us say available expressions. What does available expressions

244
00:34:55,619 --> 00:35:01,799
compute? Available expression computes. I will say an expression is available at this location

245
00:35:01,799 --> 00:35:11,339
if that expression has been computed along all paths reaching this location. So what is the

246
00:35:11,339 --> 00:35:22,739
universal set in case of available expressions? All the set of expressions. Here it is a set of

247
00:35:22,739 --> 00:35:28,259
all variables. But you do not care about what expression it is. It has been used,

248
00:35:28,259 --> 00:35:32,939
it has been used, that is it. It has been used in A plus B or used in A minus B or A star B.

249
00:35:32,939 --> 00:35:38,019
How does it matter? It has been used, that is all we care about. Okay, so now think in a slightly

250
00:35:38,019 --> 00:35:42,939
different manner. Think in a similar way we talked about this token business. We generate a token and

251
00:35:42,939 --> 00:35:50,259
try to flow it. So where will I generate a token and how will I flow it? Excellent, very nice,

252
00:35:50,260 --> 00:35:56,060
very very nice. So okay, now we have an algorithm. So the algorithm is that we,

253
00:35:56,060 --> 00:36:06,260
so what is the set of the set of live variables at the exit to the program? Nothing, empty set,

254
00:36:06,260 --> 00:36:11,980
because well I am done with the program so nothing is going to be used anymore. And then

255
00:36:11,980 --> 00:36:19,340
what I can do is for the statement before it, for the statement before it, how can I construct the

256
00:36:19,820 --> 00:36:26,900
set of available, set of live variables? So let us say I have a statement of the form A equals B

257
00:36:26,900 --> 00:36:39,260
plus C. V and C are used, very good. So B and C are used, so these will get added to the set or

258
00:36:39,260 --> 00:36:47,220
these are generated when we go through this particular statement. And anything else? A

259
00:36:48,219 --> 00:36:54,379
was not there, yeah, that is okay, but I want to like now let us say that okay, I should not

260
00:36:54,379 --> 00:37:02,459
confuse you. So let us say I know what happens at exit. Now let us say I have the set of live

261
00:37:02,459 --> 00:37:09,619
variables at this location and I want to find out the set of live variables at this location.

262
00:37:09,619 --> 00:37:17,500
And this is a statement A equals B plus C. I have to kill the use of A, why is that? Because

263
00:37:17,500 --> 00:37:24,659
think about it, so if you have A equals 1 and again I say A equals 2, the value that got set

264
00:37:24,659 --> 00:37:31,699
in this A equals 1 has no use because immediately I set A to 2. So this is as good as any other

265
00:37:31,699 --> 00:37:37,900
place, any other thing, it is as good as not setting it at all. So if I redefine a value,

266
00:37:37,900 --> 00:37:46,220
if I redefine a variable, then the old value is lost. So it is no point computing that old value.

267
00:37:46,220 --> 00:37:51,300
So if there was a statement which let us say instead of 1 it was an expensive statement

268
00:37:51,300 --> 00:37:58,300
foo, that some function was computed and it computed some foo and after that I set A to 2,

269
00:37:58,300 --> 00:38:07,780
what is the point of doing A equal 2? Make sense? So whenever I get a definition,

270
00:38:07,780 --> 00:38:19,900
I would kill the definition A, whatever has been is being redefined. So what is my generated sets?

271
00:38:19,900 --> 00:38:25,100
The whatever is being used in the expression in the statement are the generated set, what is the

272
00:38:25,099 --> 00:38:33,420
kill set? Whatever is being defined is going to be the kill set. So again this analysis,

273
00:38:33,420 --> 00:38:42,420
how does it flow? It flows backwards. I have defined how to generate and kill statements.

274
00:38:42,420 --> 00:38:58,420
What about if you hit a statement like this? So if particular statement has multiple predecessors,

275
00:38:58,420 --> 00:39:10,500
then what do you do? You have propagated to both of them and if the other thing happens,

276
00:39:10,500 --> 00:39:29,739
that multiple statements have the same predecessor, then what should I do? Union,

277
00:39:29,739 --> 00:39:37,019
because what is the definition? The definition is if it is used in any path going through the

278
00:39:37,019 --> 00:39:48,739
from that location. So this is union, available expression. So what is my universal set? You

279
00:39:48,739 --> 00:39:53,539
guys told me that instead of all expressions in the formula. Now the same business if I ask you,

280
00:39:53,539 --> 00:40:07,259
if you have a statement A equals B plus C, how will you handle it? So where do you know

281
00:40:07,259 --> 00:40:17,619
the set of available expressions? Where is it known already? What is the set of available

282
00:40:17,619 --> 00:40:21,500
expressions? Like for instance, like variables you could say that the exit of the program,

283
00:40:21,500 --> 00:40:26,219
nothing is live because nothing gets used after that. You really nothing gets used because I just

284
00:40:26,219 --> 00:40:34,340
have never. Here do you see where is it? Which location you already know the set of available

285
00:40:34,340 --> 00:40:40,900
expressions? So now can you think of this analysis? How will this go? Okay, good, good,

286
00:40:40,900 --> 00:40:46,260
good, good, good, good. Intersection wise that because it should be coming from all possible

287
00:40:46,260 --> 00:40:51,380
paths. So I will take an intersection ensure that available means it is surely available.

288
00:40:51,380 --> 00:40:55,920
I am surely computed it. So I should not miss out on any path through which it has not been

289
00:40:55,920 --> 00:41:03,900
computed. So I take a intersection over all paths and the flow is forward or backward? Forward.

290
00:41:03,900 --> 00:41:10,260
And how do I do this particular thing? A equals B plus C. So how what is my how do I generate a

291
00:41:10,260 --> 00:41:17,460
statement? How do I generate a data flow and how do I kill a data flow? So what is the statement

292
00:41:17,460 --> 00:41:22,780
when I do A equals B plus C? Let us say I know what is the set of available expressions at N1.

293
00:41:22,780 --> 00:41:29,700
How do I get available expressions at N2? How do I do that? So what is what gets generated here?

294
00:41:29,700 --> 00:41:38,340
Yeah, the expression B plus C gets generated here. What gets killed? Not uses. Right. So all

295
00:41:38,340 --> 00:41:43,579
previous expressions, whichever expressions were there, which contained A, those are killed

296
00:41:43,579 --> 00:41:47,700
because they are no more available. I computed them with some value of A, but the value of A

297
00:41:47,700 --> 00:41:51,940
has changed now. So it is not the same value that I computed them with. So I cannot use that value

298
00:41:51,940 --> 00:41:56,220
anymore. Remember what we wanted to do? We wanted to store it in a temporary and use that value,

299
00:41:56,220 --> 00:42:01,059
but it was computed with the whole value of A. Now the value of A has changed. So that value cannot

300
00:42:01,059 --> 00:42:09,500
be used again. So my kill will be all expressions with A containing A. All of them get killed.

301
00:42:12,579 --> 00:42:20,699
So again, this is a forward analysis. This I flow the tokens forward. The generating set is the set

302
00:42:20,699 --> 00:42:28,980
of all the expression that gets computed at that state and kill are all expressions assigned to

303
00:42:28,980 --> 00:42:35,340
any or that variable is assigning. Whatever that variable is assigning to, all expressions with

304
00:42:35,340 --> 00:42:41,179
that particular variable participating gets killed, gets removed from the set. No definitions. Here

305
00:42:41,179 --> 00:42:46,460
is the set of expressions. Now the data flow facts are expressions, set of expressions.

306
00:42:46,460 --> 00:42:52,260
No, no, no. So again, let us go at the, so whenever you have an expression, like you have

307
00:42:52,260 --> 00:43:01,700
z equals A plus B, then this is a definition of z and these are the uses of A. So whatever

308
00:43:01,700 --> 00:43:12,540
variables are used in that expression gets killed. All variables which are, okay, so maybe let us

309
00:43:12,540 --> 00:43:21,700
use this term, like A equals B plus C. So A is being defined. So all expressions which have A

310
00:43:21,699 --> 00:43:33,739
as a used variable, as A where A is being used will get killed. And is it, or what we do at,

311
00:43:33,739 --> 00:43:42,059
like wherever I need to combine multiple data flow facts when I have multiple predecessors?

312
00:43:42,059 --> 00:43:59,699
So what should I do? I think we have already discussed it, right? It is intersection. Because

313
00:43:59,699 --> 00:44:04,460
I want to make sure that it is surely available along all paths. It is like no matter where I

314
00:44:04,460 --> 00:44:10,820
come from, it is there. What about very busy expressions? So what do very busy expressions

315
00:44:10,820 --> 00:44:22,100
say that from a given location I want to figure out what are the expressions which are surely

316
00:44:22,100 --> 00:44:27,700
computed. So these expressions are very busy. I mean they are always being computed again and

317
00:44:27,700 --> 00:44:35,620
again, right? So in that case what I can do is, why would I like to do this optimization? How does

318
00:44:35,619 --> 00:44:55,980
it help? Because the, I know, but still I am computing it only once along all paths. Okay,

319
00:44:55,980 --> 00:45:04,460
that is one idea. But again, they may not be the same if statement. They may be, no, you cannot do

320
00:45:04,460 --> 00:45:08,539
that. I am sorry. You cannot do that because somebody else might be using that statement. Oh,

321
00:45:08,539 --> 00:45:15,539
you can use the statement structure you are saying. Sure, sure, sure, sure, sure. But what

322
00:45:15,539 --> 00:45:23,300
does it help with? It does not help the computation cost. That comparison, okay, fine. But other than

323
00:45:23,300 --> 00:45:28,579
that what it does is mainly reduce code size. The same code of A plus B is happening multiple times.

324
00:45:28,579 --> 00:45:35,139
It can be large expression and then you just do it once. But it is a nice classic analysis. So

325
00:45:35,139 --> 00:45:53,500
we will keep it. Now how do I do this? So here how can I do this analysis? Excellent.

326
00:45:54,099 --> 00:46:05,500
Intersection of and so the flow is backwards because I have to do it. And what is the gen and

327
00:46:05,500 --> 00:46:10,460
kill? The expression being generated is a gen. So it is very similar to available expressions,

328
00:46:10,460 --> 00:46:15,059
right? Because I again want to say that I want to waste it up so that I can compute it once and

329
00:46:15,059 --> 00:46:19,099
all the branches I end up using that value. So when does it get killed? When the expression

330
00:46:19,099 --> 00:46:25,579
does not, it is not valid anymore. Re-definition to one of the variables values, expression

331
00:46:25,579 --> 00:46:31,259
variables values. So the same, it is the same business. So these are four very different

332
00:46:31,259 --> 00:46:38,019
analysis. But can you see some commonality here? There is a lot of commonality, right? There is,

333
00:46:38,019 --> 00:46:44,539
it is almost the same structure, right? So that is the cool part about data flow analysis.

334
00:46:44,539 --> 00:46:50,820
Now to get an image, okay. So essentially now we have reaching definitions which we have

335
00:46:50,820 --> 00:46:57,940
available expressions, we have very busy expressions and we have liveness analysis,

336
00:46:57,940 --> 00:47:07,179
right? So we have one aspect is the direction in which I need to move my analysis. In reaching

337
00:47:07,179 --> 00:47:20,779
definition I move it forward. In available expression, forward. Very busy expression

338
00:47:20,779 --> 00:47:31,179
backwards and liveness analysis backward. So the meet operator, what do I do when multiple

339
00:47:31,179 --> 00:47:35,579
flows meet either in a backward direction or in the forward direction, right? So reaching

340
00:47:35,579 --> 00:47:48,980
definition what do we do? Union. Available expressions? Available expressions surely

341
00:47:48,980 --> 00:47:56,819
must be available. Intersection. Intersection. Very busy expression surely must be there

342
00:47:56,820 --> 00:48:12,260
in all blocks. Available liveness analysis should be used along some path. Union, right? So these are,

343
00:48:12,260 --> 00:48:29,300
these unions are some path or any path and these are all paths. Then there is how to compute the

344
00:48:29,300 --> 00:48:40,020
gen and the kill sets, right? And then there is this question of the universal set. So the data

345
00:48:40,019 --> 00:48:47,420
flow facts. So the facts in this case in reaching definitions they are what? They are definitions.

346
00:48:47,420 --> 00:48:53,340
In available expression they are expressions. In very busy expression they are expressions

347
00:48:53,340 --> 00:49:09,139
and liveness analysis they are variables. Agreed? So now for all this analysis can I try to write

348
00:49:09,139 --> 00:49:17,420
a unified equation? So either forward or backward it sort of accumulates. So there are two things.

349
00:49:17,420 --> 00:49:24,500
One is either at the forward point or at the backward point the data flow facts are accumulated

350
00:49:24,500 --> 00:49:37,900
using the meet operation. That is one part, right? So one is accumulation. The second part is that

351
00:49:38,019 --> 00:49:45,059
once I have accumulated these values I need to say that what is going to be the value of that,

352
00:49:45,059 --> 00:49:52,300
of the set the data flow facts after I cross the basic block, right? This is something referred

353
00:49:52,300 --> 00:50:02,579
to as a transfer form. So it says that if I know the data flow facts either at the beginning or

354
00:50:02,579 --> 00:50:07,579
end of the basic block how do I move it to the end or beginning of the basic block respectively?

355
00:50:07,579 --> 00:50:15,340
That is how do I transfer it through the basic block, right? So what does the transfer function

356
00:50:15,340 --> 00:50:29,940
for all of them look like? Gen of n minus, sorry, sorry, sorry, I should have, where is the value?

357
00:50:29,940 --> 00:50:50,220
Still of n union gen of n. Really interesting, right? Four different problems. All of them

358
00:50:50,220 --> 00:50:57,700
have looking transfer function. And what is the accumulation thing? It just basically does

359
00:50:57,699 --> 00:51:09,939
either meet or union or intersection over either the successor or the predecessor of the previous

360
00:51:09,939 --> 00:51:20,179
or the next set of data flow facts. So the question now is that if there is and no matter

361
00:51:20,179 --> 00:51:25,139
what, no matter which data flow analysis you come up with you will see a very similar structure.

362
00:51:25,139 --> 00:51:29,219
What can change is the transfer function may look very different, the meet operator might

363
00:51:29,219 --> 00:51:36,859
look very different, but the idea would sort of remain the same, right? So if that is the case,

364
00:51:36,859 --> 00:51:46,379
the question is can we come up with a unified model of such analysis, right? Which will say

365
00:51:46,379 --> 00:51:51,619
that okay now if this is algorithm you can use, you can plug in your version of the transfer

366
00:51:51,619 --> 00:51:58,659
function, you can plug in your version of the meet operator, you can plug in like the direction

367
00:51:58,659 --> 00:52:03,579
which way you want the data flow analysis to work, but everything else I will take care of,

368
00:52:03,579 --> 00:52:09,219
right? How do I propagate it, which order I do it, when do I say I have computed the whole thing

369
00:52:09,219 --> 00:52:31,339
and so on. Yes, that is a very good question. So yeah, so we also have to plug in the initial

370
00:52:31,339 --> 00:52:37,299
set and for the moment I would say that for case to case basis you should see for yourself

371
00:52:37,580 --> 00:52:45,940
which works, the empty set works or the universal set works. Can you give some idea of which one

372
00:52:45,940 --> 00:52:52,660
will work? So initial set is like for the first or the last basic block. Now again we have the

373
00:52:52,660 --> 00:52:56,660
same problem if you look at it, right? We have the same problem that we had with dominators.

374
00:52:56,660 --> 00:53:05,100
I can apply a very similar algorithm for every node essentially now if I say that let's say right

375
00:53:05,099 --> 00:53:10,019
pick it for something it is easier to do it than let's say reaching definition. So for reaching

376
00:53:10,019 --> 00:53:24,819
definition for a given node n, now the equation turns out to be you take a union over the

377
00:53:24,820 --> 00:53:41,220
predecessors r d of p, right? Minus for you subtract what happens at that particular node

378
00:53:41,220 --> 00:53:52,980
n and you union with the gen of that n, right? So for every node n you can come up with such

379
00:53:52,980 --> 00:54:01,059
a equation. Agreed? So the problem is that there is a r d here sitting here and there is a r d

380
00:54:01,059 --> 00:54:08,659
sitting here, right? And not just that I mean this p can like if what if there is a self loop,

381
00:54:08,659 --> 00:54:14,539
I can immediately see that there is n can occur in both sides, right? And even if there is a

382
00:54:14,539 --> 00:54:19,139
longer cyclic loop there will be a transit dependency. Eventually I mean you will compute

383
00:54:19,139 --> 00:54:24,420
some value which through that cycle will again propagate and affect this value again. Again for

384
00:54:24,420 --> 00:54:32,259
this particular business I have to do this fixed point computation. The problem is dominators we

385
00:54:32,259 --> 00:54:37,099
could get away with removing the back edges in this case we cannot get away with removing the

386
00:54:37,099 --> 00:54:44,699
back edges, right? So essentially the way you will do it is you will keep on applying these

387
00:54:44,699 --> 00:54:50,939
equations again and again and again and again till it comes to a stage where even if you go

388
00:54:50,939 --> 00:54:57,419
through all the nodes apply the equations again it will not create any change to the whole algorithm,

389
00:54:57,419 --> 00:55:03,579
right? So now the question is that if I am going to do that I need to initialize my sets the initial

390
00:55:03,579 --> 00:55:10,980
sets. What are going to be my initial sets? So for liveness analysis like maybe so that is homework.

391
00:55:11,380 --> 00:55:16,460
For each of these cases can you figure out what are going to be your initial sets? What should

392
00:55:16,460 --> 00:55:21,019
you initialize every basic block width? Of course I mean there will be exception the top most or the

393
00:55:21,019 --> 00:55:25,300
bottom most will be initialized slightly differently because you already know that set. The others you

394
00:55:25,300 --> 00:55:34,740
have to initialize to either the empty set or the full set the universal set. So which case what you

395
00:55:34,739 --> 00:55:46,979
have to initialize it. So that is something you have to think about. So now I will just leave

396
00:55:46,979 --> 00:55:55,019
with this. Can we write out this algorithm very quickly? What would this algorithm look like?

397
00:55:55,019 --> 00:56:03,099
Or maybe we will do it tomorrow. I think we are already cross time. So have it in your just in

398
00:56:03,099 --> 00:56:09,339
your head try to get this going. Try to come up with a clean formulation of what this algorithm

399
00:56:09,339 --> 00:56:13,659
might be doing. Tomorrow first thing we will do is we will try to see if we can we will try to

400
00:56:13,659 --> 00:56:18,980
actually write down the algorithm and then we will argue about it. What does it why is it correct to

401
00:56:18,980 --> 00:56:23,539
do something like this? Why do you think it will compute the correct solution? Why do you think it

402
00:56:23,539 --> 00:56:31,460
will terminate? What will happen? So we will try to analyze that. Also try to use LLVM play with it.

403
00:56:31,780 --> 00:56:38,539
See what it looks like tomorrow. We will look at how the statements in LLVM look like. And then

404
00:56:38,539 --> 00:56:44,780
we will try to implement a data flow analysis. So my plan is actually that for the motivating

405
00:56:44,780 --> 00:56:49,059
example we saw in the class today, which was giving different results on GCC and different

406
00:56:49,059 --> 00:56:53,900
result on Clang. We would like to analyze that particular program automatically and try to figure

407
00:56:53,900 --> 00:56:59,699
out what the problem is. So we will try to write a data flow analysis to do that and then we will

408
00:56:59,699 --> 00:57:08,219
try to write a dynamic analysis to do that. So I know it's a little short time and I give my

409
00:57:08,219 --> 00:57:14,579
students a lot more time but if you have to somehow get used to LLVM. Try out a few things,

410
00:57:14,579 --> 00:57:20,579
struggle a bit that's okay. But get used to LLVM so that tomorrow we can do something more fun.

411
00:57:20,579 --> 00:57:31,539
So any questions still here? So the summary is that we looked at four different analysis and

412
00:57:31,539 --> 00:57:39,579
you can find out there is lot of things which are very common. So we want to extract out those

413
00:57:39,579 --> 00:57:46,340
things and try to come up with a unified algorithm which works for all of them when we plug in the

414
00:57:46,340 --> 00:57:50,820
right parameters, the right transfer function, the right meet operator, the right initializations,

415
00:57:50,820 --> 00:57:54,180
everything else will just work magically.

