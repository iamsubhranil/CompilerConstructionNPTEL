1
00:00:00,000 --> 00:00:14,939
Is this, can I, if I am going to the next P2, can I go to the next code or you guys,

2
00:00:14,939 --> 00:00:21,679
you have copied the basic piece of code right? Okay, so you can clearly see the difference

3
00:00:21,679 --> 00:00:28,440
right? So, anyone who is not able to see that, anyone

4
00:00:28,440 --> 00:00:35,840
who is not able to run the first version of P1 yet and need help, the reason why I said

5
00:00:35,840 --> 00:00:48,840
if you say no I do not want to do then that is hard but.

6
00:00:48,840 --> 00:00:53,200
100 to 500 elements. 100 to 500 elements.

7
00:00:53,200 --> 00:01:01,640
Having trouble with it? Fine, then allocate two dimensional, I mean on heap if you can.

8
00:01:01,640 --> 00:01:07,640
Put it global. Put it global, sure, that is simpler. For

9
00:01:07,640 --> 00:01:10,800
the time being, I mean in general you should follow all the program practices, our goal

10
00:01:10,800 --> 00:01:17,000
currently is to test this thing right? So, are you VINIT student or?

11
00:01:18,000 --> 00:01:33,000
Oh, okay, cool. Say my hello to him. We go back a long way. He is a very good person.

12
00:01:33,000 --> 00:01:39,000
I came there to one and a half, one year back, no, one and a half years back also.

13
00:01:39,000 --> 00:01:41,000
You joined this year? No.

14
00:01:41,000 --> 00:01:50,000
Okay, I came there one and a half, I have come there couple of times but we know each

15
00:01:50,000 --> 00:02:01,000
other now. He was doing PhD in IAS when I was doing my Masters. In general I think VINIT

16
00:02:01,000 --> 00:02:07,000
is a very good person, once you meet you do not forget anything. Are you fine?

17
00:02:07,000 --> 00:02:13,000
Do not worry about initialization, Rama. Do not worry about initialization. Okay, the

18
00:02:13,000 --> 00:02:20,000
P1 is done, what about P2? No problem, we will go there. How much did

19
00:02:20,000 --> 00:02:28,000
you increase it to? Make it 1000, maybe. All we want to see is, I mean all we want to see,

20
00:02:28,000 --> 00:02:34,000
make you guys kind of appreciate is that a simple technique like loop and rolling can

21
00:02:34,000 --> 00:02:44,000
lead to visible gains and those of you who have finished this step. Okay.

22
00:02:44,000 --> 00:03:12,000
Hi, yes. No, no, no. Okay, there are, if you look at

23
00:03:12,000 --> 00:03:17,000
the time command, what is the output of the time command? You see that it gives you a

24
00:03:17,000 --> 00:03:29,000
few things, user time, system time and elapsed time. So, which one should you look at? So,

25
00:03:29,000 --> 00:03:34,000
the elapsed time is probably the end to end time, user time is the time that you have

26
00:03:34,000 --> 00:03:40,000
spent by you. So, you probably do not care if there was an interrupt in the system doing

27
00:03:40,000 --> 00:03:49,000
something else and all that. So, look at only the user time. Okay. So, in your case,

28
00:03:49,000 --> 00:03:55,000
what is showing in user time? No, because it says command terminated by signal 11. So,

29
00:03:55,000 --> 00:04:04,000
I think 10,000 it will not let me take, reduce it. Do not mind, but I think it is a bad

30
00:04:04,000 --> 00:04:23,000
programming practice. Replace all this by n. Do you see something else? Command terminated

31
00:04:23,000 --> 00:04:30,000
by signal 11. So, if you are getting an error, so that shows something like command terminated

32
00:04:30,000 --> 00:04:35,000
by signal 11. That means the command is terminated for some, may be out of memory or something

33
00:04:35,000 --> 00:04:40,000
like that, of that sort. So, may be movie, do not, you are allocating all of it on the

34
00:04:40,000 --> 00:04:45,000
stack, it is running out of stack or the windows is not giving you more information, that is

35
00:04:45,000 --> 00:04:52,000
fine. But may be what you could do is move these declarations to global and see if it

36
00:04:52,000 --> 00:04:59,000
is correct. So, you can, if that error goes out.

37
00:04:59,000 --> 00:05:04,000
Sir, so for the k-test one, the word. The original one.

38
00:05:04,000 --> 00:05:07,000
Yeah, original one. So, it is giving 0.0.

39
00:05:07,000 --> 00:05:10,000
No, it still says command terminated by signal 11.

40
00:05:10,000 --> 00:05:15,000
Oh yeah. Can you open the code?

41
00:05:15,000 --> 00:05:30,000
Yeah, move these two up. By the way, Malay is also here. He is, so feel free to keep,

42
00:05:30,000 --> 00:05:33,000
if you have stuck anywhere, just ask.

43
00:05:33,000 --> 00:05:38,000
Sir, I am just using the term.

44
00:05:38,000 --> 00:05:45,000
So, what is the value of n? No, but you are getting this error. Do you see this command

45
00:05:45,000 --> 00:05:54,000
terminated by signal 11? So, that means the program is crashing. Because it is crashing,

46
00:05:54,000 --> 00:06:01,000
it is not taking any time. So, what you could do, just open the files, let us say, of 2.c.

47
00:06:01,000 --> 00:06:06,000
This is VI? What I will do, I will just move them up. I will make them global. This is

48
00:06:06,000 --> 00:06:13,000
not the best way to do it. But for the time being, I just moved them to global. And now

49
00:06:13,000 --> 00:06:22,000
do the same thing. Why opt 1 to P2? Copy opt 2 to P2.

50
00:06:22,000 --> 00:06:29,000
No, I am not able to do that. No, that is what we have.

51
00:06:29,000 --> 00:06:42,000
So, now this did not direct. Now let me do time. This is doing something. Try both of

52
00:06:42,000 --> 00:06:43,000
them. So, move.

53
00:06:43,000 --> 00:06:50,000
Sir, how is it, if you move the variables to make it global, then how is it?

54
00:06:50,000 --> 00:06:54,000
How is it making a difference? We will come to that. Remind me there. This is a question

55
00:06:54,000 --> 00:07:01,000
that should. Good. Yes, how about things? Sir, I kept like 1 lakh. Then it is saying,

56
00:07:01,000 --> 00:07:18,000
but also saying user time is 0. Because command terminated by signal 11. So, it is dying.

57
00:07:19,000 --> 00:07:26,000
1 lakh is too big. Just make it 1000 or 10000. That is enough.

58
00:07:26,000 --> 00:07:33,000
When I said 10000 also. Signal 11. That means the program is crashing.

59
00:07:33,000 --> 00:07:40,000
So, please check if you are getting an error terminated by signal 11 or if you see the

60
00:07:40,000 --> 00:07:47,000
time is 0 for large inputs, be very suspicious. Do not think that it is not taking any time.

61
00:07:47,000 --> 00:07:55,000
It is not taking time because the program is dying or rather getting killed. Use a

62
00:07:55,000 --> 00:08:00,000
macro here. No, may I? No.

63
00:08:00,000 --> 00:08:22,000
Whatever. Now, you do not have to change it 1000 places. You are also getting the same

64
00:08:22,000 --> 00:08:29,000
signal 11. If you are getting signal 11, that mostly means that you are trying to allocate

65
00:08:29,000 --> 00:08:36,000
memory on the stack and you do not have enough so much stack. Lift those declarations to

66
00:08:36,000 --> 00:08:41,000
global. Who? Redshift. Yes, sir.

67
00:08:41,000 --> 00:08:50,000
I actually ran the third code with i++ instead of i++ equal to 4.

68
00:08:50,000 --> 00:09:02,000
It should have had a much worse run time. But I am actually getting a very significant

69
00:09:02,000 --> 00:09:08,000
improvement. It has gone from 4 seconds to close to 0.1 seconds. I am not able to understand

70
00:09:08,000 --> 00:09:12,000
why. Let us do with plus 4 first and show me the

71
00:09:12,000 --> 00:09:13,000
time. 0.3 seconds.

72
00:09:13,000 --> 00:09:36,000
Very good. Now, just show me the code. Scroll down.

73
00:09:36,000 --> 00:09:59,000
I am going from 0 to n. Good. I like this. Now, you tell me what is the problem?

74
00:09:59,000 --> 00:10:06,000
I accidentally reduced this. Yes, I know. Now, you tell me what is the issue?

75
00:10:06,000 --> 00:10:13,000
The issue is that this runs much faster. The issue is that this code is buggy. You tell

76
00:10:13,000 --> 00:10:16,000
me what is the bug? First you run it. I will tell you what is the bug. You may be able

77
00:10:16,000 --> 00:10:32,000
to see the bug yourself. You just run it once. But the code is buggy. Do you see this?

78
00:10:32,000 --> 00:10:39,000
There is a segmentation fault. But now you have to tell me why the segmentation fault

79
00:10:39,000 --> 00:10:44,000
has come. Without running, I told you that there is a bug in the code. You tell me what

80
00:10:44,000 --> 00:10:49,000
is the problem? I will come back to you.

81
00:10:49,000 --> 00:10:58,000
Perfect. So, this is array out of bounds.

82
00:11:28,000 --> 00:11:56,000
I am going to run it. I am going to run it. I am going to run it. I am going to run it.

83
00:11:56,000 --> 00:12:23,000
I am going to run it. I am going to run it. I am going to run it. I am going to run it.

84
00:12:23,000 --> 00:12:51,000
I am going to run it. I am going to run it. I am going to run it. I am going to run it.

85
00:12:51,000 --> 00:13:19,000
I am going to run it. I am going to run it. I am going to run it. I am going to run it.

86
00:13:19,000 --> 00:13:38,000
Okay. Guys, I think for the positive of time, we will... Can I continue it? Yeah. Should

87
00:13:38,000 --> 00:13:48,000
we do one thing? How many of you have at least tried P1 and P2? Most of you? Okay. How many

88
00:13:48,000 --> 00:13:55,000
of you still do not see any difference between P1 and P2? One hand? Okay. Let us make sure

89
00:13:55,000 --> 00:14:02,000
that is taken care. P2 and P3 you can keep trying, but I will mostly ask you to do it

90
00:14:02,000 --> 00:14:21,000
in the next class. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

91
00:14:21,000 --> 00:14:49,000
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

92
00:14:49,000 --> 00:15:08,000
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

93
00:15:08,000 --> 00:15:34,240
Last two minutes. A question. Last two minutes on this problem. We will have more, something

94
00:15:35,240 --> 00:15:41,240
more dramatically interesting problem is coming up.

95
00:15:41,240 --> 00:16:02,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

96
00:16:02,240 --> 00:16:23,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

97
00:16:23,240 --> 00:16:44,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

98
00:16:44,240 --> 00:17:11,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

99
00:17:11,240 --> 00:17:18,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

100
00:17:41,240 --> 00:17:56,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

101
00:17:56,240 --> 00:18:00,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

102
00:18:00,240 --> 00:18:22,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

103
00:18:22,240 --> 00:18:37,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

104
00:18:37,240 --> 00:18:45,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

105
00:18:45,240 --> 00:18:52,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

106
00:18:52,240 --> 00:18:57,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

107
00:18:57,240 --> 00:19:02,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

108
00:19:02,240 --> 00:19:07,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

109
00:19:07,240 --> 00:19:12,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

110
00:19:12,240 --> 00:19:19,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

111
00:19:19,240 --> 00:19:24,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

112
00:19:24,240 --> 00:19:29,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

113
00:19:29,240 --> 00:19:34,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

114
00:19:34,240 --> 00:19:39,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

115
00:19:39,240 --> 00:19:44,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

116
00:19:44,240 --> 00:19:49,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

117
00:19:49,240 --> 00:19:54,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

118
00:19:54,240 --> 00:19:59,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

119
00:19:59,240 --> 00:20:04,240
Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay.

120
00:20:05,240 --> 00:20:11,240
It is not a constant, but it is computed. But its value does not change across loop

121
00:20:11,240 --> 00:20:16,240
iterations. We call it as loop invariant. We want to factor it out and move it out.

122
00:20:20,240 --> 00:20:27,240
Right? Because its value does not change. Great. So that way the loop invariant code

123
00:20:27,240 --> 00:20:34,240
works once instead of n number of times. Okay. Here is another piece of code. i equal

124
00:20:37,240 --> 00:20:44,240
to 1 to 100, j equal to 1 to 100, k equal to 1 to 100, a sub ijk equal to i times j

125
00:20:44,240 --> 00:20:51,240
times k. Pretty simple code. How many multiplications are there? 200.

126
00:20:57,240 --> 00:21:00,240
200? 10,000.

127
00:21:00,240 --> 00:21:07,240
10,000. 1 million. 2 million multiplications. How many index operations? So, array index

128
00:21:15,240 --> 00:21:22,240
operations. So, I am doing a sub i something, something, something, right? So, I am doing

129
00:21:22,240 --> 00:21:33,059
So, I am doing A sub i how many times? Million times, then sub j another million, then sub

130
00:21:33,059 --> 00:21:42,339
k, 3 million array index operations and then you have the standard loop jumps, loop increments

131
00:21:42,339 --> 00:21:48,620
and all that. I am not touching that. Is there a part of the code that you see which is loop

132
00:21:48,619 --> 00:22:05,739
invariant here? Which one? j into k, this j into k is loop invariant is it? i into j,

133
00:22:05,739 --> 00:22:11,459
so the i into j is clearly loop invariant for which loop? For the k loop, for the inner

134
00:22:12,460 --> 00:22:23,779
most loop i into j is invariant. All of us are in the same page. So, i into j is a loop

135
00:22:23,779 --> 00:22:37,180
invariant. Is there any other loop invariant part here? A of ij, anything else? A of i.

136
00:22:37,180 --> 00:22:44,539
So, A of ij is loop invariant for the k loop, A of i is the loop invariant for the j loop.

137
00:22:44,539 --> 00:22:52,100
Why do you say A of i is a computation? Why do you say it is a computation? Because you

138
00:22:52,100 --> 00:23:04,779
are doing A adding the offset may be multiplying by the size and all that. So, to do such loop

139
00:23:04,779 --> 00:23:15,299
invariant code motion, we need to see when is it safe. What is the opportunity? When

140
00:23:15,299 --> 00:23:21,660
is it safe? We know that it is not modified in that. Where is the opportunity if you have

141
00:23:21,660 --> 00:23:26,259
a loop where you have lot of memory operations? There is an opportunity. So, you want to look

142
00:23:26,259 --> 00:23:31,819
at the loop. Easy to find. Profitability, it is machine dependent. Most of the time

143
00:23:31,859 --> 00:23:44,379
it looks profitable. I mean it depends whether I mean how much you are when you move it out.

144
00:23:44,379 --> 00:23:51,019
In this case, for loop in general for loop transformations, it is machine dependent.

145
00:23:51,019 --> 00:24:01,179
For loop invariant code motion, can it be machine dependent? Mostly it is profitable,

146
00:24:01,539 --> 00:24:10,779
but there may be some odd case. I cannot figure out where because you moved it out, some cache

147
00:24:10,779 --> 00:24:15,460
behavior has changed. Because of it, there may be some impact. I do not know, but most

148
00:24:15,460 --> 00:24:27,700
of the time it is profitable and modulo some rare combination. Register pressure can move

149
00:24:27,700 --> 00:24:33,500
from one place to other. See when we do register allocation, when we do cache fetching and

150
00:24:33,500 --> 00:24:41,819
all that, we are not doing any optimal algorithms. They are all heuristics. Some rare occurrence

151
00:24:41,819 --> 00:24:47,140
may impact the register pressure in some way, may impact the cache behavior in some way.

152
00:24:47,140 --> 00:24:52,299
That is why we say I mean we do not say it will always be profitable.

153
00:24:52,899 --> 00:24:58,579
So, we are talking about loop invariant code motion. So, for loop invariant code motion,

154
00:24:58,579 --> 00:25:04,859
we want to find out how did you say in that case i times j is loop invariant.

155
00:25:04,859 --> 00:25:20,740
Correct. So, basically what we are saying, there is part of the code which is not changing.

156
00:25:21,180 --> 00:25:29,220
How do we identify that? So, what we can do? We can look at the variables which are defined

157
00:25:29,220 --> 00:25:37,299
in the loop. So, if you look at this code, what is defined in this loop? In this loop,

158
00:25:37,299 --> 00:25:45,059
i is defined, j is defined, k is defined. And you are also writing to A. So, I just

159
00:25:45,379 --> 00:25:54,379
put ijk. In this loop, what are all defined? j, k and A. In this loop, it is k and A. So,

160
00:25:54,379 --> 00:26:00,379
now if you look at this, is there a part of the code, is there a part of the code which

161
00:26:00,379 --> 00:26:08,019
depends upon variables not in this loop def? See if you look at this code, this looks like

162
00:26:08,019 --> 00:26:14,419
a single statement. But if you have done three address code or IR, this will look like this

163
00:26:14,420 --> 00:26:23,539
is one computation i times j, then times k is another operation. So, now I have i times

164
00:26:23,539 --> 00:26:38,340
j. So, now for the k loop, for the k loop, find me an expression which is not, which

165
00:26:38,340 --> 00:26:44,100
depends on variables which are not defined in this, in this case i times j. So, I will

166
00:26:44,099 --> 00:26:51,980
do that. I will take this i times j, I will take this i times j and A sub ij and move

167
00:26:51,980 --> 00:27:02,219
it up. Nice. So, I created a temporary t1, computed the address of aij, t2 i times j

168
00:27:02,219 --> 00:27:11,299
and reuse them. Nice. All of us are on the same page. Good. In the previous page, I said

169
00:27:12,299 --> 00:27:20,740
there are 3 million array index operations. How many array index operations are here?

170
00:27:20,740 --> 00:27:32,099
This is 1 million, this is 10,000, no 20,000, right? 20,000. So, from 3 million to some

171
00:27:32,899 --> 00:27:44,899
1 million chiller, right? How many multiplications am I doing? Here, sorry, here how many multiplications?

172
00:27:44,899 --> 00:27:55,899
2 million. 2 million. Here how many multiplications? 1 million and 10,000. Right? Can I do anything

173
00:28:02,259 --> 00:28:13,259
further? I can lift this ai up, right? And so, yeah, so if you look at this part, this

174
00:28:15,019 --> 00:28:22,019
ai here has moved out. This t3, this t3, I am just focusing on just the t3 loop. The

175
00:28:24,019 --> 00:28:31,019
t3 has become local only from here to here. I created a t3, pushed it up. My life is,

176
00:28:32,619 --> 00:28:37,619
has become simpler now. How many operations? How many multiplication operations? The multiplication

177
00:28:37,619 --> 00:28:44,619
has not changed. Array index operations have changed. It has become 1 million, 10,000 plus

178
00:28:45,740 --> 00:28:52,740
100. Nice. Can I do further? So, this is the first

179
00:29:02,099 --> 00:29:09,099
one. We can of course do unrolling and all that, right? And what we saw? Let us not

180
00:29:11,859 --> 00:29:18,859
go to unrolling for this example. You can do it, but not yet. Instead of multiplication,

181
00:29:23,859 --> 00:29:30,859
we can do addition. What? Where? Good point. Which one?

182
00:29:32,099 --> 00:29:39,099
k loop. Yes. What should t be initialized to? This should be a typo here, right? This

183
00:29:53,099 --> 00:30:00,099
should be t2. This should be t2. Let us say t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t10,

184
00:30:02,139 --> 00:30:09,139
t11, t12, t13, t14. The t4 is okay. t4 equal to initial value of t2 and then how should

185
00:30:12,399 --> 00:30:19,399
t4 change? I will add. You said add, right? What should I add it to? Let us get the value

186
00:30:21,619 --> 00:30:26,980
of t2. Initially t2 value is some value. Let us call it x. After first iteration, in the

187
00:30:26,980 --> 00:30:33,980
first iteration you will do t1k equal to x. In the next iteration you will do t1k equal

188
00:30:33,980 --> 00:30:40,980
to x plus x plus x. Next, x plus x plus x. So, what am I incrementing it with? This value

189
00:30:47,059 --> 00:30:54,059
of t2. So, what we are doing is basically strength reduction. We are doing strength

190
00:30:57,220 --> 00:31:04,220
reduction. See, if there is a loop induction variable, see if it is in the loop, there

191
00:31:05,819 --> 00:31:12,819
is a induction loop index variable which is changing from i plus 1, i plus 2 and so on.

192
00:31:14,220 --> 00:31:21,220
The induction expression is changing in terms of i. Whatever the current value of i, you

193
00:31:22,100 --> 00:31:29,100
are doing something more than that. So, initially if it was iC1 plus iC2, next i plus 1 times

194
00:31:29,380 --> 00:31:36,380
C1 plus C2, next i plus 2 C1 plus C2. In such a case, what I can do? Wherever in the body

195
00:31:43,140 --> 00:31:50,140
I am using this one iC1 plus C2, I will replace it with a temporary. This temporary value,

196
00:31:50,259 --> 00:31:57,259
I will keep incrementing. So, let us see what I will do. I took a temporary t5. Initial

197
00:32:01,980 --> 00:32:08,980
value of t5 was t2 and then I am incrementing t5 by t2. Multiplication, how many multiplications

198
00:32:20,620 --> 00:32:27,620
did we have before? 2 million. We started from 2 million. It became 1 million now, 0.

199
00:32:35,780 --> 00:32:42,780
Now that is done for, I will go back to the previous code again. So, we remove this multiplication.

200
00:32:43,779 --> 00:32:50,779
We removed this multiplication. Similarly, this multiplication can also be removed. This

201
00:32:52,220 --> 00:32:59,220
multiplication, in this code if you look at it, j is changing. j is the loop index variable.

202
00:33:00,500 --> 00:33:07,500
i is not changing within this code. So, this is as if some C1. For this loop, this is some

203
00:33:07,500 --> 00:33:14,500
C1, not a constant literal, but value that does not change in the current loop. So, I

204
00:33:19,660 --> 00:33:26,660
get same t2 equal to some initial value of i and then keep incrementing this t4. t4 equal

205
00:33:30,380 --> 00:33:37,380
to i, t4 equal to t4 plus n. Multiplication is completely gone. Now, I am going to do

206
00:33:38,500 --> 00:33:45,500
something else. Anything else I can do?

207
00:33:47,500 --> 00:33:48,500
.

208
00:33:48,500 --> 00:33:51,500
T1 sub k equal to t5. Yes.

209
00:33:51,500 --> 00:33:52,500
.

210
00:33:52,500 --> 00:33:57,500
No, but k is changing.

211
00:33:57,500 --> 00:33:58,500
.

212
00:33:58,500 --> 00:34:05,500
And then, which one you want to assign only once? This one, this is an array element. So,

213
00:34:19,860 --> 00:34:26,860
I am writing to first element, second element, third element, fourth element and then, but

214
00:34:28,579 --> 00:34:35,579
that is still the right statement to focus on.

215
00:34:35,579 --> 00:34:36,579
.

216
00:34:36,579 --> 00:34:43,579
We could be, instead of every time doing t sub something, what I could do?

217
00:34:43,579 --> 00:34:44,579
.

218
00:34:44,579 --> 00:34:51,579
Here, let us say, I have a new temporary. Let us say, which one is t6. t6 equal to address

219
00:34:52,579 --> 00:34:59,579
of t1 and keep writing to star t6 and keep incrementing t6. I will do star t6 and keep

220
00:35:05,139 --> 00:35:12,139
incrementing t6. Let us do that. So, I think that goes by one step further. So, this is

221
00:35:12,139 --> 00:35:19,139
what it was. Star something equal to blah and keep incrementing by how much? That is

222
00:35:24,739 --> 00:35:30,179
the question. Let us go back to the previous, because I missed something. Here, how much

223
00:35:30,179 --> 00:35:37,179
does from one point to the next point change? Only one. Here, it changes by, here it will

224
00:35:37,179 --> 00:35:44,179
change by 100, here it will change by 10,000. So, you have to be careful. So, what we did

225
00:35:49,940 --> 00:35:56,940
first? From here, we expanded away, we exposed the indexing. I think we also did a copy propagation

226
00:35:57,700 --> 00:36:04,700
phase. There are few copies that can be thrown away. If you look at, is there a copy that

227
00:36:08,460 --> 00:36:15,460
I can, t2 is it? t2 equal to t4. Yeah, from here. Is there a copy that can go? Just check.

228
00:36:26,940 --> 00:36:33,940
Am I missing something? Yeah, t2 equal to t4. Nothing is changing from here to here

229
00:36:48,139 --> 00:36:55,139
pucca. So, I can replace this with t4. Then, the same t2 is used here. So, I can replace

230
00:36:56,940 --> 00:37:03,940
it with t4. So, this statement can go. So, we do the copy propagation and then we expose

231
00:37:11,740 --> 00:37:18,740
the indexing. t1 sub k, I made it t1. I just exposed it and then this looks like the code

232
00:37:18,900 --> 00:37:24,019
that we have seen before, where I can further again do increments in place of array this

233
00:37:24,019 --> 00:37:29,019
thing. So, I will get code like this. Star t8 equal to blah blah, keep incrementing.

234
00:37:29,019 --> 00:37:33,500
See, star t8, t8 equal to t8 plus 1. There is something beautiful about this code. How

235
00:37:33,500 --> 00:37:40,500
many of you can know what is special about such a code? This code is very amenable for

236
00:37:43,699 --> 00:37:50,699
further optimization. This is store and increment. Have you heard of this instructions? This

237
00:37:54,579 --> 00:38:01,579
is lower end increment, store and increment. So, if you see such a code can be later optimized

238
00:38:02,139 --> 00:38:09,139
there to one single fast instruction. But even at this code, just this code, how many

239
00:38:12,380 --> 00:38:19,380
multiplications are there? 0. How many additions are there? Here there are two. So, this is

240
00:38:24,579 --> 00:38:31,099
an increment. This increment will mostly get folded into the store. So, this is the main

241
00:38:31,099 --> 00:38:38,099
this thing. So, there is definitely 1 million additions. From 2 million multiplications,

242
00:38:39,099 --> 00:38:46,099
we came to 1 million additions and we had 3 million array index operations. It came

243
00:38:46,299 --> 00:38:53,299
down to 0. This is just a plain store, nothing more. Awesome, right? We will take, what time

244
00:39:04,019 --> 00:39:11,019
do we take a break? 4.15. Then I will do one more before we. So, if we, I want to do a

245
00:39:16,099 --> 00:39:23,099
break. I want you guys to go home, take this piece of code, do what we did for the simpler

246
00:39:23,460 --> 00:39:30,460
thing. You should get a kick out of seeing this run. Here we not only saw the what part,

247
00:39:35,420 --> 00:39:41,380
we also know how to do this. We said what is, I mean how do you actually, when do you,

248
00:39:41,460 --> 00:39:46,380
I mean the procedure for doing this. We said find out the variables which are defined in

249
00:39:46,380 --> 00:39:53,380
the loop, which are and then find expressions which are using variables which are not in

250
00:39:55,019 --> 00:40:02,019
the loop. Those expressions are your loop invariance. Then factor them out. Then we

251
00:40:04,380 --> 00:40:11,099
looked at strength reduction, right? We looked at strength reduction and we saw how that

252
00:40:11,099 --> 00:40:18,099
works. So, we not only saw the what part, but also looked at some how part. Is there

253
00:40:25,179 --> 00:40:32,179
further propagation you can do here? T3. What is happening with T3?

254
00:40:41,099 --> 00:40:48,099
T3 equal to T6. This can go, this can be T6 and then where is next T3? Is there any

255
00:40:51,139 --> 00:40:58,139
other occurrence of T3? No. Wow. So, this is definitely gone. What else? Sorry? T1 equal

256
00:40:58,139 --> 00:41:05,139
to T7. Same is it? Good. So, this also goes. So, this one you are saying goes, right? This

257
00:41:05,139 --> 00:41:12,139
one goes. Hello. So, this is T3. So, this is T3. So, this is T3. So, this is T3. So,

258
00:41:35,139 --> 00:41:42,139
this is T4. Good. What else goes? This guy goes, right? Next.

259
00:41:56,500 --> 00:42:03,500
T5 equal to T4 and T5 equal to T5 plus T4.

260
00:42:05,139 --> 00:42:12,139
Is it doubling? No, right? So, let us say the initial value of T4 is pick 5. So, this

261
00:42:22,059 --> 00:42:29,059
becomes 5, then 10, then 15. If you keep left shifting by 2, it will be 5, 10, 20. So, that

262
00:42:29,059 --> 00:42:36,059
we cannot do. Right? Okay. Any other? Anything more? No, right? Can we? T4 equal to i. Can

263
00:42:36,059 --> 00:42:43,059
we replace T4 with i? Here, I can use i for sure. Am I? Can I? No, I cannot because T4

264
00:42:43,059 --> 00:42:50,059
is changing in the loop. I cannot. No, I think that is it. I mean I am not able to

265
00:43:13,059 --> 00:43:20,059
do that. Okay. So, let me ask this question. How many of you understand the idea of when

266
00:43:31,500 --> 00:43:38,500
I am doing loop invariant code motion? How do I identify which parts are loop invariant?

267
00:43:39,300 --> 00:43:46,300
I first identify the variables defined in the loop and then find out expressions which

268
00:43:48,619 --> 00:43:55,619
use variables that are not defined in this. Right? The strength reduction in loops where

269
00:43:57,260 --> 00:44:04,260
I replace, if I have an expression iC1 plus iC2 where C1 and C2 are the current loop constants.

270
00:44:05,260 --> 00:44:12,260
They are not constants per se. They are constants as per the current loop. They do not change

271
00:44:12,460 --> 00:44:19,040
in the current loop. Then I replace this one with a temporary. Initialize the temporary

272
00:44:19,040 --> 00:44:26,040
before the loop. Right? And at the end of the loop, I increment this temporary by which

273
00:44:26,039 --> 00:44:33,039
value? See every time it is increasing by C1. What is the initial value? i0 C1 plus

274
00:44:39,599 --> 00:44:46,599
C2 and every time it is increasing only by C1. So, at the end I will do T equal to T

275
00:44:47,159 --> 00:44:54,159
plus C1. Right? What if the expression is C1 plus C2?

276
00:44:56,039 --> 00:45:03,039
The expression is not of this form iC1 plus C2. This scheme cannot be. You have to find

277
00:45:03,300 --> 00:45:10,300
some other scheme. But it is a fairly common pattern. It is a very fairly common pattern

278
00:45:11,340 --> 00:45:18,340
where I mean look at this. Even in our code for, sorry, yeah, if you look at this T1 plus

279
00:45:18,340 --> 00:45:25,340
K part, right, T1 times K, this is the K is the loop induction variable, T2 is independent.

280
00:45:32,579 --> 00:45:39,579
So, even though it looks like some expression, there is some part which is not changing,

281
00:45:40,200 --> 00:45:47,200
this T2 part. Make sense? Anyone who is still having issues here?

282
00:45:48,780 --> 00:45:55,780
No, right? Okay. We are done with the introduction to optimizations part where we looked at the

283
00:46:02,260 --> 00:46:07,780
basic idea of optimizations. We looked at couple of small optimizations and what they

284
00:46:07,780 --> 00:46:14,780
do and couple of small optimizations how they do. We will now look at a type of analysis

285
00:46:15,100 --> 00:46:22,100
called control flow analysis and its related optimizations, control flow optimization.

286
00:46:33,100 --> 00:46:38,780
When we, in the previous examples that we saw when we were doing analysis, we kept saying

287
00:46:38,780 --> 00:46:45,780
hey here is an expression whose value does not change. This expression can move out.

288
00:46:46,260 --> 00:46:53,260
Here is an expression whose value is a constant. I can replace it with a constant. That is

289
00:46:54,420 --> 00:47:01,420
all about data. So, the understanding of the program has to be in two directions. One on

290
00:47:02,220 --> 00:47:07,660
how the data is flowing, the other is how the control is flowing in the program. Control

291
00:47:07,659 --> 00:47:14,659
is in which instructions are executed after what, where are, I mean my if then else blocks,

292
00:47:14,659 --> 00:47:21,659
my loops and all that. So, we briefly talked about data flow analysis. We will come in

293
00:47:23,460 --> 00:47:28,460
detail about data flow analysis for most of tomorrow. Today what we will look at is control

294
00:47:28,460 --> 00:47:35,460
flow analysis now. So, here is an example. It is an example that computes the Fibonacci

295
00:47:35,460 --> 00:47:42,460
series, Mth this thing. So, if this is the input code, this could be the IR. In the

296
00:47:54,460 --> 00:48:01,460
input code, you can see there is an if, else, for and all that. In the IR, it is pretty

297
00:48:02,099 --> 00:48:09,099
high level IR. It is not very low level, but still the loop is gone. The if then else is

298
00:48:10,900 --> 00:48:17,900
gone. Can you look at this and say there is a loop? If we say I want to do optimizations

299
00:48:21,340 --> 00:48:28,340
and transformations on a higher level IR and the loop is gone, how do I say move the code

300
00:48:28,780 --> 00:48:35,780
above the loop? You may say hey, this is stupid. You had loop visible, you threw it away. Now,

301
00:48:43,740 --> 00:48:50,740
you are asking where is the loop? What if the code is written in this way? You see this

302
00:48:51,739 --> 00:48:58,739
could have been a valid code as well. Can you find out where is the loop? Moral of the

303
00:48:59,819 --> 00:49:06,819
story, you should be able to find loops from such code. It could have been your IR or the

304
00:49:07,379 --> 00:49:14,379
input code itself. So, it is not stupid to ask the question where is the loop in this

305
00:49:14,380 --> 00:49:21,380
IR? Yes. Have you seen something in this IR? What are the instructions I have? This is

306
00:49:35,140 --> 00:49:42,140
pretty much the code from there. This is a receive instruction. This says M is passed.

307
00:49:44,940 --> 00:49:51,940
The parameter says by value. Why do I need the receive instruction? Any guesses? Why

308
00:49:57,579 --> 00:50:04,579
do I need the receive instruction? If I do not have the receive instruction, what would

309
00:50:04,900 --> 00:50:05,900
happen?

310
00:50:05,900 --> 00:50:12,900
I am not sure. I am not sure. I am not sure. I am not sure. I am not sure. I am not sure.

311
00:50:14,380 --> 00:50:21,380
No, receive instruction is only about the parameter. It is only about the parameter.

312
00:50:21,380 --> 00:50:28,380
No, the value is sent by the sender at runtime. Anyway, I do not have the value now. Why do

313
00:50:35,340 --> 00:50:42,340
I need the receive instruction?

314
00:50:44,380 --> 00:50:51,380
Good. So, what she is saying, I guess is, look, if I do not have a receive instruction

315
00:51:01,059 --> 00:51:03,900
and I see it is being used, I may say it is an

316
00:51:03,900 --> 00:51:10,900
initialized variable. It is not initialized. Someone will send the value. Why do I have

317
00:51:11,900 --> 00:51:18,900
to say this is call by value? Because you need to know how you will generate code later

318
00:51:21,500 --> 00:51:26,500
whether call by value or call by reference. All of you understand call by value, call

319
00:51:26,500 --> 00:51:33,500
by reference? C supports call by value. C supports call by value. Java supports call

320
00:51:33,500 --> 00:51:40,500
by value. C plus plus supports call by value. C supports call by reference. Yes. Now, let

321
00:51:47,260 --> 00:51:52,460
us have a raise of hand for this. C supports call by reference. Yes. How many of you say

322
00:51:52,460 --> 00:51:59,460
no? How many of you say yes? C does not support call by reference. One hand, two hands, three

323
00:52:03,500 --> 00:52:10,500
hands. It is a question MCQ with only two answers. Yes and no. C supports call by value.

324
00:52:16,099 --> 00:52:23,099
C does not support call by value. C supports call by value. Good. C supports call by reference.

325
00:52:24,099 --> 00:52:31,099
C supports call by reference. One, two, three. Wow. C does not support call by reference.

326
00:52:35,980 --> 00:52:42,980
One, two, three, four, five. What about the rest? I do not think in this voting the nota

327
00:52:43,380 --> 00:52:50,380
is there. What do you guys think? How about Java? Java supports call by value. Java supports

328
00:52:55,579 --> 00:53:02,579
call by reference. One, two, three, four, five, six, seven, eight. Java supports call

329
00:53:13,179 --> 00:53:19,980
by reference. One, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve,

330
00:53:19,980 --> 00:53:26,980
thirteen, fourteen, fifteen, sixteen. Wow. Wrong. C does not support call by reference.

331
00:53:27,099 --> 00:53:34,099
Java does not support call by reference. You pass a variable. Does the value of the variable

332
00:53:35,420 --> 00:53:42,420
change when you come back from the function? If yes, then this is call by reference. If

333
00:53:42,980 --> 00:53:49,980
not, it is call by value. Java when you pass a, even if it is a variable a pointing to

334
00:53:50,019 --> 00:53:57,019
an object, a's value does not change. The field therein may change. Same thing in C

335
00:53:59,139 --> 00:54:06,139
when you pass the address of whatever you are passing is that changing? If I have a

336
00:54:12,980 --> 00:54:19,980
int x equal to 3, int star p equal to address of x and now in a function foo I am passing

337
00:54:27,980 --> 00:54:34,980
p. In foo let us say I am setting a variable x,

338
00:54:42,980 --> 00:54:49,980
star y equal to 5. What will change when you come back? Value of x. Does the value

339
00:54:55,579 --> 00:55:02,579
of p change? No. What did I pass? This value. C supports only call by value. A common statement

340
00:55:02,579 --> 00:55:09,579
C simulates call by reference. Nah. There is nothing like that. You may feel that some

341
00:55:18,179 --> 00:55:25,179
memory location you are able to modify. Yes, but C supports call by value. Java supports

342
00:55:26,099 --> 00:55:33,099
only call by value. C plus plus supports call by value and reference. Now, there is some

343
00:55:40,899 --> 00:55:47,899
I see some faces with lot of agitation. Yes, question. Yes.

344
00:55:47,900 --> 00:55:54,900
Right. That book is mistake. Yes.

345
00:56:18,900 --> 00:56:25,900
If it says so. Right. See idea is very simple. You can what the book is trying to convey.

346
00:56:26,900 --> 00:56:33,019
Let us give the benefit of doubt to the book. What the book is trying to say is that look

347
00:56:33,019 --> 00:56:40,019
if you want to change the variable, the value of a variable in a function, pass its address,

348
00:56:40,300 --> 00:56:47,300
then you come back the value that will be visible. They may say the book may be probably

349
00:56:47,300 --> 00:56:50,260
I see I do not know which book you are talking about. There may be some books which may say

350
00:56:50,260 --> 00:56:57,260
that. That book may be saying that this looks like call by reference. Since C does not support

351
00:56:59,900 --> 00:57:06,900
call by reference, pass the address, change in the function via the star operator, come

352
00:57:08,060 --> 00:57:14,460
back. Right. Let us not pass judgments on the book. But if any book says that C supports

353
00:57:14,539 --> 00:57:21,539
call by reference, that is clearly a mistake. Right.

354
00:57:21,539 --> 00:57:28,539
C plus plus has this additional syntax. So, in C plus plus, I could do like this. In C

355
00:57:33,980 --> 00:57:40,980
plus plus, I can have function foo with int and y. It has some syntax like this. Where

356
00:57:41,780 --> 00:57:48,780
now if you pass x, is there a module on code generation as well? Who? Govinda is doing

357
00:57:57,820 --> 00:58:04,820
low level optimization. Try to do self reading on how the code can be, how the code can be

358
00:58:10,980 --> 00:58:16,420
code generated for call by value and call by reference. I wanted to bring out that this

359
00:58:16,420 --> 00:58:22,619
is an important point to note that the call by value, this information that we say that

360
00:58:22,619 --> 00:58:29,619
is kind of carried over to the IR is an important factor to remember. That this is a, this argument

361
00:58:31,940 --> 00:58:38,219
is call by value, pass by value, this is pass by reference because this will have an impact

362
00:58:38,219 --> 00:58:45,219
on how we generate the code, how we emit the code.

363
00:58:47,219 --> 00:58:54,219
When you, C arrays are again interesting. Do you know that C array, do you know how

364
00:58:55,459 --> 00:59:02,459
is it allocated? Read it anywhere? If I, give me a minute. Let me erase the board here.

365
00:59:08,219 --> 00:59:15,219
So, you should, probably you are aware that C arrays, when you declare a variable A as

366
00:59:21,099 --> 00:59:28,099
an array, that variable has no, normally every variable has some memory except arrays. The

367
00:59:28,099 --> 00:59:35,099
array variable itself has no special memory. So, when you write int A, this is as if you

368
00:59:45,659 --> 00:59:52,659
are saying, give me a box whose name is A. This box is in the memory and when you write

369
00:59:52,779 --> 00:59:59,779
something to write A equal to 3, you are writing in this box. If you write int B 10, what you

370
01:00:02,219 --> 01:00:09,219
are asking is 10 elements, 10 boxes, 10 consecutive boxes. No box for B.

371
01:00:09,219 --> 01:00:16,219
So, what is B pointing to? Let me repeat my statement. What do you mean by B is pointing

372
01:00:16,219 --> 01:00:23,219
to it? What, for something to point to, see if I write int star P, what does it mean?

373
01:00:29,739 --> 01:00:36,739
It means, if I write int star P, what does it mean? It means, if I write int star P,

374
01:00:46,219 --> 01:00:53,219
what does it mean? P is a box. If you write P equal to ampersand x, this address of x,

375
01:00:55,299 --> 01:01:01,500
let us say this, sorry, address, I will write here, so that it looks continuous. P equal

376
01:01:01,500 --> 01:01:08,500
to address of A. Whatever is this address, that is in the box of P. So, P has a box.

377
01:01:09,500 --> 01:01:16,500
Now, you may say P points to A. B is not pointing to anything because B is not a box. Have you

378
01:01:22,019 --> 01:01:29,019
printed the address of B in array? What does it mean by address? Yeah, so if you write

379
01:01:29,059 --> 01:01:36,059
B or address of B or address of B 0, same thing. What does it mean? B is not a box itself.

380
01:01:38,820 --> 01:01:45,820
B is just a placeholder that you can use as a programmer. See, during the code generation,

381
01:01:52,019 --> 01:01:59,019
I have, wherever there is B, I will replace it. I have allocated some memory. I will just

382
01:01:59,260 --> 01:02:06,260
give that address there. So, it is beautiful that C has created this illusion of an array

383
01:02:06,660 --> 01:02:13,660
as a variable which does not exist. Java, the array variables are actually variables.

384
01:02:13,660 --> 01:02:20,660
They are objects. Here, this B is not an object itself. It is just a pure, just a name. That

385
01:02:22,380 --> 01:02:28,380
name does not actually exist, I mean, point to any, I mean, it is not a memory location.

386
01:02:28,380 --> 01:02:35,380
There is no memory box. I like the idea of boxes for variables. It is very, you will

387
01:02:35,380 --> 01:02:42,380
see that it gives you so much clarity. Anyway. No. If you pass B, when you come back, does

388
01:02:51,820 --> 01:02:58,820
B change? Does B change? What are you passing? B. Does B change? It is a very simple concept,

389
01:03:05,500 --> 01:03:11,500
I mean, I know what you are saying. What you are saying is you pass B and changes of B0,

390
01:03:11,500 --> 01:03:18,500
B1, B2 will reflect. But if you pass B0, will B0 change?

391
01:03:20,500 --> 01:03:27,500
So, any further questions on this pass by value, pass by reference? It is very, there

392
01:03:28,500 --> 01:03:35,500
are all very common misconceptions. So, do not feel shy, do not feel awkward, but I think

393
01:03:36,460 --> 01:03:43,460
it is important to have this clarity. So, pass by value, this annotation here which

394
01:03:49,900 --> 01:03:56,900
is present in the IR is there for a reason because you will accordingly do the code generation.

395
01:03:57,500 --> 01:04:04,500
Any further questions? No. What will do? We will take a quick break. I guess how much

396
01:04:05,179 --> 01:04:12,179
time I do not know. For 15, you said you wanted a break, right? We will do a quick break and

397
01:04:14,460 --> 01:04:21,460
and then we will see given code like this because the input code or because it could

398
01:04:21,460 --> 01:04:28,460
be the IR, how do we infer the control structure? Control structure as in I want to know, remember

399
01:04:28,460 --> 01:04:33,740
when we did loop invariant code motion, there is a loop somewhere there. I want to know

400
01:04:33,740 --> 01:04:40,740
hey where are my if then else blocks? Is it an if then else block or only an if then block?

401
01:04:40,740 --> 01:04:46,099
If there is a loop, what is the loop body? What is the loop header? All such things we

402
01:04:46,099 --> 01:04:46,860
want to infer.

