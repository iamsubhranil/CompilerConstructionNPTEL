1
00:00:00,000 --> 00:00:10,560
So, everyone got the L1 cache how it works and so on.

2
00:00:10,560 --> 00:00:23,359
Next quiz, so we saw yes.

3
00:00:23,359 --> 00:00:29,679
Typically whatever happens I mean it depends on how the layout of the processor is done.

4
00:00:29,679 --> 00:00:36,840
So, if your cache is present along with the and the MMU is outside then you will have

5
00:00:36,840 --> 00:00:38,560
those as virtually indexed.

6
00:00:38,560 --> 00:00:45,240
So, whichever cache come on the layout before the MMU comes into picture they will typically

7
00:00:45,240 --> 00:00:51,159
be virtually indexed anything which comes after that there is not much benefit of having

8
00:00:51,159 --> 00:00:54,560
them as virtually indexed because you would have anyway done the translation.

9
00:00:54,560 --> 00:01:07,879
I do not know because it could vary from processors to processors like in the GPUs L2 is still

10
00:01:07,879 --> 00:01:11,400
outside the this thing and MMU is also outside.

11
00:01:11,400 --> 00:01:17,400
So, it is more of a tradeoff between what processors design wants to do, but conceptually

12
00:01:17,400 --> 00:01:24,520
you can think of it like if the address translation is part of some other unit which lies beyond

13
00:01:24,679 --> 00:01:30,560
the cache then you get benefit out of having virtually indexed cache.

14
00:01:30,560 --> 00:01:35,959
What is the exact specific architecture doing could be their own set of tradeoffs because

15
00:01:35,959 --> 00:01:41,959
they have architecture design it just a bunch of tradeoffs involved from here and there.

16
00:01:41,959 --> 00:01:46,840
So, they have lot of factors into consideration before deciding that.

17
00:01:46,840 --> 00:01:49,120
Now let us look at this thing.

18
00:01:49,240 --> 00:01:55,760
So, what I said is you have the kernel space as part of the process address space.

19
00:01:55,760 --> 00:01:57,520
Why is this done that way?

20
00:01:57,520 --> 00:02:01,320
Why have kernel mapped as part of the user process?

21
00:02:17,319 --> 00:02:18,319
Why?

22
00:02:18,519 --> 00:02:19,519
What are the benefits?

23
00:02:30,519 --> 00:02:31,519
Correct.

24
00:02:31,519 --> 00:02:35,519
So, the main advantage is what he is saying.

25
00:02:35,519 --> 00:02:41,319
So, whenever a process needs to do a system call it will enter into the kernel space.

26
00:02:41,319 --> 00:02:46,280
Now imagine if kernel was not part of the process then it would have its own set of

27
00:02:46,280 --> 00:02:48,840
page tables.

28
00:02:48,840 --> 00:02:53,759
Now because of that the page table switch needs to happen.

29
00:02:53,759 --> 00:03:00,560
Now as soon as page table switch happens TLB needs to be flushed because TLB no longer

30
00:03:00,560 --> 00:03:04,599
holds the correct context of the virtual address.

31
00:03:04,599 --> 00:03:11,840
So, it is beneficial to have as part of the same process.

32
00:03:11,840 --> 00:03:18,640
Now how many of you have heard of a recent security threat called Spectre and Meltdown?

33
00:03:18,640 --> 00:03:23,640
So, Meltdown Spectre is slightly different.

34
00:03:23,640 --> 00:03:31,520
So, Meltdown was actually a threat which presents in most many processors including x86 ARM

35
00:03:31,520 --> 00:03:37,879
and so on where due to some security hole you could actually access kernel space.

36
00:03:38,879 --> 00:03:43,719
So, you could access the entire address space without any problems and that was done through

37
00:03:43,719 --> 00:03:48,960
a loophole which presents which is typically present in these architectures.

38
00:03:48,960 --> 00:03:56,039
And the only solution in that case is something called as kernel page table isolation or KPTI

39
00:03:56,039 --> 00:03:57,639
for a short form.

40
00:03:57,639 --> 00:04:03,680
And what KPTI does is essentially takes out the kernel space from the user address space

41
00:04:03,680 --> 00:04:05,759
and puts it separately.

42
00:04:05,759 --> 00:04:11,039
Now consequence of that is what he was saying that every time now you have a system call

43
00:04:11,039 --> 00:04:13,599
you are actually switching the page tables.

44
00:04:13,599 --> 00:04:23,439
So, this kind of had lot of performance issues and Linux community was not very happy with

45
00:04:23,439 --> 00:04:28,719
this hardware bug because they had to lose lot of performance because of this.

46
00:04:28,720 --> 00:04:35,880
Now just like we have address identifiers there is also process identifiers which are

47
00:04:35,880 --> 00:04:38,560
used for page tables.

48
00:04:38,560 --> 00:04:43,760
Some it is not again in all processors some processors have it, but it essentially allows

49
00:04:43,760 --> 00:04:49,040
you to avoid TLB flush even when you swap the page tables.

50
00:04:49,040 --> 00:04:54,680
So, even when you switch the page tables you do not have to flush the TLB in the same way

51
00:04:55,120 --> 00:04:59,680
because what you are storing in TLB is not just the virtual address to physical address

52
00:04:59,680 --> 00:05:05,079
mapping, but process identifier plus virtual address mapping to the physical address.

53
00:05:05,079 --> 00:05:11,120
So, some processors do have that even in the TLB, but again with those processors the performance

54
00:05:11,120 --> 00:05:14,079
was not so good, but we cannot do much.

55
00:05:14,079 --> 00:05:20,759
So, as of now most of the Linux kernels the latest versions will have kernel page table

56
00:05:20,759 --> 00:05:24,920
isolation applied where the kernel space actually does not live in this.

57
00:05:24,920 --> 00:05:29,439
So, this is historical now.

58
00:05:29,439 --> 00:05:36,719
The next quiz, so I have this code what this code is trying to do is it is contiguously

59
00:05:36,719 --> 00:05:48,120
trying to malloc 768 MB and whenever it runs out of the memory it breaks out of this infinite

60
00:05:48,120 --> 00:05:55,680
loop and sorry there is a typo this should have been counter, but and we count how many

61
00:05:55,680 --> 00:06:01,699
times we were able to successfully allocate 768 MB.

62
00:06:01,699 --> 00:06:08,240
Now let us say I run this program on two machines one which is 32 bit one which is 64 bit what

63
00:06:08,240 --> 00:06:11,360
will be the relationship between the count.

64
00:06:11,360 --> 00:06:19,800
Does count determined by physical memory which is present or will it be dependent on 32 bit

65
00:06:19,800 --> 00:06:35,439
versus 64 bit.

66
00:06:35,439 --> 00:06:37,400
But if you do not have that much physical.

67
00:06:37,439 --> 00:06:43,799
Now let us say you have a machine which has 32 bit which is 32 bit with 4 GB RAM and you

68
00:06:43,799 --> 00:06:49,599
have another machine which is 64 bit with 4 GB RAM what will happen will the counter

69
00:06:49,599 --> 00:06:50,599
be same.

70
00:06:50,599 --> 00:06:51,599
Why?

71
00:06:51,600 --> 00:06:53,600
Why?

72
00:07:51,600 --> 00:07:54,840
And then we will switch to the next example where we will look at that.

73
00:07:54,840 --> 00:08:01,160
So, essentially remember all the addresses which need to be returned to the program need

74
00:08:01,160 --> 00:08:02,160
to be virtual.

75
00:08:02,160 --> 00:08:05,320
We saw that earlier.

76
00:08:05,320 --> 00:08:08,520
So the pointer which is returned by malloc has to be virtual.

77
00:08:08,520 --> 00:08:17,080
So malloc has to at least allocate that much virtual address space at least that much virtual

78
00:08:17,080 --> 00:08:19,080
address space needs to be allocated.

79
00:08:19,079 --> 00:08:25,159
Now if malloc cannot find this much contiguous virtual address space it will error out.

80
00:08:25,159 --> 00:08:32,120
So if it cannot find 768 MB in the heap region it will error out and virtual addresses have

81
00:08:32,120 --> 00:08:37,399
to be contiguous because that is how pointer arithmetic works.

82
00:08:37,399 --> 00:08:45,519
Now chances of running out of finding contiguous 768 MB blocks in a 64 bit process versus a

83
00:08:45,519 --> 00:08:53,240
32 bit process 64 bit process has much more chunk available of 768 MB just by because

84
00:08:53,240 --> 00:08:57,559
you have more address space available you probably have more chances of finding such

85
00:08:57,559 --> 00:08:59,419
a thing.

86
00:08:59,419 --> 00:09:05,159
So leaving aside the physical resource for a moment if you just look at the virtual address

87
00:09:05,159 --> 00:09:11,439
space the 32 bit machine will run out of this allocation sooner than 64 bit machine.

88
00:09:11,439 --> 00:09:14,679
Does everyone agree with that?

89
00:09:14,679 --> 00:09:17,399
Now let us look at the other example.

90
00:09:17,399 --> 00:09:22,239
Here actually sorry I should have changed this.

91
00:09:22,239 --> 00:09:26,539
So I have these two codes.

92
00:09:26,539 --> 00:09:30,039
The left one is same as the earlier one which I showed.

93
00:09:30,039 --> 00:09:33,679
The right one is actually using caloc instead of malloc.

94
00:09:33,679 --> 00:09:39,439
What is the difference between the two?

95
00:09:39,440 --> 00:09:45,900
So caloc unlike malloc will actually write zeros into the memory.

96
00:09:45,900 --> 00:09:53,760
So caloc actually has to physically access that memory to put zeros.

97
00:09:53,760 --> 00:10:00,720
Now the way malloc actually works is it only allocates the virtual addresses.

98
00:10:00,720 --> 00:10:04,900
It does not actually give you a physical address.

99
00:10:04,899 --> 00:10:12,139
So whenever you do malloc, malloc will give you a contiguous virtual address space but

100
00:10:12,139 --> 00:10:17,939
all those pages will not have any backup in the RAM.

101
00:10:17,939 --> 00:10:22,980
They will not be mapped.

102
00:10:22,980 --> 00:10:30,299
As you start accessing data into that that is when it will actually start allocating

103
00:10:30,299 --> 00:10:32,899
physical pages for it.

104
00:10:32,899 --> 00:10:36,860
And that is what he was saying that it depends on how things are implemented.

105
00:10:36,860 --> 00:10:39,500
This scheme is called as copy on write.

106
00:10:39,500 --> 00:10:42,019
I do not know if you have heard of this term.

107
00:10:42,019 --> 00:10:46,779
So most of the operating systems support something called as copy on write.

108
00:10:46,779 --> 00:10:54,639
So what happens is you write some only when you write something is when you get physical

109
00:10:54,639 --> 00:10:56,139
space for it.

110
00:10:56,139 --> 00:10:59,539
Otherwise you have just inherited whatever was earlier present.

111
00:10:59,539 --> 00:11:01,980
You do not have any physical back.

112
00:11:01,980 --> 00:11:09,300
So in this case the code which is with caloc will actually run out of memory when you have

113
00:11:09,300 --> 00:11:12,060
run out of either address space.

114
00:11:12,060 --> 00:11:15,899
So it depends on what you run out of sooner whether you run out of the address space or

115
00:11:15,899 --> 00:11:20,460
whether you run out of the physical resource.

116
00:11:20,460 --> 00:11:24,879
Does this make sense?

117
00:11:24,879 --> 00:11:25,879
Now assign yes.

118
00:11:25,879 --> 00:11:41,200
Better implementation of malloc simply means a better way to track the scheme.

119
00:11:41,200 --> 00:11:47,039
The overall not how lazily memory is actually allocated.

120
00:11:47,039 --> 00:11:50,360
Actually I do not have time to cover memory allocators in detail.

121
00:11:50,360 --> 00:11:54,279
But the way memory allocators actually work like if you want to write your own malloc

122
00:11:54,679 --> 00:12:00,600
It is not that these things you have to write because these are more of a services provided

123
00:12:00,600 --> 00:12:02,240
by the operating systems.

124
00:12:02,240 --> 00:12:03,679
So you have to build on top of it.

125
00:12:03,679 --> 00:12:09,120
So unless you are writing the operating system kernel itself where you get to choose these

126
00:12:09,120 --> 00:12:16,159
policies a memory allocator is simply keeping track of what is free and what is allocated.

127
00:12:16,159 --> 00:12:21,240
And then the better so when someone says I have a better memory allocator what they are

128
00:12:21,240 --> 00:12:27,279
saying is I have a better implementation which finds free blocks quickly or has some

129
00:12:27,279 --> 00:12:29,039
ways to compact things.

130
00:12:29,039 --> 00:12:31,039
So it is all abstraction which is created.

131
00:12:31,039 --> 00:12:36,879
They are not changing the policies provided by the operating system.

132
00:12:36,879 --> 00:12:38,379
Is the distinction clear?

133
00:12:38,379 --> 00:12:43,440
So what we talked about was actually a thing in the operating system.

134
00:12:43,440 --> 00:12:49,100
Copy on write is decided by operating system not by malloc versus calloc.

135
00:12:49,100 --> 00:12:56,340
It is a OS policy because of that behavior of malloc and calloc might appear different.

136
00:12:56,340 --> 00:13:00,899
But if you know what happens behind malloc behind calloc then you should be able to reason

137
00:13:00,899 --> 00:13:03,779
about it.

138
00:13:03,779 --> 00:13:07,159
Now the assignment for you is something like this.

139
00:13:07,159 --> 00:13:13,060
You have to write a program which will print addresses of different portions.

140
00:13:13,059 --> 00:13:20,099
So write a program which takes which prints address of some function which prints address

141
00:13:20,099 --> 00:13:25,719
of some data which prints address of some variable in the stack and which prints address

142
00:13:25,719 --> 00:13:28,959
of something in the heap.

143
00:13:28,959 --> 00:13:35,500
And verify if they match to something similar to what we had seen here.

144
00:13:35,500 --> 00:13:39,500
Where the function addresses should be something like this.

145
00:13:40,139 --> 00:13:46,779
So that might be very close to the kernel and so on.

146
00:13:46,779 --> 00:13:51,799
Remember to compile with dash M32 otherwise you might see completely random stuff which

147
00:13:51,799 --> 00:13:55,100
is not shown in this diagram.

148
00:13:55,100 --> 00:14:00,179
So whatever concepts you are trying to learn I think the best way to understand them is

149
00:14:00,179 --> 00:14:04,279
to be able to write some program which can demonstrate that concept.

150
00:14:04,279 --> 00:14:10,259
Otherwise that will make your knowledge much more grounded and you can observe things.

151
00:14:10,259 --> 00:14:14,819
Now one of the things which you can do which is comparatively better than this is using

152
00:14:14,819 --> 00:14:17,600
some commands.

153
00:14:17,600 --> 00:14:21,980
So let's say I want to actually observe the memory map of how things are.

154
00:14:21,980 --> 00:14:28,439
I cannot keep doing this because there might be some things like we know before main there

155
00:14:28,439 --> 00:14:32,319
is also something called as underscore start as of now.

156
00:14:32,360 --> 00:14:37,560
So we can't exactly get what is the stack layout and so on because there might be some

157
00:14:37,560 --> 00:14:42,920
other things which are hidden behind my back which are also occupying space.

158
00:14:42,920 --> 00:14:47,040
So you can actually print memory map of a program.

159
00:14:47,040 --> 00:14:51,860
So for that you have to find what is the process ID.

160
00:14:51,860 --> 00:14:55,280
So there is a command called pgrep.

161
00:14:55,280 --> 00:14:56,940
Everyone is aware of command grep.

162
00:14:56,940 --> 00:14:59,560
Grep is to search something.

163
00:14:59,559 --> 00:15:07,959
So pgrep searches for a process which are running and then I can actually use a command

164
00:15:07,959 --> 00:15:12,759
called pmap which shows me the memory map of that process.

165
00:15:12,759 --> 00:15:14,279
So let's try that.

166
00:15:14,279 --> 00:15:31,079
So let's say I have

167
00:15:31,080 --> 00:15:47,520
So let's say I have some proc.c.

168
00:15:47,520 --> 00:15:51,780
To ensure I can keep poking the binary I will keep it running.

169
00:15:51,780 --> 00:15:56,720
So I will put a scanf so that the process is kind of waiting for something to happen

170
00:15:56,879 --> 00:16:01,360
and it doesn't run fast enough and I can't observe it.

171
00:16:01,360 --> 00:16:10,279
So now I have this dot is left.

172
00:16:10,279 --> 00:16:12,600
So this process is now running.

173
00:16:12,600 --> 00:16:18,160
Now let's switch back to other terminal and look for where is a dot out.

174
00:16:18,160 --> 00:16:21,879
So it says the PID for this is this one.

175
00:16:21,879 --> 00:16:32,879
So I will use that and this is the actual memory map of this.

176
00:16:32,879 --> 00:16:38,960
So it says that there are some segments which are loaded at this address which have read

177
00:16:38,960 --> 00:16:43,559
and execute permission and these are of 4k.

178
00:16:43,559 --> 00:16:45,700
Now this is the interesting part.

179
00:16:45,700 --> 00:16:52,580
So you remember we said that you will get secfault only when you cross the segment boundaries.

180
00:16:52,580 --> 00:17:01,259
So you can see that so if you are on stack if you access up to 132k bytes you will not

181
00:17:01,259 --> 00:17:08,980
get a secfault but if you do something beyond that you will start getting secfault.

182
00:17:08,980 --> 00:17:14,460
Similarly it says that there is some 4k segment which is read and write then there are bunch

183
00:17:14,460 --> 00:17:15,940
of other things.

184
00:17:15,940 --> 00:17:18,460
Then there is libc which is there.

185
00:17:18,460 --> 00:17:24,500
With libc you can for now assume it's something which provides all the things which you were

186
00:17:24,500 --> 00:17:29,460
using so far printf malloc and other things and this is also loaded and remember this

187
00:17:29,460 --> 00:17:31,400
is dot so.

188
00:17:31,400 --> 00:17:38,840
So this is shared object which we will see how they work and then there is ld dot so.

189
00:17:38,840 --> 00:17:41,299
This is also something which we will see later.

190
00:17:41,500 --> 00:17:48,299
If you look at the map which we had so it had stack and memory map region for shared

191
00:17:48,299 --> 00:17:49,339
libraries.

192
00:17:49,339 --> 00:17:55,099
So this is all the shared library region which I was showing in the memory map and then there

193
00:17:55,099 --> 00:17:58,019
is a stack.

194
00:17:58,019 --> 00:17:59,220
Does that make sense?

195
00:17:59,220 --> 00:18:06,279
You can also observe the same thing using a different command called slash proc.

196
00:18:06,279 --> 00:18:20,399
So you could do cat slash proc slash pid slash maps and this also prints similar information.

197
00:18:20,399 --> 00:18:31,440
It actually let me dump this to a file so it's readable.

198
00:18:31,440 --> 00:18:36,940
So this actually prints the similar information.

199
00:18:36,940 --> 00:18:42,160
But it also prints the exact paths on where the things are loaded from.

200
00:18:42,160 --> 00:18:46,160
So libc is loaded from this location.

201
00:18:46,160 --> 00:18:56,420
Now what is this saying is this segment whichever was formed was loaded from a dot out.

202
00:18:56,420 --> 00:19:03,980
Now remember we had said that from the program code segment will be loaded, data segment

203
00:19:03,980 --> 00:19:06,660
will be loaded and bss segment will be loaded.

204
00:19:06,660 --> 00:19:09,400
So that's where these come from.

205
00:19:09,400 --> 00:19:14,720
So what it is saying is from executable these three segments have come, from libc these

206
00:19:14,720 --> 00:19:20,560
bunch of things have come, from ld these things have come and this is a stack.

207
00:19:20,560 --> 00:19:22,660
Everyone got how we did this?

208
00:19:22,779 --> 00:19:29,600
So you should be able to observe this using these kind of commands.

209
00:19:29,600 --> 00:19:32,380
Any doubts so far?

210
00:19:32,380 --> 00:19:37,940
So just to quickly revise since morning we looked into details of what are static libraries

211
00:19:37,940 --> 00:19:43,740
and then we looked into details of how processors are created and how virtual memory is useful

212
00:19:43,740 --> 00:19:48,259
in creating all the abstraction which we know of for memory.

213
00:19:48,259 --> 00:19:53,700
Now let's switch on to loader on what loader actually does.

214
00:19:53,700 --> 00:19:59,420
Now I will actually not get into lot of details of loader because I think dynamic linker is

215
00:19:59,420 --> 00:20:02,440
much more interesting topic than this.

216
00:20:02,440 --> 00:20:05,539
So what happens is what all loader needs to do?

217
00:20:05,539 --> 00:20:10,819
We saw loader has to create the memory map.

218
00:20:10,819 --> 00:20:16,059
Loader is essentially responsible for saying allocate some space at this virtual address

219
00:20:16,059 --> 00:20:17,420
in the stack.

220
00:20:17,580 --> 00:20:22,380
Take some things from executable code segment etc.

221
00:20:22,380 --> 00:20:25,740
Copy them at this virtual address in the process and so on.

222
00:20:25,740 --> 00:20:31,140
So loader is essentially responsible for getting data from disk and actually loading it into

223
00:20:31,140 --> 00:20:32,860
the memory.

224
00:20:32,860 --> 00:20:39,900
And then loader will actually start executing the program point which was specified in the

225
00:20:39,900 --> 00:20:40,900
elf.

226
00:20:40,900 --> 00:20:45,620
Remember in elf I had showed you that there was something called as entry point?

227
00:20:45,619 --> 00:20:52,500
That is where once loader is done with its activities it will actually jump.

228
00:20:52,500 --> 00:20:56,779
Now what happens in the startup?

229
00:20:56,779 --> 00:21:04,339
So there is something called as CRT which stands briefly for C runtime.

230
00:21:04,339 --> 00:21:09,619
So what happens is when you are running your C program it's not that loader can magically

231
00:21:09,619 --> 00:21:11,099
start running it.

232
00:21:11,099 --> 00:21:16,500
For example, everyone knows that main takes some arguments.

233
00:21:16,500 --> 00:21:18,939
ARGC, ARGV.

234
00:21:18,939 --> 00:21:22,539
So who populates them?

235
00:21:22,539 --> 00:21:27,740
Someone needs to populate them and where will they get populated?

236
00:21:27,740 --> 00:21:29,259
Stack.

237
00:21:29,259 --> 00:21:30,919
Stack of main.

238
00:21:30,919 --> 00:21:34,419
So they need to be on stack frame of the main.

239
00:21:34,419 --> 00:21:40,939
So all of that setup which is needed to be able to start executing main needs to be done

240
00:21:40,940 --> 00:21:45,299
by underscore start.

241
00:21:45,299 --> 00:21:50,600
There are few other interesting things which underscore start does which we will see later.

242
00:21:50,600 --> 00:21:57,019
But underscore start is essentially responsible for start setting up the state so that main

243
00:21:57,019 --> 00:21:58,799
can be executed.

244
00:21:58,799 --> 00:22:05,440
Now start itself comes in an object file called as CRT 1.0.

245
00:22:06,360 --> 00:22:11,640
So many times you might see this error CRT 1.0 missing or something like that.

246
00:22:11,640 --> 00:22:20,759
And what linker does the start which it is said in the execute L file as the entry point

247
00:22:20,759 --> 00:22:24,000
it is address of the underscore start function.

248
00:22:24,000 --> 00:22:29,000
So what linker says is loader once you are done loading the program please start executing

249
00:22:29,000 --> 00:22:32,720
a function called as underscore start.

250
00:22:32,720 --> 00:22:34,559
And what does start does?

251
00:22:34,559 --> 00:22:38,279
So it does bunch of things before calling main.

252
00:22:38,279 --> 00:22:44,039
So it calls lip-c first to initialize the lip-c so that malloc and other things are

253
00:22:44,039 --> 00:22:47,319
initialized properly which might have been used.

254
00:22:47,319 --> 00:22:52,379
Then it calls init function which initializes some state.

255
00:22:52,379 --> 00:22:54,759
Then it sets up at exit handlers.

256
00:22:54,759 --> 00:22:59,559
So what happens is when your program exits it is not that it immediately exits.

257
00:23:00,159 --> 00:23:04,859
There are some post clean up which happens as part of at exit.

258
00:23:04,859 --> 00:23:10,559
So start function will say that once the program is done call these functions call those functions

259
00:23:10,559 --> 00:23:11,960
and so on.

260
00:23:11,960 --> 00:23:16,759
Then it finally calls main and then it will finally call exit which will actually return

261
00:23:16,759 --> 00:23:19,000
to the operating system.

262
00:23:19,000 --> 00:23:21,200
Is it clear?

263
00:23:21,200 --> 00:23:27,519
So essentially if you just want to conceptually remember this remember underscore start will

264
00:23:27,519 --> 00:23:31,680
set up the state for main to start functioning correctly.

265
00:23:31,680 --> 00:23:36,920
And there are few other things which happen in init etc which we will do in the last phase

266
00:23:36,920 --> 00:23:39,539
of the module.

267
00:23:39,539 --> 00:23:40,759
Is it clear?

268
00:23:40,759 --> 00:23:47,240
So I will not actually get into details but I will show you picture of what happens actually.

269
00:23:47,240 --> 00:23:52,960
So what I showed you was a simplified picture but what is actually happening before main

270
00:23:52,960 --> 00:23:55,879
is all of this.

271
00:23:55,880 --> 00:24:02,160
So it is not a simple thing although it appears that you just set up state and it works.

272
00:24:02,160 --> 00:24:07,920
What is happening is loader is calling start then lip see start main gets called and then

273
00:24:07,920 --> 00:24:12,320
there are bunch of other things and at this point main is called but there are bunch of

274
00:24:12,320 --> 00:24:15,040
other things which are happening.

275
00:24:15,040 --> 00:24:20,400
Now I will not get actually into details of what each of these are doing because this

276
00:24:20,400 --> 00:24:23,960
is actually too specific to an implementation.

277
00:24:23,960 --> 00:24:25,880
There is no concept behind it.

278
00:24:25,880 --> 00:24:28,819
So I would rather skip this.

279
00:24:28,819 --> 00:24:35,480
But you can look you can just search for these names and you will start getting some information

280
00:24:35,480 --> 00:24:38,519
on web on what these do.

281
00:24:38,519 --> 00:24:48,920
No.

282
00:24:48,920 --> 00:24:58,960
So on Linux there is no other way.

283
00:24:58,960 --> 00:25:03,480
So what happens is when you do exec loader will come into picture which needs to load

284
00:25:04,480 --> 00:25:09,839
which you have set and then it will do all of this before actually start executing main

285
00:25:09,839 --> 00:25:15,539
of that function.

286
00:25:15,539 --> 00:25:19,880
Now let us look at more interesting topic which is dynamic linking.

287
00:25:19,880 --> 00:25:24,880
So remember static libraries which we saw in the morning had disadvantage.

288
00:25:24,880 --> 00:25:29,980
One of the disadvantage was that the code is kind of present in every executable.

289
00:25:29,980 --> 00:25:35,339
So if I have printf code that will be present in the every executable file which is probably

290
00:25:35,339 --> 00:25:38,180
not desired.

291
00:25:38,180 --> 00:25:47,180
And bug fix in static library requires everyone to update and recompile their code.

292
00:25:47,180 --> 00:25:52,180
So and we overcome these by using shared libraries.

293
00:25:52,180 --> 00:25:58,819
So a shared library is an object file which can be loaded at runtime.

294
00:25:58,819 --> 00:26:02,819
It is not linked statically in your executable.

295
00:26:02,819 --> 00:26:06,220
It is loaded at runtime when your application starts.

296
00:26:06,220 --> 00:26:08,299
That's when it gets loaded.

297
00:26:08,299 --> 00:26:15,659
And it can be loaded at arbitrary memory location.

298
00:26:15,659 --> 00:26:22,779
And this process of loading this library is essentially known as dynamic linking because

299
00:26:22,859 --> 00:26:29,500
we are dynamically calling in some code which was not earlier present in my executable.

300
00:26:29,500 --> 00:26:33,779
So remember yesterday I was trying to tell you that executable is self-sufficient, doesn't

301
00:26:33,779 --> 00:26:35,779
have any other dependencies.

302
00:26:35,779 --> 00:26:38,460
That was true for static dependencies.

303
00:26:38,460 --> 00:26:45,619
If there could still be a dynamic dependency on from the executable to a dynamic library.

304
00:26:45,619 --> 00:26:50,539
And this work is essentially done by dynamic linker.

305
00:26:50,539 --> 00:26:56,659
And Linux will refer to these libraries as dynamic shared objects or DSOs.

306
00:26:56,659 --> 00:27:02,659
And Windows refers to them as DLLs, dynamic link libraries.

307
00:27:02,659 --> 00:27:08,139
Now how do you create, just like we saw how we create static library, we should be able

308
00:27:08,139 --> 00:27:10,740
to create a shared library.

309
00:27:10,740 --> 00:27:13,339
So let's say I have this code.

310
00:27:13,339 --> 00:27:20,779
I can do something like this where I can say gcc, temp.c, which is my code.

311
00:27:20,779 --> 00:27:26,659
And I specify a flag called dash shared, which is telling that instead of creating a normal

312
00:27:26,659 --> 00:27:34,699
relocatable object or executable object, create a shared object.

313
00:27:34,699 --> 00:27:40,220
And just like static libraries, the convention even for dynamic libraries is to name them

314
00:27:40,299 --> 00:27:48,100
as lib name.so.

315
00:27:48,100 --> 00:27:58,860
So can you all write this code and create your own shared library?

316
00:27:58,860 --> 00:28:07,620
Are you able to have lib my.so on your disk now?

317
00:28:07,619 --> 00:28:22,819
Okay, so that might happen if you don't have 32 bit dynamic linker and 32 bit runtime.

318
00:28:22,819 --> 00:28:31,500
Can you do this on the server machine where it is already there?

319
00:28:31,500 --> 00:28:50,500
Let's create it here so we can see.

320
00:29:20,500 --> 00:29:40,380
Okay, so is everyone able to do that?

321
00:29:40,380 --> 00:30:05,660
So let's write some client code also, which will use this.

322
00:30:05,660 --> 00:30:09,640
So I have a client code which calls into that library.

323
00:30:09,640 --> 00:30:11,880
And I will now compile my client code.

324
00:30:11,880 --> 00:30:15,380
So I will say gcc minus m32 client.c.

325
00:30:15,380 --> 00:30:21,700
And just like we tried giving the path for the static libraries, let's try the same

326
00:30:21,700 --> 00:30:22,700
thing.

327
00:30:22,700 --> 00:30:26,519
So I give l. which says find my libraries here.

328
00:30:26,519 --> 00:30:29,980
And the library I'm trying to link is my.

329
00:30:29,980 --> 00:30:44,420
Okay, one second.

330
00:30:44,420 --> 00:30:49,420
And it worked.

331
00:30:49,420 --> 00:31:03,060
Sorry.

332
00:31:03,060 --> 00:31:06,519
Yes because I am creating executable.

333
00:31:06,519 --> 00:31:11,500
So now I have a client.c compiled.

334
00:31:11,500 --> 00:31:16,340
Let me try to run it.

335
00:31:16,339 --> 00:31:21,899
It didn't run.

336
00:31:21,899 --> 00:31:29,059
It's saying while loading libraries libmy.so cannot open shared object file, no such file

337
00:31:29,059 --> 00:31:35,259
or direct.

338
00:31:35,259 --> 00:31:42,779
So simply being able to create library and specify it at compile time does not allow

339
00:31:42,779 --> 00:31:44,539
me to use that.

340
00:31:44,539 --> 00:31:47,740
Something else needs to be done.

341
00:31:47,740 --> 00:31:54,960
So unlike static libraries, you need to install dynamic libraries.

342
00:31:54,960 --> 00:32:02,299
And installation means you have to copy them at some standard location like userlib or

343
00:32:02,299 --> 00:32:08,220
something and run a command called ldconfig.

344
00:32:08,220 --> 00:32:18,819
So you have to put your shared library at some specific location to be able to use that.

345
00:32:18,819 --> 00:32:25,420
The other option is essentially when you are compiling your program, you specify where

346
00:32:25,420 --> 00:32:30,860
to search the shared library using dash wl command.

347
00:32:30,859 --> 00:32:46,899
So other option we have is we can use dash wl, dash rpath with dot.

348
00:32:46,899 --> 00:32:53,939
And now when I run it, it actually worked.

349
00:32:53,939 --> 00:33:00,599
So dash rpath says that at compile time, this is the hard coded location where I must look

350
00:33:00,599 --> 00:33:04,299
for my shared library.

351
00:33:04,299 --> 00:33:11,699
Now if the shared library is not present at this specific path, it is not going to work.

352
00:33:11,699 --> 00:33:17,299
So it is restrictive from that point of view because at compile time you are saying look

353
00:33:17,299 --> 00:33:20,779
for library which is present only at this specific path.

354
00:33:20,779 --> 00:33:24,379
If it is present in any other path, it does not matter.

355
00:33:24,379 --> 00:33:28,899
So this is kind of a problematic thing.

356
00:33:28,900 --> 00:33:36,580
So the other option is actually being able to use something called as ld library path.

357
00:33:36,580 --> 00:33:45,640
So you can say export ld library path and specify the path at runtime and then it will

358
00:33:45,640 --> 00:33:47,140
run.

359
00:33:47,140 --> 00:33:52,860
Now even if I put libmy.so at some other location, I will just change my ld library path and it

360
00:33:52,860 --> 00:33:54,400
will start working.

361
00:33:54,400 --> 00:33:58,160
Yeah, no that is okay.

362
00:33:58,160 --> 00:34:04,040
You are going into, so the shell instance in which you are running must have ld library

363
00:34:04,040 --> 00:34:05,540
path set.

364
00:34:05,540 --> 00:34:11,000
So that is a different problem what you are trying to say.

365
00:34:11,000 --> 00:34:12,000
Is it clear?

366
00:34:12,000 --> 00:34:17,860
So see what happened is static library was part of the executable.

367
00:34:17,860 --> 00:34:24,640
So when it was being run, loader did not have to search where to look for function foo because

368
00:34:24,640 --> 00:34:26,780
it was part of the executable.

369
00:34:26,780 --> 00:34:31,620
But that is strictly different in case of dynamic libraries because dynamic libraries

370
00:34:31,620 --> 00:34:34,680
get me are loaded at runtime.

371
00:34:34,680 --> 00:34:40,620
So dynamic loader needs to know where is this library present.

372
00:34:40,620 --> 00:34:43,280
Where should I find my foo?

373
00:34:43,280 --> 00:34:48,840
And it finds it by looking at some libraries which are at standard location.

374
00:34:48,840 --> 00:34:53,620
Otherwise if while compiling you had hard coded the path using r path, then it will

375
00:34:53,620 --> 00:34:55,300
look for that.

376
00:34:55,300 --> 00:34:58,720
Otherwise it will look for ld library path.

377
00:34:58,720 --> 00:35:02,560
Now how do you find out what all an executable depends on?

378
00:35:02,560 --> 00:35:11,600
So you can do a command called ldd which says list out all the libraries which will be loaded

379
00:35:11,599 --> 00:35:16,360
dynamically by this program.

380
00:35:16,360 --> 00:35:23,960
So there is something called as Linux gate, then there is something called libmyso, libc

381
00:35:23,960 --> 00:35:27,839
and then there is this ldlinux.

382
00:35:27,839 --> 00:35:29,299
Now let us try this.

383
00:35:29,299 --> 00:35:38,139
So let us say I do not set my ld library path and I try to run ldd.

384
00:35:38,139 --> 00:35:42,279
Now it says libmy.so not found.

385
00:35:42,279 --> 00:35:48,219
So it was not able to find and that is when I try to run this executable now I will get

386
00:35:48,219 --> 00:35:52,299
that error that I could not load what is libmy.so.

387
00:35:52,299 --> 00:35:58,339
So if you are any time getting this error, try to look what does ldd show and whether

388
00:35:58,339 --> 00:36:01,159
ldd is able to look up these paths.

389
00:36:01,159 --> 00:36:05,259
If it is not then you are guaranteed to get this error and then you have to set either

390
00:36:05,260 --> 00:36:16,140
ldd library path or change your rl path to point to that.

391
00:36:16,140 --> 00:36:20,760
So essentially what loader is going to do, it is going to find all the directories which

392
00:36:20,760 --> 00:36:25,240
are listed in etcld.so.conf.

393
00:36:25,240 --> 00:36:32,980
So this is the system variable file which can where you can add the default libraries

394
00:36:32,980 --> 00:36:40,780
of where to find them and then you can have either r path configuration or ld library

395
00:36:40,780 --> 00:36:44,860
path to have the dso's looked up.

396
00:36:44,860 --> 00:36:59,579
Now can someone guess why we have r path as well as ld library path?

397
00:36:59,579 --> 00:37:02,940
So ld library path what it allows you?

398
00:37:02,940 --> 00:37:08,019
It allows you to configure changing the library which is being loaded.

399
00:37:08,019 --> 00:37:12,500
So you may want to try with a different library and see running the things.

400
00:37:12,500 --> 00:37:16,579
But all of this activity is typically during development.

401
00:37:16,579 --> 00:37:22,980
But when you are shipping your software you do not want user to configure ld library path

402
00:37:22,980 --> 00:37:28,799
and you do not want accidentally some other libmy.so get into the picture.

403
00:37:28,800 --> 00:37:36,320
So for example let us say you had shipped libmy.so which did linked list.

404
00:37:36,320 --> 00:37:41,800
Then there is another libmy.so which pretends to do linked list but is actually doing something

405
00:37:41,800 --> 00:37:48,600
malicious and you set ld library path to that and application will start running that.

406
00:37:48,600 --> 00:37:50,840
So you do not want that to happen.

407
00:37:50,840 --> 00:37:57,500
That is why when you are shipping your software along with a dso you will say please use this

408
00:37:57,500 --> 00:38:03,860
specific version only which is at this location and typically that might have some privilege

409
00:38:03,860 --> 00:38:05,260
for you to change.

410
00:38:05,260 --> 00:38:06,579
So you may not be able to change.

411
00:38:06,579 --> 00:38:11,539
For example if it is installed in user then you need root permissions to overwrite a file

412
00:38:11,539 --> 00:38:12,619
in that.

413
00:38:12,619 --> 00:38:14,659
So there is some security.

414
00:38:14,659 --> 00:38:16,340
Does that make sense?

415
00:38:16,340 --> 00:38:20,860
So ld library path is really useful when you are doing development because you might say

416
00:38:20,860 --> 00:38:25,219
that okay I have this older version of the library let me try injecting new and whether

417
00:38:25,219 --> 00:38:26,900
it works and so on.

418
00:38:26,900 --> 00:38:33,639
But when you are shipping something you will configure your build to have hard coded paths.

419
00:38:33,639 --> 00:38:38,579
Now let us examine what all goes into the dynamic shared object.

420
00:38:38,579 --> 00:38:43,619
So remember yesterday I had told you that elf is a format which can be used to represent

421
00:38:43,619 --> 00:38:48,460
all three things executable, relocatable and dynamic shared.

422
00:38:48,460 --> 00:38:55,260
So if you look at kind you will actually see dyn which says it is a dynamic shared object.

423
00:38:55,260 --> 00:39:07,060
So if you look at redelf-h of libmy.so it is actually an elf file of type dynamic shared

424
00:39:07,060 --> 00:39:08,380
object.

425
00:39:08,380 --> 00:39:19,380
If you look at if you look this for a.out it is an elf file which is executable.

426
00:39:19,380 --> 00:39:26,820
So elf holds the information that this elf is being described for a dynamic shared object.

427
00:39:26,820 --> 00:39:30,700
Then there is entry point.

428
00:39:30,700 --> 00:39:39,740
Now entry point for dso is very interesting because entry point could be anything because

429
00:39:39,740 --> 00:39:43,059
it is being loaded dynamically.

430
00:39:43,059 --> 00:39:50,820
So depending on where is the space in the memory mapped region it will get loaded.

431
00:39:50,820 --> 00:39:52,619
Does everyone understand this?

432
00:39:52,619 --> 00:39:59,840
Because let us say you are running your program and you have so much data and some usage of

433
00:39:59,840 --> 00:40:01,659
stack and so on.

434
00:40:01,659 --> 00:40:06,420
Then the dso needs to be in the memory mapped region and there might be multiple dsos which

435
00:40:06,420 --> 00:40:09,079
your program depends on.

436
00:40:09,199 --> 00:40:13,480
So every dso starting point might be different.

437
00:40:13,480 --> 00:40:17,599
So the entry point address here is really from the start of the file.

438
00:40:17,599 --> 00:40:19,779
It is nothing more.

439
00:40:19,779 --> 00:40:29,159
So what this is saying is 3d0 is where the code starts from the start of the file.

440
00:40:29,159 --> 00:40:33,599
And how do we actually fix it?

441
00:40:33,599 --> 00:40:35,480
So relocation.

442
00:40:35,480 --> 00:40:40,719
So relocation will actually put it at some specific address and things will get changed

443
00:40:40,719 --> 00:40:45,880
as part of that.

444
00:40:45,880 --> 00:40:49,599
Now if you look at it, so this is the code.

445
00:40:49,599 --> 00:40:55,360
What this code is doing is it is accessing this global variable gbl and then some way

446
00:40:55,360 --> 00:40:57,199
adding that to parameters.

447
00:40:57,199 --> 00:41:04,159
Now if you look at the generated elf for it you would see that there are couple of relocations

448
00:41:04,159 --> 00:41:06,599
here.

449
00:41:06,599 --> 00:41:10,920
Now these relocations are on the dynamic section.

450
00:41:10,920 --> 00:41:20,699
And what they are saying is change address 500 with the address of gbl.

451
00:41:20,699 --> 00:41:22,279
What is at 500?

452
00:41:22,279 --> 00:41:27,119
We can see there are bunch of zeros.

453
00:41:27,119 --> 00:41:33,839
So what this is going to do is dynamic linker when it is loading this library it is going

454
00:41:33,840 --> 00:41:40,960
to change these zeros with address of gbl.

455
00:41:40,960 --> 00:41:48,240
Similarly here we see there is a relocation on 50a which is this.

456
00:41:48,240 --> 00:41:51,720
So this will also change with address of gbl.

457
00:41:51,720 --> 00:41:55,019
Similarly this will also change with address of gbl.

458
00:41:55,019 --> 00:42:02,280
So every reference of gbl which was earlier, see because the same problem happens.

459
00:42:02,280 --> 00:42:12,080
When linker is creating code for this does linker know where the gbl will go?

460
00:42:12,080 --> 00:42:17,160
Static linker does not know where gbl will go because the dynamic library may get loaded

461
00:42:17,160 --> 00:42:21,400
at different points in different processes.

462
00:42:21,400 --> 00:42:28,900
For example address of gbl in p1 might be 100 and address of gbl in p2 might be 500.

463
00:42:28,900 --> 00:42:33,980
So you cannot change this to 100 or 500 at link time.

464
00:42:33,980 --> 00:42:35,180
Does everyone get this?

465
00:42:35,180 --> 00:42:41,059
So the same problem which assembler had in static compilation, the same problem happens

466
00:42:41,059 --> 00:42:46,820
when linker is when compiler is trying to create a shared object file.

467
00:42:46,820 --> 00:42:49,300
Because it does not know where it will get loaded.

468
00:42:49,300 --> 00:42:55,700
Unlike your executable, in executable you knew text section is going to go here and

469
00:42:56,019 --> 00:43:01,299
section is here so you can have all of their addresses.

470
00:43:01,299 --> 00:43:10,579
And that is why we need relocations which will change this as part of dynamic link.

471
00:43:10,579 --> 00:43:16,319
So these will actually get changed by the dynamic linker.

472
00:43:16,319 --> 00:43:20,659
So when dynamic linker is done loading the library it would have assigned some address

473
00:43:20,659 --> 00:43:27,659
to gbl in that particular process and then it will change the address to that.

474
00:43:27,659 --> 00:43:28,659
Yes.

475
00:43:28,659 --> 00:43:29,659
Yes.

476
00:43:29,659 --> 00:43:30,659
We will see that.

477
00:43:30,659 --> 00:43:31,659
We will come to that.

478
00:43:31,659 --> 00:43:58,579
So every reference of gbl is kind of changed.

479
00:43:59,579 --> 00:44:03,000
this relocation is actually performed at load time.

480
00:44:03,000 --> 00:44:09,619
So using shared objects it is causing some additional work to happen as part of the application

481
00:44:09,619 --> 00:44:10,619
load.

482
00:44:10,619 --> 00:44:14,779
It is not coming for free.

483
00:44:14,779 --> 00:44:20,239
So your assignment is to figure out what happens when you do these function calls.

484
00:44:20,239 --> 00:44:26,099
So we saw that whenever foo was referring to gbl there were some relocations.

485
00:44:26,099 --> 00:44:31,059
Now your task is to write a function in dso and call it and see what kind of relocations

486
00:44:31,059 --> 00:44:36,299
get generated.

487
00:44:36,299 --> 00:44:42,139
So let us try to do this so we can observe here.

488
00:44:42,139 --> 00:45:09,179
So in this shared library I will simply call bar and

489
00:45:09,219 --> 00:45:16,699
So I have modified this code which was the earlier example which now has function call.

490
00:45:16,699 --> 00:45:30,119
Now let us try to compile this.

491
00:45:31,119 --> 00:45:41,559
Now if I look at the relocations there are some relocations which were for patching gbl

492
00:45:41,559 --> 00:45:47,880
which were present earlier also and now there is additional relocation for patching bar

493
00:45:47,880 --> 00:45:54,139
and it is of other type it is of pc32 which we saw yesterday because when we are doing

494
00:45:54,139 --> 00:45:58,400
function call we are not patching the absolute address of the function.

495
00:45:58,400 --> 00:46:02,079
We are patching the relative address of the function.

496
00:46:02,079 --> 00:46:23,019
Now if you look at the actual code using so and if I look at say underscore sorry foo.

497
00:46:23,019 --> 00:46:29,179
So if I look at foo I do see that foo has some relocations.

498
00:46:29,179 --> 00:46:36,739
So this call instruction now this fcff you remember we saw yesterday also this is minus

499
00:46:36,739 --> 00:46:42,860
4 so the same thing has come up and it is going to change with address of bar.

500
00:46:42,860 --> 00:46:51,840
Similarly gbl wherever gbl is referenced there are relocations to patch the address of gbl.

501
00:46:51,840 --> 00:46:57,840
So in dynamic library what is happening is for every reference of the variable we are

502
00:46:57,840 --> 00:46:59,000
getting a relocation.

503
00:46:59,000 --> 00:47:05,120
So if you call bar twice you should see two relocations because address at both places

504
00:47:05,120 --> 00:47:06,800
need to be changed.

505
00:47:06,800 --> 00:47:12,600
Similarly gbl is kind of reference three times so its addresses there are three relocations

506
00:47:12,600 --> 00:47:19,160
for it and all these relocations need to be resolved at run time when the application

507
00:47:19,160 --> 00:47:20,360
starts.

508
00:47:20,360 --> 00:47:27,360
So the problem is this is this scheme actually works for supporting shared libraries because

509
00:47:27,360 --> 00:47:32,680
what will happen is you will have this shared library and once it is loaded by the loader

510
00:47:32,680 --> 00:47:38,680
it will resolve all these relocations once it is done loading it as some specific address.

511
00:47:38,680 --> 00:47:44,599
Once it knows the address of gbl and bar it will change the text section.

512
00:47:44,599 --> 00:47:50,799
Now the issues with this scheme are essentially first issue is remember we had relocation

513
00:47:50,799 --> 00:47:53,199
for every reference.

514
00:47:53,199 --> 00:47:59,360
So every time a function is called all those references need to be changed.

515
00:47:59,360 --> 00:48:05,199
Does everyone understand this and this needs to happen at load time that means your application

516
00:48:05,199 --> 00:48:11,920
will start running slower because initial overhead will be for dynamic linker to come

517
00:48:11,920 --> 00:48:18,920
up with the addresses of all these variables and patch them.

518
00:48:18,920 --> 00:48:22,079
Everyone understands this overhead which needs to happen.

519
00:48:22,079 --> 00:48:26,480
Now the second issue is actually more serious which is what I think that other person was

520
00:48:26,480 --> 00:48:34,039
trying to ask is the fundamental reason why we started off with shared libraries is because

521
00:48:34,039 --> 00:48:36,559
we do not want to duplicate code.

522
00:48:36,559 --> 00:48:44,440
We do not want every program to have duplicate code of common libraries like printf.

523
00:48:44,440 --> 00:48:49,559
Now with dso we are able to share it but what will happen when you are actually loading

524
00:48:49,559 --> 00:48:58,759
it references need to be changed and the reference the addresses with which the references will

525
00:48:58,759 --> 00:49:05,639
be changed will actually be different for different processes because depending on where

526
00:49:05,719 --> 00:49:08,639
bar is loaded into the memory.

527
00:49:08,639 --> 00:49:15,519
So in p1 process p1 bar might be loaded at address 100.

528
00:49:15,519 --> 00:49:24,079
In p2 bar might be loaded at address 500 and you will change the text section of bar and

529
00:49:24,079 --> 00:49:32,039
foo to refer to address 100 in process p1 and in process p2 you will change it to address

530
00:49:32,039 --> 00:49:33,900
500.

531
00:49:33,900 --> 00:49:36,780
Does everyone get this?

532
00:49:36,780 --> 00:49:40,700
So can you really share code of foo?

533
00:49:40,700 --> 00:49:48,420
So foo which was calling bar in process p1 foo needs to call address 100 in process p2

534
00:49:48,420 --> 00:49:55,740
foo needs to call address 500 that means the content of the text section is different.

535
00:49:55,740 --> 00:49:58,900
Does everyone understand this?

536
00:49:58,900 --> 00:50:03,840
And if the content is going to be different can you have one physical copy of that?

537
00:50:03,840 --> 00:50:10,700
No, because in p1 you need to refer to a version which is going to call the one with address

538
00:50:10,700 --> 00:50:16,860
100 and in p2 you need the one which will be called with address 500.

539
00:50:16,860 --> 00:50:24,460
So you cannot share the code in physical memory which is what we started off as one of the

540
00:50:24,460 --> 00:50:28,160
goals which we wanted to have.

541
00:50:28,159 --> 00:50:31,359
So that is where the problem comes.

542
00:50:31,359 --> 00:50:39,199
So if you have relocations they are going to change things in a way that will make it

543
00:50:39,199 --> 00:50:45,480
process specific because the addresses are going to be process specific.

544
00:50:45,480 --> 00:50:46,719
So how to solve this?

545
00:50:46,719 --> 00:50:49,480
Why not reserve some addresses?

546
00:50:49,480 --> 00:50:56,920
So why not say that Lipsy is always loaded at address 100 for everyone that way the addresses

547
00:50:56,920 --> 00:51:01,559
will not change.

548
00:51:01,559 --> 00:51:04,639
So what are the issues with that approach?

549
00:51:04,639 --> 00:51:12,119
If we do that if we say that this DSO takes address 100 to 500 for all processes that

550
00:51:12,119 --> 00:51:17,840
way addresses will remain same and we don't even if we change the text section the content

551
00:51:17,840 --> 00:51:20,980
will still be same for all the processes.

552
00:51:20,980 --> 00:51:24,200
What are issues with such an approach?

553
00:51:25,000 --> 00:51:26,599
Correct.

554
00:51:26,599 --> 00:51:31,659
So if you reserve some addresses that means even if there is a process which does not

555
00:51:31,659 --> 00:51:37,839
need to use that DSO those addresses cannot be reused for something else.

556
00:51:37,839 --> 00:51:44,679
So very inefficient use of the address space plus if the library changes so for example

557
00:51:44,679 --> 00:51:50,339
today printf requires 5 bytes to store tomorrow it requires 50 bytes then how will you get

558
00:51:50,579 --> 00:51:56,700
more addresses because you have said printf should fit within only these addresses and

559
00:51:56,700 --> 00:52:01,500
then you create your own library then how will you get address space.

560
00:52:01,500 --> 00:52:07,019
So it becomes a problem of who is the authority to give you that these addresses are reserved

561
00:52:07,019 --> 00:52:13,380
for you and that needs to be consistent across everyone every process.

562
00:52:13,380 --> 00:52:17,940
So this is basically really bad idea we can't do with this.

563
00:52:17,940 --> 00:52:21,700
So that's where the position independent code comes into picture.

564
00:52:21,700 --> 00:52:26,619
How many of you have heard of this term PIC?

565
00:52:26,619 --> 00:52:32,860
So what position independent code implies is it's the code which can be loaded at any

566
00:52:32,860 --> 00:52:38,860
address without any modifications.

567
00:52:38,860 --> 00:52:44,420
And if we somehow have position independent code what it means is I could load it at any

568
00:52:44,420 --> 00:52:49,820
location in different processes and I don't have to change it.

569
00:52:49,820 --> 00:52:53,820
That means it truly works.

570
00:52:53,820 --> 00:52:58,539
So if we can somehow have position independent code the problem which we have currently at

571
00:52:58,539 --> 00:53:02,539
our hand will get solved.

572
00:53:02,539 --> 00:53:05,619
Now how do you obviously achieve this?

573
00:53:05,619 --> 00:53:07,019
Indirection.

574
00:53:07,019 --> 00:53:11,320
Every problem can be solved using additional indirection.

575
00:53:11,320 --> 00:53:15,760
So let's look at what assembler did.

576
00:53:15,760 --> 00:53:21,720
You remember yesterday we learnt assembler for 5 minutes where we saw that there are

577
00:53:21,720 --> 00:53:24,200
3 types of addresses.

578
00:53:24,200 --> 00:53:29,680
There is PC relative address, there is section relative address and there is file relative

579
00:53:29,680 --> 00:53:31,760
address.

580
00:53:31,760 --> 00:53:41,320
Now the beauty of PC relative address is it is position independent.

581
00:53:41,320 --> 00:53:43,760
Does everyone get why?

582
00:53:43,760 --> 00:53:49,840
Because no matter where the text section begins the distance between JMP done and done is

583
00:53:49,840 --> 00:53:54,760
going to remain same.

584
00:53:54,760 --> 00:54:01,360
If I use section relative address that might actually change because I have to add something

585
00:54:01,360 --> 00:54:05,160
to get to the data section.

586
00:54:05,160 --> 00:54:12,480
So essentially PC relative addresses by design are position independent and no matter where

587
00:54:12,480 --> 00:54:14,760
the text section is loaded.

588
00:54:14,760 --> 00:54:22,360
So if JMP says JMP to 5 bytes after current instruction then no matter where it is loaded

589
00:54:22,360 --> 00:54:26,480
the same instruction is going to work.

590
00:54:26,480 --> 00:54:30,120
No matter what is the address of the JMP itself.

591
00:54:30,119 --> 00:54:31,799
Does that make sense?

592
00:54:31,799 --> 00:54:35,000
So this is the key idea which we will use.

593
00:54:35,000 --> 00:54:42,279
So when dynamic linker is linked, when the static linker is merging the objects it knows

594
00:54:42,279 --> 00:54:47,119
sizes of various sections.

595
00:54:47,119 --> 00:54:52,719
And it knows that when move refers to some data.

596
00:54:52,719 --> 00:55:00,399
So when we had a reference for GBL in the text section instead of using address of GBL

597
00:55:00,399 --> 00:55:05,799
why can't we use relative address of GBL from the current instruction.

598
00:55:05,799 --> 00:55:07,239
Does that make sense?

599
00:55:07,239 --> 00:55:12,859
So remember what we were doing earlier is when we had move instruction we were actually

600
00:55:12,859 --> 00:55:16,359
using the actual address of GBL variable.

601
00:55:16,360 --> 00:55:23,000
So if GBL was loaded at location 100 then we would say move from address 100 to some

602
00:55:23,000 --> 00:55:24,000
register.

603
00:55:24,000 --> 00:55:32,880
Instead we could say that move from relative address of GBL from the current instruction.

604
00:55:32,880 --> 00:55:40,320
And no matter where the base of this starts the code will still keep working as long as

605
00:55:40,320 --> 00:55:44,400
they are in the same contiguous region.

606
00:55:44,440 --> 00:55:51,760
And remember when we saw the memory map the text section and code data section were all

607
00:55:51,760 --> 00:55:53,720
one after the other.

608
00:55:53,720 --> 00:55:56,960
And those were laid out by linker statically.

609
00:55:56,960 --> 00:56:00,760
Nothing came in between that.

610
00:56:00,760 --> 00:56:05,079
So this is the essential idea of what we will do.

611
00:56:05,079 --> 00:56:11,480
So we will somehow generate code which will not use absolute address in the instruction

612
00:56:11,639 --> 00:56:15,599
but relative address in the instructions.

613
00:56:15,599 --> 00:56:23,920
And this is done by additional level of indirection called as GOT global offset table.

614
00:56:23,920 --> 00:56:28,039
I hope it is very easy to remember term now.

615
00:56:28,039 --> 00:56:35,219
So GOT you can think of as a indirection which exists.

616
00:56:35,219 --> 00:56:43,859
So what you do is for every variable which you have you store its address in a table

617
00:56:43,859 --> 00:56:47,259
called as global offset table.

618
00:56:47,259 --> 00:56:53,179
So global offset table holds address of every variable and it holds absolute address of

619
00:56:53,179 --> 00:56:55,379
every variable.

620
00:56:55,379 --> 00:57:03,699
So the GOT holds absolute address of every variable and GOT is at fixed distance from

621
00:57:03,699 --> 00:57:06,059
the text section.

622
00:57:06,059 --> 00:57:15,139
So whenever you have to refer to a variable you first look up where is the GOT entry for

623
00:57:15,139 --> 00:57:24,779
that and read the address of that and use that address to actually dereference.

624
00:57:24,779 --> 00:57:26,059
Is it clear?

625
00:57:26,059 --> 00:57:32,939
The indirection so from code instead of directly accessing the variable you first see what

626
00:57:32,940 --> 00:57:42,179
is the address of variable in the GOT and GOT is at fixed position as laid out by linker

627
00:57:42,179 --> 00:57:45,940
and then from GOT you get the address.

628
00:57:45,940 --> 00:57:56,300
So now one of the things is x86 supports instructions like call and jump which support PC relative

629
00:57:56,300 --> 00:57:57,440
addressing.

630
00:57:57,440 --> 00:58:03,340
That means the offset which you are encoding needs to be relative to the current instruction

631
00:58:03,340 --> 00:58:09,820
but the instructions like move do not really support relative addressing.

632
00:58:09,820 --> 00:58:16,960
So whenever I say move from this address hardware is going to interpret that address as absolute

633
00:58:16,960 --> 00:58:17,960
address.

634
00:58:17,960 --> 00:58:26,440
There is no way that you can say that move from five locations below current location.

635
00:58:26,440 --> 00:58:28,220
So there is no way.

636
00:58:28,220 --> 00:58:33,320
So how do you obtain PC relative data reference?

637
00:58:33,320 --> 00:58:39,119
So if you have a program counter so if I know my current instruction and if I know the absolute

638
00:58:39,119 --> 00:58:41,700
address I can compute the difference.

639
00:58:41,700 --> 00:58:55,039
So for example in so let us say my current instruction is here my PC is here and then

640
00:58:55,039 --> 00:59:01,420
I have bunch of other instructions and then I have my data section.

641
00:59:01,420 --> 00:59:08,239
I can obtain the relative address between PC and data by knowing the address of PC absolute

642
00:59:08,239 --> 00:59:13,719
address of PC and absolute address of data because I can simply subtract them to get

643
00:59:13,719 --> 00:59:16,960
the distance between them.

644
00:59:16,960 --> 00:59:21,519
Now how do you get program counter?

645
00:59:21,519 --> 00:59:29,039
So you still remember we had a trick yesterday which was the first quiz on how to get address

646
00:59:29,039 --> 00:59:32,039
of the current instruction.

647
00:59:32,039 --> 00:59:41,599
We get address of current instruction by doing a dummy call and popping from the stack and

648
00:59:41,599 --> 00:59:47,159
EBX now holds the current instruction and now we already know how to get absolute address

649
00:59:47,159 --> 00:59:54,599
of symbols and we subtract them and we get the PC relative address.

650
00:59:54,599 --> 00:59:56,639
Is it clear?

651
00:59:56,639 --> 01:00:04,259
Now this is what the code will look like.

652
01:00:04,259 --> 01:00:10,879
So whenever you have to access any variable you first have to get address of GOT and address

653
01:00:10,879 --> 01:00:16,960
of GOT can be obtained using the trick which I showed in the last slide because GOT is

654
01:00:16,960 --> 01:00:20,880
at some fixed position from every instruction.

655
01:00:20,880 --> 01:00:27,240
Once you have address of GOT every variable has a entry in GOT.

656
01:00:27,240 --> 01:00:36,480
So let's say you say GBL is entry 0, GBL 2 is entry 2, GBL 3 is entry 3 and so on.

657
01:00:36,480 --> 01:00:43,000
Then you get address of the variable from GOT and then that's what you use to dereference

658
01:00:43,000 --> 01:00:45,440
your code.

659
01:00:45,440 --> 01:00:48,200
Is the algorithm clear on how we are going to do it?

660
01:00:48,200 --> 01:00:54,240
So anytime you have to refer to a variable you first look up where is the GOT.

661
01:00:54,240 --> 01:01:00,960
Once you have GOT you know layout of the GOT that in what order symbols are laid out in

662
01:01:00,960 --> 01:01:08,720
GOT and then you use that entry to get the actual address of the symbol.

663
01:01:08,720 --> 01:01:10,639
So this is how the code will look.

664
01:01:10,639 --> 01:01:15,920
I'm sure when you were looking at this assembly you were seeing something like this x86 PC

665
01:01:15,920 --> 01:01:17,619
get THUNC CX.

666
01:01:17,619 --> 01:01:19,759
How many of you saw this?

667
01:01:19,759 --> 01:01:25,119
That there was something in the text section called THUMCX and THUMBX and so on.

668
01:01:25,119 --> 01:01:29,759
So this THUNC code is actually doing the trick which we did.

669
01:01:29,759 --> 01:01:35,319
So it is going to do a call and it is going to do a pop and return.

670
01:01:35,320 --> 01:01:41,960
So after this instruction CX registers holds address of the current instruction.

671
01:01:41,960 --> 01:01:48,960
And then we add to that the offset I mean this address will likely be negative and then

672
01:01:48,960 --> 01:01:55,360
we add to that the address of the how far GOT is from the text section which was decided

673
01:01:55,360 --> 01:01:58,720
by linker.

674
01:01:59,279 --> 01:02:05,959
So at this point ECX holds the base address of GOT.

675
01:02:05,959 --> 01:02:10,819
Then we essentially get to the variable which we wanted.

676
01:02:10,819 --> 01:02:19,500
So minus C holds the address of whatever variable we were concerned with and loads that address

677
01:02:19,500 --> 01:02:28,039
and then we actually load from that address to get the content of the variable.

678
01:02:28,039 --> 01:02:29,159
Is this clear?

679
01:02:29,159 --> 01:02:35,239
Because this is the key part of how dynamic libraries work.

680
01:02:35,239 --> 01:02:42,000
So remember to access any variable you have to first load somehow GOT.

681
01:02:42,000 --> 01:02:47,519
GOT you can load by knowing the PC relative address between your text section and data

682
01:02:47,519 --> 01:02:50,679
section which was done by linker.

683
01:02:50,679 --> 01:02:56,920
Once you have GOT then within GOT you have series of variables addresses and then you

684
01:02:56,920 --> 01:03:03,639
load address of whatever variable you want from that into the register and then you actually

685
01:03:03,639 --> 01:03:09,960
dereference it.

686
01:03:09,960 --> 01:03:15,039
The question is how is the address of variable actually placed into GOT?

687
01:03:15,039 --> 01:03:23,760
How does GOT know that GBL is at location 563 or whatever?

688
01:03:23,760 --> 01:03:27,000
Because the addresses will still be allocated at runtime.

689
01:03:27,000 --> 01:03:31,760
So compiler does not know or linker does not know what will be the actual address to be

690
01:03:31,760 --> 01:03:36,360
put in GOT.

691
01:03:36,360 --> 01:03:39,080
Relocation.

692
01:03:39,079 --> 01:03:57,199
So what we do is we generate a relocation on this entry for example.

693
01:03:57,199 --> 01:04:04,840
Since we do not know what is address of var 1 until it is loaded we can simply say var

694
01:04:04,840 --> 01:04:10,440
1 holds some dummy content and there will be a relocation to patch this content with

695
01:04:10,440 --> 01:04:14,840
address of var 1.

696
01:04:14,840 --> 01:04:17,480
Is that clear?

697
01:04:17,480 --> 01:04:23,000
So var 1 in GOT needs to hold absolute address and unless it is loaded we do not know that

698
01:04:23,000 --> 01:04:24,079
address.

699
01:04:24,079 --> 01:04:34,380
So there will be a relocation to patch this address.

700
01:04:34,380 --> 01:04:36,680
So you can actually see this.

701
01:04:36,680 --> 01:04:42,519
So there is another type of relocation called R386 globe dat.

702
01:04:42,519 --> 01:04:46,900
What this is saying is patch the address of var 1 in GOT.

703
01:04:46,900 --> 01:04:53,420
This offset is actually in the GOT.

704
01:04:53,420 --> 01:04:59,860
Now I told you relocations are bad because of relocations we were not able to share the

705
01:04:59,860 --> 01:05:02,140
text section.

706
01:05:02,139 --> 01:05:10,500
So now if we are again going to generate relocation what is the use of all this scheme?

707
01:05:10,500 --> 01:05:15,179
Because of relocations which were present earlier we were not able to share the text

708
01:05:15,179 --> 01:05:17,139
section.

709
01:05:17,139 --> 01:05:26,019
Now we are saying to patch address of variable in GOT we still need a relocation.

710
01:05:26,019 --> 01:05:46,500
But as soon as something is patched which is different for different processes you cannot

711
01:05:46,500 --> 01:05:51,099
share it.

712
01:05:51,099 --> 01:05:56,900
Does everyone get the question on what I am trying to ask?

713
01:05:56,900 --> 01:05:59,099
So recollect what was happening earlier.

714
01:05:59,099 --> 01:06:04,900
So in earlier case what was happening is MOV instruction had a relocation which says patch

715
01:06:04,900 --> 01:06:08,460
the address of GBL in MOV instruction.

716
01:06:08,460 --> 01:06:13,860
Because of that the problem was if GBL was at different locations there was a problem

717
01:06:13,860 --> 01:06:18,059
because the code section cannot be shared between two processes.

718
01:06:18,059 --> 01:06:23,539
Now what we are saying is we did all this complicated thing and we said that MOV will

719
01:06:23,539 --> 01:06:34,179
now refer to GOT and GOT will have a relocation because GOT how does it know where is GBL?

720
01:06:34,179 --> 01:06:41,380
So are we not losing all the benefit which we created by this indirection?

721
01:06:41,700 --> 01:06:44,619
Correct.

722
01:06:44,619 --> 01:06:51,780
So one of the things which you have to understand is GOT is not in the text section.

723
01:06:51,780 --> 01:06:55,140
GOT is in the data section.

724
01:06:55,140 --> 01:06:57,980
So there are no relocations on the text section.

725
01:06:57,980 --> 01:07:04,740
Remember text section was only referring to GOT which was at the fixed relative address.

726
01:07:04,740 --> 01:07:08,099
And GOT what will relocation do?

727
01:07:08,099 --> 01:07:15,179
Relocation will change data in GOT and it will change it differently for different processes.

728
01:07:15,179 --> 01:07:16,619
But guess what?

729
01:07:16,619 --> 01:07:21,860
Every process needs to have its own data because things are going to be different.

730
01:07:21,860 --> 01:07:29,819
Because GBL in process P1 may hold different data than it may hold in process P2.

731
01:07:29,819 --> 01:07:33,880
Does everyone get this?

732
01:07:33,880 --> 01:07:40,599
So what we did by this is we shifted all the relocations which earlier were present in

733
01:07:40,599 --> 01:07:43,519
text section into data section.

734
01:07:43,519 --> 01:07:48,440
That way text section can now actually be shared.

735
01:07:48,440 --> 01:07:56,400
So when you have Lipsy loaded, what is happening is all the processes are sharing same physical

736
01:07:56,400 --> 01:07:58,119
copy of printf.

737
01:07:58,119 --> 01:08:03,800
Although printf itself might be loaded at different addresses for different processes.

738
01:08:03,800 --> 01:08:10,200
The data required by printf is still duplicated by every process because data needs to be

739
01:08:10,200 --> 01:08:15,519
different because processes may call printf differently.

740
01:08:15,519 --> 01:08:16,900
Does that make sense?

741
01:08:16,900 --> 01:08:22,680
So what this is allowing us to do is to be able to share the code.

742
01:08:22,680 --> 01:08:25,619
It's not sharing data.

743
01:08:25,619 --> 01:08:31,960
And shared libraries are for sharing code, not sharing data.

744
01:08:31,960 --> 01:08:33,899
Is this clear?

745
01:08:33,899 --> 01:08:41,480
Because this is I think the fundamental reason why DSOs exist and why there is this complicated

746
01:08:41,480 --> 01:08:44,640
mechanism.

747
01:08:44,640 --> 01:08:51,319
Now the library which we created earlier did not have this GOT and other things.

748
01:08:51,319 --> 01:08:54,079
So how do you create a library which had GOT?

749
01:08:54,079 --> 01:09:03,559
So you specify a flag called fpick when creating the shared library.

750
01:09:03,559 --> 01:09:05,500
So let's try that.

751
01:09:05,500 --> 01:09:08,119
So I had this library already.

752
01:09:08,119 --> 01:09:18,100
So instead of compiling it as normal library, I will compile it as pick library.

753
01:09:18,100 --> 01:09:29,740
Now what I see is if I look at the obj dump with relocations, you can see foo does not

754
01:09:29,740 --> 01:09:33,220
have any relocations.

755
01:09:33,220 --> 01:09:37,620
If you look at it, foo does not have any relocations.

756
01:09:37,620 --> 01:09:42,940
Unlike earlier case where foo had relocations to patch the address of gbl and bar and this

757
01:09:42,940 --> 01:09:45,039
and that.

758
01:09:45,039 --> 01:09:57,239
And there is we can see something called as GOT.

759
01:09:57,239 --> 01:10:02,439
So there is something called as GOT which is coming.

760
01:10:02,439 --> 01:10:15,539
And you can also see there are relocations on GOT.

761
01:10:15,539 --> 01:10:26,139
For some reason this machine has become very slow.

762
01:10:26,139 --> 01:10:31,379
So if you look at it, now these are actually some of the relocations which will be present

763
01:10:31,380 --> 01:10:33,119
on GOT.

764
01:10:33,119 --> 01:10:39,039
So it is asking to populate address of gbl in the GOT.

765
01:10:39,039 --> 01:10:41,140
Is everyone clear with that?

766
01:10:41,140 --> 01:10:49,920
So to create a shared library, we have fpick.

767
01:10:49,920 --> 01:10:55,140
So I think we can stop here for now and continue after the lunch.

