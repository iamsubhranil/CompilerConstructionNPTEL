1
00:00:00,000 --> 00:00:15,000
Correct. So, C99 onwards that means if you are using fairly recent compiler it should

2
00:00:15,000 --> 00:00:20,000
be there unless you are using some turbo C kind of thing this would not be there, but

3
00:00:20,000 --> 00:00:28,160
in any recent and decent compiler this should be supported. This concept is actually called

4
00:00:28,160 --> 00:00:39,159
as variable length array or VLA in short form. Now, the question is when you have VLA in

5
00:00:39,159 --> 00:00:50,840
your program how will the offsets computed because n is dynamic value and it can vary

6
00:00:50,840 --> 00:00:58,720
for every call which you make to that function. So, how will you allocate and access the variables?

7
00:00:58,720 --> 00:01:08,040
So far what we have seen is you have ESP from which you can reference and ESP will keep

8
00:01:08,040 --> 00:01:16,240
growing or changing. So, whenever you have VLA you have to change the ESP dynamically.

9
00:01:16,239 --> 00:01:41,060
Yes. So, that is one way to implement VLA where you can actually allocate it on heap. So,

10
00:01:41,060 --> 00:01:48,100
that would solve the problem to some extent, but if you had to allocate it on stack then what will

11
00:01:48,100 --> 00:01:55,460
you do? By the way the semantics of VLA is by the time function returns you have to deallocate.

12
00:01:56,500 --> 00:02:02,020
So, what you will have to do is you have to insert a malloc call and free call at end of

13
00:02:02,020 --> 00:02:08,740
the function. So, that is how you can implement it on heap, but you have to implement it on stack

14
00:02:08,740 --> 00:02:21,100
what will you do? What I would suggest is today end of day or whenever you have time try writing

15
00:02:21,100 --> 00:02:27,260
such programs and look at the assembly and see what kind of stack layout is generated and you

16
00:02:27,260 --> 00:02:34,540
can try this with base pointer preserved and with dash f omit base pointer and see how things are

17
00:02:34,539 --> 00:02:40,819
changing. But this essentially requires dynamic allocation on the stack as the program is running

18
00:02:40,819 --> 00:02:49,139
you have to keep allocating. Any doubts before we kind of move on? So, so far what we have seen is

19
00:02:49,139 --> 00:02:55,379
how to handle local variables and we have seen how to transfer control back and forth between

20
00:02:55,379 --> 00:03:00,219
caller and callee. The other thing which is interesting is how the parameters need to be

21
00:03:00,219 --> 00:03:07,180
handled. So, we had parameters which need to be passed from caller to callee. Now just like the

22
00:03:07,180 --> 00:03:13,180
problems which we had earlier the callee function needs to know where the parameters are so that it

23
00:03:13,180 --> 00:03:19,939
can access it and caller needs to know where the return at value is so that they can interface

24
00:03:19,939 --> 00:03:28,300
between the two. So, typically how will where will you pass parameters? Let us go with the same set

25
00:03:28,380 --> 00:03:34,620
of things which we were trying to answer. Can we store them in hardware registers? We may not have

26
00:03:34,620 --> 00:03:41,939
sufficient number of registers and plus we might have an aggregate which is like a struct like a

27
00:03:41,939 --> 00:03:47,820
struct of 10 elements or struct of 5 elements those again may not fit into the registers.

28
00:03:47,820 --> 00:03:57,980
What about global variables? Correct same problem with recursion so the answer is stack. So, now you

29
00:03:57,979 --> 00:04:05,579
should know at least how to get to stack. So, this is the stack frame which we have seen so far. So,

30
00:04:05,579 --> 00:04:12,099
we have stack frame of the caller function and stack frame of the callee function and here we

31
00:04:12,099 --> 00:04:18,139
know we have local variables which are stored. So, where should parameters be stored? Should

32
00:04:18,139 --> 00:04:22,740
they be stored in the stack frame of callee function or stack frame of the caller functions?

33
00:04:22,740 --> 00:04:36,500
Why callee? But how will a caller function allocate something into callee stack frame?

34
00:04:36,500 --> 00:04:42,340
Because remember to access callee stack frame you must have written address already pushed

35
00:04:42,340 --> 00:04:48,540
on to the stack and that will happen only after call instruction is executed. So,

36
00:04:48,540 --> 00:04:55,700
how will you say how will you create a hole in the stack? See to be able to allocate in

37
00:04:55,700 --> 00:05:02,939
the callee stack frame what you need is caller is executing somewhere here you need to create

38
00:05:02,939 --> 00:05:08,780
a hole for return address for the call instruction then allocate stuff here get back stack pointer

39
00:05:08,780 --> 00:05:15,660
here and then so that it is laid out. So, it actually gets allocated in the caller stack frame.

40
00:05:16,660 --> 00:05:21,900
So, these are allocated on the caller stack frames. So, caller function will push things

41
00:05:21,900 --> 00:05:30,980
on to the stack and then the call instruction will push the return address. So, parameters are just

42
00:05:30,980 --> 00:05:41,740
above the stack pointer sorry return address and this essentially forms yet another contract.

43
00:05:41,780 --> 00:05:49,139
Now, callee needs to access things from the caller stack frame. Does everyone understand

44
00:05:49,139 --> 00:05:55,100
this? We could not allocate it in callee stack frame because caller does not have access to

45
00:05:55,100 --> 00:06:01,500
callee stack frame, but callee can access callers stack frame and this kind of gets to a point which

46
00:06:01,500 --> 00:06:07,100
we were getting earlier and you need to make sure that callee can access callers stack frame. You

47
00:06:07,100 --> 00:06:15,500
cannot have a violation there. So, what will happen is so let us say I had this function. So,

48
00:06:15,500 --> 00:06:21,300
this has bunch of local variables x y and some those we have already seen those are saved here.

49
00:06:21,300 --> 00:06:29,060
So, if EBP is here they are at EBP minus 4 EBP minus 8 EBP minus 12 and then there are

50
00:06:29,060 --> 00:06:37,540
parameters m and n. So, those are actually pushed here. Again the same thing applies

51
00:06:37,540 --> 00:06:43,939
that if you had a base pointer then they will be at the fixed offset. So, you can access them as

52
00:06:43,939 --> 00:06:51,540
EBP plus 4 is written address EBP plus 8 is this parameter EBP plus 12 is this parameter.

53
00:06:51,900 --> 00:07:00,100
And you can access the parameter with their EBP relative address. Again in this case you can use

54
00:07:00,100 --> 00:07:06,180
stack pointer it just adds more complexity within the compiler, but there is nothing wrong with

55
00:07:06,180 --> 00:07:12,700
being able to use stack pointer. Now the question what should be the order of parameters on the

56
00:07:12,699 --> 00:07:18,060
stack? Should it be passed left to right or should it be passed right to left?

57
00:07:18,060 --> 00:07:43,019
Correct. So, does that even matter? So, does the order of parameters on the stack matter?

58
00:07:48,540 --> 00:07:53,579
So, as long as both caller and callee agree that I am passing left to right or right to left and

59
00:07:53,579 --> 00:07:59,660
both of them access in the consistent way there shouldn't be any problem. Yes.

60
00:07:59,660 --> 00:08:12,939
Correct. So, in this case if you actually look at it the parameter I mean parameters are passed

61
00:08:12,939 --> 00:08:19,819
in right to left order. So, if you look at n is pushed first then m is pushed. So, in this case

62
00:08:19,819 --> 00:08:25,259
things are actually passed right to left and the reason for that is vararq functions.

63
00:08:26,060 --> 00:08:32,460
Does everyone know what is a vararq function? Printf is an example of vararq function. So,

64
00:08:32,460 --> 00:08:42,059
let us say I had a printf in which I pass a string and I pass x y z w whatever number of parameters

65
00:08:43,020 --> 00:08:47,900
now let us imagine what is happening in vararq function. So, let us try to say that I will push

66
00:08:47,900 --> 00:08:52,860
things from left to right that means what will happen is first percent s will be pushed

67
00:08:53,980 --> 00:08:59,420
then x will be pushed then y will be pushed then g will be pushed then w will be pushed

68
00:08:59,420 --> 00:09:07,820
and my stack pointer is here. Now the problem is

69
00:09:08,620 --> 00:09:14,700
printf function the callee function does it know how many parameters were passed?

70
00:09:16,780 --> 00:09:22,460
It does not know how many parameters were passed. The only way it can figure out how many parameters

71
00:09:22,460 --> 00:09:31,500
were passed is by looking at percent s. So, if this was say percent d percent d percent d percent d.

72
00:09:31,580 --> 00:09:39,019
So, it knows that four things were passed to me. But how does it know where this string itself is

73
00:09:39,019 --> 00:09:47,259
stored? The string itself will be stored at some location in the caller stack frame and I do not

74
00:09:47,259 --> 00:09:56,299
know where it is. See because what is happening is so this is in the caller what is happening in the

75
00:09:56,299 --> 00:10:03,659
callee. So, in callee I need to access the parameter. So, I can access the parameter using

76
00:10:03,659 --> 00:10:16,620
ebp plus 4 ebp plus 8 ebp plus 12 and so on. But I do not know where is this string stored

77
00:10:18,299 --> 00:10:22,379
right because it will depend on how many parameters were passed.

78
00:10:22,379 --> 00:10:29,820
Instead let us look at it differently. If I pass things in right to left order then caller

79
00:10:30,539 --> 00:10:40,539
will look like this. So, I have w I have y x sorry I have z y x percent s.

80
00:10:41,899 --> 00:10:43,580
How does callee know where is the string?

81
00:10:43,580 --> 00:10:55,259
ebp plus 4. So, first parameter always is at deterministic location no matter how many other

82
00:10:55,259 --> 00:11:00,700
parameters were passed. So, no matter 100 parameters were passed or 200 parameters were

83
00:11:00,700 --> 00:11:08,060
passed first parameter will always be at deterministic location which allows us to implement var arc

84
00:11:08,059 --> 00:11:15,339
functions. If you do not have var arc function it does not matter whether you pass left to right

85
00:11:15,339 --> 00:11:21,259
or right to left or even any other order for that matter. For example, I might say I will first pass

86
00:11:21,259 --> 00:11:26,619
middle parameter then one on the left one on the right and keep going. So, it does not matter as

87
00:11:26,619 --> 00:11:33,979
long as both of them agree on something. So, var arc function causes us to have this.

88
00:11:34,940 --> 00:11:43,420
Now, can you help answer this quiz? So, I have two functions foo and bar both of which print

89
00:11:43,420 --> 00:11:50,779
their name and return some value and then in printf I call foo and bar. We know parameters are passed

90
00:11:50,779 --> 00:11:59,899
from right to left. Sorry.

91
00:11:59,899 --> 00:12:15,740
First we call bar. So, are you saying the output will be 2 4. So,

92
00:12:16,620 --> 00:12:31,340
is the output. So, one output can you tell me exact output bar then foo

93
00:12:31,340 --> 00:12:53,180
4 2. So, this is one possible answer we have got bar foo 4 2 any other. Bar foo 2 4.

94
00:12:53,500 --> 00:13:05,019
Okay. Any other answers.

95
00:13:06,859 --> 00:13:19,019
Yes. Okay. Sorry.

96
00:13:19,340 --> 00:13:26,139
Bar foo 2 4 previous one. So, this one is discarded. Can you explain why you discarded this option?

97
00:13:29,899 --> 00:13:36,539
Correct. Correct. Okay. So, the param no matter order in which parameters are passed

98
00:13:37,100 --> 00:13:41,819
foo is still printed. I mean whatever value returned by foo will be printed as first

99
00:13:41,900 --> 00:13:47,660
and whatever value of bar is printed here. So, this has to print 2 and 4.

100
00:13:48,780 --> 00:13:56,540
Yeah. Okay. And then since things 4 and 2 and then bar and foo any other answers. Yes.

101
00:13:58,540 --> 00:14:05,660
Okay. So, we have someone saying foo bar 4 2.

102
00:14:05,659 --> 00:14:12,299
Can this also come?

103
00:14:17,659 --> 00:14:27,500
How many of you think first answer is correct? Raise your hand. Okay. Majority. How many of you

104
00:14:27,500 --> 00:14:39,899
think second answer is correct? Okay. Minority. Any other answers? Any one for f, b, o, a something

105
00:14:39,899 --> 00:14:57,419
some mix. Okay. So, the reasoning why second answer is coming is because

106
00:14:57,659 --> 00:15:04,460
it will evaluate foo first by looking at first percent d and then it will look at evaluate bar

107
00:15:04,460 --> 00:15:14,059
by looking at second percent d. Okay. So, what is the correct answer? Okay. So, this is where we get

108
00:15:14,059 --> 00:15:23,019
into unspecified behavior. Okay. Both answers are correct. Okay. But you have to remember

109
00:15:23,019 --> 00:15:35,100
order of parameter passing is not order of evaluation. Okay. Nothing in c says that foo

110
00:15:35,100 --> 00:15:43,579
must be done first and bar must be done after that or vice versa. So, order of parameter passing

111
00:15:43,579 --> 00:15:49,819
does not influence order of evaluation. So, this code is actually equivalent to this.

112
00:15:49,900 --> 00:15:58,300
T is equal to foo, T2 is equal to bar or T is equal to bar and T2 equal to foo. Okay.

113
00:16:00,860 --> 00:16:05,820
Just for that matter you must have by now you should be preparing for your campus interviews.

114
00:16:05,820 --> 00:16:08,140
Right. So, you must have seen codes like this.

115
00:16:08,139 --> 00:16:25,019
So, what is the order in which things are evaluated?

116
00:16:28,059 --> 00:16:34,460
So, tell me the answer to this question. i is 1 to begin with, j is 0 to begin with.

117
00:16:39,100 --> 00:16:41,740
What is the textbook answer for this question?

118
00:16:44,779 --> 00:16:54,539
Correct. Okay. So, eval from right to left. So, first minus minus j will happen. Then i plus 1

119
00:16:54,539 --> 00:17:00,460
will happen. So, this will actually print 2. Then it will again print 1 and this will again increment

120
00:17:00,460 --> 00:17:06,220
2. So, that is the bookish answer which you must have seen in some MCQs. Right. Now, that is

121
00:17:06,220 --> 00:17:12,620
actually incorrect. That is incorrect for two reasons. One is you do not know the order in which

122
00:17:12,620 --> 00:17:20,860
things are evaluated. Second is this code actually has undefined behavior. Because it is trying to

123
00:17:20,860 --> 00:17:27,259
modify value of the same variable multiple times within something called as a sequence point.

124
00:17:28,140 --> 00:17:36,059
Okay. So, just sequence points are the points where language says all the side effects must

125
00:17:36,059 --> 00:17:41,500
have completed prior to that. And there is no sequence point within this which causes that to

126
00:17:41,500 --> 00:17:48,379
happen. Okay. So, the answer to this question is undefined behavior. But most likely in the MCQ,

127
00:17:48,379 --> 00:17:53,660
you will not have that option. So, remember evaluate from right to left to get the correct

128
00:17:54,460 --> 00:18:01,019
answer to match the book. But it is not correct. Okay. So, if you have undefined behavior, take

129
00:18:01,019 --> 00:18:09,340
that. If you do not have, remember how to evaluate. Okay. Now, so far we have seen this that stack

130
00:18:09,340 --> 00:18:14,460
grows down, stack grows down. How do you detect programmatically? So, can you write program

131
00:18:15,660 --> 00:18:17,740
which will detect that stack is growing down?

132
00:18:17,740 --> 00:18:31,420
You do not have, you do not have access to push from C. You have to write a C program to detect.

133
00:18:31,420 --> 00:18:45,420
Okay. So, let us do this. So, I do something like this. So, I have

134
00:18:45,420 --> 00:18:55,900
f int foo where I create x, y, z. What will I do? How do I detect stack grows down?

135
00:19:07,580 --> 00:19:08,779
What is the problem with this?

136
00:19:08,779 --> 00:19:20,059
ASLR will not play a role here. But we will see what is ASLR actually.

137
00:19:28,700 --> 00:19:34,299
Correct. So, one of the things is C does not say or mandate that x must be allocated first,

138
00:19:34,299 --> 00:19:40,139
then y must be allocated and then z must be allocated. So, compiler is first free to allocate

139
00:19:40,139 --> 00:19:49,419
z first or y first or x first. So, you cannot rely on the addresses of x, y and z. In what case

140
00:19:49,419 --> 00:19:57,099
there is a guarantee for having contiguous is array. So, if I had ARR of something, then C

141
00:19:57,179 --> 00:20:05,259
mandates that array is allocated contiguously. That means address of ARR 0 and addresses of ARR

142
00:20:05,259 --> 00:20:09,740
1, they are related and contiguous. So, how will I actually write the expression?

143
00:20:10,299 --> 00:20:14,859
What should I write to actually say stack grows down? What should be the condition?

144
00:20:14,859 --> 00:20:24,859
If blah, blah, blah printf down else

145
00:20:44,939 --> 00:20:46,859
A1.

146
00:21:00,939 --> 00:21:07,579
Does everyone understand how this is happening? So, if you look at even our diagrams,

147
00:21:07,659 --> 00:21:20,539
they had it that way. So, ARR of 5 addresses lower than ARR of 6 addresses.

148
00:21:25,899 --> 00:21:30,299
Now, can you figure out the answer to this question? This will take some time.

149
00:21:30,299 --> 00:21:34,299
Please work out on paper and tell me what happens.

150
00:21:37,579 --> 00:21:47,740
Everyone understands at least the syntax and the code.

151
00:21:51,579 --> 00:21:54,699
Sorry, infinite.

152
00:21:58,699 --> 00:22:05,259
Okay, any other answers? So, they are saying it is some sort of infinite call to bar.

153
00:22:05,259 --> 00:22:07,579
It doesn't look like.

154
00:22:14,460 --> 00:22:17,420
It is some simple pointer manipulation.

155
00:22:26,460 --> 00:22:27,819
Any other answers so far?

156
00:22:27,819 --> 00:22:30,939
Yes.

157
00:22:38,220 --> 00:22:39,259
Do you need to know?

158
00:22:43,819 --> 00:22:48,939
In this particular case, it shouldn't matter. But can you explain why you were curious about that?

159
00:22:52,059 --> 00:22:57,339
I mean, how does that help you know the answer? I am just trying to understand what is the intuition.

160
00:22:57,819 --> 00:23:03,659
Okay.

161
00:23:08,619 --> 00:23:08,939
Sorry.

162
00:23:12,779 --> 00:23:18,779
Okay, so it will just call infu. I mean, it will print infu and then it will print indbar. That is it.

163
00:23:18,779 --> 00:23:25,420
It will never return from main.

164
00:23:25,420 --> 00:23:32,619
It will never return from main. Okay. So, if I had put in main as a printf,

165
00:23:32,619 --> 00:23:34,779
then it will get printed multiple times.

166
00:23:38,619 --> 00:23:40,460
Okay, why do you think that way?

167
00:23:40,460 --> 00:23:55,500
So, so far we have two answers. One is there is infu which is printed and then inbar, inbar,

168
00:23:55,500 --> 00:24:01,259
inbar, inbar which is continuously printed. Then we have another answer which is infu is printed,

169
00:24:01,259 --> 00:24:08,620
inbar is printed and then some sort of hang occurs. But neither we are infu or bar. Is that correct?

170
00:24:08,619 --> 00:24:14,939
Okay. Any other answers? And one answer was infu, inbar successfully exit. No issues.

171
00:24:17,179 --> 00:24:21,659
Let's try. Let's I think. Okay, so I have the same code.

172
00:24:27,979 --> 00:24:29,419
Okay, now we are going to run it.

173
00:24:30,220 --> 00:24:40,380
So, it is some sort of a loop in bar. Okay, so this answer that it successfully terminates is

174
00:24:40,380 --> 00:24:46,300
incorrect. Your answer that it somehow will be an infinite loop in main is incorrect.

175
00:24:47,180 --> 00:24:55,259
Let's look at what has happened here. Okay, so let's see what happens here. So, when we first

176
00:24:55,259 --> 00:25:00,700
call foo, there is no problem so far. We are just calling a normal function. We come here.

177
00:25:02,140 --> 00:25:08,140
What is the layout of stack as soon as we enter foo? So, stack looks something like this. So,

178
00:25:08,140 --> 00:25:14,379
we had parameters which are passed which is a essentially. Then we have return address.

179
00:25:16,619 --> 00:25:21,339
Remember params were passed in the caller stack frame and after that return address was present.

180
00:25:21,819 --> 00:25:33,259
Right. So, p holds address of a. So, p is pointing here. Right. Then we say minus minus p.

181
00:25:34,779 --> 00:25:44,539
Okay, that means p now starts pointing here. Okay. And we save this value to val. Val now holds

182
00:25:44,539 --> 00:25:50,379
return address. What is return address in this case when foo is called? What is the return address?

183
00:25:51,980 --> 00:25:58,539
It is the instruction following foo. That means it is called to bar. So, if this statement was

184
00:25:58,539 --> 00:26:07,099
location 0x100 and if this location was 0x200, then this value is holding 200.

185
00:26:09,339 --> 00:26:16,539
Everyone got so far? Okay. Now, then we print foo and then we return. Where will we return?

186
00:26:16,539 --> 00:26:25,019
200. Sorry. 200. So, we will return here. See, we have not done anything. Okay. We have simply

187
00:26:25,019 --> 00:26:33,500
copied that value. Okay. Then we call bar. We come here. So, the stack frame will look

188
00:26:34,140 --> 00:26:49,099
somewhat similar to this where we have parameter b and p is pointing to b and then we decrement p.

189
00:26:49,099 --> 00:26:58,380
So, p is now pointing here and what we do is we say p is equal to 0x200. That means we changed

190
00:26:58,380 --> 00:27:10,700
the return address to then in bar prints and where will bar function return? 200. What is at

191
00:27:10,700 --> 00:27:20,460
200? Call to foo. It again comes here. Again does the same thing. Again. So, it keeps doing the same

192
00:27:20,460 --> 00:27:28,140
thing. So, what we did is we overwrote the return address such that it calls bar multiple times.

193
00:27:28,940 --> 00:27:35,340
This is actually one of the security holes. This forms basis of something called as buffer

194
00:27:35,340 --> 00:27:43,420
overflow attack. Has anyone heard of it? Yes. Okay. So, imagine see here I did something simpler,

195
00:27:43,420 --> 00:27:52,700
but imagine if I could somehow do it something like this. So, if I said val here, val actually

196
00:27:52,700 --> 00:28:03,180
is some function man in the middle. If I somehow changed return address to a functions address

197
00:28:03,180 --> 00:28:10,539
called man in the middle, then what will happen? Bar will return to function man in the middle.

198
00:28:11,259 --> 00:28:17,580
Man in the middle will do whatever it wants to do and then can do whatever it needs to do.

199
00:28:18,139 --> 00:28:24,299
Right. So, what we have got access to is access to the return address of a function.

200
00:28:25,179 --> 00:28:32,859
And if we overwrite it or manipulate it, we can manipulate things very easily and we can do some

201
00:28:32,859 --> 00:28:36,539
interesting things with it. Okay. So, for example, let us look at it this way.

202
00:28:37,899 --> 00:28:44,859
So, let us say I had printf in main. Right. And I simply did this.

203
00:28:48,539 --> 00:28:54,299
Okay. Now, let us invoke this code.

204
00:28:54,299 --> 00:29:19,659
Okay. So, it has now gone to in foo, in bar, in main. So, I was able to successfully execute

205
00:29:19,660 --> 00:29:27,180
main in between foo and bar and do something in it. And this could be a function which has some

206
00:29:27,180 --> 00:29:34,620
malicious code which can actually do something harm foo. Okay. So, having written address on stack

207
00:29:34,620 --> 00:29:40,060
actually poses some security problems. Okay. There are some ways to deal with it,

208
00:29:40,060 --> 00:29:47,660
but in most cases you have this security issue in your system. And that is why you must have

209
00:29:48,300 --> 00:29:56,620
probably read somewhere, do not use strcpy, use strncpy. Right. Those kinds of things are there

210
00:29:56,620 --> 00:30:03,900
because you do not want to accidentally overwrite variables on the stack. See, if you accidentally

211
00:30:03,900 --> 00:30:09,340
overwrite variables on the stack, you will actually corrupting the return address. And when you

212
00:30:09,339 --> 00:30:17,819
corrupt return address, something bad can happen. Okay. So, so far, just to recollect,

213
00:30:17,819 --> 00:30:23,899
before the break we looked into how things were passed as a control, how parameters were passed,

214
00:30:23,899 --> 00:30:28,859
how local variables were done. Now, let us look at return value which is the last thing which is

215
00:30:28,859 --> 00:30:34,939
remaining. Right. So, return value is actually comparatively simpler because what happens is

216
00:30:34,940 --> 00:30:40,620
most of the programming languages support only one return value. So, they say you can only return

217
00:30:40,620 --> 00:30:47,019
one value from a function. You cannot return multiple values. Right. So, that you can actually

218
00:30:47,019 --> 00:30:54,700
do by register itself. So, most of the implementations including x86 simply pass return value via

219
00:30:54,700 --> 00:31:00,539
register. They do not put it on the stack. So, you can return. So, whatever is your return value,

220
00:31:00,539 --> 00:31:06,539
just before returning, you populate that value into EAX and the caller function will access

221
00:31:07,420 --> 00:31:16,059
EAX to get that value. Okay. Now, if you return a large struct, what will happen? See, C says

222
00:31:16,059 --> 00:31:21,980
return only one value, but it does not say it has to be a 32-bit value. It can be a structure. Right.

223
00:31:21,980 --> 00:31:29,180
I can have a structure of 100 elements. How will I return? See, if I have a function which returns

224
00:31:29,180 --> 00:31:39,340
a structure, so the simplest thing which most of the implementations do is EAX is a 32-bit value.

225
00:31:39,340 --> 00:31:45,660
So, it can at least hold a pointer for 32-bit systems. Right. So, what you can do is you can

226
00:31:45,660 --> 00:31:53,420
actually, the caller function actually creates the structure on the stack and it is some sort of a

227
00:31:53,420 --> 00:31:59,340
call by address where you pass that address to the callee function. The callee function modifies

228
00:31:59,340 --> 00:32:06,860
whatever it wants and EAX holds address to that and you use that. Okay. Does everyone get this?

229
00:32:06,860 --> 00:32:13,100
So, when you are calling a function, you pass a hidden parameter. The hidden parameter will be

230
00:32:13,100 --> 00:32:20,300
essentially address of the structure which is the return value. Okay. You call the callee function

231
00:32:20,299 --> 00:32:26,779
will do whatever update it needs to do in that address and then return address of that variable

232
00:32:27,339 --> 00:32:35,579
as EAX and the caller function can use that address in EAX to refer to the structure. Okay.

233
00:32:35,579 --> 00:32:41,099
That is how you return a larger value which does not fit into EAX register. Okay.

234
00:32:50,299 --> 00:33:05,740
Correct. Yes. So, that is a problem. So, the problem which Ujwal is trying to raise is

235
00:33:06,460 --> 00:33:12,220
return values are optional. Right. The caller function does not need to say x is equal to foo.

236
00:33:12,220 --> 00:33:17,419
It can simply say foo although foo is a returning a value. So, the caller function does not need to

237
00:33:17,420 --> 00:33:24,539
collect the return value. Right. But you will still have the overhead just because foo was

238
00:33:24,539 --> 00:33:30,539
returning struct. It had to populate all of that. Right. And that is needed because when you are

239
00:33:30,539 --> 00:33:36,300
compiling foo, you have no idea whether return value will actually be used or not used. So,

240
00:33:36,300 --> 00:33:42,300
you have to be conservative and do that. You cannot do much about it. Does everyone get this point?

241
00:33:42,299 --> 00:33:49,180
Because foo might be defined in a different file than the main function and foo function does not

242
00:33:49,180 --> 00:33:54,139
know whether main is actually going to use the return value or not. So, it still has to do

243
00:33:54,139 --> 00:34:00,859
whatever is required assuming worst case in which case it will actually use the value. Okay.

244
00:34:00,859 --> 00:34:14,219
This is same as how parameters are. So, think of it this way that compiler simply translated

245
00:34:14,219 --> 00:34:25,819
a function like this struct as foo with int x int y to something equivalent to this. Wide foo

246
00:34:25,820 --> 00:34:39,980
int x int y struct as star. So, it passed this as a hidden parameter, did all the updates and

247
00:34:39,980 --> 00:34:51,460
simply returned actually this should be int star or struct star struct as star and simply returned

248
00:34:51,460 --> 00:35:16,380
address of that. I will come to who specifies these things. Correct. So, it is in the caller

249
00:35:16,500 --> 00:35:25,900
stack. So, so far we have seen how things actually work between function calls. Now,

250
00:35:25,900 --> 00:35:32,460
one thing which is remaining which I think was coming earlier in couple of times is both the

251
00:35:32,460 --> 00:35:38,059
caller function and callee function are using the same hardware. It is not that caller function is

252
00:35:38,059 --> 00:35:43,500
executing on one hardware and callee is executing on other hardware. So, they have to share the

253
00:35:43,579 --> 00:35:50,699
hardware. That means they have to share the registers and someone was saying what if so,

254
00:35:50,699 --> 00:35:55,219
when we were talking about things like written address. So, what if the callee function needs

255
00:35:55,219 --> 00:36:02,860
eax and it overwrites it. So, in this case what is happening is caller function is moving value 5

256
00:36:02,860 --> 00:36:10,099
into edx then calling the callee function and callee function is overwriting edx and when the

257
00:36:10,099 --> 00:36:17,779
control comes back this edx value is no longer present because there is only one register called

258
00:36:17,779 --> 00:36:28,139
edx in the hardware. There is no caller underscore edx or callee underscore edx. So, it was overwritten.

259
00:36:28,139 --> 00:36:36,139
So, edx must be somehow saved before and after call instruction. Who should save it?

260
00:36:36,139 --> 00:36:50,299
Yeah. So, let us go with some step by step things. So, let us say so, what is the requirement?

261
00:36:50,299 --> 00:36:55,659
Requirement is caller function should save and restore all the registers before and after call

262
00:36:55,659 --> 00:37:01,059
it is going to use and callee function should save and restore registers it is using in the

263
00:37:01,059 --> 00:37:06,659
function body. So, caller function uses some registers it saves and restores them across the

264
00:37:06,659 --> 00:37:13,259
call instruction. If callee function uses some registers it saves and restores them. Now,

265
00:37:13,259 --> 00:37:19,820
if there is a register which is used by both of them then there is possibly redundancy. So,

266
00:37:19,820 --> 00:37:28,940
let us say there is eax register is being used by caller. So, caller is saying that okay I am

267
00:37:28,940 --> 00:37:34,820
using this so I must save this register. So, it has saved that register. Now, callee comes callee

268
00:37:34,820 --> 00:37:40,940
is saying I also need to use eax. So, I should save it. So, there is unnecessary saving which

269
00:37:40,940 --> 00:37:47,139
is happening because both of them were using it both of them are saving it without it would

270
00:37:47,139 --> 00:37:52,820
have been ideal if only one of them saved it because that would save some time and same

271
00:37:52,820 --> 00:38:01,580
thing will happen is the question really is does the caller function know which registers

272
00:38:01,580 --> 00:38:07,740
callee function is using and does callee function know which registers caller is using does it know.

273
00:38:07,740 --> 00:38:15,980
So, when you call a function foo do you know which registers are being used by foo?

274
00:38:15,980 --> 00:38:27,579
You do not know because foo's definition may not be available and you have to do inter procedural

275
00:38:27,579 --> 00:38:35,860
analysis. Did you learn anything about inter procedural analysis in your okay and obviously

276
00:38:35,860 --> 00:38:41,460
in separate compilation things I mean separate compilation is the biggest hammer which kind of

277
00:38:41,460 --> 00:38:48,300
puts everything outside the scope of compiler. Compiler has simply no way to deal with it.

278
00:38:49,099 --> 00:38:54,480
So, if foo is defined in the file you can do something but you still have to do inter

279
00:38:54,480 --> 00:39:01,260
procedural analysis and if foo is defined outside then you simply cannot do much. So,

280
00:39:01,260 --> 00:39:06,780
in most practical cases you would not know which registers are being used. So,

281
00:39:06,820 --> 00:39:14,180
let us use the convention. Let us not the up the guideline which we want to have is we want to

282
00:39:14,180 --> 00:39:20,019
avoid unnecessary saves and restores. So, we do not want duplication of the work. So, let us come up

283
00:39:20,019 --> 00:39:27,540
with a convention that caller saves all the registers. So, caller function saves and restores

284
00:39:27,540 --> 00:39:34,500
all the registers before doing the call. So, what will happen is this is the caller function and it

285
00:39:34,500 --> 00:39:42,179
is calling a callee it will save all the registers before doing the call. Calls the callee function

286
00:39:42,179 --> 00:39:47,099
callee function does not do any save restore. So, callee function is happily using all the

287
00:39:47,099 --> 00:39:53,579
registers and returns and then callee function caller function restores all the registers.

288
00:39:53,579 --> 00:40:02,059
Okay now the problem with this is every time a function is called you have to do this save restore.

289
00:40:02,179 --> 00:40:13,139
So, the save restore is happening at every call instruction. And the problem is caller since it

290
00:40:13,139 --> 00:40:18,059
does not know what registers are being actually used it may actually end up save and restoring

291
00:40:18,059 --> 00:40:24,619
registers which are not even used. For example, let us say ESI register callee does not even use

292
00:40:24,619 --> 00:40:30,019
that. So, but caller since it does not know it will still save and restore it which is waste of

293
00:40:30,019 --> 00:40:36,380
time. Now, the question is does caller really need to save and restore all the registers.

294
00:40:36,380 --> 00:40:49,219
Correct. So, caller really need to save and restores only the registers which are used by

295
00:40:49,219 --> 00:40:55,420
caller. So, for example, let us say there was a register EBX which was not at all used in caller.

296
00:40:55,539 --> 00:41:03,380
Now, no matter whether callee uses it or not you do not have to save and restore it. Okay,

297
00:41:03,380 --> 00:41:08,539
does that make sense? So, if there is a register which is not at all used in the caller you do

298
00:41:08,539 --> 00:41:14,220
not save restore. So, you have one optimization even when caller was supposed to do all the

299
00:41:14,220 --> 00:41:25,059
saving. The other is if caller is using a register, but the register live range ends just before the

300
00:41:25,059 --> 00:41:31,099
call instruction. Does everyone understand what is live range of a register? Right. So,

301
00:41:31,099 --> 00:41:37,820
if the register live range does not cross the call instruction that means caller was using

302
00:41:37,820 --> 00:41:46,460
EBX register, but does not use beyond this point or overrides it beyond this point then it does

303
00:41:46,460 --> 00:41:52,940
not need to save restore. So, it does not need to save restore a dead register. So, if there is a

304
00:41:53,019 --> 00:41:58,740
register which is not at all used or which is dead across the call instruction it does not need

305
00:41:58,740 --> 00:42:05,860
to save restore. So, this is one convention, but there is still downside that every call has this

306
00:42:05,860 --> 00:42:13,059
save and restore logic. Let us look at the extreme other case where callee is responsible for doing

307
00:42:13,059 --> 00:42:19,820
every save and restore. Caller is happily using all the registers. So, callee will save all the

308
00:42:19,820 --> 00:42:26,220
registers at the start of the function and will restore them before returning. So, callee will

309
00:42:26,220 --> 00:42:34,660
save all the registers and restore all the registers. Again here you can do an optimization where

310
00:42:34,660 --> 00:42:43,180
callee will save and restore only registers which are being used. And one other better advantage is

311
00:42:43,180 --> 00:42:48,660
the code to do save and restore is kind of localized to the function. It is not kind of

312
00:42:48,659 --> 00:42:54,219
spread around everywhere. So, that is I mean when you are reading assembly it is kind of spread

313
00:42:54,219 --> 00:43:02,659
around in the prior convention. Here it is at least localized and here again the same problem

314
00:43:02,659 --> 00:43:09,099
happens it callee does not know whether a function register is being used. So, we should try to get

315
00:43:09,099 --> 00:43:15,219
best of both worlds. So, essentially you say that there are some registers which are responsibility

316
00:43:15,219 --> 00:43:21,899
of caller which caller will save. The other registers are responsibility of callee. So,

317
00:43:21,899 --> 00:43:28,019
you divide your registers into two parts. One is responsibility of caller other is

318
00:43:28,019 --> 00:43:37,500
a responsibility of callee and you do this. So, this is register saving convention. So,

319
00:43:37,500 --> 00:43:43,059
you split your sets into two sets. One is something called as a caller saved registers.

320
00:43:43,059 --> 00:43:49,099
As the name indicates it is caller's responsibility to save these registers before

321
00:43:49,099 --> 00:43:53,139
doing the function call and restore them after the function call is being done.

322
00:43:53,139 --> 00:44:04,860
No. So, only caller saved registers need to be saved and there it can do an optimization if

323
00:44:04,860 --> 00:44:10,179
there is a dead register or a registers whose live range does not cross then it does not need to save.

324
00:44:11,139 --> 00:44:17,219
If something is being. So, think of it this way any caller saved register callee is free to

325
00:44:17,219 --> 00:44:23,539
overwrite it without having to worry about it. That is why these are called as scratch registers.

326
00:44:23,539 --> 00:44:30,259
So, these are scratch for the callee function. So, callee function is free to overwrite them

327
00:44:30,259 --> 00:44:36,739
without worrying about what will happen at caller. If caller wants to use it across the call then it

328
00:44:36,739 --> 00:44:43,739
better saves it. If it does not want to use it, it does not need to save it. But callee does not

329
00:44:43,739 --> 00:44:50,619
have any responsibility of saving and restoring. Then there is callee saved registers which is

330
00:44:50,619 --> 00:44:59,299
exact opposite which is essentially callee's responsibility to save and restore. And caller

331
00:44:59,299 --> 00:45:06,419
function is free to use these registers across the call without having to save restore. And these

332
00:45:06,420 --> 00:45:11,900
are called preserved registers. These are preserved because the value of these registers

333
00:45:11,900 --> 00:45:16,940
does not change across the call instruction. So, they are preserved across the call instruction.

334
00:45:18,019 --> 00:45:26,380
And this is yet another agreement between the caller and callee. And where to yes.

335
00:45:26,380 --> 00:45:40,180
We will get to that. Now, where we have been saying that it is save and restore save and

336
00:45:40,180 --> 00:45:45,180
restore. So, where to actually save it right. Yeah, stack by now you should be able to articulate

337
00:45:45,180 --> 00:45:52,059
why global variables will not work and so on. So, answer is stack. You should whatever registers

338
00:45:52,059 --> 00:45:56,679
you need to save, you save them in stack. So, essentially this is what happens. So,

339
00:45:56,679 --> 00:46:03,500
let us say EAX is the register and it is caller save. Let us assume. Then before calling the

340
00:46:03,500 --> 00:46:09,980
callee function, the caller function will push this on to the stack and come to callee. Let us

341
00:46:09,980 --> 00:46:18,860
say EDI is a callee saved register. Then callee function will save it before using it and pop it

342
00:46:18,860 --> 00:46:25,940
before returning. And then callee function is free to use EDI without having to save restore.

343
00:46:25,940 --> 00:46:30,500
But for EAX it has to pop from the stack. Yes.

344
00:46:30,500 --> 00:46:42,880
We will come to that. Any other questions so far? So, so far we have two questions. What is the

345
00:46:42,880 --> 00:46:49,400
EAX register? Is it caller saved, callee saved? And second is what happens when a function is

346
00:46:49,400 --> 00:47:01,920
caller as well as callee? Correct. We will come to that also. Any other things? Sorry. You didn't

347
00:47:01,920 --> 00:47:10,480
get the benefit. So, the question is why are we doing this? So, one is essentially you. So,

348
00:47:10,480 --> 00:47:16,320
let us look at the various options we had. The first option we had is both caller and callee

349
00:47:16,320 --> 00:47:23,320
save all the registers. So, there is some redundancy. We said that then caller is responsible

350
00:47:23,320 --> 00:47:30,199
for saving everything. There is some issue with that. So, this is also not perfect, but it is

351
00:47:30,199 --> 00:47:35,599
trying to just load balance the two things. So, we don't want to burden too much caller or too

352
00:47:36,079 --> 00:47:41,119
much callee. We are just trying to get best of both things. And this actually enables some

353
00:47:41,119 --> 00:47:47,799
optimizations which we will see on having this split. So, to answer your question, if you look

354
00:47:47,799 --> 00:47:59,839
at x86, these are caller saved registers EAX, ECX, EDX. Callee save is EBX, ESI, EDI. And special

355
00:47:59,840 --> 00:48:08,600
registers ESP and EBP are callee saved. Now, can someone answer why stack pointer needs to

356
00:48:08,600 --> 00:48:14,760
be callee saved? What will happen if it? So, let us say I was designing my system. Can I make my

357
00:48:14,760 --> 00:48:18,480
stack pointer caller saved? Yes.

358
00:48:29,840 --> 00:48:43,079
But that is the semantic of callee saved. Callee saved is saying that if something is callee

359
00:48:43,079 --> 00:48:50,680
saved, callee is responsible for saving and restoring it. So, before returning from callee,

360
00:48:50,680 --> 00:48:57,160
the callee function must ensure that the stack pointer is pointing to the correct address.

361
00:48:57,159 --> 00:49:07,480
So, I didn't get why you think that makes it callee callers saved or callees.

362
00:49:07,480 --> 00:49:27,639
Correct. Does everyone get this? So, essentially, let us try to play this hypothetically. So,

363
00:49:27,639 --> 00:49:33,760
let us say ESP was caller saved. So, what will happen is before doing the call,

364
00:49:33,760 --> 00:49:42,440
caller will save it onto the stack. Now, control will transfer to the callee saved function. Now,

365
00:49:42,440 --> 00:49:47,360
since it is a caller saved register, callee function is free to modify it and does not

366
00:49:47,360 --> 00:49:54,040
have to change it to the original value. It is responsibility of the caller. So,

367
00:49:54,040 --> 00:50:03,120
callee function happily keeps modifying stack pointer. Then the RET instruction comes. RET

368
00:50:03,119 --> 00:50:11,079
instruction requires the stack pointer to point to stop a stack. If callee doesn't adjust it,

369
00:50:11,079 --> 00:50:16,799
then RET instruction will not work properly and it will start popping random stuff from the stack

370
00:50:16,799 --> 00:50:24,159
when RET executes. That is why it is callee saved because callee anyway has to clean up the stack

371
00:50:24,159 --> 00:50:33,519
to get to that. Does that make sense? Now, to answer your question on how many are here

372
00:50:33,519 --> 00:50:40,599
and how many are here, it is actually a performance thing. There is no right or wrong answer except

373
00:50:40,599 --> 00:50:47,319
in special case like this where semantics mandate you to have it callee saved. I could have very

374
00:50:47,319 --> 00:50:53,839
well said that EAX is my callee saved registers. So, there is nothing in the hardware which is

375
00:50:53,840 --> 00:51:00,440
forcing you to make EAX callers saved or callee saved. It is some convention which is decided and

376
00:51:00,440 --> 00:51:06,880
usually there is a lot of tuning which happens to decide this split. But it is an engineering

377
00:51:06,880 --> 00:51:13,400
trade-off. There is no conceptual answer to that that it must be this way and the other way is

378
00:51:13,400 --> 00:51:22,920
incorrect. Now, let us look at these quizzes. So, let us say you have a function foo which is

379
00:51:22,920 --> 00:51:30,000
calling bar. Now, let us say foo happens to be a very complex function. By complex, I mean it has

380
00:51:30,000 --> 00:51:36,519
lot of instructions, doing lot of computations and so on. And function bar is very simple. And

381
00:51:36,519 --> 00:51:45,400
you are an optimizing compiler. So, you have to do register allocation. Now, when you are generating

382
00:51:45,400 --> 00:51:50,960
code for foo, should you use more callers saved registers or should you use more callee saved

383
00:51:50,960 --> 00:51:57,119
registers? Is the question clear? So, there is a function foo which is very complex. It is calling

384
00:51:57,119 --> 00:52:06,240
a simple function bar. So, bar is likely have small set of instructions. Foo is going to be very large

385
00:52:06,240 --> 00:52:13,440
and foo is calling bar. Now, when you are register allocating function foo, should you use more

386
00:52:13,440 --> 00:52:19,519
callers saved registers in foo or should you use more callee saved registers into foo? Why callee

387
00:52:19,639 --> 00:52:31,880
saved? Okay, so they are saying foo should use callee saved register, more callee saved registers.

388
00:52:31,880 --> 00:52:43,079
Correct. So, what will happen is since foo is complex, you could assume that foo is going to

389
00:52:43,079 --> 00:52:48,719
use many registers. And many variables will be mapped to different set of registers. Now,

390
00:52:48,719 --> 00:52:55,480
if you use more callers saved registers, then every time bar is called, it is callers responsibility

391
00:52:55,480 --> 00:53:01,799
to save and restore them. So, foo has to do additional work plus it is already constrained

392
00:53:01,799 --> 00:53:09,319
on the registers because it is going to be large. So, it is useful for foo to use more callee saved

393
00:53:09,319 --> 00:53:16,799
registers. This kind of tries to answer the question which you had. So, if you didn't have

394
00:53:16,800 --> 00:53:23,039
this kind of split, both foo and bar will be responsible for saving all the registers,

395
00:53:23,039 --> 00:53:28,840
in which case both of them have to do equal redundant work, in which case you are doing

396
00:53:28,840 --> 00:53:35,480
suboptimal use of your resources. Instead, if you divide your responsibility between foo and bar,

397
00:53:35,480 --> 00:53:44,200
and depending on how complex either of them are, you could tune your register allocator to use more,

398
00:53:44,279 --> 00:53:50,919
shift more burden onto the simpler function than pulling it on yourself. Does that make sense?

399
00:53:50,919 --> 00:53:57,359
That is why compilers register allocation also need to be aware of these facts, not just for

400
00:53:57,359 --> 00:54:06,359
generating code, but also for optimizations. And obviously, what will you do in the opposite case?

401
00:54:06,359 --> 00:54:11,960
If foo was simple and bar was complex, you would do the opposite, where you will say foo should

402
00:54:11,960 --> 00:54:23,800
use more callee saved registers. Now, let us say foo calls bar, but bar does not call any other

403
00:54:23,800 --> 00:54:31,679
function. So, foo is calling a function bar and bar does not do any other call. So, bar simply

404
00:54:31,679 --> 00:54:36,199
computes whatever it needs without calling any additional function and simply returns.

405
00:54:36,199 --> 00:54:44,119
So, when allocating for bar, which register should you use? Should you use more caller

406
00:54:44,119 --> 00:54:52,960
saved registers or should you use more callee saved registers? Why callee saved?

407
00:54:52,960 --> 00:55:05,800
Okay.

408
00:55:23,960 --> 00:55:30,000
Correct. So, to answer this question, let us go back to the earlier question which we were getting.

409
00:55:30,000 --> 00:55:35,880
So, what happens when you have a function which is being called by someone else and it is also

410
00:55:35,880 --> 00:55:41,559
calling some other function. So, let us say that we have a chain, main calls foo and foo calls bar.

411
00:55:41,559 --> 00:55:49,240
So, let us talk about function foo. So, function foo is being called as well as it is calling

412
00:55:49,239 --> 00:55:56,559
other function. So, foo acts as a callee from point of view of main and foo acts as a caller

413
00:55:56,559 --> 00:56:04,559
from point of view of bar. So, foo has a responsibility in worst case to do both the worlds because when it

414
00:56:04,559 --> 00:56:14,000
is called from main, it has to save all the callee saved registers which it is using. And when it is

415
00:56:14,039 --> 00:56:22,119
calling bar, it has to save all the caller saved registers. So, foo has to do worst of both worlds.

416
00:56:22,119 --> 00:56:32,840
Now, if foo was not calling a function and if you use callee saved registers, then what it means is

417
00:56:32,840 --> 00:56:39,840
foo has to save and restore at least callee saved registers. But if foo was using only

418
00:56:40,000 --> 00:56:46,960
caller saved registers, then it has to do nothing. So, a function which does not call any other

419
00:56:46,960 --> 00:56:55,760
function actually benefits from using caller saved registers which is what he was trying to say. So,

420
00:56:55,760 --> 00:57:00,840
if you have a function which does not call any other function, if you use caller saved registers,

421
00:57:00,840 --> 00:57:08,240
that function has to do nothing as far as save restore goes. If it uses callee saved registers,

422
00:57:08,319 --> 00:57:14,799
then it has to do save and restore. And for an intermediate function as in a non-leaf function,

423
00:57:14,799 --> 00:57:21,559
it has to do both of them. So, leaf functions typically can do things without save and restore.

424
00:57:22,279 --> 00:57:28,599
Now, the third question. So, let us say you are compiler. In which order you should compile

425
00:57:28,599 --> 00:57:34,519
functions? So, should you compile and register allocate caller first or should you compile and

426
00:57:34,519 --> 00:57:40,400
register allocate callee first? Does the question make sense? See, it is not that you are going to

427
00:57:40,400 --> 00:57:45,800
register allocate entire program. You will probably do function by function. In which case,

428
00:57:45,800 --> 00:57:51,000
should you compile callee function first and register allocate it or should you compile

429
00:57:51,000 --> 00:58:09,280
caller function first and register allocate it? So, going back to this first example,

430
00:58:09,280 --> 00:58:16,320
we utilize the information whether foo is complex or bar is complex and decided our

431
00:58:16,400 --> 00:58:21,680
register allocation scheme. So, if you knew more information about the function which you are

432
00:58:21,680 --> 00:58:28,320
calling, not in terms of exact all the things, but even if you simply know that this function

433
00:58:28,320 --> 00:58:33,160
is using these many registers and these type of registers, you could take that decision and

434
00:58:33,160 --> 00:58:41,519
feed back to the caller. So, that is what most compilers would actually do. So, they would prefer

435
00:58:41,679 --> 00:58:47,639
to compile callee first and then caller and feed back the information from caller to caller,

436
00:58:47,639 --> 00:58:56,880
so, callee to caller and use that to influence the optimizations. Again, in whole program only,

437
00:58:56,880 --> 00:59:01,119
if you have separate compilation, everything goes for a toss. So, you have to be conservative

438
00:59:01,119 --> 00:59:11,079
and do the worst thing. So far, are things clear? So, so far, we have seen some contracts between

439
00:59:11,239 --> 00:59:17,119
caller function and callee function. We saw the contract, the first contract was where the return

440
00:59:17,119 --> 00:59:25,440
address is and we learned that on x86, it is part of the stack as per when we push the call the

441
00:59:25,440 --> 00:59:30,960
instruction and how are parameters stored on to the stack and in what order they are stored on to

442
00:59:30,960 --> 00:59:39,000
the stack. Where is the return value and how it is obtained and which registers are caller saved

443
00:59:39,000 --> 00:59:44,559
and which registers are callee saved. So far, we have seen these as contracts between the two.

444
00:59:44,559 --> 00:59:53,159
If any of the contract is violated, then we have a problem because if say caller is assuming that

445
00:59:53,159 --> 00:59:58,039
I need to pass registers in left to right or parameters in left to right order and callee

446
00:59:58,039 --> 01:00:03,239
assumes parameters are from right to left, then it is not going to work as expected. Similarly,

447
01:00:03,239 --> 01:00:08,119
if caller assumes that the return address is passed by a global variable, but the callee function

448
01:00:08,119 --> 01:00:13,719
is looking at it from the stack, then it is not going to work. So, both caller and callee function

449
01:00:13,719 --> 01:00:21,359
must agree upon something. So, these contracts are actually called as calling conventions. So,

450
01:00:21,359 --> 01:00:28,079
these set of contracts, there is a term called as calling convention. Now, coming back to the

451
01:00:28,079 --> 01:00:35,719
question of who decides calling convention? Is it hardware? Is it compiler? Is it someone else? Is

452
01:00:36,199 --> 01:00:42,319
it me? Is it you? So, calling conventions are actually decided by something called as

453
01:00:42,319 --> 01:00:49,719
application binary interface or ABI. How many of you have heard this term ABI? So,

454
01:00:49,719 --> 01:00:59,919
ABI is a contract which exists between binaries, binary interface and it is published by a platform.

455
01:00:59,920 --> 01:01:07,240
It is not operating system alone. It is not hardware alone. It is a combination. So,

456
01:01:07,240 --> 01:01:20,119
x86 does not have ABI. x86 Linux has an ABI. x86 Windows has an ABI and each ABI can be different.

457
01:01:21,400 --> 01:01:28,539
Just like we saw caller saved callee saved convention, x86 Windows may decide I may have

458
01:01:28,539 --> 01:01:36,900
a different convention than x86 Linux. But every platform provides an application binary interface

459
01:01:36,900 --> 01:01:46,340
and all the tools which are involved on that platform need to comply to that ABI. So, GCC has

460
01:01:46,340 --> 01:01:57,820
to comply to the ABI which is on x86 Linux. C lang on Linux has to comply on x86 Linux ABI.

461
01:01:57,820 --> 01:02:06,460
C lang on Windows has to comply to x86 Windows ABI. Does that make sense? ABI decides calling

462
01:02:06,460 --> 01:02:12,500
conventions, but there are other parts of the ABI also. For example, size of integer. It is

463
01:02:12,500 --> 01:02:20,980
not specified by compiler. So, do not think size of int is 4. It is compiler dependent. It is ABI

464
01:02:20,980 --> 01:02:29,420
dependent. ABI is the interface which is actually specifying what is the size of int. For example,

465
01:02:29,420 --> 01:02:40,980
long int has worst ABI. So, long int on 32-bit Linux is 32-bit. Long int on 32-bit Windows is

466
01:02:40,980 --> 01:02:51,659
32-bit. Long int on 64-bit Linux is 64-bit and long int on Windows is 32-bit. So, Windows has a

467
01:02:51,659 --> 01:02:59,139
weird ABI for long int where it says long int on Windows is going to be 32-bit. And that they had

468
01:02:59,139 --> 01:03:06,340
done for portability reasons, but it is odd man out. And that is why you should not use long int

469
01:03:06,740 --> 01:03:11,980
as a data type in your program because it makes it less portable. Because if you are writing

470
01:03:11,980 --> 01:03:18,660
something as long int, assuming it will be 64-bit, then your code will not run on Windows 64 as

471
01:03:18,660 --> 01:03:28,620
expected. So, knowing ABI helps you write portable programs. The same thing you need to follow when

472
01:03:28,620 --> 01:03:35,019
you are writing assembly. So, if you are writing assembly program which might be called from another

473
01:03:35,099 --> 01:03:44,619
C program, your assembly program must comply to the ABI. So, your program must expect the

474
01:03:44,619 --> 01:03:49,980
pointers parameters are passed in this order and so on and so forth. So, you have to as an assembly

475
01:03:49,980 --> 01:03:55,900
programmer, you have to know what is the ABI which is being followed. As a compiler writer,

476
01:03:55,900 --> 01:04:01,300
you need to know what is the ABI being followed. So, you can generate code for that ABI. Does that

477
01:04:01,500 --> 01:04:07,380
make sense? Now, the question is, is there only one calling convention specified by the ABI?

478
01:04:07,380 --> 01:04:25,500
What are issues with only one calling convention? Correct. So, so far whatever we have seen were

479
01:04:25,500 --> 01:04:31,060
mostly trade-offs. There is no truly right answer and truly wrong answer. It was just a

480
01:04:31,059 --> 01:04:36,380
judgmental call that four caller saved registers is okay, four callee saved is okay. Whatever

481
01:04:36,380 --> 01:04:45,460
applies to broad class of programs makes sense. But as he said, it is not optimal for a specific

482
01:04:45,460 --> 01:04:52,659
use case. For example, if I know I am going to pass only two parameters to a function and my

483
01:04:52,659 --> 01:04:59,099
function is very critical. Let us say my function is called deeply within some set of nested loops

484
01:04:59,099 --> 01:05:04,460
and is very important for performance. Do I really want to pass my parameters via stack?

485
01:05:04,460 --> 01:05:12,779
Because remember stack is a memory access and memory access goes through a hierarchy of accesses

486
01:05:12,779 --> 01:05:17,579
and if it is not in cache, then you will hit to DRAM and it will take a lot of time to come.

487
01:05:18,219 --> 01:05:25,699
So, there are multiple calling conventions which are specified. So, there is something

488
01:05:25,859 --> 01:05:30,460
called as fast call. I do not know how many of you have heard of it. But fast call essentially

489
01:05:30,460 --> 01:05:36,579
says first two arguments of the function are passed via register. So, instead of using stack,

490
01:05:36,579 --> 01:05:42,239
if you have first two parameters will be passed on to the registers. And again you have to realize

491
01:05:42,239 --> 01:05:48,179
that it is not only caller who decides. Both of them have to agree and both when you are compiling

492
01:05:48,179 --> 01:05:53,500
both caller and both callee, you need to know whether it is going to be called with X convention

493
01:05:53,500 --> 01:05:59,780
or Y convention. It cannot be arbitrary convention. So, there are bunch of other

494
01:05:59,780 --> 01:06:06,860
calling conventions which are specified. And so, let us say there are no callee. So,

495
01:06:06,860 --> 01:06:12,460
there is only one calling convention. Let us hypothetically assume. Can calling convention

496
01:06:12,460 --> 01:06:19,260
be relaxed by compiler? Can compiler do that? So, let us say there is a function foo which

497
01:06:19,260 --> 01:06:26,700
is called from main. Compiler says I see foo is being used in a very critical loop. So,

498
01:06:26,700 --> 01:06:33,860
let me instead of using stack pass things via registers. Is compiler allowed to do that?

499
01:06:33,860 --> 01:06:51,420
Correct. So, compiler in theory can do it because it is generating code for main as well as foo.

500
01:06:51,420 --> 01:06:58,579
But what are the preconditions? So, let us say you come up with this optimization where you will say

501
01:06:58,579 --> 01:07:06,219
that I will do some analysis and figure out I should call this function and pass parameters

502
01:07:06,219 --> 01:07:12,860
via registers. What are the preconditions for that optimization to kick in? In what cases

503
01:07:12,860 --> 01:07:27,299
compiler cannot do that optimization? Programmer cannot assume that because language standard

504
01:07:27,300 --> 01:07:35,460
does not say that programmer can assume that. See, because when you are generating code as a

505
01:07:35,460 --> 01:07:41,580
compiler and whenever you are doing optimization, one of the most important aspect of optimization

506
01:07:41,580 --> 01:07:47,500
is to not break semantics of the program. So, no matter how good is your optimization,

507
01:07:47,500 --> 01:07:54,300
if it breaks the program semantics, it is illegal. So, what are the preconditions for you? So,

508
01:07:54,300 --> 01:07:59,700
let us say you implemented this optimization. When what will be the conditions you will check

509
01:07:59,700 --> 01:08:03,820
under which you can apply this and in what conditions you cannot apply this?

510
01:08:03,820 --> 01:08:13,740
Can a parameter be covered by argument? Okay, so there are some sanity checks that

511
01:08:13,740 --> 01:08:20,020
the optimization is only for function with two parameters. So, that is one check.

512
01:08:20,020 --> 01:08:32,380
Okay, so if the parameters are such that you cannot put them into physical register,

513
01:08:32,380 --> 01:08:36,740
like they are like 64 bit values or something like that, maybe you. So,

514
01:08:36,740 --> 01:08:44,300
two checks. Any other things you need to check. Remember, programmer is not asking compiler to

515
01:08:44,300 --> 01:08:55,779
do this. Compiler is kind of doing it out of its own magic. What if compiler does not know

516
01:08:55,779 --> 01:09:02,180
all the callers of the function? So, the function foo is being called, it takes two parameters,

517
01:09:02,180 --> 01:09:08,940
but I do not know from what all positions foo might be called. In what cases can that happen?

518
01:09:08,939 --> 01:09:27,139
Foo is defined in current file. But when can callers of foo come from other file? So,

519
01:09:27,139 --> 01:09:33,579
separate compilation foo is defined. The callers of foo can be other file in separate compilation.

520
01:09:34,300 --> 01:09:39,059
Is there something when I am compiling that I know foo might be called from other files?

521
01:09:39,059 --> 01:09:52,059
Okay, does anyone know something called as static when you apply to function, what happens? So,

522
01:09:52,059 --> 01:09:59,340
let us say if I do this, what is the meaning of this? Does anyone know? When I say a function is

523
01:09:59,340 --> 01:10:08,380
static? So, let me ask you this. What is the difference between these? So, you have to tell

524
01:10:08,380 --> 01:10:16,340
me difference in these four cases. So, there is int gbl, there is static int gbl2, there is void

525
01:10:16,340 --> 01:10:25,619
foo and there is static void bar. What is the difference between these things? What is the

526
01:10:25,619 --> 01:10:39,180
difference between gbl and gbl2? These are global variables by the way. So, all of this is written

527
01:10:39,180 --> 01:10:56,280
at outside main. So, is there any difference between gbl and gbl2? Yes.

528
01:10:56,279 --> 01:11:14,479
Correct. So, gbl is actually usable in other file using external int gbl. I cannot do external

529
01:11:14,479 --> 01:11:26,119
int gbl2. So, static keyword here is implying that this variable is not accessible outside

530
01:11:26,119 --> 01:11:35,959
this file. Gbl is accessible outside this file. So, there is a term called as translation unit,

531
01:11:35,959 --> 01:11:43,359
which you might have heard. So, gbl can be used in other translation unit, gbl2 cannot be used

532
01:11:43,359 --> 01:11:51,199
in other translation. In the same way foo can be used in other translation units, bar cannot be

533
01:11:51,199 --> 01:12:02,799
used in other translation units. So, when I have a function which is static, I know all callers of

534
01:12:02,799 --> 01:12:13,319
that function will be in the same file, even if I am doing separate compilation. So, if I mark a

535
01:12:13,319 --> 01:12:20,279
function static that is good, that allows compiler to do more optimizations, because compiler knows

536
01:12:20,279 --> 01:12:27,239
that static functions cannot be called from other file. So, even though I am doing separate

537
01:12:27,239 --> 01:12:33,479
compilation, I can assume few things about this function. And one of the things could be relaxing

538
01:12:33,479 --> 01:12:39,399
calling conventions, because I know that all the callers are in this file and they are at 0.1,

539
01:12:39,399 --> 01:12:46,519
0.5, 0.10, 0.25. As long as those points match with the function, I am doing this optimization.

540
01:12:46,520 --> 01:13:15,320
What if someone does this? So, this code is actually doing a function pointer to bar,

541
01:13:15,479 --> 01:13:28,319
and the function pointer itself can be external in other file. So, I can do external this and use.

542
01:13:28,319 --> 01:13:36,359
So, it is not that bar is not callable from other files, but it is not callable directly,

543
01:13:36,439 --> 01:13:45,319
it can be called from function pointer. So, compiler cannot simply do this for every static

544
01:13:45,319 --> 01:13:55,960
function. It has to do it for static functions whose address is not taken or whose address is

545
01:13:55,960 --> 01:14:05,399
taken only in static function pointers. So, there are bunch of conditions you have to match to figure

546
01:14:05,399 --> 01:14:13,879
out yes. And by now you should know pointer analysis. So, even if this was static, I could

547
01:14:13,879 --> 01:14:24,199
do something like this. Some other pointer is equal to fp and then whatever other magic and

548
01:14:24,199 --> 01:14:31,559
everything goes for a toss. So, as soon as you put pointers, in theory it is possible, but for

549
01:14:31,560 --> 01:14:37,240
practical reasons it gets very hard. So, but simple condition is if your function does not

550
01:14:37,240 --> 01:14:45,960
have address taken, you can apply this optimization. That is why whenever you are writing programs with

551
01:14:45,960 --> 01:14:51,480
multiple files, it is very important for you to express your intent. For example, if you know

552
01:14:51,480 --> 01:14:57,480
this function is for this file only, like if you have a print routine, which is printing some data,

553
01:14:57,479 --> 01:15:02,679
it is unlikely that you want this to be called from someone else. It could be a debugging routine

554
01:15:02,679 --> 01:15:08,599
which you have written. So, you want that to be marked static so that it will enable compiler to

555
01:15:08,599 --> 01:15:19,799
do more things. And obviously, separate compilation is a problem. So, separate compilation poses

556
01:15:19,800 --> 01:15:27,480
problem. Function pointers create problems. So far we have seen calling conventions. Now,

557
01:15:27,480 --> 01:15:39,079
x86-64, which is a 64-bit architecture, x86 had only 8 registers. x86-64 has 16 registers.

558
01:15:39,800 --> 01:15:51,960
And the Linux ABI is something like this. First 6 parameters are passed by registers. For first 6

559
01:15:51,960 --> 01:15:57,720
parameters, you do not need to use stack. And they are passed in this order. First parameter will be

560
01:15:57,720 --> 01:16:07,559
in RDI register, second will be in RSI register, third will be RDX and so on. And frame pointer

561
01:16:07,560 --> 01:16:16,120
is optional. There is no need for frame pointer. All the references will be relative to stack.

562
01:16:19,720 --> 01:16:25,240
Then how will debugger work? Remember we were using EBP for debugger.

563
01:16:27,400 --> 01:16:32,520
How will debugger work? How will debugger know where is the caller function stack free?

564
01:16:37,560 --> 01:16:51,480
So, with hyphen g, he is saying you can still have RBP.

565
01:16:51,719 --> 01:17:07,719
So, you simulate something. But you still waste space on stack and so on. So, compilers do

566
01:17:07,719 --> 01:17:13,719
something more interesting, which we will get to in the last phase of the session to solve this

567
01:17:13,720 --> 01:17:22,119
problem. And then rax continues to be the return address register. So, x86-64 changes the ABI in

568
01:17:22,119 --> 01:17:29,159
two particular ways. That one is frame pointer is now optional. Debuggers cannot rely on compiler

569
01:17:29,159 --> 01:17:34,760
would have populated the frame pointer. And frame pointer becomes available as a general purpose

570
01:17:34,760 --> 01:17:43,400
register for compiler to use. rax is same and it has first 6 parameters in the registers.

571
01:17:43,639 --> 01:17:49,960
It is an improvement. If you are compiling your program to x86-64 and if you are using limited

572
01:17:49,960 --> 01:17:53,799
parameters, most of them will get passed via register. You do not have to access stack.

573
01:17:55,879 --> 01:18:03,079
So, this is how the stack frame will look. You have parameters which are 7 plus in the stack.

574
01:18:03,719 --> 01:18:08,759
First parameters are in registers. So, they do not appear in stack frame. And frame pointer

575
01:18:08,760 --> 01:18:17,560
itself is optional. Now, there is something called as a red zone here. This is an optimization for

576
01:18:17,560 --> 01:18:29,800
leaf functions. So, what red zone allows, it is a region of 128 bytes, which the function can use

577
01:18:30,440 --> 01:18:41,800
without having to update the stack part. So, if I have to use some variables which fit within 128

578
01:18:41,800 --> 01:18:48,680
bytes and need to be on stack for various reasons. We saw that if there was an array,

579
01:18:49,320 --> 01:18:55,960
it has to be on stack. If there was in the address of something was taken, it had to be on stack.

580
01:18:55,960 --> 01:19:03,000
So, if there is some local variables up to 128 bytes, I can actually put them on the stack

581
01:19:03,560 --> 01:19:11,079
without having to update the stack pointer. Now, why do I want to do this? This seems a bit

582
01:19:11,079 --> 01:19:17,319
bizarre. I want to use stack, but I do not want to use update the stack pointer. Why?

583
01:19:18,119 --> 01:19:33,079
Why do I want to avoid stack pointer update? But that again compiler would do. If it updates,

584
01:19:33,079 --> 01:19:42,679
it has to adjust the offset. So, one thing is remember stack pointer is callee saved.

585
01:19:43,000 --> 01:19:50,840
So, if callee updates the stack pointer in any way, it has to restore it. That means it has to

586
01:19:50,840 --> 01:20:01,320
save it and it has to restore it. So, it has to do at least two instructions. To avoid those two

587
01:20:01,320 --> 01:20:09,159
instructions, this exists. So, I want to use stack without having to save and restore the stack

588
01:20:09,159 --> 01:20:17,159
pointer. This I can do for leaf functions because leaf functions are not going to call any other

589
01:20:17,159 --> 01:20:25,639
function. So, I know the stack frame is not going to grow. So, if I simply access the variables which

590
01:20:25,639 --> 01:20:33,319
live beyond the stack, then I am safe to use that because they will not be overwritten by the

591
01:20:33,319 --> 01:20:43,399
subsequent calls. Does that make sense? So, it is an optimization to having to avoid save and restore.

592
01:20:47,239 --> 01:20:53,239
And leaf functions can use it. So, leaf functions can get away without having to do anything in the

593
01:20:53,239 --> 01:21:00,279
stack. If they use caller saved registers, which was their preference, and they can use red zone

594
01:21:00,279 --> 01:21:12,759
to save some simple variables. Any questions so far? So, so far what we have seen is we have seen

595
01:21:12,759 --> 01:21:20,119
how functions call actually work. We started off with how to transfer the controls. We then looked

596
01:21:20,119 --> 01:21:25,479
at how parameters are passed. We looked at how return address is populated. We looked at calling

597
01:21:25,479 --> 01:21:31,479
conventions and register saving and other things related to them. So, that kind of completes whatever

598
01:21:31,479 --> 01:21:34,919
happens for the function calls.

