1
00:00:00,000 --> 00:00:10,919
So, let us get started. So, we are going to continue today on code generation first and

2
00:00:10,919 --> 00:00:16,280
then we will see the dynamic programming approach. Yesterday we talked about the Seti-Wulman

3
00:00:16,280 --> 00:00:22,080
approach for doing code generation of trees which consists of two passes namely the labeling

4
00:00:22,080 --> 00:00:27,440
pass and then the code generation pass. So, we will move further and then we will see

5
00:00:27,440 --> 00:00:32,120
one more approach for generating optimal code for tree.

6
00:00:32,120 --> 00:00:39,359
So, in this approach what we are going to do is that if you want to generate code for

7
00:00:39,359 --> 00:00:46,240
any operation, the cost of generating code for this operation is same as cost of generating

8
00:00:46,240 --> 00:00:52,920
code for T 1, cost of generating code for T 2 plus the cost of this instruction itself.

9
00:00:53,399 --> 00:00:58,520
Therefore, if you are asking for the minimum cost for generating code for this instruction,

10
00:00:58,520 --> 00:01:02,960
that should actually be based on the minimum cost for generating code for this instruction

11
00:01:02,960 --> 00:01:07,120
plus the minimum cost for generating code for this instruction and then the cost for

12
00:01:07,120 --> 00:01:12,159
this. In other words, this has this so called optimal

13
00:01:12,159 --> 00:01:17,719
sub structure property of dynamic programming. In dynamic programming what do you say? The

14
00:01:17,719 --> 00:01:24,799
problem is divided into sub problems and the sub problems satisfy the optimal sub

15
00:01:24,799 --> 00:01:31,079
structure property. That optimal sub structure property is essentially satisfied here because

16
00:01:31,079 --> 00:01:36,560
the minimum cost for generating code for this instruction is same as the minimum cost for

17
00:01:36,560 --> 00:01:41,400
generating code for this instruction plus the minimum cost for generating code for this

18
00:01:41,400 --> 00:01:47,480
sub tree plus the cost of this. There cannot be any better way than doing this.

19
00:01:48,240 --> 00:01:53,280
If you take let us say a cost which is not minimum for a sub tree, is there any likelihood

20
00:01:53,280 --> 00:01:59,880
that eventually you will end up with minimum cost? No. So, this satisfies this optimal

21
00:01:59,880 --> 00:02:06,040
sub structure property and therefore, we could apply this dynamic programming approach and

22
00:02:06,040 --> 00:02:17,400
then we can get this. T 1 and T 2 can be executed in any arbitrary order and it may not have

23
00:02:17,560 --> 00:02:23,200
enough registers available. So, some if you do not have enough registers available, some

24
00:02:23,200 --> 00:02:27,439
results may be stored temporarily in a memory. That is really how it is. We will see how

25
00:02:27,439 --> 00:02:34,800
that is going to be done. So, the way that by which we proceed is as follows. For every

26
00:02:34,800 --> 00:02:41,719
node we want to compute the cost of generating code for that node and then we want to let

27
00:02:41,719 --> 00:02:46,280
us say if you have R register, then what you want to do is that you want to find out what

28
00:02:46,280 --> 00:02:53,400
is the cost what is the cost of generating code using one register, two registers, etcetera

29
00:02:53,400 --> 00:02:58,400
all the way up to R register. You also want to find out what is the cost of generating

30
00:02:58,400 --> 00:03:03,759
code for this and storing this result in memory that also you want to find out.

31
00:03:03,759 --> 00:03:09,280
So, the cost of generating code and storing it memory is same as the cost of generating

32
00:03:09,280 --> 00:03:16,280
code using R registers plus storing it in memory. That is really how we calculate that

33
00:03:16,560 --> 00:03:23,560
cost. So, essentially at every node we are going to have an array of cost. We will store

34
00:03:23,800 --> 00:03:29,800
in array element 0 the cost of doing it in memory and then 1 to R the cost of doing it

35
00:03:29,800 --> 00:03:36,520
using 1, 2, 3 up to R register. So, it is basically an array of R plus 1 elements. That

36
00:03:36,520 --> 00:03:42,360
is really what we are going to do. So, as I mentioned earlier the cost of computing

37
00:03:42,360 --> 00:03:48,560
it in memory is basically cost of computing it using at most R registers plus the store

38
00:03:48,560 --> 00:03:52,080
cost. Again we are going to follow this contiguous

39
00:03:52,080 --> 00:03:57,280
evaluation, but there is a small twist here. First what we will do is that we have to evaluate

40
00:03:57,280 --> 00:04:02,920
each sub tree completely before you move on to the other sub tree, but within each sub

41
00:04:03,079 --> 00:04:09,239
tree if some node has to be evaluated using memory, remember the memory cost is cost of

42
00:04:09,239 --> 00:04:14,599
computing it using R registers plus the store cost. That means that we must have all the

43
00:04:14,599 --> 00:04:20,399
registers available for that. Therefore, in each sub tree what we will do is that we will

44
00:04:20,399 --> 00:04:27,120
first compute that particular sub tree which requires it to be computed using memory. That

45
00:04:27,120 --> 00:04:29,879
is when you will have all the R registers available.

46
00:04:30,159 --> 00:04:36,600
So, you first compute evaluate the sub trees of T that need to be evaluated into memory

47
00:04:36,600 --> 00:04:42,279
using all the R registers and then after the computation you put the value into a temporary

48
00:04:42,279 --> 00:04:49,279
location or into memory. Then you can do the rest of the computation for T 1. Similarly,

49
00:04:49,279 --> 00:04:55,000
after you have finished this you can now go to T 2 and again within T 2 whichever computation

50
00:04:55,000 --> 00:05:00,560
which requires to be done within the memory you finish that then do the rest of T 2.

51
00:05:00,560 --> 00:05:06,040
Then you go to the operation. So, this is the order in which you are going to do the

52
00:05:06,040 --> 00:05:12,319
code generation. This is basically required again to ensure that you will be able to generate

53
00:05:12,319 --> 00:05:18,480
code with the minimum cost. This particular method generates code since it has to traverse

54
00:05:18,520 --> 00:05:26,520
each node exactly once. It has a cost which is proportional to the number of nodes in

55
00:05:26,520 --> 00:05:33,000
the tree. How many of you know about dynamic programming approach? What is the simplest

56
00:05:33,000 --> 00:05:37,640
example for dynamic programming approach? Simplest example?

57
00:05:37,639 --> 00:05:44,639
Dijkstra's algorithm. Fibonacci. Fibonacci is the simplest recursive evaluation of Fibonacci.

58
00:05:50,439 --> 00:05:56,039
It is a simplest example and what do you do in that thing? Essential idea of dynamic programming

59
00:05:56,039 --> 00:06:03,039
is that you memorize the Fibonacci values of the previous two numbers. Therefore, it

60
00:06:04,040 --> 00:06:11,040
needs to be computed exactly once for each number. That is why it has a computation cost

61
00:06:12,000 --> 00:06:19,000
which is... Now, let us see how we are going to do this dynamic. Again the dynamic programming

62
00:06:19,240 --> 00:06:23,560
approach is going to exactly follow the same thing. If I want to calculate the cost of

63
00:06:23,560 --> 00:06:30,560
this subtree that is going to in turn going to go into the cost of two subtrees there.

64
00:06:30,759 --> 00:06:35,240
Then that in turn is going to require cost of computing subtree there and so on and so

65
00:06:35,240 --> 00:06:42,240
forth. At each point in time I actually store the cost of right the minimum cost for generating

66
00:06:42,319 --> 00:06:49,319
code for that subtree using 1, 2, 3 up to R registers as well as using memory. Then

67
00:06:49,439 --> 00:06:55,600
I keep using this upward. That is how we memorize these values and then keep using it upward

68
00:06:55,680 --> 00:07:01,040
so that it traverses the tree exactly once to get the cost.

69
00:07:01,040 --> 00:07:06,000
Now let us see how that works. Essentially you are going to compute the cost bottom up

70
00:07:06,000 --> 00:07:13,000
manner starting from the leaf nodes. Let us assume that this is an array of n to R plus

71
00:07:13,200 --> 00:07:20,200
1. It should have been R plus 1 because there is also 0 for each node where you have R registers

72
00:07:20,759 --> 00:07:27,759
and C n of i is the minimum cost of computing the complete subtree which is routed at node

73
00:07:28,719 --> 00:07:35,719
n using i registers. When you do this thing you also have to find out once you have found

74
00:07:36,839 --> 00:07:42,240
out which has the minimum cost you also remember what kind of gives you that minimum cost what

75
00:07:42,240 --> 00:07:46,719
combination gave you that minimum cost. So that when you generate code you can use that

76
00:07:46,720 --> 00:07:53,720
combination to generate that code. When I give you an example this will become clear.

77
00:07:53,720 --> 00:07:58,400
Now using this cost array you determine the subtree that must be computed into memory.

78
00:07:58,400 --> 00:08:03,800
If any subtree requires to be computed into memory then that subtree has to be then the

79
00:08:03,800 --> 00:08:10,320
code for that subtree has to be generated first. Then of course the rest of the subtree

80
00:08:10,320 --> 00:08:15,200
that is the order in which you are going to do. Let us see again we will take the same

81
00:08:15,199 --> 00:08:20,959
example and then start computing the cost for each of the nodes. Again computing the

82
00:08:20,959 --> 00:08:27,959
cost is going bottom up. Remember in the Shetty-Wulman algorithm when you are doing labeling, labeling

83
00:08:27,959 --> 00:08:33,080
was bottom up. That is exactly the same thing that you are going to do.

84
00:08:33,080 --> 00:08:39,659
And now let us look at the cost for each one of these leaf nodes to start with. If you

85
00:08:39,659 --> 00:08:48,500
know that each leaf node is going to be either a variable which is in memory or a constant.

86
00:08:48,500 --> 00:08:53,799
If it is a variable which is in memory then computing it with using memory is actually

87
00:08:53,799 --> 00:08:58,659
no cost because it is already in the memory. If it is a constant it is a constant we can

88
00:08:58,659 --> 00:09:04,699
actually use it directly in our this one as long as it is a small constant. Now let us

89
00:09:04,700 --> 00:09:13,540
look at this. So, this node a is basically a variable to compute this using memory it

90
00:09:13,540 --> 00:09:20,020
requires no cost. But to compute it using one register you need a move instruction.

91
00:09:20,020 --> 00:09:28,300
Therefore, that requires a cost of one. Computing it using two registers is same as one register

92
00:09:28,300 --> 00:09:33,700
because you do not need the second register. So, you can just not use it at all. So, the

93
00:09:33,700 --> 00:09:40,780
cost of computing any node right any leaf node which is actually in memory is basically

94
00:09:40,780 --> 00:09:47,780
0 for memory and for on for the first register and any other register also it will be 1.

95
00:09:47,780 --> 00:09:52,500
So, here we are going to do this example again using two registers. That is why you have

96
00:09:52,500 --> 00:10:01,700
three elements for each node. So, that explains this 0 1 1 cost for all the leaf nodes. Now

97
00:10:01,700 --> 00:10:09,860
let us see how do we compute the cost for t 1. Now the cost for computing or generating

98
00:10:09,860 --> 00:10:15,980
code for t 1 using one register we will do that first. Now if you want to compute the

99
00:10:15,980 --> 00:10:23,740
code using one register one possibility is that you can give one register for t 1 and

100
00:10:23,740 --> 00:10:30,780
no register for b. Remember that the right operand can be memory left operand has to

101
00:10:30,779 --> 00:10:41,019
be a register. That means that using one register the cost of computing a is 1. Using 0 registers

102
00:10:41,019 --> 00:10:46,779
or using memory which is already there in the memory the cost of computing this is 0

103
00:10:46,779 --> 00:10:55,819
right. Therefore, the cost of computing t 1 is basically 1 plus 0 plus 1. One for this

104
00:10:56,660 --> 00:11:03,780
a into memory sorry loading a into register another for b which is already I mean sorry

105
00:11:03,780 --> 00:11:09,900
nothing for b because b is already in memory and one for doing the add operation for t

106
00:11:09,900 --> 00:11:19,740
1. So, that is the cost of evaluating or generating code for t 1 using one register for a and

107
00:11:20,220 --> 00:11:28,899
0 registers for b. How about using one register for b and 0 register for a not possible because

108
00:11:28,899 --> 00:11:41,899
the left operand has to be in register right. Are there any other possibilities?

109
00:11:41,899 --> 00:11:49,100
a and b 1 a and t 1 you can use the same register remember this is the cost of generating code

110
00:11:49,100 --> 00:11:55,779
not the number of registers correct. So, cost of generating code with one register even

111
00:11:55,779 --> 00:12:00,779
this is with one register not with two registers right. I am basically including the number

112
00:12:00,779 --> 00:12:05,779
of instructions cost is here is the number of instruction not the number of registers

113
00:12:05,779 --> 00:12:13,420
ok correct. And we have to consider all possible instructions and operand modes or operands

114
00:12:13,420 --> 00:12:18,379
for this that is why we consider register operand for this memory operand for this memory

115
00:12:18,740 --> 00:12:25,220
operand for this register operand for b is not possible ok right. So, this is the cost

116
00:12:25,220 --> 00:12:32,139
of computing this element remember this sub tree and this sub tree are the same ok. So,

117
00:12:32,139 --> 00:12:37,779
whenever you fill the cost for t 1 you can also fill the cost for t 2 appropriately ok.

118
00:12:37,779 --> 00:12:44,779
Now, let us find out what is the cost of doing t 1 using two registers now there are several

119
00:12:44,860 --> 00:12:51,539
possibilities you can compute a in one register and b in one register. And when you do that

120
00:12:51,539 --> 00:12:56,459
the cost of computing a in one register is one cost of computing b in one register is

121
00:12:56,459 --> 00:13:03,579
one and the cost of computing t 1 is one more. So, there is one move instruction for this

122
00:13:03,579 --> 00:13:10,459
one move instruction for this and possibly an add instruction for this right that cost

123
00:13:10,460 --> 00:13:17,460
is three. Now, if I am given three registers I can give both registers to a and no register

124
00:13:18,500 --> 00:13:25,500
to b does not sound like a good idea, but let us see what is the cost of this right

125
00:13:26,100 --> 00:13:33,100
in this case since b is the right operand ok it can be given zero registers and it can

126
00:13:33,500 --> 00:13:40,500
be taken from memory and that actually gives me a lower cost right. Therefore, if I give

127
00:13:41,139 --> 00:13:46,940
two registers to a two registers to b and then no registers or two registers to a and

128
00:13:46,940 --> 00:13:52,580
no register for b then essentially I am computing this using two registers which is same as

129
00:13:52,580 --> 00:13:59,580
computing it using one register plus computing this in memory which is zero and then adding

130
00:13:59,580 --> 00:14:04,860
up these two things along with the cost of t 1. So, that cost will be two now let us

131
00:14:04,860 --> 00:14:10,420
look at this interesting possibility which we have not seen before correct remember when

132
00:14:10,420 --> 00:14:17,420
we did code generation for trees what did we say if the left sub tree has a particularly

133
00:14:17,820 --> 00:14:24,620
the labeling algorithm of a seti woolman what does it say that there are two sub trees ok

134
00:14:24,860 --> 00:14:30,980
what is the minimum number of registers required for the node let us say if the left sub tree

135
00:14:30,980 --> 00:14:36,779
requires r 1 registers minimum registers the right sub tree requires r 2 minimum registers

136
00:14:36,779 --> 00:14:41,179
what would be the cost of generating I mean what would be the minimum number of registers

137
00:14:41,179 --> 00:14:48,179
required for the root correct why did we say that if they are not equal what did we say

138
00:14:48,179 --> 00:14:55,179
because we can compute the result requiring both the registers first and then keep that

139
00:14:58,099 --> 00:15:03,099
register and use the other exactly right. So, now remember that I should not simply

140
00:15:03,099 --> 00:15:10,099
say that if I give two registers to a after computing a I can only to keep the result

141
00:15:10,259 --> 00:15:17,259
only in one register all other registers can be released for b ok. So, that is this possibility

142
00:15:17,740 --> 00:15:24,100
I give two registers to a I first compute a correct and then after finished computing

143
00:15:24,100 --> 00:15:31,100
a I can release all, but one register and that register can be used for b and I can

144
00:15:31,100 --> 00:15:37,139
evaluate the cost. So, I need to consider this possibility also saying computing a using

145
00:15:37,139 --> 00:15:43,139
two registers and computing b using one register do not treat this as three registers right

146
00:15:43,340 --> 00:15:49,299
it is not like three registers right if I have two here and one here then this will

147
00:15:49,299 --> 00:15:55,860
be only two if I have one here and one here this will be two that is true right. So, you

148
00:15:55,860 --> 00:16:00,699
have to remember that possibility and you also have to include that therefore, the cost

149
00:16:00,699 --> 00:16:07,700
of computing t 1 is the minimum cost of three three or two which is two right.

150
00:16:08,700 --> 00:16:15,700
So, when you do this thing what you really need to do is I will show you right. So, here

151
00:16:16,020 --> 00:16:21,860
what we have calculated is that for t 1 we said that the minimum cost is this one a in

152
00:16:21,860 --> 00:16:27,900
a register and b in memory right. So, what we need to do is that here we need to show

153
00:16:27,900 --> 00:16:34,900
a in register b in memory I am sorry let us do this not here. So, this is for a first

154
00:16:37,700 --> 00:16:44,700
for two registers correct. So, here we will say a in register b in memory ok this information

155
00:16:50,100 --> 00:16:57,100
is something that we need to save. So, that when you come to t 2 if you choose two registers

156
00:16:57,580 --> 00:17:04,299
ok it means that you have to use this particular option correct you need to remember that otherwise

157
00:17:04,299 --> 00:17:06,940
you would not know how you have arrived at that.

158
00:17:06,940 --> 00:17:12,299
Similarly, of course for this also you need to remember right here what you say here a

159
00:17:12,299 --> 00:17:19,299
in register b in memory correct. So, you need to remember these things right every time

160
00:17:20,819 --> 00:17:26,339
you store the minimum cost you say which pattern has cost this minimum cost in this case the

161
00:17:26,339 --> 00:17:33,339
pattern which has cost this minimum cost is this one right. Therefore, you save that information

162
00:17:33,740 --> 00:17:40,740
over here right ok make sense alright. Now, let us move forward and then see how do we

163
00:17:44,500 --> 00:17:48,699
compute this. So, moment I do ok now the last thing that we need to find out is what is

164
00:17:48,699 --> 00:17:55,699
the cost of evaluating t 1 in memory which is the third thing that we need to see right

165
00:17:56,539 --> 00:18:03,539
evaluating t t 1 in memory is the cost of evaluating t 1 using r registers plus storing

166
00:18:04,500 --> 00:18:11,500
it in memory right. So, that will be 2 plus 1 ok make sense. So, now, you have finished

167
00:18:12,100 --> 00:18:17,539
this 3 2 2 you also know that this will also be 3 2 2.

168
00:18:17,539 --> 00:18:23,740
Now, let us take one more example and then see how that works let us look at t 3 and

169
00:18:23,740 --> 00:18:29,579
then look at evaluating t 3 with 1 2 or 3 registers. See remember whenever you are evaluating

170
00:18:29,579 --> 00:18:35,460
the cost of generating code for a particular node you need to consider all possible combinations

171
00:18:35,460 --> 00:18:41,900
ok and you need to consider for all possible registers from 1 to r. I do not think that

172
00:18:41,900 --> 00:18:48,900
using r registers is going to be cheaper right than using is likely to be cheaper than using

173
00:18:49,780 --> 00:18:54,500
r minus 1 or r minus 2 registers there is no reason for that. For example, here you

174
00:18:54,500 --> 00:19:01,500
can see right using fewer registers right using only memory is actually expensive in

175
00:19:03,860 --> 00:19:08,900
some cases it could it could be I mean using sorry the other way around should have said

176
00:19:08,900 --> 00:19:15,420
the following thing using fewer registers may not necessarily be more expensive than

177
00:19:15,539 --> 00:19:18,980
using more registers ok that is really what it is ok.

178
00:19:18,980 --> 00:19:24,340
Now, let us look at this particular example shows you that right let us first find out

179
00:19:24,340 --> 00:19:31,340
cost of evaluating t 3 with 1 register. If I have 1 register right obviously the left

180
00:19:32,180 --> 00:19:39,180
child has to be in the register the right one has to be memory ok, but then what does

181
00:19:39,220 --> 00:19:43,700
it mean I could have actually done the following thing I could have computed the right child

182
00:19:43,860 --> 00:19:50,539
using memory and put it in sorry right child using 1 register and put it into memory that

183
00:19:50,539 --> 00:19:55,500
is also possible correct. Given that I have 1 register I could have

184
00:19:55,500 --> 00:20:01,980
first computed t 2 using that 1 register put the value into memory that means that eventually

185
00:20:01,980 --> 00:20:08,660
everything is in memory and then use that 1 register for this. So, when you say cost

186
00:20:08,660 --> 00:20:15,500
of evaluating this ok using 1 register you could have given that 1 register to e and

187
00:20:15,500 --> 00:20:22,500
then you could have calculated t 2 in memory right that means that this cost would be 1

188
00:20:22,540 --> 00:20:28,860
register which is 1 calculating this in memory which is 3 plus cost of this instruction which

189
00:20:28,860 --> 00:20:35,860
is 1 which is 5 and that is this cost ok right I mean that actually we will find out that

190
00:20:36,779 --> 00:20:42,699
is it has to be the minimum are there other possibilities again there are no other possibilities

191
00:20:42,699 --> 00:20:47,819
I cannot calculate both of them in memory I cannot calculate this in register and this

192
00:20:47,819 --> 00:20:52,379
in memory that is not possible. So, among the possibilities this is the only other only

193
00:20:52,379 --> 00:20:58,259
possibility among this and that possibility gives me a cost of 5 ok.

194
00:20:58,259 --> 00:21:04,539
Therefore, this one is 5 and I have to remember that this has to be computed in 1 register

195
00:21:04,539 --> 00:21:11,139
and this has to be computed in memory that is this cost plus this cost ok. Now, let us

196
00:21:11,139 --> 00:21:18,139
find out cost of evaluating 3 t 3 using 2 registers right again 2 registers there are

197
00:21:18,619 --> 00:21:25,619
several possibilities let us find out which one is going to cost the minimum ok I have

198
00:21:26,420 --> 00:21:31,619
only 1 example done here maybe we can quickly work out the other. So, if I have 2 registers

199
00:21:31,619 --> 00:21:38,619
I could have given 1 register for this and 1 register for that correct now 1 register

200
00:21:38,659 --> 00:21:45,659
for this and 1 register for that would add up to 1 plus 2 3 plus 1 more which is 4 correct

201
00:21:47,339 --> 00:21:53,219
so, that is 1 possible value I could have given 2 registers for this and 0 registers

202
00:21:53,219 --> 00:21:59,419
for that that will add up to 1 plus 3 plus 1 which is 5 which is higher than 4 and there

203
00:21:59,420 --> 00:22:05,539
is no point looking at it any other possibility I could have given 2 registers for this and

204
00:22:05,539 --> 00:22:12,539
1 register for that that is also a possibility remember when I put 2 1 right this still has

205
00:22:12,740 --> 00:22:19,740
2 right if I put 2 here and 1 here then it is again 1 plus 2 plus 1 4 which is same as

206
00:22:21,380 --> 00:22:28,380
the minimum cost. So, here when I put this 4 right I could store that 1 register for

207
00:22:28,860 --> 00:22:34,540
this 1 register for that typically that is a better option than saying 2 registers for

208
00:22:34,540 --> 00:22:40,140
this and 1 register right both of them giving me the same minimum cost. So, I might as well

209
00:22:40,140 --> 00:22:46,620
put the first one ok now after having done this thing we have to calculate the cost of

210
00:22:46,620 --> 00:22:52,620
evaluating this in memory which is same as the cost of the minimum cost across 1 2 3

211
00:22:53,099 --> 00:23:00,099
4 or registers plus 1 correct yeah 3 sorry we are calculating every node yeah that is

212
00:23:08,859 --> 00:23:15,859
because we have 2 registers absolutely right. So, this as you will see that it is dependent

213
00:23:16,339 --> 00:23:22,579
on the number of nodes and the number of registers correct right. So, it is going to be order

214
00:23:22,579 --> 00:23:29,579
n into r ok now let us look at t 4 correct. So, calculating t 4 with 1 register is calculating

215
00:23:34,539 --> 00:23:41,539
this with 1 register and this in memory right. So, that would be 5 sorry that would be 5

216
00:23:42,420 --> 00:23:49,420
plus 2 7 plus 1 8 right if you have 1 register that is the only possibility because you cannot

217
00:23:52,539 --> 00:23:59,019
give the register to the right side. Now, let us look at if you have 2 registers

218
00:23:59,019 --> 00:24:06,019
then you could have given 2 registers to this and 1 register to that ok that is 2 plus 5

219
00:24:06,180 --> 00:24:13,180
7 plus 1 8 or you could have given 1 register to this and 1 register to this ok that is

220
00:24:15,779 --> 00:24:22,779
also 8 right 2 register sorry 1 register to this 1 register to this that is also 8 ok

221
00:24:23,500 --> 00:24:30,500
let us look at how do we get 7 you give 2 registers to this and 1 register to this right

222
00:24:31,500 --> 00:24:36,940
and when you give 2 registers to this right you can first evaluate this particular sub

223
00:24:36,940 --> 00:24:43,940
tree and then release all, but 1 register and then use that register to evaluate this

224
00:24:46,019 --> 00:24:53,019
ok that can be done is not it and when you do that it is 4 plus 2 6 plus 1 7 that is

225
00:24:54,059 --> 00:24:59,619
the minimum cost again here you will save all the patterns for 8 what is the pattern

226
00:24:59,619 --> 00:25:06,619
right 1 here 1 here for 7 what is the pattern 2 here and 1 here not 2 here and 1 here right.

227
00:25:07,500 --> 00:25:14,500
So, we have to say for example for this one ok 2 2 2 registers to T 3 1 register to T

228
00:25:21,899 --> 00:25:28,899
1 you have to store things like that right and when you do that thing if you have a 2

229
00:25:29,619 --> 00:25:35,099
registers if you are going to generate code for this instruction correct what is the assumption

230
00:25:35,099 --> 00:25:40,939
or giving 2 registers here 1 register that and the moment you do that in code generation

231
00:25:40,939 --> 00:25:46,739
what do you have to do you have to generate code for this sub tree first before you generate

232
00:25:46,739 --> 00:25:52,379
code for that sub tree and just give me 1 minute I will take your question and within

233
00:25:52,379 --> 00:25:57,979
this sub tree if any of the nodes kind of keep a pattern saying that it has to be evaluated

234
00:25:58,180 --> 00:26:04,259
in memory then that has to be evaluated first except for leaf nodes because leaf nodes doing

235
00:26:04,259 --> 00:26:09,779
it in memory is actually nothing right for example here right you are going to do it

236
00:26:09,779 --> 00:26:14,779
in memory, but that is really nothing you do not generate any code for that, but for

237
00:26:14,779 --> 00:26:20,059
all other internal nodes if something needs to be done in memory then for that code needs

238
00:26:20,059 --> 00:26:27,059
to be generated yes sir question your question.

239
00:26:27,980 --> 00:26:48,420
2 registers to T 1 right and 1 register to 0 registers okay 2 registers will give you

240
00:26:48,420 --> 00:27:02,779
this and 0 registers will give you what right it is actually not when you give 2 registers

241
00:27:02,779 --> 00:27:07,980
to here you can as well give 1 register, but that 1 register also could be including memory

242
00:27:07,980 --> 00:27:15,259
cost okay you can consider either 1 register cost or you should consider memory cost whichever

243
00:27:15,259 --> 00:27:20,660
is lower right in fact what you will do is that you will actually look at this entire

244
00:27:20,660 --> 00:27:25,619
array and then if you are looking at some k registers you will look at all values k

245
00:27:25,619 --> 00:27:33,460
minus 1 k minus 2 etcetera up to memory okay whatever is the minimum cost we can take because

246
00:27:33,460 --> 00:27:38,660
doing it in this in fact you would have done that already because this minimum cost itself

247
00:27:38,660 --> 00:27:45,019
would have worked out that way okay doing it using that many registers 1 k minus 1 register

248
00:27:45,779 --> 00:27:53,539
right is actually what it is so it is fine okay it would have effectively result in this

249
00:27:53,539 --> 00:27:59,700
case so in this case if you give 2 registers to T 1 and only 1 register to T 3 you are

250
00:27:59,700 --> 00:28:08,460
either going to choose this pattern or this pattern okay and unfortunately these 2 patterns

251
00:28:08,460 --> 00:28:16,259
are going to result in a higher cost whereas what you want is this and if you want that

252
00:28:16,259 --> 00:28:21,779
you should have given 2 registers to T 3 and 1 register to T 1 and that means that you

253
00:28:21,779 --> 00:28:31,299
have to evaluate this sub tree first before evaluating that sub right any questions okay

254
00:28:31,460 --> 00:28:38,859
So let us now so this process is basically computing the cost right for all the nodes

255
00:28:38,859 --> 00:28:45,220
now we still have to generate code remember computing the cost is bottom up and generating

256
00:28:45,220 --> 00:28:52,579
the code is going to be top down so you look at this for every node choose that particular

257
00:28:52,579 --> 00:28:58,379
value which has the minimum cost right and then for that particular minimum cost you

258
00:28:58,380 --> 00:29:04,060
also know how to generate code for example for this 7 we saw that you have to allocate

259
00:29:04,060 --> 00:29:11,180
2 registers to T 3 and 1 register to T 1 and the moment you say 2 registers to T 3 you

260
00:29:11,180 --> 00:29:17,700
know that you have to evaluate this sub tree first correct therefore the moment you say

261
00:29:17,700 --> 00:29:21,980
that you have to I mean of course the code generated is going to be the other way around

262
00:29:21,980 --> 00:29:27,380
okay you will not generate code like this but here the code that has to be generated

263
00:29:27,380 --> 00:29:32,140
is something like this is going to be well let us actually do it the other way around

264
00:29:32,140 --> 00:29:37,260
right then you come down right and then you say that next I have to generate code for

265
00:29:37,260 --> 00:29:44,620
T 3 before generating code for T 1 right now how do we generate code for T 3 again you

266
00:29:44,620 --> 00:29:53,380
look at it 2 registers okay that is the minimum cost and you have to use right for that whatever

267
00:29:53,380 --> 00:29:58,580
is the pattern then you will follow that pattern might be 1 register here and 1 register

268
00:29:58,580 --> 00:30:05,620
there right and this 1 register mean move this to blah blah and then do this and then

269
00:30:05,620 --> 00:30:10,340
do this then you come to this side then here you will say that I have to use 1 register

270
00:30:10,340 --> 00:30:15,820
which will be move a comma into some register and do this again you will try to see whether

271
00:30:15,820 --> 00:30:21,940
you can evaluate this in the same way that the left sub tree value is evaluated in the

272
00:30:22,059 --> 00:30:27,779
same register of the destination register right the ordering that in way in which I

273
00:30:27,779 --> 00:30:32,860
have given is basically to remember the pattern not to generate the code obviously you have

274
00:30:32,860 --> 00:30:37,460
to generate the code from the leaf node to the not bottom up it is top down but it is

275
00:30:37,460 --> 00:30:43,019
a recursive procedure it will go to the leaf node generate code and then go to the parent

276
00:30:43,019 --> 00:30:48,220
node remember the code generation mechanism that we saw in the labeling and you are trying

277
00:30:48,420 --> 00:30:54,620
to do this swap registers and other things something very similar okay that is really

278
00:30:54,620 --> 00:30:58,740
what happens here okay so we are not going to go through the code generation process

279
00:30:58,740 --> 00:31:04,059
in any more details other than looking at this level of detail right all right any questions

280
00:31:04,059 --> 00:31:15,140
yeah. Two different approaches that is all. Complexity

281
00:31:15,140 --> 00:31:30,380
wise both are going to be more or less the same yes space meaning yes yes yes so whereas

282
00:31:30,380 --> 00:31:35,500
that is a labeling approach yes okay I am not really sure whether there are any other

283
00:31:35,500 --> 00:31:40,500
advantages of dynamic programming I do not recall but yeah they are somewhat similar

284
00:31:40,500 --> 00:31:49,099
approach yeah so that is also going to be stored in an array along with that so you

285
00:31:49,099 --> 00:31:53,660
have the C array which is the cost array and similarly a P array which is let us say the

286
00:31:53,660 --> 00:32:01,460
pattern array which will store how to distribute the registers for that particular cost right

287
00:32:01,460 --> 00:32:06,940
we did not explicitly talk about that but that cost is included which adds to his point

288
00:32:07,059 --> 00:32:16,059
more storage cost right any other questions right we will see one more mechanism for generating

289
00:32:16,059 --> 00:32:27,340
code right and that is the tree pattern matching approach this also allows you to select appropriate

290
00:32:27,340 --> 00:32:32,460
instructions remember when we talked about this code generation scheme the dynamic code

291
00:32:32,460 --> 00:32:38,220
generation scheme and the dynamic programming approach based code generation scheme for each

292
00:32:38,220 --> 00:32:43,660
node not only you consider these different possibilities of which register to be given

293
00:32:43,660 --> 00:32:49,700
to what you can also think in terms of what other instructions can possibly implement this

294
00:32:49,700 --> 00:32:56,100
that also needs to be looked at okay of course here we do not have an example which kind of

295
00:32:56,099 --> 00:33:04,859
meets that but for example let us say if this is A plus 1 right when I give you a example for tree

296
00:33:04,859 --> 00:33:09,379
pattern matching it will become more obvious but let us say for the time being that this is

297
00:33:09,379 --> 00:33:16,500
computing A plus 1 instead of A plus B right then in that case it would have been better to do an

298
00:33:16,500 --> 00:33:24,299
increment operation right and if the architecture allows you to do an increment operation even in

299
00:33:24,299 --> 00:33:31,659
memory then that is even better because it will actually have a cost of 1 for this entire sub tree

300
00:33:31,659 --> 00:33:38,579
correct otherwise you have to move it into a register increment 1 but if it allows you to

301
00:33:38,579 --> 00:33:45,099
increment it in memory then you could have actually done this using that so again it depends so you

302
00:33:45,099 --> 00:33:51,220
need to consider all possible combinations but it can still be done now let us see how tree pattern

303
00:33:51,220 --> 00:33:56,220
matching essentially does many of these things and allows you to do appropriate instruction

304
00:33:56,220 --> 00:34:03,620
selection as well okay so that is the next thing that you are going to talk about okay so there

305
00:34:03,620 --> 00:34:08,940
are many different possible ways by which we can select the instruction and choosing the appropriate

306
00:34:08,940 --> 00:34:16,500
one is a complex problem right and you do not want to kind of manually also write many of these

307
00:34:16,500 --> 00:34:23,260
code again different possible addressing modes are there that also complicates the matter and

308
00:34:23,260 --> 00:34:28,900
there are different possible instruction combinations that can also generate code for the same set of

309
00:34:28,900 --> 00:34:36,699
instruction and lastly we want to see whether this process of right writing the code generator

310
00:34:36,699 --> 00:34:42,780
itself can be automated right for example let us say you wrote a code generator for

311
00:34:42,780 --> 00:34:49,380
architecture a but tomorrow you want to write a code generator for architecture b do you have

312
00:34:49,380 --> 00:34:55,620
to go in and rewrite that entire code generator for architecture b or can architecture a and

313
00:34:55,620 --> 00:35:01,820
architecture b specified in some way and there is a code generator generator which generates

314
00:35:01,820 --> 00:35:07,820
the code generator for a and the code generator for b can we do that it is possible to do that

315
00:35:07,820 --> 00:35:13,820
also and this kind of an approach where you try to do instruction selection using tree pattern

316
00:35:13,820 --> 00:35:19,780
matching enables you to do that in fact we are going to talk briefly talk about two code

317
00:35:19,780 --> 00:35:26,059
generator generators which are very popular okay before we go into those details let us first look

318
00:35:26,059 --> 00:35:31,380
at how this tree pattern matching based code generation works for this we are going to use

319
00:35:31,380 --> 00:35:35,340
this intermediate representation which is called the tree intermediate code.

320
00:35:35,340 --> 00:35:40,740
Tree intermediate code is nothing but a DAG like structure or a tree like structure it is

321
00:35:40,740 --> 00:35:46,220
a tree like structure not a DAG it is a tree like structure okay and let us see an example

322
00:35:46,220 --> 00:35:52,620
to understand this so this is the statement intermediate statement that I want to for which

323
00:35:52,620 --> 00:35:59,700
I want to generate the code a of i is equal to b plus 1 right and let us try to understand this

324
00:35:59,699 --> 00:36:05,179
tree representation before we go to anything else and in this particular example let us also

325
00:36:05,179 --> 00:36:13,739
make sure that we understand what these variables are let us say a and i are local variables what

326
00:36:13,739 --> 00:36:18,980
do we mean by local variables where are they stored they are stored in the stack frame and

327
00:36:18,980 --> 00:36:24,219
when they are stored in the stack frame they are going to be referenced with reference to the stack

328
00:36:24,219 --> 00:36:31,099
frame address correct that is really what we need to understand and let us say that variable b is

329
00:36:31,099 --> 00:36:39,659
global that means it will be in the data segment okay okay now let us remember these things and

330
00:36:39,659 --> 00:36:49,659
then see how this tree pattern thing works right b plus 1 right 1 is a constant b is in the global

331
00:36:49,659 --> 00:36:56,339
memory right b sorry b is a global variable therefore it is in the data segment correct and

332
00:36:56,339 --> 00:37:05,779
if you want to load b either you need to have the address of b and then move it using some

333
00:37:05,779 --> 00:37:11,819
instruction into a register or you could take the address and then directly use that memory

334
00:37:11,819 --> 00:37:18,819
location right again you have to think in terms of what addressing modes can be done right if it

335
00:37:18,820 --> 00:37:26,180
is in the data segment then to access b first thing is that you need the address address is

336
00:37:26,180 --> 00:37:36,019
going to be 32 bits or more correct right okay as opposed to let us look at this i right here

337
00:37:36,019 --> 00:37:46,900
also i need the address of i but this i is a local variable it is in the stack frame so when it is

338
00:37:46,900 --> 00:37:54,660
in the stack frame this location is going to be relative to that stack pointer location so how

339
00:37:54,660 --> 00:38:05,260
do we specify the address now stack pointer plus minus some offset so what is that addressing mode

340
00:38:05,260 --> 00:38:12,780
it is called the displacement addressing mode correct so here i do not need the absolute address

341
00:38:12,780 --> 00:38:23,660
of i whereas here i need the absolute address of b if i want to load it correct whether i use the

342
00:38:23,660 --> 00:38:32,940
memory or i use it i mean or i move the contents to a register for me to access b i need the address

343
00:38:32,940 --> 00:38:38,980
of b and here the address of b can only be specified as an absolute quantity 32 bit number

344
00:38:38,980 --> 00:38:46,780
or higher whereas to specify the address of i it is much simpler it is going to be a small offset

345
00:38:46,780 --> 00:38:52,780
from the stack pointer so i can use it using a displacement addressing mode and in the displacement

346
00:38:52,780 --> 00:38:59,300
addressing mode my offset is going to be a small constant 4 8 maybe 32 maybe 48 whatever number it

347
00:38:59,300 --> 00:39:06,219
is but it is still less than a 12 bit or a 16 bit number and therefore i can actually use that index

348
00:39:06,219 --> 00:39:14,259
addressing mode correct having said that right so at this point in time of course we are not taking

349
00:39:14,259 --> 00:39:20,639
the decision we are saying that what is the offset of i right and that offset has to be added to the

350
00:39:20,639 --> 00:39:28,379
stack pointer in order for me to get the address and then i index that address that means that i

351
00:39:28,380 --> 00:39:37,420
dereference that memory location to get the value and that value would be i correct similarly if

352
00:39:37,420 --> 00:39:43,500
i want to find out a of i correct and remember this is the left hand side that means that we

353
00:39:43,500 --> 00:39:47,980
are interested in the address and we are going to store the value in that location how do i find

354
00:39:47,980 --> 00:39:55,900
a of i let us assume a is an array of characters to make things simpler right how do i find a of

355
00:39:56,059 --> 00:40:04,940
i i need to have address of a plus add the offset corresponding to i since it is a character each

356
00:40:04,940 --> 00:40:15,740
location requires only one if it is a short or an integer what should we have done sorry plus

357
00:40:15,739 --> 00:40:25,899
4 what should be multiplied by 4 i should be multiplied by 4 correct so this value that i

358
00:40:25,899 --> 00:40:30,739
have dereference should have been multiplied by 2 or 4 depending on whether it is a short or an

359
00:40:30,739 --> 00:40:37,739
word and then that value should have been added to the address of a how do i get the address of a

360
00:40:37,739 --> 00:40:45,619
a is also a local variable it is also in the stack therefore it is going to be offset from the

361
00:40:45,619 --> 00:40:52,339
stack pointer by a small offset that offset needs to be added to the stack pointer and that gives

362
00:40:52,339 --> 00:40:59,899
me the value of address of a and to that address of a i take this offset value and then i add it

363
00:40:59,900 --> 00:41:10,099
i get the address of a of i correct right if i index it or dereference it and get the value then

364
00:41:10,099 --> 00:41:15,900
of course i would have got a of i but in this case what i need to do is that i have to dereference

365
00:41:15,900 --> 00:41:22,820
and then store so it is not a read it is a write but you are computing the left hand side of this

366
00:41:22,820 --> 00:41:29,380
expression okay so to that value to that particular location what am i going to write i am going to

367
00:41:29,380 --> 00:41:37,980
write b plus 1 okay so do we understand how this tree pattern thing working no sorry not

368
00:41:37,980 --> 00:41:43,820
the tree pattern the tree intermediate code working right any questions

369
00:41:43,820 --> 00:42:03,500
address of i why do we have this as two different leaf node why not we put this as one leaf node

370
00:42:03,500 --> 00:42:08,940
okay the first thing that would have happened is that this tree would have become a DAG okay

371
00:42:08,940 --> 00:42:14,860
second thing is since it is a leaf node the cost is not that something that you are going

372
00:42:14,860 --> 00:42:19,300
to worry about so it is okay to duplicate that you could have put that essentially you could

373
00:42:19,300 --> 00:42:24,780
have put this pointer over here nothing would have happened except that suddenly the tree has

374
00:42:24,780 --> 00:42:30,659
become a DAG and you are stuck with it okay we will see what happens when you have a DAG because

375
00:42:30,659 --> 00:42:37,380
in practice right when you generate either the tree intermediate code or when you generate the

376
00:42:37,380 --> 00:42:45,059
you know dependence graph they are going to be a graph rather than a tree okay and in those

377
00:42:45,059 --> 00:42:51,260
cases this optimal algorithm is not going to work because they are no longer tree right we

378
00:42:51,260 --> 00:42:56,940
will see what to do with that but for the time being we will just duplicate this thing because

379
00:42:56,940 --> 00:43:06,260
it is not really different so only a leaf node okay any questions we move forward okay now given

380
00:43:06,260 --> 00:43:11,620
this let us see how the tree pattern matching is going to use this tree intermediate code for

381
00:43:11,620 --> 00:43:20,180
generating code for this okay so the tree pattern matching starts off with a set of patterns which

382
00:43:20,180 --> 00:43:26,060
are defined and for each pattern it gives you what is the code to be generated and what is the cost

383
00:43:26,060 --> 00:43:32,660
for that particular pattern right for example if I have a pattern which says a constant has to be

384
00:43:32,659 --> 00:43:40,339
moved to a register right that pattern would cause the code generated to be like move constant

385
00:43:40,339 --> 00:43:47,699
to register I similarly if I have a pattern like a memory location has to be moved to a register

386
00:43:47,699 --> 00:43:56,379
then that is load A to RI if I have a pattern which says that memory location needs to be stored

387
00:43:56,380 --> 00:44:04,099
with the value of a register I right then that would look like that would generate a code store

388
00:44:04,099 --> 00:44:17,619
of RI in memory location A right let us look at more patterns here actually I have okay that has

389
00:44:17,619 --> 00:44:28,619
to be a store right okay we will come back to this little later I will try to find out what is

390
00:44:28,619 --> 00:44:34,460
the mistake in this was thinking it is a store but then you do not have if it is a store then

391
00:44:34,460 --> 00:44:42,460
this should not have been there okay this should not have been there okay so maybe without this

392
00:44:42,460 --> 00:44:50,659
you can actually think of this if you have this pattern right register J use the value of register

393
00:44:50,659 --> 00:45:04,260
J to index I will use this pointer here so for example right you have the value of registers

394
00:45:04,260 --> 00:45:10,460
J which is used to index that means that you are dereferencing and in that location you want to

395
00:45:10,619 --> 00:45:20,659
register I so that is basically store RI into indirect location or J now this is a simple thing

396
00:45:20,659 --> 00:45:26,380
where you are basically adding two registers okay and when you do this the result goes to register

397
00:45:26,380 --> 00:45:31,380
okay so this essentially says the value goes to register that memory that is really what it says

398
00:45:31,380 --> 00:45:45,579
okay yeah okay so yeah now there are more things here so for example if you have a register and

399
00:45:45,579 --> 00:45:53,780
you want to add a constant one to it then you can say that add hash one to RI or you could have

400
00:45:53,780 --> 00:46:00,539
actually replaced it by increment instruction if such a thing exists right and here if you want

401
00:46:00,539 --> 00:46:08,139
to do constant plus register then it is also increment and so on okay so like this for all

402
00:46:08,139 --> 00:46:15,420
the instructions and possible combinations you generate the patterns okay and all of these

403
00:46:15,420 --> 00:46:20,980
patterns can be expressed as grammars okay that is very important because later on you will use

404
00:46:20,980 --> 00:46:28,340
these grammars and then write these code generators okay now let us look at how these patterns are

405
00:46:28,340 --> 00:46:36,740
going to be used in order for us to evaluate this expression okay now let us first start off with

406
00:46:36,740 --> 00:46:49,300
this address here right now that address here okay remember that this is a offset value which

407
00:46:49,300 --> 00:46:59,060
has to be added to the stack pointer okay right so what I can do is that I can move this small

408
00:46:59,060 --> 00:47:06,900
offset into a register remember the left hand side has always has to be a register right so I can move

409
00:47:06,900 --> 00:47:12,780
this into a register so the pattern that I find here is that there is a pattern which is saying

410
00:47:12,780 --> 00:47:20,540
constant A to register if I apply that pattern right that matches with this okay and therefore

411
00:47:20,540 --> 00:47:29,920
I can say that the corresponding instruction for this is right load hash A remember hash A is the

412
00:47:29,920 --> 00:47:37,980
offset that we are talking about has to be moved into a register or not right this is already in

413
00:47:37,980 --> 00:47:43,300
register so I do not need to this is stack pointer register stack pointer so this is already a

414
00:47:43,300 --> 00:47:49,980
register now if I look at it this pattern is something like register 0 plus register stack

415
00:47:49,980 --> 00:47:58,260
pointer right so register register and that going to a register the corresponding pattern is add

416
00:47:58,260 --> 00:48:07,579
or not comma stack point right now the next step you are now replacing this by a register because

417
00:48:07,579 --> 00:48:13,380
that is how the code has been generated that value is available in or not now what about the

418
00:48:13,380 --> 00:48:21,819
code for this entire sub tree now right there are two possibilities here one possibility is to look

419
00:48:21,819 --> 00:48:28,699
at this sub tree first and that sub tree can be matched with this pattern which says that register

420
00:48:28,699 --> 00:48:38,980
I okay register I is equal to index of constant plus register J right so you can just see what

421
00:48:38,980 --> 00:48:45,659
that is okay let us look at this this address I is going to be a small constant that has to be

422
00:48:45,659 --> 00:48:52,379
added to a register stack pointer so that is essentially constant plus register J right and

423
00:48:52,700 --> 00:49:01,539
then that has to be indexed and that value going to a register okay so if I look at this particular

424
00:49:01,539 --> 00:49:08,900
sub tree then that sub tree can be matched by this pattern matcher to this pattern and you can

425
00:49:08,900 --> 00:49:15,539
generate code for this okay and there is a cost that is involved for that whereas you can actually

426
00:49:15,699 --> 00:49:22,980
look at this entire sub tree okay and you can match it with this pattern right again look at

427
00:49:22,980 --> 00:49:34,179
this part is very similar to this part okay but then this register I plus indexing of this right

428
00:49:34,179 --> 00:49:42,699
and going to a register is possible right why because my left operand is a register which is

429
00:49:42,699 --> 00:49:49,579
this value and my right operand is a memory location that memory location is actually

430
00:49:49,579 --> 00:50:01,019
expressed in the displacement addressing mode correct so small I small offset SP I mean small

431
00:50:01,019 --> 00:50:06,539
offset essentially tells you how far away is I from the stack pointer and then when I add this

432
00:50:06,539 --> 00:50:14,699
to the stack pointer correct I get the address of I I dereference it I get the value of I okay

433
00:50:14,699 --> 00:50:20,420
so if I look at this entire tree it can be matched using this pattern in other words

434
00:50:20,420 --> 00:50:26,619
what I have is that I have this pattern in my pattern matching table and the pattern

435
00:50:26,619 --> 00:50:31,900
matcher essentially look at the tree and then tries to find out how to find a pattern that

436
00:50:31,900 --> 00:50:37,579
fits with the various patterns that are described in that and then it tries to choose the maximum

437
00:50:37,579 --> 00:50:42,619
pattern or the pattern which gives you minimum cost typically maximum pattern gives you the

438
00:50:42,619 --> 00:50:50,180
minimum cost so if I can do that then the code for this entire thing is actually now this P okay

439
00:50:50,180 --> 00:50:57,420
so that essentially means that this whole sub tree can now be replaced by a register which is

440
00:50:57,420 --> 00:51:05,500
in R naught right so let us do that now what we have is that we have this sub tree for which we

441
00:51:05,500 --> 00:51:11,659
need to generate code now again look at this this is memory and this is a global location therefore

442
00:51:11,659 --> 00:51:20,139
first thing is that we need to move the address of B into a register right and then we have to

443
00:51:20,139 --> 00:51:27,219
increment that register right this has to be value B because you have to increment B

444
00:51:27,219 --> 00:51:32,980
not supposed to increment the address of B okay so again look at this what do we have we have

445
00:51:32,980 --> 00:51:37,940
mem of B right and in order for me to find out mem of B what I need to do is that I have to

446
00:51:37,940 --> 00:51:47,980
load the value of B into a register I do that using this instruction load B comma R1 right and

447
00:51:48,300 --> 00:51:55,980
then of course I have register plus 1 I can generate the increment instruction now that

448
00:51:55,980 --> 00:52:02,699
will replace this by a register this already is a register with an index right now what we can do

449
00:52:02,699 --> 00:52:09,019
is that this is equivalent to doing a store instruction that is store this value in the

450
00:52:09,019 --> 00:52:17,059
location pointed by this register so that completes the code generation for this right

451
00:52:17,059 --> 00:52:24,259
so essentially what you have here in the tree pattern matching based code generator is that

452
00:52:24,259 --> 00:52:32,219
the I mean the code generator has a set of patterns right and for each one of those patterns you also

453
00:52:32,219 --> 00:52:38,300
have this information about what is the code to be generated and how much cost it requires

454
00:52:38,300 --> 00:52:43,660
then the tree pattern matcher essentially walks through the tree and then tries to reduce each

455
00:52:43,660 --> 00:52:51,660
part of the tree or sub tree right to a pattern and then for that pattern what is the cost like

456
00:52:51,660 --> 00:52:57,780
that it tries to cover or complete this entire tree that is really how the tree pattern matching

457
00:52:57,780 --> 00:53:03,860
based algorithms work we are not going to go into the details of how to write that pattern

458
00:53:03,860 --> 00:53:09,340
matcher and how to specify the patterns and things just to give you an idea of what several

459
00:53:09,340 --> 00:53:15,620
of the code generators are based on pattern matching code generators okay that is the point

460
00:53:15,620 --> 00:53:24,180
that we need to any more questions okay now let us move forward okay as I mentioned earlier this

461
00:53:24,180 --> 00:53:32,539
is something that yeah okay oh sorry this is slightly different topic so now let us address

462
00:53:32,539 --> 00:53:40,779
this question of what happens if my basic block results in a DAG rather than a tree if it is a

463
00:53:40,779 --> 00:53:51,340
tree we have good solutions available but if it is a DAG what do we do right okay so for this optimal

464
00:53:51,340 --> 00:53:57,139
code generation is NP-Hard we may not be able to generate optimal code so we have to use some

465
00:53:57,139 --> 00:54:05,980
heuristic to how we have to use some heuristic to generate efficient code right so one possible

466
00:54:05,980 --> 00:54:13,500
way is to look at your DAG and then split some of these nodes so that your DAG becomes a tree

467
00:54:13,500 --> 00:54:20,219
right let me give you an example here right supposing let us say that we have

468
00:54:20,219 --> 00:54:48,739
something like this right it is a tree except that this particular node is shared right now

469
00:54:48,739 --> 00:54:57,739
one way to make this a DAG is to replicate this node so if I replicate that node then it becomes

470
00:54:57,739 --> 00:55:07,419
something like this with this removed correct then it becomes a tree right then I can generate code

471
00:55:07,419 --> 00:55:13,659
for this tree but when I replicate what happens is that I will generate code for this part and

472
00:55:14,460 --> 00:55:21,619
I will again generate code for this part which is redundant and it will increase the cost of my

473
00:55:21,619 --> 00:55:31,539
right code generator okay another way of doing this is not so much replicate but generate code

474
00:55:31,539 --> 00:55:38,259
for one part do not do this right generate code for this part store it into a memory location and

475
00:55:38,260 --> 00:55:44,740
use that memory location in the other one so that is the other way of doing it so instead of

476
00:55:44,740 --> 00:55:50,980
repeating the computation twice you kind of do the computation once and then store it in memory

477
00:55:50,980 --> 00:55:56,980
and in the other side you essentially use it okay that is the second part compute the shard

478
00:55:56,980 --> 00:56:03,900
tree once and then save it in memory and reuse okay this in general works for a class of machines

479
00:56:03,900 --> 00:56:09,700
but again you have to remember that this may not necessarily result in the optimal code again

480
00:56:09,700 --> 00:56:18,380
right okay now the next point is about code generator generators as I mentioned earlier

481
00:56:18,380 --> 00:56:24,420
writing code generator is fine but if you have to write code generator for machine A then code

482
00:56:24,420 --> 00:56:29,340
generator for machine B then code generator for machine C you do not want to repeat this exercise

483
00:56:29,500 --> 00:56:37,820
again and again so can we actually automate this code generators itself right so for that typically

484
00:56:37,820 --> 00:56:42,380
you use this tree pattern matching based approach and dynamic programming approach you kind of

485
00:56:42,380 --> 00:56:46,420
combine these two things using tree pattern matching you kind of find out what is the

486
00:56:46,420 --> 00:56:51,700
minimum cost for each sub tree and then using that you kind of apply it in the next higher

487
00:56:51,699 --> 00:56:58,939
level okay so essentially it accepts three patterns associated cost and the semantic

488
00:56:58,939 --> 00:57:03,939
action which is essentially the code generation and then using some kind of a grammar you

489
00:57:03,939 --> 00:57:10,739
express these patterns and then you kind of write you write the code for a tree matcher

490
00:57:10,739 --> 00:57:16,019
which kind of goes through the graph which kind of goes through the tree and then identifies what

491
00:57:16,019 --> 00:57:20,839
can be matched but you also have to cover this entire tree and you have to find the one which

492
00:57:20,840 --> 00:57:26,840
covers it using the minimum cost okay so the first pass is the bottom up pass which finds a

493
00:57:26,840 --> 00:57:31,760
set of patterns that cover the tree with the minimum cost and the second pass execute a

494
00:57:31,760 --> 00:57:38,480
semantic action which is basically generating the code and that is typically the top down part okay

495
00:57:38,480 --> 00:57:48,720
so there are a few code generator generators Twig, Iberg and Berg and Iberg okay these are

496
00:57:48,719 --> 00:57:52,959
kind of popular code generator generators unfortunately we are not going to go into

497
00:57:52,959 --> 00:58:00,279
the details of this in this lecture okay so you may want to look up what these things are so essentially

498
00:58:00,279 --> 00:58:06,480
the entire process of writing a code generator itself can be automated and if you have a code

499
00:58:06,480 --> 00:58:11,000
generator generator that will actually do similar to what you have seen in lexical analysis and

500
00:58:11,000 --> 00:58:17,199
right lex and yak so you know you no longer write these lexical analyzers right there are

501
00:58:17,199 --> 00:58:23,639
programs which can generate these things okay now let us look at the last part after having

502
00:58:23,639 --> 00:58:29,319
done these things you end up with the so-called machine code now is it guaranteed that this

503
00:58:29,319 --> 00:58:36,239
machine code is supposed to be very good or will it also have some opportunities for optimization

504
00:58:36,239 --> 00:58:43,759
okay let us look at it and then that kind of optimization opportunities can be addressed with

505
00:58:43,760 --> 00:58:49,760
what is called the peephole optimizer peephole essentially means a small window so what you

506
00:58:49,760 --> 00:58:56,440
do is that in this generated machine code you look at small windows of instructions and within

507
00:58:56,440 --> 00:59:02,920
that small windows of instructions if you identify certain patterns for doing optimization you apply

508
00:59:02,920 --> 00:59:11,240
those optimizations right so these optimizations are effectively local optimization because you

509
00:59:11,239 --> 00:59:16,919
are looking at a small window of instructions okay and this is typically carried out on the

510
00:59:16,919 --> 00:59:23,919
machine code but sometimes one could also apply this on the intermediate code okay as I mentioned

511
00:59:23,919 --> 00:59:29,239
earlier it is going to look at a small window but it is a sliding window of code which is what is

512
00:59:29,239 --> 00:59:36,199
called the peephole and then it tries to apply these optimizations okay each improvement can

513
00:59:36,199 --> 00:59:40,879
itself internally to additional improvement so you have to kind of repeatedly apply these things

514
00:59:40,880 --> 00:59:47,680
like in many of the other optimizations okay now these are some of the optimizations that

515
00:59:47,680 --> 00:59:54,559
are possible using peephole optimization okay for example eliminating redundant instructions

516
00:59:54,559 --> 01:00:01,280
eliminating unreachable code eliminating jump over jumps algebraic simplifications

517
01:00:01,280 --> 01:00:08,440
strength reduction and certain machine idioms okay we will see examples of some of these things in

518
01:00:08,440 --> 01:00:15,159
order for us to understand so for example let us say that the code generated has a load instruction

519
01:00:15,159 --> 01:00:21,119
and then subsequently a store instruction and between this load and store instruction let us

520
01:00:21,119 --> 01:00:27,760
assume that X was not sorry that R1 was not modified right that means that I am loading a

521
01:00:27,760 --> 01:00:35,440
value from memory into R1 I am using it multiple times and then again I am storing it into memory

522
01:00:35,440 --> 01:00:46,360
obviously this is a redundant instruction it can be eliminated right now let us look at this piece

523
01:00:46,360 --> 01:00:57,880
of code right I have condition equal to 1 if condition equal to 1 go to L1 do this right now

524
01:00:57,880 --> 01:01:07,200
will this code be ever executed in this situation no right because condition is 1 and then you are

525
01:01:07,200 --> 01:01:14,440
going to go to L1 so if you do constant propagation then this becomes 1 equal to 1 which is always

526
01:01:14,440 --> 01:01:20,400
true that means that you are going to go here so this is an unreachable code it can be eliminated

527
01:01:20,400 --> 01:01:28,160
and if this code happens to be just following this then all of this can be eliminated right

528
01:01:28,160 --> 01:01:33,480
this condition can be eliminated this add can be eliminated but if there are I mean whatever

529
01:01:33,480 --> 01:01:37,960
instructions that are here you can actually eliminate all of them as well because they are

530
01:01:37,960 --> 01:01:44,639
all dead code right so let me just since it is always going to jump from here to here any

531
01:01:44,639 --> 01:01:51,159
instruction that you see here right like the add or any additional instruction that you hear

532
01:01:51,159 --> 01:01:56,799
they are all redundant and means they are all dead code so they are never going to be reached

533
01:01:56,799 --> 01:02:03,519
and you can eliminate them and the moment you eliminate this your L1 is directly below this

534
01:02:03,519 --> 01:02:13,000
one correct therefore this condition is also redundant and can be eliminated right so that

535
01:02:13,000 --> 01:02:20,280
is why you apply these people optimization repeatedly right jump over jumps yeah sorry question

536
01:02:20,280 --> 01:02:31,360
in the intermediate code possibly it would have been done in the intermediate code but there are

537
01:02:31,360 --> 01:02:36,840
certain things that you do during code generation that would have caused some of these things to

538
01:02:36,840 --> 01:02:45,680
happen also it is to answer your question you try to do some of these optimizations in the

539
01:02:45,680 --> 01:02:51,120
intermediate code and then you take the optimized intermediate code and generate the machine code

540
01:02:51,120 --> 01:02:57,480
but in the process of generating the machine code right again these opportunities would

541
01:02:57,480 --> 01:03:02,000
possibly arise because of the way in which you are generating machine code see I can give you

542
01:03:02,000 --> 01:03:08,639
an example for this just saying that this let us say that we are trying to compute something

543
01:03:08,639 --> 01:03:17,880
right I mean so I will give you an example of this for example let us say that X is I mean let's say

544
01:03:17,880 --> 01:03:25,280
that we have a variable which we were spilling loading and then again spilling and then loading

545
01:03:26,160 --> 01:03:33,120
if you are doing that right it may be the case that I have been loading and again I am trying

546
01:03:33,120 --> 01:03:37,960
to spill in between there were no modifications that were done there are no modifications that

547
01:03:37,960 --> 01:03:42,920
were done then there is no reason to store it so this can be eliminated so there are these

548
01:03:42,920 --> 01:03:48,400
opportunities that do arise and typically a simple peephole optimizer pass which repeatedly

549
01:03:48,400 --> 01:03:53,160
goes through this code kind of cleans up this so here is another example where you have what

550
01:03:53,159 --> 01:04:02,039
is called a jump over jump okay so here you have a less than b go to L1 and then in L1 you say go

551
01:04:02,039 --> 01:04:06,920
to L2 right if you look at these two things together you could have replaced this and then

552
01:04:06,920 --> 01:04:12,960
said go to L2 strength reduction essentially says that instead of using some more expensive

553
01:04:12,960 --> 01:04:17,920
operations you could have used right other operations again you could ask this question

554
01:04:17,920 --> 01:04:22,680
wouldn't instruction selection have taken this care taken care of yes it could have

555
01:04:22,680 --> 01:04:28,039
taken care of this but then if that didn't consider it for whatever reason it is then

556
01:04:28,039 --> 01:04:33,200
these opportunities do arise see for example when you are generating code right maybe this

557
01:04:33,200 --> 01:04:40,519
8 was not a constant right and then maybe you did some constant propagation like what

558
01:04:40,519 --> 01:04:46,000
you did over here and then that resulted in this value being 8 now you have an additional

559
01:04:46,000 --> 01:04:51,480
opportunity of doing this so whenever you have this multiplication you can replace multiplication

560
01:04:51,480 --> 01:04:59,119
of a number which is 2 power 8 2 power k then you can replace it by a shift operation similarly

561
01:04:59,119 --> 01:05:05,159
power operation can be I mean the power will not happen in the machine code level but yeah

562
01:05:05,159 --> 01:05:10,639
similar things like what you have seen in strength reduction right again machine idioms

563
01:05:10,639 --> 01:05:15,800
where you can actually replace certain things for example here we are loading x to r naught

564
01:05:16,600 --> 01:05:24,280
incrementing r naught by 1 and storing the value correct so we could have replaced this

565
01:05:24,280 --> 01:05:30,760
by a increment instruction if the machine supports an increment so these are opportunities

566
01:05:30,760 --> 01:05:38,600
that you get in code generation and you can actually exploit them right and you can eliminate

567
01:05:38,600 --> 01:05:45,039
some redundant code or optimize your code so this optimization is the last phase after

568
01:05:45,039 --> 01:05:51,519
I mean last in the sense of after code generation you do one more pass of peephole optimization

569
01:05:51,519 --> 01:05:57,320
and eliminate some of these redundant codes right that is something that you do okay that

570
01:05:57,320 --> 01:06:04,559
kind of completes our discussion on code generators so do you have any more questions on this

571
01:06:04,559 --> 01:06:05,559
yeah.

572
01:06:05,559 --> 01:06:33,239
They will have separate code generators for each one of them okay so why do not we actually

573
01:06:33,919 --> 01:06:39,479
defer this question for some time right and we will come back and answer this but important

574
01:06:39,479 --> 01:06:45,319
thing to know is that when you say something as a compiler right it includes some code

575
01:06:45,319 --> 01:06:50,359
generator how that code generator is generated is a different issue either it could have

576
01:06:50,359 --> 01:06:56,919
been written by some set of people or it could have been generated by a generator but then

577
01:06:56,919 --> 01:07:01,159
that module has to be a part of the compiler that is something that we need to understand

578
01:07:01,279 --> 01:07:09,000
Now this retarget ability to multiple target machines right you would have seen why that

579
01:07:09,000 --> 01:07:19,559
happens right why that happens meaning like so you have these different languages so this

580
01:07:19,559 --> 01:07:25,359
is language one language two and language n right and then you have these different

581
01:07:25,360 --> 01:07:34,680
machines machine one machine two and machine three right so the conventional approach is

582
01:07:34,680 --> 01:07:40,599
to kind of write from each language to the respective machine so that will be m cross

583
01:07:40,599 --> 01:07:47,400
m you do not do that you never do that thing right so it goes into some intermediate form

584
01:07:47,400 --> 01:07:57,400
right and then from there are separate code generators for this is the standard approach

585
01:07:57,400 --> 01:08:03,160
that is followed now this code generator here will simply put code generator but it involves

586
01:08:03,160 --> 01:08:07,599
code generator plus a number of other cases as well right this code generator which is

587
01:08:07,599 --> 01:08:14,800
specific for machine one correct your question is it generated by a generator or is it manually

588
01:08:14,800 --> 01:08:24,360
written you definitely have to have a CG for each okay the question is whether the CG is

589
01:08:24,360 --> 01:08:30,520
manually generated or is generated by a code generator right so code generators if you have

590
01:08:30,520 --> 01:08:36,119
a code generator which can generate effective code yes you have a single code generator and

591
01:08:36,119 --> 01:08:42,800
then specify these for each one of those machines and then the code generator would generate the

592
01:08:42,800 --> 01:08:49,480
CG for each one of them right obviously that that that is the purpose of code generator generator

593
01:08:49,480 --> 01:09:00,320
right okay I am not very sure about the way in which things are done in GCC I will suddenly

594
01:09:00,320 --> 01:09:04,360
flash some slide in the next discussion okay.

