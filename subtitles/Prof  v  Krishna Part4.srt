1
00:00:00,000 --> 00:00:15,519
So, if you look at this code here, once you draw this CFG, you will find that here is

2
00:00:15,519 --> 00:00:16,640
one basic block.

3
00:00:16,640 --> 00:00:21,719
From this basic block, you have one edge to this basic block.

4
00:00:21,719 --> 00:00:26,120
You have another kind of couple of basic blocks here from which there is an edge to the block

5
00:00:26,120 --> 00:00:28,359
here, but that part is unreachable.

6
00:00:28,919 --> 00:00:31,359
So that part goes away.

7
00:00:31,359 --> 00:00:39,439
And then you have, so I just, and then I do not need the label here.

8
00:00:39,439 --> 00:00:46,679
Basically, now I can, I will basic block here and edge to the next basic block.

9
00:00:46,679 --> 00:00:50,480
This guy has only one successor, the bottom guy has only one predecessor.

10
00:00:50,480 --> 00:00:55,000
I can straighten the, do straightening.

11
00:00:55,000 --> 00:00:56,640
So this label is gone.

12
00:00:56,719 --> 00:00:57,719
I do not need.

13
00:00:57,719 --> 00:01:06,480
Similarly, now here is a basic block which has, now initially this basic block had two

14
00:01:06,480 --> 00:01:09,480
parents, two predecessors.

15
00:01:09,480 --> 00:01:13,159
Now it has only one predecessor.

16
00:01:13,159 --> 00:01:18,640
So because you did one optimization, it enabled one more.

17
00:01:18,640 --> 00:01:25,120
So now this basic block, so I have one basic block all the way here, then this, then this.

18
00:01:25,120 --> 00:01:30,800
Now if you look at it, if you do some simple constant propagation, we have not learned

19
00:01:30,800 --> 00:01:34,719
how to do it, but that is fine.

20
00:01:34,719 --> 00:01:38,640
So here it is y equal to 2 and y equal to b plus 1.

21
00:01:38,640 --> 00:01:41,640
You have already done reaching definitions, right?

22
00:01:41,640 --> 00:01:48,680
The reaching definitions will tell you that this definition reaches nowhere, right?

23
00:01:48,680 --> 00:01:54,000
So y equal to 2, this guy will, is gone.

24
00:01:54,000 --> 00:01:59,519
Then y equal to b plus 1, constant propagation will make it y equal to 2.

25
00:01:59,519 --> 00:02:08,639
Now this b equal to 1 reaches nowhere, then x plus plus remains.

26
00:02:08,639 --> 00:02:14,199
Now you have this if else, is y greater than 3?

27
00:02:14,199 --> 00:02:18,879
No, so you know that the then part is gone.

28
00:02:18,879 --> 00:02:24,439
So this is constant propagation if you do, that goes out.

29
00:02:24,439 --> 00:02:32,039
And now I have this if, before I do, see here I have y greater than 3, the else part is

30
00:02:32,039 --> 00:02:35,400
y is less than 3.

31
00:02:35,400 --> 00:02:40,300
So that means this inner if is always false.

32
00:02:40,300 --> 00:02:48,240
So I can not only remove that part, but I can also remove this inner, okay?

33
00:02:48,320 --> 00:02:54,340
And if you are dealing with CFG, you will find that this particular block now has only

34
00:02:54,340 --> 00:02:55,600
one parent.

35
00:02:55,600 --> 00:02:59,360
So you will merge those two, now I will have this if x greater than 5, y equal to y minus

36
00:02:59,360 --> 00:03:01,000
3.

37
00:03:01,000 --> 00:03:03,280
And now comes something trickier.

38
00:03:03,280 --> 00:03:07,000
Now I have a while loop, while y is less than 100.

39
00:03:07,000 --> 00:03:14,680
Your constant propagation will tell you that y is, value of y can be either 2 or minus

40
00:03:14,680 --> 00:03:15,680
1.

41
00:03:16,120 --> 00:03:20,599
So constant propagation, normally we keep only one constant.

42
00:03:20,599 --> 00:03:26,200
But let us say you do something smart, we do not know what that smart thing is.

43
00:03:26,200 --> 00:03:33,120
Then you can say this condition is true for the first time, right?

44
00:03:33,120 --> 00:03:34,580
So we will come to that.

45
00:03:34,580 --> 00:03:40,520
So we have this while loop here, we will first convert it to a do while loop, right?

46
00:03:40,520 --> 00:03:47,280
Do while y is 100.

47
00:03:47,280 --> 00:03:51,920
And we know the condition is true for the first time, so we can, we do not need an if

48
00:03:51,920 --> 00:03:53,280
condition on the top.

49
00:03:53,280 --> 00:03:57,879
If we did not know, then we would be forced to keep a condition that looks like this.

50
00:03:57,879 --> 00:04:01,780
If y is less than 100, right?

51
00:04:01,780 --> 00:04:08,000
But in our case we know it, so we skip that.

52
00:04:08,000 --> 00:04:14,080
And now I have z equal to 4 and z equal to 5.

53
00:04:14,080 --> 00:04:18,279
This definition reaches nowhere.

54
00:04:18,279 --> 00:04:23,040
So this definition goes.

55
00:04:23,040 --> 00:04:26,519
Then I have z equal to 5, this is loop invariant.

56
00:04:26,519 --> 00:04:35,519
I will move it outside, right?

57
00:04:35,519 --> 00:04:44,959
And now I have z equal to 5 which reaches here.

58
00:04:44,959 --> 00:04:51,539
It is a constant.

59
00:04:51,539 --> 00:04:55,079
So I remove that and da-da.

60
00:04:55,079 --> 00:04:58,519
I have y equal to y minus 3, what is the value of y here?

61
00:04:58,519 --> 00:04:59,519
2.

62
00:04:59,519 --> 00:05:02,959
So 2 minus 3 is minus 1.

63
00:05:03,719 --> 00:05:14,239
This also goes and I can do couple of more things.

64
00:05:14,239 --> 00:05:24,319
So this kind of, right.

65
00:05:24,319 --> 00:05:27,759
So now if we look at this code, right?

66
00:05:27,759 --> 00:05:32,179
Using the techniques we have studied so far, this is what you can do.

67
00:05:32,180 --> 00:05:37,980
And some of you said look, I am smart.

68
00:05:37,980 --> 00:05:42,060
I can see that this is actually doing just a simple addition.

69
00:05:42,060 --> 00:05:43,060
Sum equal to sum.

70
00:05:43,060 --> 00:05:44,060
So what I am adding?

71
00:05:44,060 --> 00:05:52,899
y, y plus 1, y plus 2, y plus 3 up till 100 from some initial value of y, right?

72
00:05:52,899 --> 00:06:01,259
And then you applied your favorite mathematical formula and computed this whole part.

73
00:06:01,339 --> 00:06:03,740
If y equal to 2, what will be the answer?

74
00:06:03,740 --> 00:06:05,899
Else, what will be the answer?

75
00:06:05,899 --> 00:06:06,980
That can also be done, right?

76
00:06:06,980 --> 00:06:15,099
So some of you said look, I will replace the whole do-y loop and the print to something

77
00:06:15,099 --> 00:06:16,420
like this.

78
00:06:16,420 --> 00:06:34,379
If y equal to 2, sum equal to something else, sum equal to something else, right?

79
00:06:34,379 --> 00:06:43,740
Both are same, is it?

80
00:06:43,740 --> 00:06:44,740
You get the same answer?

81
00:06:44,740 --> 00:06:45,740
Yes.

82
00:06:46,060 --> 00:06:47,060
Really?

83
00:06:47,060 --> 00:06:51,939
Sir, if we plug in y and sum, then it is 2 to the power minus.

84
00:06:51,939 --> 00:06:55,300
So there is something interesting that many of you have missed.

85
00:06:55,300 --> 00:06:57,500
The initial value of sum is not given.

86
00:06:57,500 --> 00:06:58,500
Yes, sorry?

87
00:06:58,500 --> 00:06:59,500
Yes, so we do not know.

88
00:06:59,500 --> 00:07:02,500
Sum equal to sum constant value.

89
00:07:02,500 --> 00:07:05,500
Sum plus sum constant value, yes.

90
00:07:05,500 --> 00:07:06,500
Both are fixed.

91
00:07:06,500 --> 00:07:07,500
Both are the same.

92
00:07:07,500 --> 00:07:08,500
Same for y equal to 2 or minus 2.

93
00:07:08,500 --> 00:07:09,500
And they would not be same, but the formula is same.

94
00:07:09,500 --> 00:07:16,500
How can it be same?

95
00:07:16,500 --> 00:07:27,379
Sir, for y we are starting from 2, next step.

96
00:07:27,379 --> 00:07:30,779
See here, let us say y is minus 1.

97
00:07:31,779 --> 00:07:39,419
0, 1, they cancel out, 2 to 99 and the other way is 2 to 99, right?

98
00:07:39,419 --> 00:07:40,419
Good.

99
00:07:40,419 --> 00:07:46,419
So now the moral of the story is that either way you have only a single number, sum equal

100
00:07:46,419 --> 00:07:51,619
to sum plus sum constant.

101
00:07:51,619 --> 00:07:54,619
What is the, anyone bother to calculate it?

102
00:07:54,619 --> 00:07:55,619
Huh?

103
00:07:55,619 --> 00:07:56,619
4949.

104
00:07:56,619 --> 00:07:57,619
4949, is it?

105
00:07:58,459 --> 00:08:01,459
All of you are in the, I have not calculated it.

106
00:08:01,459 --> 00:08:04,459
If you say it, I will just take it.

107
00:08:04,459 --> 00:08:06,379
Okay, wow.

108
00:08:06,379 --> 00:08:12,300
So this whole thing is gone.

109
00:08:12,300 --> 00:08:21,860
The print sum will go and I will replace it with sum and now can we remove this as well?

110
00:08:21,860 --> 00:08:24,740
Okay, a couple of things I have.

111
00:08:24,740 --> 00:08:27,500
See here is z equal to 5, right?

112
00:08:27,500 --> 00:08:34,580
If this is my whole code, I can remove z equal to 5 and I can probably also remove, I can

113
00:08:34,580 --> 00:08:45,299
remove, I can remove y equal to minus, I can remove y equal to 2, I am not using it.

114
00:08:45,299 --> 00:08:51,179
This goes, wait slowly, one at a time.

115
00:08:51,179 --> 00:08:53,139
So, right?

116
00:08:53,779 --> 00:08:59,740
Okay, I have, if x greater than 5, nothing, right?

117
00:08:59,740 --> 00:09:01,980
Now can I eliminate this if condition?

118
00:09:01,980 --> 00:09:08,240
Because the condition has no side effects, I can eliminate that as well.

119
00:09:08,240 --> 00:09:17,019
So once I eliminate that, I do not need x plus plus.

120
00:09:17,019 --> 00:09:21,460
So please do not tell me in the morning all the code I wrote is only two lines of code.

121
00:09:21,460 --> 00:09:24,980
No, some plus equal to.

122
00:09:24,980 --> 00:09:35,980
No, fine, you, whether you keep it some plus here or here, that is right.

123
00:09:35,980 --> 00:09:42,540
So of these, the last optimization is something that not many compilers do, where we took

124
00:09:42,540 --> 00:09:44,420
the while loop and try to compute.

125
00:09:45,379 --> 00:09:52,219
to, if it is such a simple math, it can be done, but otherwise it is harder.

126
00:09:52,219 --> 00:09:56,579
The other thing which is hard is y's value is it minus 1 or 2, right?

127
00:09:56,579 --> 00:10:00,259
And then you merge both of them into a single, you say hey, both of them will have compute

128
00:10:00,259 --> 00:10:01,259
the same value.

129
00:10:01,259 --> 00:10:10,059
That is a bit of math and a compiler may not normally do.

130
00:10:10,699 --> 00:10:32,739
No, it is not always you can identify that.

131
00:10:32,739 --> 00:10:34,500
And then compute the closed form expression.

132
00:10:34,500 --> 00:10:37,099
That is what you guys did, right?

133
00:10:37,139 --> 00:10:41,860
You took the do while loop, you took the, computed the closed form expression.

134
00:10:41,860 --> 00:10:49,139
From that you said hey, I can actually reduce the closed form expression to a single number.

135
00:10:49,139 --> 00:10:56,139
That is what was that.

136
00:10:56,139 --> 00:11:06,940
I think researchers understand and the developers know about these techniques, but as I said,

137
00:11:07,780 --> 00:11:13,860
unless the pattern is something obviously simple, it is not easy to come up with closed

138
00:11:13,860 --> 00:11:15,860
form expressions in arbitrary code.

139
00:11:15,860 --> 00:11:25,220
You know, but I can have arbitrary code in between, right?

140
00:11:25,220 --> 00:11:26,220
That makes it hard.

141
00:11:26,220 --> 00:11:32,300
See, if the code is simple, it can be done and I am pretty sure we can find prior work

142
00:11:32,300 --> 00:11:33,300
on that.

143
00:11:33,659 --> 00:11:34,659
Okay.

144
00:11:34,659 --> 00:11:44,859
Yes, that can also be done.

145
00:11:44,859 --> 00:11:47,859
What is your name?

146
00:11:47,859 --> 00:11:56,539
Atharva is saying if all my, if I have a piece of code in which some variables, values are

147
00:11:56,539 --> 00:12:00,459
already there or some variables are assigned some constants and I am doing some evaluation

148
00:12:00,459 --> 00:12:01,459
on that.

149
00:12:01,620 --> 00:12:08,180
Why cannot the compiler partially evaluate that part and plug in that code?

150
00:12:08,180 --> 00:12:09,180
That also happens.

151
00:12:09,180 --> 00:12:11,379
Those who are interested read about partial evaluation.

152
00:12:11,379 --> 00:12:12,379
Okay.

153
00:12:12,379 --> 00:12:19,940
People do a lot of work on that.

154
00:12:19,940 --> 00:12:27,420
But anyway, moral of the story was the code that, the optimizations that we did yesterday

155
00:12:27,420 --> 00:12:29,860
can be very effective, right?

156
00:12:30,259 --> 00:12:36,259
I mean, do you see any link between this and this, right?

157
00:12:36,259 --> 00:12:43,259
And Ujwal, to be able to say that this and this are equivalent is pretty hard, right?

158
00:12:43,259 --> 00:12:46,259
We are talking something else in the morning.

159
00:12:46,259 --> 00:12:47,259
Okay.

160
00:12:47,259 --> 00:12:49,259
Any questions on this so far?

161
00:12:49,259 --> 00:12:50,259
Okay.

162
00:12:50,259 --> 00:12:51,259
Then, what I will do?

163
00:12:51,259 --> 00:12:56,259
I will close this and, okay.

164
00:12:56,659 --> 00:13:05,980
So, now we will start a new topic which is not actually new.

165
00:13:05,980 --> 00:13:13,620
I am told you have already been, I mean, the, Professor Shubhujit from Kanpur has already

166
00:13:13,620 --> 00:13:18,100
covered quite a bit of data flow analysis.

167
00:13:18,100 --> 00:13:26,300
I however need a few concepts to be on top of your mind or in your cache.

168
00:13:26,300 --> 00:13:27,620
So, what I have done?

169
00:13:27,620 --> 00:13:34,379
I put in some introductory material which we will call as recap, okay, which will go

170
00:13:34,379 --> 00:13:40,740
over quickly then before we go into our material, okay.

171
00:13:40,740 --> 00:13:43,820
We want to do some optimization.

172
00:13:43,820 --> 00:13:52,180
These optimizations need to understand how the data is flowing in the program and we

173
00:13:52,180 --> 00:13:58,379
want to do data flow analysis to do this, to understand about the program.

174
00:13:58,379 --> 00:14:07,940
So, data flow analysis we do so that we can provide information about how a program manipulates

175
00:14:07,940 --> 00:14:10,140
the data in the program, okay.

176
00:14:10,460 --> 00:14:16,980
So, it basically studies the behavior of the function.

177
00:14:16,980 --> 00:14:21,980
You can use the data flow analysis to build the control flow information.

178
00:14:21,980 --> 00:14:31,419
If you find that y is always 2, then you could say, hey, because y is always 2, the y greater

179
00:14:31,419 --> 00:14:34,139
than 3, that condition is false.

180
00:14:35,139 --> 00:14:44,259
So, your data flow information can help refine and build control flow information, okay.

181
00:14:44,259 --> 00:14:46,659
You can use data flow analysis to understand the program.

182
00:14:46,659 --> 00:14:51,860
For instance, you can use it to say, hey, here is a piece of code that sorts an array,

183
00:14:51,860 --> 00:14:54,779
ascending order, right.

184
00:14:54,779 --> 00:15:00,100
It is pretty involved but can be done in theory, right.

185
00:15:01,060 --> 00:15:04,139
You can use data flow analysis to generate the model of the original program and verify

186
00:15:04,139 --> 00:15:12,019
that the model is correct, okay.

187
00:15:12,019 --> 00:15:16,860
The key point about data flow analysis as you guys know is that it should give information

188
00:15:16,860 --> 00:15:24,879
that the program does not misrepresent what the procedure does.

189
00:15:24,879 --> 00:15:33,799
When it says it may do something, that means the rest of it is not possible.

190
00:15:33,799 --> 00:15:36,159
The opposite of may is must not, right.

191
00:15:36,159 --> 00:15:41,000
So, the data flow analysis says that something is impossible, that should be the case that

192
00:15:41,000 --> 00:15:44,200
it is never possible, okay.

193
00:15:44,200 --> 00:15:48,320
Data flow analysis is also done for program validation to validate that the program does

194
00:15:48,320 --> 00:15:49,960
what it says, okay.

195
00:15:50,040 --> 00:15:59,519
There are different types of analysis, intra-procedural and inter-procedural analysis.

196
00:15:59,519 --> 00:16:07,280
We will study, we will start with intra-procedural analysis, then we will touch upon inter-procedural

197
00:16:07,280 --> 00:16:14,320
analysis, okay.

198
00:16:14,320 --> 00:16:18,840
You have already seen iterative data flow analysis where you build a collection of data

199
00:16:18,840 --> 00:16:22,480
flow equations, right.

200
00:16:22,480 --> 00:16:25,399
So, what is a data flow equation?

201
00:16:25,399 --> 00:16:33,320
It tells which data may flow into which variable or which expression or different program abstractions

202
00:16:33,320 --> 00:16:38,360
and once you have these equations, they are solved iteratively.

203
00:16:38,360 --> 00:16:43,879
What we do is we invariably start from a conservative set of initial values and continuously improve

204
00:16:43,879 --> 00:16:44,879
the precision.

205
00:16:44,919 --> 00:16:52,799
The dominator computation yesterday, for instance, was one such example where we initially said

206
00:16:52,799 --> 00:16:57,759
for each variable, the dominators are the set of the all, sorry, for each statement,

207
00:16:57,759 --> 00:17:05,759
set of dominators are all the statements and kept on refining them, right, okay.

208
00:17:05,759 --> 00:17:11,359
So one disadvantage of such a scheme is that initially we may be handling too large a data.

209
00:17:11,839 --> 00:17:15,599
So what sometimes people do, they start from an aggressive set of initial values, very

210
00:17:15,599 --> 00:17:20,359
small, kind of which is very aggressive and then continuously improve the precision, kind

211
00:17:20,359 --> 00:17:25,159
of improve the precision, kind of I will make it bigger, bigger, bigger.

212
00:17:25,159 --> 00:17:29,799
So both are possible depending on the program, problem you are solving you can choose.

213
00:17:29,799 --> 00:17:33,319
So the advantage is the data sets are small to start with.

214
00:17:33,319 --> 00:17:36,919
The choice mostly depends on the problem at hand, okay.

215
00:17:37,480 --> 00:17:42,240
For instance, by the way, you remember the reaching definition example, right.

216
00:17:42,240 --> 00:17:53,240
So in this code, can you tell does the definition of I at line 4 reach the users in 7 and 8?

217
00:17:53,240 --> 00:17:57,440
Does it reach yes or no?

218
00:17:57,440 --> 00:17:59,880
Yes it may reach.

219
00:17:59,880 --> 00:18:03,440
But if I say, must it reach?

220
00:18:03,440 --> 00:18:06,480
I do not know, right.

221
00:18:07,039 --> 00:18:10,680
But reaching definitions, when we say mostly we talk about may and may information.

222
00:18:10,680 --> 00:18:20,839
So using may information we say that this I in both the statements it reaches, right.

223
00:18:20,839 --> 00:18:31,120
And what about does the value of J at line 7 is computed here?

224
00:18:31,120 --> 00:18:32,440
Does it reach the line 10?

225
00:18:32,440 --> 00:18:35,640
Does it reach the use in line 10?

226
00:18:35,800 --> 00:18:47,440
Does the value, does the definition J gets here at line 7, does it reach?

227
00:18:47,440 --> 00:18:50,600
It may reach.

228
00:18:50,600 --> 00:18:52,600
Why it may not reach?

229
00:18:52,600 --> 00:18:53,600
Sorry?

230
00:18:54,559 --> 00:19:09,439
If n is negative, if n is negative, you are saying this may not even execute.

231
00:19:09,439 --> 00:19:11,719
Then some other definition may reach.

232
00:19:11,719 --> 00:19:14,439
Am I asking is this the only definition that may reach?

233
00:19:14,439 --> 00:19:15,439
No.

234
00:19:15,439 --> 00:19:22,119
I am saying, is it guaranteed that this definition will reach?

235
00:19:22,639 --> 00:19:25,639
No, why not?

236
00:19:25,639 --> 00:19:26,639
Correct.

237
00:19:26,639 --> 00:19:29,639
Okay, so?

238
00:19:29,639 --> 00:19:41,639
So, will the definition of this J, whatever the I that may get, I may change or not I

239
00:19:41,639 --> 00:19:43,279
do not know at this time.

240
00:19:43,279 --> 00:19:47,559
I am getting there is some definition here.

241
00:19:47,559 --> 00:19:48,559
Will it reach here?

242
00:19:48,559 --> 00:19:50,719
Is it guaranteed to reach that point?

243
00:19:51,319 --> 00:19:54,720
Assuming the while loop is, I enter the while loop.

244
00:19:54,720 --> 00:20:02,200
Still no guarantee, why not?

245
00:20:02,200 --> 00:20:05,759
What happens in the G function?

246
00:20:05,759 --> 00:20:08,880
So what may happen?

247
00:20:08,880 --> 00:20:10,880
It can be infinite loop, right?

248
00:20:10,880 --> 00:20:13,319
If it is an infinite loop, it may not reach.

249
00:20:13,319 --> 00:20:19,360
So, yeah, so there can be, you can even terminate in G.

250
00:20:19,359 --> 00:20:24,039
And if you want to be paranoid like that, you can even have an exception inside that,

251
00:20:24,039 --> 00:20:26,439
which will jump out, right?

252
00:20:26,439 --> 00:20:31,679
So what we are saying, it may reach, right?

253
00:20:31,679 --> 00:20:33,079
Make sense?

254
00:20:33,079 --> 00:20:37,759
Anyone who still does not see that this J, there is a chance that this, after you execute

255
00:20:37,759 --> 00:20:43,799
this J, I may not get this definition here, because the loop may not terminate.

256
00:20:44,240 --> 00:20:51,559
So most of the time, when we do such analysis, we assume that all loops terminate, all branches

257
00:20:51,559 --> 00:20:56,399
are taken, we are, when you say it is precise, it is module of those things.

258
00:20:56,399 --> 00:20:57,399
Okay.

259
00:20:57,399 --> 00:21:00,399
So you have already done reaching definition.

260
00:21:00,399 --> 00:21:01,399
Good.

261
00:21:01,399 --> 00:21:08,879
So data flow equations behavior, so when we specify data flow equations, so for example,

262
00:21:08,960 --> 00:21:15,960
in the previous line, we kind of say, here is a definition, here is a definition, this

263
00:21:15,960 --> 00:21:25,480
definition is created in this block, and the definition is flowing through me, right?

264
00:21:25,480 --> 00:21:30,600
So before the block, what definitions were reaching?

265
00:21:30,600 --> 00:21:35,460
After the block, what definitions are carried forward, right?

266
00:21:35,460 --> 00:21:43,140
So we call these equations as transfer equations or transfer equations or flow equations, right?

267
00:21:43,140 --> 00:21:50,660
So in the forward analysis, you know that given for a block S, how do I compute the

268
00:21:50,660 --> 00:21:51,660
out?

269
00:21:51,660 --> 00:21:59,259
The out depends on its ins and what is happening inside, right?

270
00:21:59,259 --> 00:22:06,879
So if I see whatever is happening inside is, I know is a constant, then it is a function

271
00:22:06,879 --> 00:22:18,500
of ins, and this F encapsulates whatever is happening in the block.

272
00:22:18,500 --> 00:22:33,900
In backward analysis, I compute my in based on outs of my outs, right?

273
00:22:33,900 --> 00:22:45,380
And the rules have an interesting property that they change the values only in one direction,

274
00:22:45,380 --> 00:22:52,820
something like if I initially have all zeros, then from zeros it will only go to ones, it

275
00:22:52,820 --> 00:22:57,700
will never go from one to zero, right?

276
00:22:57,700 --> 00:23:02,080
So basically what we are saying, the information is going only in one progressing one direction,

277
00:23:02,080 --> 00:23:09,460
we call it kind of intuitively that is what and we call it as monotone, what is a monotone,

278
00:23:09,460 --> 00:23:11,500
we have been informed, right?

279
00:23:11,619 --> 00:23:19,619
So this ensures that iterations, the process will terminate.

280
00:23:19,619 --> 00:23:22,940
By the way, you studied about reaching definitions, right?

281
00:23:22,940 --> 00:23:33,299
What is the use of reaching definition?

282
00:23:33,299 --> 00:23:44,659
We can remove dead code, right?

283
00:23:44,659 --> 00:23:55,259
We can remove dead code, what else can we do?

284
00:23:55,259 --> 00:23:56,259
You can do many things.

285
00:23:56,420 --> 00:24:04,740
Can you use reaching definitions to find errors in the program?

286
00:24:04,740 --> 00:24:05,740
Such as?

287
00:24:05,740 --> 00:24:20,220
If there is no definition is reaching a use, then Java will say uninitialized variable,

288
00:24:20,220 --> 00:24:23,220
right?

289
00:24:24,180 --> 00:24:33,259
And because of what you have studied in the properties of lattices and fixed points, we

290
00:24:33,259 --> 00:24:39,819
know that this iterative solution will produce an acceptable solution, right?

291
00:24:39,819 --> 00:24:46,019
And brief summarization of the monotones, we say a function is a monotone if x is less

292
00:24:46,019 --> 00:24:52,700
than y, then fx is less than fy.

293
00:24:52,700 --> 00:24:57,700
And the flow function has to model the effect of the programming language, I mean what the

294
00:24:57,700 --> 00:25:03,379
statement does.

295
00:25:03,379 --> 00:25:08,660
And we want the flow functions to be monotones because we want the process to terminate,

296
00:25:08,660 --> 00:25:10,660
good.

297
00:25:11,300 --> 00:25:21,420
And we say for a function f, it has reached a fixed point if f of z is equal to z, okay?

298
00:25:21,420 --> 00:25:26,100
So that is a fixed point of a function.

299
00:25:26,100 --> 00:25:31,860
And in our case, when we have a series of data flow equations, we compute the fixed

300
00:25:31,860 --> 00:25:34,460
point and we call it the solution, right?

301
00:25:34,460 --> 00:25:40,220
That means we cannot define it any further, okay, good.

302
00:25:40,779 --> 00:25:47,779
And our goal is to compute data flow equations by doing the meet over all paths.

303
00:25:47,779 --> 00:25:49,779
This is covered, right?

304
00:25:49,779 --> 00:25:51,779
MOP solutions, good.

305
00:25:51,779 --> 00:25:57,180
So we start with some prescribed information at the entry or sometimes exit and then keep

306
00:25:57,180 --> 00:26:01,819
on doing either forward or backward analysis.

307
00:26:01,819 --> 00:26:09,819
And we repeatedly apply this till we reach a fixed point, okay.

308
00:26:09,819 --> 00:26:18,819
This is the kind of a skeleton of a forward analysis, okay?

309
00:26:18,819 --> 00:26:25,579
So let us, maybe you have been shown a similar algorithm using different thing.

310
00:26:25,579 --> 00:26:29,619
We will go over it and derive constant propagation from this, okay?

311
00:26:29,619 --> 00:26:36,779
So let us pay attention here.

312
00:26:36,779 --> 00:26:44,420
So we have a set of nodes where for our convenience, we can assume every statement is a different

313
00:26:44,420 --> 00:26:46,779
node.

314
00:26:46,779 --> 00:26:48,980
And statement, do not keep very complicated statements.

315
00:26:48,980 --> 00:26:52,259
We will keep every statement as, let us say our three address code statements, simple

316
00:26:52,259 --> 00:26:55,059
statements, okay?

317
00:26:55,059 --> 00:27:02,259
We have a set of nodes, entry node, okay?

318
00:27:02,740 --> 00:27:10,940
And the transfer, the flow function for each of these things, which is like it takes a

319
00:27:10,940 --> 00:27:19,740
node and it takes some input and gives you some other output.

320
00:27:19,740 --> 00:27:25,220
L is my lattice, lattice of values.

321
00:27:26,180 --> 00:27:33,819
And so let us see what we do.

322
00:27:33,819 --> 00:27:37,940
Initially for each block, so I have a work list.

323
00:27:37,940 --> 00:27:45,019
I want to process all the blocks in my input.

324
00:27:45,019 --> 00:27:50,299
So I have a work list where I initialize it to N minus entry.

325
00:27:50,379 --> 00:27:52,859
So I initialize the entry, I initialize that.

326
00:27:52,859 --> 00:28:01,220
And I initialize the in of entry to be some unit value, okay?

327
00:28:01,220 --> 00:28:08,299
And I initialize the in of every other basic block as some top value, top value in my lattice,

328
00:28:08,299 --> 00:28:10,819
okay?

329
00:28:10,819 --> 00:28:12,379
Then what I do?

330
00:28:12,379 --> 00:28:15,500
I take one element from the work list.

331
00:28:15,500 --> 00:28:17,139
Which element doesn't matter?

332
00:28:17,140 --> 00:28:26,660
I pick one element from the work list and then what I do for that element, for that

333
00:28:26,660 --> 00:28:31,860
element, I look at all its predecessors.

334
00:28:31,860 --> 00:28:36,300
From the predecessors, what am I getting?

335
00:28:36,300 --> 00:28:40,620
My predecessors out is my in, right?

336
00:28:41,099 --> 00:28:50,979
So what I will do, I want the out of that predecessor.

337
00:28:50,979 --> 00:28:54,299
How do I get the out of that predecessor?

338
00:28:54,299 --> 00:29:03,099
See I have a block like this.

339
00:29:03,099 --> 00:29:13,339
I want to take a meet of the out of this and out of this, right?

340
00:29:13,339 --> 00:29:19,059
This out and this out, I want to take a meet of, correct?

341
00:29:19,059 --> 00:29:23,899
And this out I can compute.

342
00:29:23,899 --> 00:29:31,879
If I know this in, then I can take the in if I call this as P, right?

343
00:29:31,880 --> 00:29:47,920
So whatever is the in of that P, I can use the transfer function of this guy and take

344
00:29:47,920 --> 00:29:51,960
the input and compute the out.

345
00:29:51,960 --> 00:30:01,200
Similarly, I can take this guy's transfer function, compute this guy.

346
00:30:01,200 --> 00:30:12,200
So now once I have these two, I can take a meet of these two to give me the in for this

347
00:30:12,200 --> 00:30:17,559
block B. That's what I am doing here.

348
00:30:17,559 --> 00:30:26,840
So I am taking a meet of all my predecessors outs and computing my in.

349
00:30:27,079 --> 00:30:37,919
Then I will check if my in is different from what was there before.

350
00:30:37,919 --> 00:30:45,519
If it is different, then I am setting my in as the new value and then what I am saying,

351
00:30:45,519 --> 00:30:47,399
hey, something has changed.

352
00:30:47,399 --> 00:30:48,559
I have two options.

353
00:30:48,559 --> 00:30:54,759
Like in the previous case, I will say reanalyze the whole world or say don't reanalyze the

354
00:30:54,759 --> 00:31:02,400
whole world but analyze only what may get affected because of me.

355
00:31:02,400 --> 00:31:06,519
What may get affected because of my in?

356
00:31:06,519 --> 00:31:09,079
Only my successors, not others.

357
00:31:09,079 --> 00:31:16,480
So what I will do, if the value is, if my in has changed, then I will set my in to the

358
00:31:16,480 --> 00:31:23,000
new value and add to the work list all my successors.

359
00:31:23,960 --> 00:31:30,599
All are on the same page.

360
00:31:30,599 --> 00:31:42,079
And then we keep on repeating till the work list is empty.

361
00:31:42,079 --> 00:31:47,960
And do we have a conviction that this loop will terminate?

362
00:31:47,960 --> 00:31:48,960
Why?

363
00:31:49,000 --> 00:31:54,079
And now I am adding to the work list.

364
00:31:54,079 --> 00:31:56,720
I may randomly add to the work list, right?

365
00:31:56,720 --> 00:32:02,840
What is the guarantee that I will terminate?

366
00:32:02,840 --> 00:32:03,840
Anyone?

367
00:32:03,840 --> 00:32:13,440
Yes, I am removing one element at a time to the work list and then adding, in the worst

368
00:32:13,440 --> 00:32:14,440
case, all my successors.

369
00:32:14,440 --> 00:32:17,799
There may be a loop.

370
00:32:17,799 --> 00:32:21,359
So I keep on adding my successors.

371
00:32:21,359 --> 00:32:23,759
So may be, will I be in an infinite loop?

372
00:32:23,759 --> 00:32:24,759
Right?

373
00:32:24,759 --> 00:32:27,119
So what I am doing, I am adding my successors.

374
00:32:27,119 --> 00:32:31,319
If I am in a loop, you add me, I add you.

375
00:32:31,319 --> 00:32:32,319
Why?

376
00:32:32,319 --> 00:32:38,119
I mean, it is a set, work list is a set.

377
00:32:38,119 --> 00:32:41,680
Yes, so there are no repeated elements.

378
00:32:41,680 --> 00:32:42,680
That is right.

379
00:32:43,560 --> 00:32:51,039
So I have added all my successors.

380
00:32:51,039 --> 00:32:52,039
Let us say I have only one successor.

381
00:32:52,039 --> 00:32:53,039
That is you.

382
00:32:53,039 --> 00:32:57,960
And we are in a loop and so you will add your successors.

383
00:32:57,960 --> 00:32:58,960
That is me.

384
00:32:58,960 --> 00:32:59,960
So you add me, I add you.

385
00:32:59,960 --> 00:33:02,960
Then there is a change.

386
00:33:02,960 --> 00:33:03,960
Okay, good.

387
00:33:03,960 --> 00:33:08,960
That is the key point.

388
00:33:08,960 --> 00:33:13,960
I am adding only when there is a change.

389
00:33:13,960 --> 00:33:14,960
Okay.

390
00:33:14,960 --> 00:33:23,960
Why do you say so?

391
00:33:23,960 --> 00:33:29,120
So Rishabh is saying after certain time, there will not be any change.

392
00:33:29,120 --> 00:33:30,120
What gives you that confidence?

393
00:33:30,120 --> 00:33:31,120
Right.

394
00:33:31,120 --> 00:33:32,120
So you are right.

395
00:33:32,119 --> 00:33:41,279
So you are doing a meet.

396
00:33:41,279 --> 00:33:46,519
So in a lattice, if you keep doing meet, you will finally reach the bottom.

397
00:33:46,519 --> 00:33:49,799
Once you reach the bottom, there will not be any more change.

398
00:33:49,799 --> 00:33:50,799
It is a lattice.

399
00:33:50,799 --> 00:33:52,159
We do not know what the elements are.

400
00:33:52,159 --> 00:33:53,959
Null set, empty set, we do not know.

401
00:33:53,959 --> 00:33:56,279
We are talking in terms of a lattice.

402
00:33:56,279 --> 00:33:58,679
I initialize to top.

403
00:33:58,679 --> 00:34:00,559
I keep taking meet, keep taking meet.

404
00:34:01,440 --> 00:34:07,599
Either there is no change or I mean there is no, finally I have to stop somewhere because

405
00:34:07,599 --> 00:34:10,119
the lattice height is finite.

406
00:34:10,119 --> 00:34:15,840
So if I keep on taking meet, finally I will terminate.

407
00:34:15,840 --> 00:34:17,840
Right.

408
00:34:17,840 --> 00:34:24,639
Yes, no, no, no.

409
00:34:24,639 --> 00:34:25,639
What is bothering?

410
00:34:25,719 --> 00:34:34,319
Okay, okay.

411
00:34:34,319 --> 00:34:37,319
Anyone still bothering?

412
00:34:37,319 --> 00:34:40,319
Okay.

413
00:34:40,319 --> 00:34:45,879
Yes, we are definitely assuming there have to be monotonic.

414
00:34:46,119 --> 00:34:56,920
If it is not monotonic, then we are not sure.

415
00:34:56,920 --> 00:35:02,320
So F is monotonic and it is working on a lattice.

416
00:35:02,320 --> 00:35:05,320
That gives us, okay.

417
00:35:05,320 --> 00:35:06,320
Fine.

418
00:35:06,760 --> 00:35:17,240
We will use this iterative data flow analysis to derive an algorithm to do constant propagation.

419
00:35:17,240 --> 00:35:19,320
Okay.

420
00:35:19,320 --> 00:35:26,080
We already have seen how we are using the constant propagation.

421
00:35:26,080 --> 00:35:28,640
So what is the idea of constant propagation?

422
00:35:28,960 --> 00:35:35,119
So we will take whatever values that are constants on all possible executions, on all possible

423
00:35:35,119 --> 00:35:41,799
executions and then we will propagate those.

424
00:35:41,799 --> 00:35:45,599
If I have an expression which is guaranteed, variable which is guaranteed to be constant

425
00:35:45,599 --> 00:35:56,199
in all possible executions, then I will replace those occurrences of the variable with a constant,

426
00:35:56,199 --> 00:35:58,000
right.

427
00:35:58,360 --> 00:36:08,000
I will replace it in all, as far as I can push, okay.

428
00:36:08,000 --> 00:36:09,000
But this is conservative.

429
00:36:09,000 --> 00:36:12,039
It can discover only a subset of all possible constants.

430
00:36:12,039 --> 00:36:16,119
We cannot discover all possible constants, right.

431
00:36:16,119 --> 00:36:26,840
Why do I say I cannot discover all possible constants?

432
00:36:26,840 --> 00:36:30,760
Why do I say I cannot discover all possible constants?

433
00:36:30,760 --> 00:36:35,240
Example, what is the example?

434
00:36:35,240 --> 00:36:37,240
Okay.

435
00:36:37,240 --> 00:36:39,240
Yeah.

436
00:37:09,639 --> 00:37:12,239
See what you are seeing is the ordering.

437
00:37:12,239 --> 00:37:15,799
What if I do the other way around?

438
00:37:15,799 --> 00:37:21,119
See I mean what if I will first do the other optimization then do constant propagation.

439
00:37:21,119 --> 00:37:22,119
But here is an example, right.

440
00:37:22,119 --> 00:37:24,519
I mean very simple example.

441
00:37:24,519 --> 00:37:43,000
If i is greater than 10, x equal to 3, else x equal to 5, right.

442
00:37:43,000 --> 00:37:46,320
This code was written long back.

443
00:37:46,320 --> 00:37:54,280
So if you do not like 2018 and make it 2000, you will recollect the y2k problem.

444
00:37:55,040 --> 00:37:56,040
Right.

445
00:37:56,040 --> 00:37:59,280
If it is greater than 2000, do something else, do something else.

446
00:37:59,280 --> 00:38:06,440
If you look at this code and want to optimize now, the code is still there but now you know

447
00:38:06,440 --> 00:38:12,680
that this year is always going to be greater than 2000.

448
00:38:12,680 --> 00:38:20,200
But the compiler would not know and cannot say that this is a constant.

449
00:38:20,200 --> 00:38:21,200
It is a constant.

450
00:38:22,119 --> 00:38:25,199
So the programmer knows, programmer with his intelligence or her intelligence now know

451
00:38:25,199 --> 00:38:28,559
that it is a constant.

452
00:38:28,559 --> 00:38:30,079
But we cannot detect all the constants.

453
00:38:30,079 --> 00:38:35,559
Similarly, there may be a loop that the programmer knows that it will be executed or it will

454
00:38:35,559 --> 00:38:38,759
never be executed.

455
00:38:38,759 --> 00:38:41,439
But compiler cannot figure out some of those.

456
00:38:41,439 --> 00:38:47,079
So we are, we discover only a subset of the constants.

457
00:38:47,960 --> 00:38:54,000
And a constant lattice, constant propagation lattice is this lattice where you have all

458
00:38:54,000 --> 00:39:02,599
the constant literals in the middle and you have top on the top and meet of any one of

459
00:39:02,599 --> 00:39:05,599
them is bottom.

460
00:39:05,599 --> 00:39:06,599
Right.

461
00:39:07,119 --> 00:39:17,480
So what is the, what do these values top and bottom mean?

462
00:39:17,480 --> 00:39:21,799
For us, bottom means constant value cannot be guaranteed.

463
00:39:21,799 --> 00:39:23,880
Right.

464
00:39:23,880 --> 00:39:29,460
So if a value of Xi compute to be a bottom, it means it is not a constant.

465
00:39:29,460 --> 00:39:33,519
If it is top, it means it may be a constant but not yet determined.

466
00:39:34,440 --> 00:39:37,440
So these are the initial values.

467
00:39:37,440 --> 00:39:47,840
And for all X, X meet top is X and X meet bottom is bottom.

468
00:39:47,840 --> 00:40:01,039
And if it is two constants, I am doing C1 meet C1 is C1 and C1 meet C2 is bottom.

469
00:40:01,559 --> 00:40:08,759
Does that make sense?

470
00:40:08,759 --> 00:40:17,960
And so we will be using a pair of techniques from a pretty old paper and this technique

471
00:40:17,960 --> 00:40:23,000
is called the Kildall's algorithm.

472
00:40:23,000 --> 00:40:30,800
And if you are interested, you can also look at the refluis paper of the old time.

473
00:40:31,560 --> 00:40:33,800
So we are talking about simple constants.

474
00:40:33,800 --> 00:40:38,480
So we are talking about constant that can be proved to be constant provided you do not

475
00:40:38,480 --> 00:40:40,519
assume which way the branch is taken.

476
00:40:40,519 --> 00:40:49,280
You will assume that both branches are taken and only one value is maintained per variable

477
00:40:49,280 --> 00:40:50,760
along each path.

478
00:40:50,760 --> 00:40:54,480
So I cannot say X is either minus 1 or 2.

479
00:40:54,480 --> 00:40:58,240
In the previous loop, we said no, no, Y will be minus 1 or 2.

480
00:40:58,240 --> 00:40:59,240
No.

481
00:40:59,679 --> 00:41:06,919
So here we are talking about simple constants where, do you want to watch?

482
00:41:06,919 --> 00:41:09,000
Go ahead.

483
00:41:09,000 --> 00:41:11,919
We will maintain only one value.

484
00:41:11,919 --> 00:41:16,119
We will not maintain multiple values, simple constants.

485
00:41:16,119 --> 00:41:21,000
The Kildall's algorithm starts with an entry node.

486
00:41:21,000 --> 00:41:23,759
The processing starts with an entry node.

487
00:41:24,280 --> 00:41:29,440
We will process each node and produce a constant information.

488
00:41:29,440 --> 00:41:35,720
That is, I will process a statement and say I had a set of constants.

489
00:41:35,720 --> 00:41:41,520
Now I have another set of constants.

490
00:41:41,520 --> 00:41:45,760
And we will pass this information to all its successors.

491
00:41:45,760 --> 00:41:49,800
And at a merge point, let us say I have a set of constants coming from left side, another

492
00:41:49,800 --> 00:41:51,500
set coming from right side.

493
00:41:51,500 --> 00:41:53,980
And what will I do?

494
00:41:53,980 --> 00:42:01,019
I will take a pairwise meet.

495
00:42:01,019 --> 00:42:12,340
And when I am processing a node, if its constant value has changed, but the constants it carries

496
00:42:12,340 --> 00:42:17,380
has changed, then I will say my constants have changed.

497
00:42:17,380 --> 00:42:28,140
New successors, make sure you are added to the work list.

498
00:42:28,140 --> 00:42:33,420
For simplicity, we will assume we have one basic block per statement.

499
00:42:33,420 --> 00:42:38,420
And for each statement, we will have a transfer function.

500
00:42:38,420 --> 00:42:41,380
We will see what the transfer function will look like.

501
00:42:41,380 --> 00:42:46,539
The important thing is the data set of dataflow values.

502
00:42:46,699 --> 00:42:47,699
What am I tracking?

503
00:42:47,699 --> 00:42:52,539
I want to know whether a variable is a constant or not.

504
00:42:52,539 --> 00:42:54,019
Correct?

505
00:42:54,019 --> 00:43:11,219
So for each block, I will track for each variable v1, v2 up to vn, I will track whether it is

506
00:43:11,219 --> 00:43:16,460
a what is its constant value or rather what is its value.

507
00:43:17,380 --> 00:43:21,460
What value can a variable take?

508
00:43:21,460 --> 00:43:25,980
Either one of the constant literals, top or bottom.

509
00:43:25,980 --> 00:43:35,300
A variable may contain only these three types of values, either a constant literal, top

510
00:43:35,300 --> 00:43:39,220
or bottom.

511
00:43:39,980 --> 00:43:49,859
Now, if I call it as this map as m that takes a variable v and gives me its value, then

512
00:43:49,859 --> 00:43:57,859
each variable, each statement when I process it, it takes one m as input and gives me an

513
00:43:57,859 --> 00:44:00,619
m prime as output.

514
00:44:00,619 --> 00:44:07,859
That is, it has, it takes as input a set of values for variables and gives out another

515
00:44:07,860 --> 00:44:14,500
set of values for the variables.

516
00:44:14,500 --> 00:44:16,980
So now let us look at how the functions look like.

517
00:44:16,980 --> 00:44:24,260
Again, as we said, we will start with an entry node.

518
00:44:24,260 --> 00:44:37,140
Which statements in the program can change my variable to value map m?

519
00:44:37,139 --> 00:44:40,900
Only assignment statements, nothing else, right?

520
00:44:40,900 --> 00:44:45,059
Jumps do not change nothing, right?

521
00:44:45,059 --> 00:44:46,059
Only assignment statements.

522
00:44:46,059 --> 00:44:53,259
So now let us understand how does it, how do these things change for assignment statements?

523
00:44:53,259 --> 00:44:54,259
Okay.

524
00:44:54,260 --> 00:45:09,940
Let us say I have a statement S and I want to compute the flow function Fs, right?

525
00:45:09,940 --> 00:45:12,300
And we say it is an assignment statement.

526
00:45:12,300 --> 00:45:16,900
So what is the structure of an assignment statement?

527
00:45:17,900 --> 00:45:21,860
It can be, sorry, S can be of one of the following, right?

528
00:45:21,860 --> 00:45:29,539
S can be a copy, right?

529
00:45:29,539 --> 00:45:35,980
Or what expressions I can have?

530
00:45:35,980 --> 00:45:38,780
Either a unary expression or a binary expression.

531
00:45:38,780 --> 00:45:39,780
That is it.

532
00:45:39,780 --> 00:45:43,380
My three address code does not have anything more than that.

533
00:45:43,380 --> 00:45:58,500
So x equal to y of z or x equal to of y, right?

534
00:45:58,500 --> 00:46:08,099
Now if this is my statement, so my flow function of Fs takes some m as an argument.

535
00:46:08,099 --> 00:46:09,099
What is m?

536
00:46:09,819 --> 00:46:14,380
m is the mapping flow of variables to values.

537
00:46:14,380 --> 00:46:25,860
In the out for S, which variables value may change?

538
00:46:25,860 --> 00:46:29,739
My statement is of the form x equal to blah.

539
00:46:29,739 --> 00:46:32,980
Which variables value may change?

540
00:46:32,980 --> 00:46:33,980
X.

541
00:46:33,980 --> 00:46:38,980
For rest of the variables, the value will not change.

542
00:46:39,860 --> 00:46:40,860
Does that make sense?

543
00:46:40,860 --> 00:46:41,860
Okay.

544
00:46:41,860 --> 00:46:48,860
So, for the Fs of m, right, how do I define this function?

545
00:46:48,860 --> 00:47:00,539
It returns an m prime such that m prime of a variable v is equal to mv, the old, this

546
00:47:00,539 --> 00:47:07,260
mv, if v is not equal to x, right?

547
00:47:07,260 --> 00:47:14,940
If v is not equal to x, if v is not equal to x, then m prime v is same as mv.

548
00:47:14,940 --> 00:47:23,220
If I write, if I let me, okay, here it is, I am writing v there, so I will just change

549
00:47:23,220 --> 00:47:28,460
it to v so that we talk about the same thing.

550
00:47:28,460 --> 00:47:30,740
Okay?

551
00:47:31,219 --> 00:47:44,099
So, this is v, m prime of v prime is equal to m of v prime if v is not equal to v prime.

552
00:47:44,099 --> 00:47:45,099
Okay?

553
00:47:45,099 --> 00:47:52,419
So, if you are not, if you are writing to v, then the map of all other variables, there

554
00:47:52,419 --> 00:47:55,099
is no change.

555
00:47:55,099 --> 00:47:57,539
If v prime is equal to v, right?

556
00:47:58,059 --> 00:48:04,579
So what will happen to m prime of v?

557
00:48:04,579 --> 00:48:05,820
What will happen to m prime of v?

558
00:48:05,820 --> 00:48:10,579
Let us compute.

559
00:48:10,579 --> 00:48:13,539
What will happen to m prime of v?

560
00:48:13,539 --> 00:48:16,539
There are three conditions.

561
00:48:16,539 --> 00:48:28,059
If v is equal to y is the statement you are processing, what will be m prime of v?

562
00:48:28,059 --> 00:48:29,300
Perfect.

563
00:48:29,300 --> 00:48:37,860
m prime of v is equal to m of y.

564
00:48:37,860 --> 00:48:40,380
What were it was?

565
00:48:40,380 --> 00:48:41,380
Right?

566
00:48:41,380 --> 00:48:42,380
Fine?

567
00:48:42,380 --> 00:48:43,380
Okay.

568
00:48:44,059 --> 00:48:47,780
If it is y of z, then what?

569
00:48:47,780 --> 00:48:50,340
What can this of be?

570
00:48:50,340 --> 00:48:54,820
Plus minus star, something like that, right?

571
00:48:54,820 --> 00:48:55,820
Okay?

572
00:48:55,820 --> 00:48:59,619
So, v equal to y of z, then what?

573
00:48:59,619 --> 00:49:00,619
Right.

574
00:49:00,619 --> 00:49:09,460
So, you are saying m prime of v equal to m of y of m of z.

575
00:49:09,460 --> 00:49:17,460
So, let us say m of y was 2 and m of z was 3, then you will say, and this is, op is plus,

576
00:49:17,460 --> 00:49:20,699
then you will do 2 plus 3 and mark it as 5.

577
00:49:20,699 --> 00:49:23,019
But what if this is 2 and this is bottom?

578
00:49:23,019 --> 00:49:26,460
If what does it mean?

579
00:49:26,460 --> 00:49:30,260
One of them is not a constant, the other one is a constant.

580
00:49:30,260 --> 00:49:31,260
Then what?

581
00:49:31,260 --> 00:49:32,260
Then?

582
00:49:32,260 --> 00:49:33,260
Not a constant.

583
00:49:33,260 --> 00:49:34,260
Not a constant.

584
00:49:35,060 --> 00:49:42,060
So, if both of them, if this is a constant, c1 and this is a constant c2, then I will

585
00:49:42,060 --> 00:49:46,100
do c1 of c2.

586
00:49:46,100 --> 00:49:49,300
If one of them is bottom, then?

587
00:49:49,300 --> 00:49:50,540
Then the value is bottom.

588
00:49:50,540 --> 00:49:53,900
This is this or bottom.

589
00:49:53,900 --> 00:49:56,420
When is it bottom?

590
00:49:56,420 --> 00:50:00,020
If either one of them is bottom.

591
00:50:00,020 --> 00:50:03,180
Okay?

592
00:50:04,099 --> 00:50:08,859
And similarly, if it is v equal to op y, what will it be?

593
00:50:08,859 --> 00:50:19,899
What will be m prime of v?

594
00:50:19,899 --> 00:50:26,099
If y is constant, if y is constant, then?

595
00:50:26,099 --> 00:50:30,379
Then op c1.

596
00:50:30,380 --> 00:50:38,180
If m of y is equal to c1 else bottom.

597
00:50:38,180 --> 00:50:42,340
If it is bottom, this is bottom.

598
00:50:42,340 --> 00:50:43,340
Make sense?

599
00:50:43,340 --> 00:50:44,340
Yeah.

600
00:50:44,340 --> 00:50:45,340
Yeah.

601
00:50:45,340 --> 00:50:46,340
This one, right?

602
00:50:46,340 --> 00:50:47,340
Yeah.

603
00:50:47,340 --> 00:50:56,340
What it says is, if it is bottom, then?

604
00:50:56,900 --> 00:50:57,900
This one, right?

605
00:50:57,900 --> 00:50:58,900
Yeah.

606
00:50:58,900 --> 00:51:05,940
What it says is, you are processing a statement which says v equal to blah.

607
00:51:05,940 --> 00:51:07,420
Correct?

608
00:51:07,420 --> 00:51:16,539
Before processing this statement, you had values for all the variables including v.

609
00:51:17,539 --> 00:51:27,099
After processing this statement, which one of the old values have changed, may have changed?

610
00:51:27,099 --> 00:51:32,340
Only those which, only that of v.

611
00:51:32,340 --> 00:51:38,460
For the rest which is not v, let us say you have v1, v2, v3.

612
00:51:38,460 --> 00:51:41,139
You are writing v1 equal to blah.

613
00:51:41,139 --> 00:51:45,420
Does it have, because of this statement, does the value of v2 and v3 change?

614
00:51:45,420 --> 00:51:46,420
No.

615
00:51:47,300 --> 00:51:52,180
What we are saying, except for the current variable which is being written to, for rest

616
00:51:52,180 --> 00:51:59,180
all the variables, the value is same as previous value.

617
00:51:59,180 --> 00:52:00,180
Right?

618
00:52:00,180 --> 00:52:01,180
Okay.

619
00:52:01,179 --> 00:52:16,940
So, we know that the value of y and z will be either constant or bottom, not top, because

620
00:52:16,940 --> 00:52:19,940
there must be some initialization.

621
00:52:19,940 --> 00:52:20,940
Right.

622
00:52:20,940 --> 00:52:26,739
So, in the context of Java, right, where you are guaranteed that there are no uninitialized

623
00:52:26,739 --> 00:52:33,739
variables, you can be guaranteed that this will never happen.

624
00:52:33,739 --> 00:52:43,659
However, it may so happen that during the analysis, the way you choose the, the order

625
00:52:43,659 --> 00:52:49,139
in which you choose, it may so happen that I am doing top of top, because you have picked

626
00:52:49,139 --> 00:52:50,139
a basic block.

627
00:52:50,139 --> 00:52:53,699
See, we are saying pick any block, we are not saying in any order, right.

628
00:52:54,659 --> 00:52:59,299
You have picked a basic block whose predecessors have not yet been processed.

629
00:52:59,299 --> 00:53:00,939
So, you may get a top.

630
00:53:00,939 --> 00:53:03,939
So, in that case, you just leave it as top.

631
00:53:03,939 --> 00:53:07,339
You do not make it a bottom, you just keep it as top.

632
00:53:07,339 --> 00:53:15,899
So, that is why we still kept this rule that if neither of them is bottom, we will keep

633
00:53:15,899 --> 00:53:16,899
it as top.

634
00:53:16,899 --> 00:53:22,259
We will let it, after some time, the top will become one of the more complex.

635
00:53:22,260 --> 00:53:23,260
Yeah.

636
00:53:23,260 --> 00:53:45,460
So, now what you are saying is, why do not I take into consideration some properties

637
00:53:46,460 --> 00:53:52,579
of mathematics and make it more precise, right.

638
00:53:52,579 --> 00:53:53,579
You can.

639
00:53:53,579 --> 00:53:55,860
So, you are saying, what is your name again?

640
00:53:55,860 --> 00:53:56,860
Badri.

641
00:53:56,860 --> 00:53:57,860
Badri.

642
00:53:57,860 --> 00:54:03,099
So, what Badri is saying is, if I, let us say I am doing an op, where I am doing something

643
00:54:03,099 --> 00:54:10,780
multiplied by 0, I can as well, even if the other number is bottom, I can as well make

644
00:54:10,780 --> 00:54:11,780
it a 0.

645
00:54:11,780 --> 00:54:12,780
Yes, you can.

646
00:54:13,780 --> 00:54:21,860
What else can you do like that?

647
00:54:21,860 --> 00:54:22,860
X minus x.

648
00:54:22,860 --> 00:54:23,860
X minus x.

649
00:54:23,860 --> 00:54:33,220
Both x's are bottoms, but you can say, in general, bottom minus bottom is not 0, right.

650
00:54:33,220 --> 00:54:41,100
But x minus x is, so you can take some of those mathematical or x divided by x, right.

651
00:54:41,420 --> 00:54:43,299
Some of those you can.

652
00:54:43,299 --> 00:54:51,019
What would x divided by x?

653
00:54:51,019 --> 00:54:57,059
X divided by x is not guaranteed to be 1, right, because you do not know if x is 0.

654
00:54:57,059 --> 00:55:02,500
But yeah, so you can, I mean, you can then find out if x is 0 or not.

655
00:55:02,500 --> 00:55:05,019
You can take into those mathematical properties.

656
00:55:05,940 --> 00:55:13,460
In, for a simpler scenario, we are saying, let us not worry about that, okay.

657
00:55:13,460 --> 00:55:23,019
And at a merge point, so now if I have, from this side I am getting 1M1, from this side

658
00:55:23,019 --> 00:55:25,420
I am getting M2.

659
00:55:25,420 --> 00:55:26,420
What is M1?

660
00:55:26,420 --> 00:55:29,980
It is a map from every variable to its value.

661
00:55:29,980 --> 00:55:30,980
What is M2?

662
00:55:31,260 --> 00:55:36,780
It is a map from every variable to their value in that path.

663
00:55:36,780 --> 00:55:44,579
Now I want to compute a merged M. How do I compute this?

664
00:55:44,579 --> 00:55:56,579
For each variable V, MV equal to M1V meet M2V, perfect.

665
00:56:01,579 --> 00:56:06,579
Okay, questions?

666
00:56:18,579 --> 00:56:21,579
Okay, there it will be in terms of sets.

667
00:56:21,579 --> 00:56:25,980
There it has to be in terms of sets.

668
00:56:25,980 --> 00:56:37,780
So you, let us say, see, I do not know what I will, were you taught using bit vectors

669
00:56:37,780 --> 00:56:38,780
or?

670
00:56:38,780 --> 00:56:39,780
Bit vectors.

671
00:56:39,780 --> 00:56:47,380
Okay, and did you, what did you initialize the values of each nodes?

672
00:56:47,380 --> 00:56:53,380
You started with empty sets, okay.

673
00:56:53,780 --> 00:56:59,579
In your case, then the meet was the union operator.

674
00:56:59,579 --> 00:57:03,019
The meet was the union operator.

675
00:57:03,019 --> 00:57:08,140
And when you keep meeting, finally you will reach, what is the worst you can assume?

676
00:57:08,140 --> 00:57:12,539
Every variable, every definition reaches every point.

677
00:57:12,539 --> 00:57:17,660
So your bottom is the set of all variables.

678
00:57:17,660 --> 00:57:20,539
Your top is the set of no variables.

679
00:57:20,699 --> 00:57:23,699
So it is empty set, right?

680
00:57:37,699 --> 00:57:42,699
Okay, in the mop type of solutions, meet over all paths, that is what we try to do.

681
00:57:42,699 --> 00:57:49,420
There is also something called job type of solutions, join over all paths.

682
00:57:50,300 --> 00:57:54,700
So, okay, what you keep your top and bottom is not so important.

683
00:57:54,700 --> 00:58:00,420
Some people keep lattice like this, some people keep it this way.

684
00:58:00,420 --> 00:58:09,300
But as long as you are proceeding in one direction, you are in good position, you are in good

685
00:58:09,300 --> 00:58:12,300
shape, okay.

686
00:58:12,300 --> 00:58:17,019
It is just people's, what you are used to.

687
00:58:17,019 --> 00:58:22,980
So I am used to this thing where my top is on the top and bottom is on the bottom.

688
00:58:22,980 --> 00:58:24,940
There are some people who like it the other way around.

689
00:58:24,940 --> 00:58:30,739
There are some school of thoughts, okay.

690
00:58:30,739 --> 00:58:37,059
So we understand the transfer functions and we understand what we do at a meet, right?

691
00:58:37,059 --> 00:58:38,380
Any questions on this?

692
00:58:38,380 --> 00:58:39,380
No?

693
00:58:39,380 --> 00:58:43,539
Okay, if not, we will take an example.

694
00:58:43,539 --> 00:58:53,539
So for this example, okay, we will do, what will you do?

695
00:58:53,539 --> 00:58:56,099
Do constant propagation.

696
00:58:56,099 --> 00:58:58,099
What are my variables?

697
00:58:58,099 --> 00:59:01,900
X, Y and Z.

698
00:59:01,900 --> 00:59:11,059
And now we said we will start with the entry.

699
00:59:11,059 --> 00:59:22,940
So the entry point, every variable has, is mapped to top, top, okay.

700
00:59:22,940 --> 00:59:31,460
So what is the transfer function for this statement?

701
00:59:31,460 --> 00:59:37,059
It changes the value of X to the constant literal 10.

702
00:59:38,059 --> 00:59:41,059
Y and Z, it does not change.

703
00:59:41,059 --> 00:59:46,619
This statement changes the value of Y to 1.

704
00:59:46,619 --> 00:59:47,619
This one?

705
00:59:47,619 --> 00:59:50,139
Z to 5.

706
00:59:50,139 --> 00:59:56,820
This one will take the value of Y and the transfer function is like this.

707
00:59:56,820 --> 01:00:00,440
The transfer function for that would be this.

708
01:00:00,440 --> 01:00:03,400
Both are constants.

709
01:00:03,400 --> 01:00:16,039
If M Y, sorry, if M Y and M Z, this is C 1 and M Z equal to C 2.

710
01:00:16,039 --> 01:00:18,119
Both are constants.

711
01:00:18,119 --> 01:00:22,599
So the transfer function can be some code like this for this.

712
01:00:22,599 --> 01:00:29,240
And transfer function for this would be if X is constant, then new value of X is C 1

713
01:00:29,239 --> 01:00:34,119
minus 1, else bottom.

714
01:00:34,119 --> 01:00:46,199
Similarly here, transfer function for this.

715
01:00:46,199 --> 01:00:48,039
No that is meet here.

716
01:00:48,039 --> 01:00:50,000
Transfer function for print, nothing.

717
01:00:50,000 --> 01:00:54,399
It is not an assignment statement.

718
01:00:54,399 --> 01:00:56,619
We are only looking at assignment statements.

719
01:00:56,619 --> 01:00:59,699
So here we will just treat it as an identity function.

720
01:00:59,699 --> 01:01:06,619
It just takes an M and passes the same M down.

721
01:01:06,619 --> 01:01:10,900
So now let us do constant propagation.

722
01:01:10,900 --> 01:01:12,339
So I will start from here.

723
01:01:12,339 --> 01:01:18,099
I will start M. Let me do one thing.

724
01:01:18,099 --> 01:01:25,159
So what is my M?

725
01:01:25,699 --> 01:01:33,119
So my M is X equal to top, Y equal to top, Z equal to top.

726
01:01:33,119 --> 01:01:36,980
That is what I started with.

727
01:01:36,980 --> 01:01:40,759
I do not know at this time.

728
01:01:40,759 --> 01:01:45,079
And after processing the first statement, what will it be?

729
01:01:45,079 --> 01:01:55,400
It will be 10, right?

730
01:01:55,400 --> 01:02:03,000
After processing the second statement, what will it be?

731
01:02:03,000 --> 01:02:04,000
What would X?

732
01:02:04,000 --> 01:02:05,000
10.

733
01:02:05,000 --> 01:02:12,279
See it takes an M. It took an M of X equal to 10 and Y equal to top and changed it to

734
01:02:12,279 --> 01:02:14,599
Y equal to 1.

735
01:02:15,119 --> 01:02:19,599
And then third one?

736
01:02:19,599 --> 01:02:26,119
Z 5.

737
01:02:26,119 --> 01:02:32,880
Now I have if condition.

738
01:02:32,880 --> 01:02:38,360
So if you see it in the CFG style, I will take this M that I have, this X equal to 10,

739
01:02:39,120 --> 01:02:46,519
Z equal to 5 and pass it to both the branches.

740
01:02:46,519 --> 01:03:08,079
So let me do that.

741
01:03:08,799 --> 01:03:11,239
Now let me, which one should I handle now?

742
01:03:11,239 --> 01:03:12,239
Which one should I process?

743
01:03:12,239 --> 01:03:14,360
The then part or the else part?

744
01:03:14,360 --> 01:03:20,319
Does not matter.

745
01:03:20,319 --> 01:03:24,400
So let us say I process the then part first.

746
01:03:24,400 --> 01:03:31,920
So after processing Y equal to Y by X, what will happen?

747
01:03:31,920 --> 01:03:36,219
Y is?

748
01:03:36,219 --> 01:03:49,339
So it will take the old value of Y and old value of X and get me 0, right?

749
01:03:49,339 --> 01:03:53,099
Integer division.

750
01:03:53,099 --> 01:03:56,539
And then I have X equal to X minus 1.

751
01:03:56,539 --> 01:03:59,919
What will it be?

752
01:03:59,919 --> 01:04:02,919
X equal to 9.

753
01:04:03,519 --> 01:04:13,059
And then I will just see if I can.

754
01:04:13,059 --> 01:04:16,099
And then Z equal to Z plus 1.

755
01:04:16,099 --> 01:04:23,320
It will become 6.

756
01:04:23,320 --> 01:04:26,480
And now I am doing Z equal to, in the else part, see.

757
01:04:26,480 --> 01:04:34,480
So at the end of the con, end of the then part of the con, I have X equal to 9, Y equal

758
01:04:34,480 --> 01:04:38,780
to 0, Z equal to 6.

759
01:04:38,780 --> 01:04:43,800
If you follow the algorithm, right, if you are careful, in my work list initially I had

760
01:04:43,800 --> 01:04:46,679
only the entry, which is at the top.

761
01:04:46,679 --> 01:04:51,920
Then I added X equal to 10.

762
01:04:51,920 --> 01:04:58,340
As I process this, the X equal to 10, the m value has changed.

763
01:04:58,340 --> 01:05:01,599
So I added its successor.

764
01:05:01,599 --> 01:05:09,320
Because I changed Y equal to something, next again the m value, what is the m value here

765
01:05:09,320 --> 01:05:12,800
at this time, before print?

766
01:05:12,800 --> 01:05:22,760
No, initially it is initialized to top, top, top, right.

767
01:05:22,760 --> 01:05:29,280
So technically after I process Z equal to Z plus 1, I will add to my work list its successor.

768
01:05:29,280 --> 01:05:32,280
Who is its successor?

769
01:05:32,280 --> 01:05:38,880
Print, right, or rather the join point you can say.

770
01:05:38,960 --> 01:05:44,079
So now if you say this print, which is the basic block, which has two predecessors.

771
01:05:44,079 --> 01:05:49,820
One predecessor is this Y equal to 0, the other predecessor is Z equal to Z plus 1.

772
01:05:49,820 --> 01:05:54,720
Now let us say I decide to process print.

773
01:05:54,720 --> 01:06:02,720
Then what will be the value of my m here?

774
01:06:02,719 --> 01:06:15,919
So I am taking a meat of top, top, top and X equal to 9, Y equal to 0, Z equal to 6.

775
01:06:15,919 --> 01:06:20,919
And it will be 906.

776
01:06:20,919 --> 01:06:23,179
No problem, we are not done yet.

777
01:06:23,179 --> 01:06:24,879
Now what is there in my work list?

778
01:06:24,879 --> 01:06:31,079
So the out of this will be, if I add, since its m has changed, I can process this guy

779
01:06:31,440 --> 01:06:40,079
and its out will be same X equal to 9, Y equal to 0, Z equal to 6.

780
01:06:40,079 --> 01:06:42,840
And now there is nothing more to add.

781
01:06:42,840 --> 01:06:46,119
The print has no successors, it will not add nothing.

782
01:06:46,119 --> 01:06:49,119
But what is there in my work list is Z equal to Z plus Y.

783
01:06:49,119 --> 01:06:51,239
Let me process that.

784
01:06:51,239 --> 01:06:55,279
I will do X equal to 10, Y equal to 1, Z equal to 5.

785
01:06:55,279 --> 01:06:58,279
What will be the out?

786
01:06:58,480 --> 01:07:04,820
Z will be equal to 6.

787
01:07:04,820 --> 01:07:11,000
And then I am saying Y equal to 0.

788
01:07:11,000 --> 01:07:15,320
So what will be the out?

789
01:07:15,320 --> 01:07:18,800
X equal to 10, Y equal to 0.

790
01:07:18,800 --> 01:07:21,280
Now what is the successor of this Y equal to 0?

791
01:07:21,280 --> 01:07:22,280
Print.

792
01:07:22,280 --> 01:07:30,160
Now for print, so the Y equal to 0's out has changed.

793
01:07:30,160 --> 01:07:33,720
I will add its successor now.

794
01:07:33,720 --> 01:07:39,120
I will add its successor.

795
01:07:39,120 --> 01:07:40,519
Now what is its successor?

796
01:07:40,519 --> 01:07:42,200
The print.

797
01:07:42,200 --> 01:07:47,200
So for processing print, I will take the meat of its predecessors.

798
01:07:47,200 --> 01:07:50,360
So I will take a meat of Y, X equal to 10, X equal to 9.

799
01:07:50,440 --> 01:07:51,440
It will be bottom.

800
01:07:51,440 --> 01:07:54,440
How do I write bottom?

801
01:07:54,440 --> 01:08:03,320
I will just write B. I do not have latex fonts here.

802
01:08:03,320 --> 01:08:05,079
I could search and put it.

803
01:08:05,079 --> 01:08:07,200
I am just writing B, B for bottom.

804
01:08:07,200 --> 01:08:13,920
Then meat of Y equal to 0, Y equal to 0, Y equal to 0, Z equal to 6, Z equal to 6.

805
01:08:13,920 --> 01:08:15,920
And then what will be the out of this?

806
01:08:15,920 --> 01:08:18,319
Out of the print?

807
01:08:19,279 --> 01:08:21,840
X equal to B. Nothing has changed.

808
01:08:21,840 --> 01:08:24,119
So I will stop here.

809
01:08:24,119 --> 01:08:26,639
And now what have I done?

810
01:08:26,639 --> 01:08:30,079
I have identified the constants.

811
01:08:30,079 --> 01:08:34,639
I have not done the constant replacement yet.

812
01:08:34,639 --> 01:08:38,119
I have not done the constant replacement yet.

813
01:08:38,119 --> 01:08:39,119
Now what I will do?

814
01:08:39,119 --> 01:08:41,519
I will go over this code.

815
01:08:41,720 --> 01:08:50,880
On the right hand side, wherever there is an expression, I will take the constants from

816
01:08:50,880 --> 01:08:54,000
that map and replace.

817
01:08:54,000 --> 01:08:58,080
So this will become Y equal to 0.

818
01:08:58,080 --> 01:08:59,440
This will become X equal to 9.

819
01:08:59,440 --> 01:09:04,240
This will become Z equal to 6.

820
01:09:04,240 --> 01:09:05,840
This will become Z equal to 6.

821
01:09:05,840 --> 01:09:09,680
This is already Y equal to 0.

822
01:09:09,840 --> 01:09:21,280
And this will become print X plus, not B plus, not bottom plus, X plus 0 plus 6.

823
01:09:21,280 --> 01:09:24,480
But 0 plus 6 I can simplify to 6.

824
01:09:24,480 --> 01:09:28,360
So it will be print X plus 6.

825
01:09:28,360 --> 01:09:37,520
And now you can invoke your reaching definitions and find where does this X equal to 10 reach?

826
01:09:37,520 --> 01:09:38,520
Nowhere.

827
01:09:38,520 --> 01:09:39,520
Remove.

828
01:09:40,360 --> 01:09:41,360
Y equal to 1 reaches?

829
01:09:41,360 --> 01:09:42,360
Nowhere.

830
01:09:42,360 --> 01:09:43,360
Z equal to 5 reaches?

831
01:09:43,360 --> 01:09:44,360
Nowhere.

832
01:09:44,360 --> 01:09:52,760
Oh sorry, sorry, sorry, sorry, sorry.

833
01:09:52,760 --> 01:09:53,760
X reaches.

834
01:09:53,760 --> 01:09:55,460
So I have to keep the X. My bad, my bad.

835
01:09:55,460 --> 01:09:56,460
This X reaches.

836
01:09:56,460 --> 01:09:58,560
Y and Z go away.

837
01:09:58,560 --> 01:10:03,800
This Y, poof, this X remains.

838
01:10:03,800 --> 01:10:04,800
Does it?

839
01:10:04,800 --> 01:10:08,480
Yeah, this is X equal to 9.

840
01:10:08,480 --> 01:10:10,920
This is X equal to 9.

841
01:10:10,920 --> 01:10:13,920
Why do I need this X equal to 10?

842
01:10:13,920 --> 01:10:18,039
Oh this will go down here.

843
01:10:18,039 --> 01:10:19,039
That's why.

844
01:10:19,039 --> 01:10:20,640
There is a reaching definition.

845
01:10:20,640 --> 01:10:23,600
This definition does reach.

846
01:10:23,600 --> 01:10:24,600
This X is equal to 9.

847
01:10:24,600 --> 01:10:26,079
This may also reach.

848
01:10:26,079 --> 01:10:29,360
This guy poof, this guy poof, this guy poof.

849
01:10:29,360 --> 01:10:32,800
So the else part is gone.

850
01:10:33,800 --> 01:10:38,840
So we did first pass, we propagated the constants.

851
01:10:38,840 --> 01:10:44,239
Second pass we replaced them and threw away unnecessary definition.

852
01:10:44,239 --> 01:10:45,239
Right?

853
01:10:45,239 --> 01:10:48,880
All on the same page?

854
01:10:48,880 --> 01:10:49,880
Any questions?

855
01:10:49,880 --> 01:10:50,880
Now?

856
01:10:50,880 --> 01:10:51,880
Okay.

857
01:10:51,880 --> 01:10:52,880
If you look at.

858
01:10:52,880 --> 01:10:53,880
If you look at.

859
01:10:53,960 --> 01:11:11,920
Yeah, here the lattice is a skewed lattice.

860
01:11:11,920 --> 01:11:20,920
I mean it's a kind of a flat, flat like this.

861
01:11:20,920 --> 01:11:21,920
As in?

862
01:11:21,920 --> 01:11:40,920
No, no, no, no, no, we don't have to reach the top, do we?

863
01:11:40,920 --> 01:11:44,399
In reaching definitions do we always reach a place where set of all definitions?

864
01:11:44,399 --> 01:11:45,399
No.

865
01:11:45,399 --> 01:11:46,399
We stop somewhere in between.

866
01:11:46,879 --> 01:11:55,879
Similarly when we did these dominators, we didn't say everybody is my dominator.

867
01:11:55,879 --> 01:11:56,879
You may.

868
01:11:56,879 --> 01:11:57,879
Okay.

869
01:11:57,879 --> 01:12:02,879
So what you are saying is when you take a meet, there you don't always go to the bottom.

870
01:12:02,879 --> 01:12:06,559
Here the moment you take a meet with anything other than you, you quickly fall onto the

871
01:12:06,559 --> 01:12:07,559
bottom.

872
01:12:07,559 --> 01:12:08,559
Yes.

873
01:12:08,559 --> 01:12:09,559
This is a, that way it is skewed.

874
01:12:09,559 --> 01:12:14,559
It's kind of very, the height is only bottom top.

875
01:12:14,559 --> 01:12:15,559
Okay.

876
01:12:15,720 --> 01:12:16,720
Okay.

877
01:12:16,720 --> 01:12:17,720
Okay.

