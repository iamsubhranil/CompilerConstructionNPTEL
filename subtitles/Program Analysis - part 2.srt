1
00:00:00,000 --> 00:00:10,240
So, just check if these these tools are there, there is a tool called Clang, are you able

2
00:00:10,240 --> 00:00:11,240
to run Clang?

3
00:00:11,240 --> 00:00:12,240
Clang.

4
00:00:12,240 --> 00:00:18,400
There should be a tool called OPT, this is the optimization pass in LLVM that is there

5
00:00:18,400 --> 00:00:27,400
and you will not need it, but still see LLC is there ok awesome.

6
00:00:27,399 --> 00:00:37,159
Now what we will do is just write a sample code, does not really matter what, let me

7
00:00:37,159 --> 00:00:41,519
just see if I have something you can just write that, I should have maybe sent you this.

8
00:00:41,519 --> 00:00:45,000
So I sent a mail yesterday, but ok.

9
00:00:45,000 --> 00:00:53,119
So can you see this?

10
00:00:53,119 --> 00:00:58,399
Let us just expand it, let us write some bit of code, little bit more code.

11
00:01:24,120 --> 00:01:43,680
If z is greater than 0, something else something ok.

12
00:01:44,160 --> 00:01:54,560
There is some program you have, does not matter what.

13
00:01:54,560 --> 00:02:04,160
And then essentially you should be the way to, so just check if you can do Clang, you

14
00:02:04,159 --> 00:02:14,079
can do Clang whatever is the file name a.c.

15
00:02:14,079 --> 00:02:16,120
Does it work for you?

16
00:02:16,120 --> 00:02:28,719
So now the first step in LLVM is to convert your program into the LLVM IR.

17
00:02:28,719 --> 00:02:40,400
So do you know this M cross N versus M plus N design of compilers?

18
00:02:40,400 --> 00:02:44,360
So essentially now the idea is that you would always like to, there can be multiple front

19
00:02:44,360 --> 00:02:50,000
ends and all the front ends would compile down to the same IR, the same intermediate

20
00:02:50,000 --> 00:02:52,000
presentation.

21
00:02:52,000 --> 00:02:59,560
Now you can have a bunch of compiler passes which will all transform the same IR and eventually

22
00:02:59,560 --> 00:03:08,719
there will be an M number of back end passes which will translate the output into the respective

23
00:03:08,719 --> 00:03:13,199
target language, the IR into the respective target language.

24
00:03:13,199 --> 00:03:18,199
So which means that you will not have to write the compiler, the optimization passes for

25
00:03:18,199 --> 00:03:23,319
every source target combination.

26
00:03:23,319 --> 00:03:31,280
So LLVM completely breaks down this division, I mean it makes everything explicit.

27
00:03:31,280 --> 00:03:35,599
So it has, you will be able to see the three passes completely differently.

28
00:03:35,599 --> 00:03:44,439
So the first pass is the pass which will convert a source language program into the IR that

29
00:03:45,000 --> 00:03:49,319
using the front end which is the client front end.

30
00:03:49,319 --> 00:03:56,639
Then you have the OPT pass which will run optimizations on your program and you can

31
00:03:56,639 --> 00:04:02,400
tell it which passes you want to learn, which passes you want to run your program through.

32
00:04:02,400 --> 00:04:08,199
And these passes can be given in a certain order, you can say run DCE, then CPE, then

33
00:04:08,199 --> 00:04:11,840
this you can actually run these passes in a certain order and it will exactly run these

34
00:04:11,840 --> 00:04:14,520
passes in that given order.

35
00:04:14,520 --> 00:04:19,680
And after that you can use the back end pass to transform your program which is the LLVM

36
00:04:19,680 --> 00:04:23,720
pass, you can transform your program to the respective target, whichever target language

37
00:04:23,720 --> 00:04:27,560
you want to target.

38
00:04:27,560 --> 00:04:35,379
So we will first use Clang to produce an IR for your program.

39
00:04:35,379 --> 00:04:46,139
So essentially the command for that is you say Clang minus emit LLVM and you say a dot

40
00:04:46,139 --> 00:04:49,379
c whichever program you want.

41
00:04:49,379 --> 00:04:53,019
Once you run it you will get an error.

42
00:04:53,019 --> 00:04:55,860
It says emit LLVM cannot be used when linking.

43
00:04:55,860 --> 00:05:02,620
Any idea what is the problem is?

44
00:05:02,620 --> 00:05:07,579
What would that do?

45
00:05:07,579 --> 00:05:08,819
But you would not like that.

46
00:05:08,819 --> 00:05:12,540
So essentially now what I want is essentially what has happened is but what is the error,

47
00:05:12,540 --> 00:05:13,540
what is the problem?

48
00:05:13,540 --> 00:05:21,139
Right, so right now I want to convert it into LLVM and it may be linking against a lot of

49
00:05:21,139 --> 00:05:28,259
libraries like printf, scanf, the gllipc library and I do not have their byte codes available,

50
00:05:28,259 --> 00:05:32,659
I do not have those definitions with me right now.

51
00:05:32,659 --> 00:05:37,180
So I do not want to do linking right now because I just want to do optimization on whatever

52
00:05:37,180 --> 00:05:38,579
code I have.

53
00:05:38,579 --> 00:05:42,659
I do not care, it will not produce complete program at this moment.

54
00:05:42,659 --> 00:05:48,800
So essentially you can simply say that skip linking by just saying minus c.

55
00:05:48,800 --> 00:05:54,379
So it will skip linking, it will not do linking.

56
00:05:54,379 --> 00:06:01,060
And once you do that you will get a file called, what file did you get?

57
00:06:01,060 --> 00:06:04,139
A.BC.

58
00:06:04,139 --> 00:06:07,060
So BC is the bytecode file.

59
00:06:07,060 --> 00:06:11,620
So the LLVM IR is also referred to as the LLVM bytecode.

60
00:06:11,620 --> 00:06:15,100
So this is the bytecode file.

61
00:06:15,100 --> 00:06:17,019
Bitcode, same thing.

62
00:06:17,019 --> 00:06:28,620
So it is referred to as, so now essentially what you would do is that you would, so if

63
00:06:28,620 --> 00:06:35,919
you want to, so if you try to look at this program you will not be able to look at this

64
00:06:35,919 --> 00:06:40,779
program because it is a binary representation but there is also a human readable format

65
00:06:40,779 --> 00:06:42,060
which is LL format.

66
00:06:42,060 --> 00:06:44,939
So we will do it when we want to examine the instructions.

67
00:06:44,939 --> 00:06:50,779
At this point in time we really do not care about, we do not want to examine the instructions.

68
00:06:50,779 --> 00:06:58,540
So now with this you can run the optimization pass.

69
00:06:58,540 --> 00:07:05,379
So the running the optimization pass is you say OPT and if you say minus minus help you

70
00:07:05,379 --> 00:07:13,139
will be able to see all optimizations that are available in LLVM at this moment.

71
00:07:13,139 --> 00:07:30,979
So you can, let us see if we can see some interesting optimizations.

72
00:07:30,979 --> 00:07:33,180
Let us try to do this simple thing.

73
00:07:33,180 --> 00:07:40,979
Print function.

74
00:07:40,980 --> 00:07:45,340
So let us try to just run this.

75
00:07:45,340 --> 00:07:57,140
So we say OPT print function a.bc.

76
00:07:57,140 --> 00:08:01,780
Now there is a problem, this guy will try to emit things onto the terminal which is

77
00:08:01,780 --> 00:08:02,819
not good.

78
00:08:02,819 --> 00:08:11,139
So you can redirect the output to dev null.

79
00:08:11,139 --> 00:08:19,740
So it actually shows you the body of the function that it has compiled.

80
00:08:19,740 --> 00:08:28,019
So this is the LLVM interpretive representation, the human readable form of the LLVM interpretive

81
00:08:28,019 --> 00:08:29,319
representation.

82
00:08:29,319 --> 00:08:35,240
So this IR looks very similar to machine code.

83
00:08:35,240 --> 00:08:39,799
So it is referred to as a low level IR, it is very close to the machine code.

84
00:08:39,799 --> 00:08:48,960
So you can see that, but it uses these what are called virtual registers or to store values,

85
00:08:48,960 --> 00:08:49,960
intermediate values.

86
00:08:49,960 --> 00:08:52,620
So these are like temporaries.

87
00:08:52,620 --> 00:08:56,039
So there are different instructions and maybe we will come back to it when we start doing

88
00:08:56,039 --> 00:08:57,039
data flow analysis.

89
00:08:57,039 --> 00:09:00,159
So at this point in time, we don't care about what these instructions are.

90
00:09:00,159 --> 00:09:04,240
But what are interesting is, let's only look at the branch instruction.

91
00:09:04,240 --> 00:09:11,639
So for instance, there is this conditional branch instruction which says that you try

92
00:09:11,639 --> 00:09:19,559
to, so it looks at 6, the result of 6.

93
00:09:19,559 --> 00:09:27,000
The result of 6 is a comparison SDT signed greater than.

94
00:09:27,000 --> 00:09:31,159
So it does a signed comparison between 5 and 0.

95
00:09:31,159 --> 00:09:38,679
I don't know, so 5, we had some variable I guess.

96
00:09:38,679 --> 00:09:48,559
5 basically if you look at the temporary 5, the temporary 5 loads the value of Z.

97
00:09:48,559 --> 00:09:54,399
And then it essentially does a signed comparison between Z and a constant 0.

98
00:09:54,399 --> 00:09:56,039
So I think that was our if condition.

99
00:09:56,039 --> 00:10:00,159
We had I think if Z is less than 0 or something like that.

100
00:10:00,159 --> 00:10:10,839
And then depending on the value of 6, it branches to either label 7 or label 10.

101
00:10:10,839 --> 00:10:18,079
And essentially you can see that label 7 has a set of instructions and it says its predecessor

102
00:10:18,080 --> 00:10:31,360
is 0 and label 10 has these instructions and it says it comes from 2, 3, 4, 7 and 0.

103
00:10:31,360 --> 00:10:36,960
The code, okay.

104
00:10:36,960 --> 00:10:37,960
This was the code.

105
00:10:37,960 --> 00:10:44,960
Z is greater than 0.

106
00:10:44,960 --> 00:10:51,960
Where is it?

107
00:10:51,960 --> 00:10:52,960
%5.

108
00:10:52,960 --> 00:10:53,960
No, sorry.

109
00:10:53,960 --> 00:10:54,960
I don't know.

110
00:10:54,960 --> 00:10:55,960
What?

111
00:10:55,960 --> 00:11:10,560
That can be the naming can, so you are probably using a different version of.

112
00:11:11,359 --> 00:11:13,799
%5 is Z, right?

113
00:11:13,799 --> 00:11:17,439
But think, see what happens to Z.

114
00:11:17,439 --> 00:11:21,279
Z I think we have reassigned, right?

115
00:11:21,279 --> 00:11:28,639
So Z is Z was initially 2 and then it, so essentially it uses this notion of virtual

116
00:11:28,639 --> 00:11:29,639
registers.

117
00:11:29,639 --> 00:11:33,000
Virtual registers are basically it has an infinite set of registers.

118
00:11:33,000 --> 00:11:36,279
Every time you do a reassignment, it will just fetch a new register and write it.

119
00:11:36,279 --> 00:11:43,799
It will never reuse those values.

120
00:11:43,799 --> 00:11:54,399
So like given this, you should be able to see what your control flow graph looks like.

121
00:11:54,399 --> 00:12:01,639
Now okay, so you can, all of you can run OPT, right?

122
00:12:01,639 --> 00:12:02,639
No issues?

123
00:12:02,639 --> 00:12:03,639
Great.

124
00:12:03,639 --> 00:12:10,319
So once we have OPT, the next thing we will do is that we would like to build our own

125
00:12:10,319 --> 00:12:13,960
pass.

126
00:12:13,960 --> 00:12:23,720
So a very simple pass is something referred to as a hello world pass and maybe you can

127
00:12:23,720 --> 00:12:30,000
type it or I already have the code, so it is there in, so this is already available

128
00:12:30,000 --> 00:12:31,319
at this particular location.

129
00:12:31,320 --> 00:12:36,240
You can just copy it from here if you want to.

130
00:12:36,240 --> 00:12:39,640
So we will later see how to write a pass, but for the moment just let us try to see

131
00:12:39,640 --> 00:12:40,640
how to compile a pass.

132
00:12:40,640 --> 00:12:43,560
We will later see how to, so I think the code is there.

133
00:12:43,560 --> 00:12:46,879
You can just copy paste that code into an editor and we will try to just build it and

134
00:12:46,879 --> 00:12:47,879
run it.

135
00:12:47,879 --> 00:12:49,720
Okay, could you guys get that example?

136
00:12:49,720 --> 00:12:58,040
Right, so now the way to compile this is that you can say G plus plus, it was a C program.

137
00:12:58,040 --> 00:13:00,200
You will need to, you need to build that.

138
00:13:00,200 --> 00:13:03,600
So there are many ways of building a pass into LLVM.

139
00:13:03,600 --> 00:13:08,600
One is that you can actually add it to the LLVM system so that like the passes you are

140
00:13:08,600 --> 00:13:10,120
seeing, those are all passes in LLVM.

141
00:13:10,120 --> 00:13:12,720
When I said help, you could see a lot of things, right?

142
00:13:12,720 --> 00:13:14,600
All of these are passes in LLVM.

143
00:13:14,600 --> 00:13:19,600
So you can actually build it such that it becomes part of that.

144
00:13:19,600 --> 00:13:23,640
Problem is it will require you to have the whole of LLVM and you will have to put your

145
00:13:23,640 --> 00:13:25,960
code inside it and build the whole thing.

146
00:13:25,960 --> 00:13:30,920
The easier way is to build your program, build your pass as a separate, what is called

147
00:13:30,920 --> 00:13:34,280
a shared library, right?

148
00:13:34,280 --> 00:13:45,280
And then the advantage is that, well you do not have to do much work, that is it.

149
00:13:45,280 --> 00:13:52,240
So the way to build the shared object is, right?

150
00:13:52,240 --> 00:13:56,519
So you can use this command.

151
00:13:56,519 --> 00:13:58,200
So it is a long command.

152
00:13:58,200 --> 00:14:03,600
So make sure you, can you all of you see it or should I, okay let me just pull it out.

153
00:14:03,600 --> 00:14:07,560
So G++, Fpix says that I want position independent code.

154
00:14:07,560 --> 00:14:11,080
So essentially, let me not get into it.

155
00:14:11,080 --> 00:14:16,360
Then Rdynamic and Shared say that I want to build a shared library.

156
00:14:16,360 --> 00:14:17,960
You may or may not use this.

157
00:14:17,960 --> 00:14:22,960
So this is if you want to enable C11.

158
00:14:22,960 --> 00:14:28,200
Next these two have to be set and then you have the name of the file that you are compiling,

159
00:14:28,200 --> 00:14:32,600
that is example 1.cpp for the moment and minus O says what is the name of the shared object

160
00:14:32,600 --> 00:14:33,600
that you want to create.

161
00:14:33,600 --> 00:14:38,160
So the header files, if you are installed the LLVM depth, they are already there in

162
00:14:38,160 --> 00:14:39,160
your system path.

163
00:14:39,160 --> 00:14:44,280
So no, because it is already in the system searchable path.

164
00:14:44,280 --> 00:14:47,920
Try to run this command and see if you are able to build your pass.

165
00:14:47,919 --> 00:14:50,439
So here it will be the hello world pass.

166
00:14:50,439 --> 00:14:55,039
So it would be hello.cpp and hello1.o whatever it is.

167
00:14:55,039 --> 00:14:57,519
Have you, do you have the LLVM depth package installed?

168
00:14:57,519 --> 00:15:01,120
All of you, do you guys have LLVM depth installed?

169
00:15:01,120 --> 00:15:03,159
Okay, okay dictate to me.

170
00:15:03,159 --> 00:15:06,159
Tell me, tell me, tell me.

171
00:15:06,159 --> 00:15:07,159
Sir, just try to write.

172
00:15:07,159 --> 00:15:08,159
I will just write it here.

173
00:15:08,159 --> 00:15:11,159
With the, with the addition to it.

174
00:15:11,159 --> 00:15:13,879
I will just write it here.

175
00:15:13,879 --> 00:15:15,159
My thing will not compile with that.

176
00:15:15,159 --> 00:15:19,959
So I do not know what to do, but let you open up the, okay what is it?

177
00:15:19,959 --> 00:15:22,839
Hi-finite is for include path.

178
00:15:22,839 --> 00:15:24,879
Then you say which, what is the path?

179
00:15:24,879 --> 00:15:27,879
Slash home.

180
00:15:27,879 --> 00:15:28,879
Student.

181
00:15:28,879 --> 00:15:29,879
Student.

182
00:15:29,879 --> 00:15:30,879
School.

183
00:15:30,879 --> 00:15:31,879
LLVM.

184
00:15:31,879 --> 00:15:32,879
LLVM.

185
00:15:32,879 --> 00:15:33,879
Clang 8.

186
00:15:33,879 --> 00:15:34,879
Clang 8.

187
00:15:34,879 --> 00:15:35,879
Then build.

188
00:15:35,879 --> 00:15:36,879
Okay.

189
00:15:36,879 --> 00:15:37,879
Okay.

190
00:15:37,879 --> 00:15:38,879
Another is hi-finite.

191
00:15:38,879 --> 00:15:39,879
Okay.

192
00:15:39,879 --> 00:16:03,600
Instead of build, there is a LLVM and then include.

193
00:16:03,600 --> 00:16:04,600
Instead of build, you have LLVM.

194
00:16:04,600 --> 00:16:05,600
LLVM include.

195
00:16:06,320 --> 00:16:09,320
No, yeah.

196
00:16:09,320 --> 00:16:16,279
So, just add it to the end of your command.

197
00:16:16,279 --> 00:16:19,159
Maybe before over, I mean generally boot.

198
00:16:19,159 --> 00:16:24,000
Just check if you are able to build this.

199
00:16:24,000 --> 00:16:25,000
Works?

200
00:16:25,000 --> 00:16:26,000
Okay, awesome.

201
00:16:26,000 --> 00:16:33,000
So, if all of you have the same configuration, it should work.

202
00:16:34,000 --> 00:16:35,000
Okay.

203
00:16:35,000 --> 00:16:36,000
So, let's see.

204
00:16:36,000 --> 00:16:37,000
Okay.

205
00:16:37,000 --> 00:16:38,000
So, let's see.

206
00:16:38,000 --> 00:16:39,000
Okay.

207
00:16:39,000 --> 00:16:40,000
So, let's see.

208
00:16:40,000 --> 00:16:41,000
Okay.

209
00:16:41,000 --> 00:16:42,000
So, let's see.

210
00:16:42,000 --> 00:16:43,000
Okay.

211
00:16:43,000 --> 00:16:44,000
So, let's see.

212
00:16:44,000 --> 00:16:45,000
Okay.

213
00:16:45,000 --> 00:16:46,000
So, let's see.

214
00:16:46,000 --> 00:16:47,000
Okay.

215
00:16:47,000 --> 00:16:48,000
So, let's see.

216
00:16:48,000 --> 00:16:49,000
Okay.

217
00:16:49,000 --> 00:16:50,000
So, let's see.

218
00:16:50,000 --> 00:16:51,000
Okay.

219
00:16:51,000 --> 00:16:52,000
So, let's see.

220
00:16:52,000 --> 00:16:53,000
Okay.

221
00:16:53,000 --> 00:16:54,000
So, let's see.

222
00:16:54,000 --> 00:16:55,000
Okay.

223
00:16:55,000 --> 00:16:56,000
So, let's see.

224
00:16:56,000 --> 00:16:57,000
Okay.

225
00:16:57,000 --> 00:16:58,000
So, let's see.

226
00:16:58,000 --> 00:16:59,000
Okay.

227
00:16:59,000 --> 00:17:00,000
So, let's see.

228
00:17:00,000 --> 00:17:01,000
Okay.

229
00:17:01,000 --> 00:17:02,000
So, let's see.

230
00:17:02,000 --> 00:17:03,000
Done, anybody still lagging?

231
00:17:03,000 --> 00:17:04,000
Not working?

232
00:17:04,000 --> 00:17:05,000
What is the error?

233
00:17:05,000 --> 00:17:06,000
No, so, this minus I did not work for you?

234
00:17:06,000 --> 00:17:07,000
Okay.

235
00:17:07,000 --> 00:17:08,000
So, let's see.

236
00:17:08,000 --> 00:17:09,000
Okay.

237
00:17:09,000 --> 00:17:10,000
So, let's see.

238
00:17:10,000 --> 00:17:11,000
Okay.

239
00:17:11,000 --> 00:17:12,000
Okay.

240
00:17:12,000 --> 00:17:13,000
So, let's see.

241
00:17:13,000 --> 00:17:14,000
So, let's see.

242
00:17:14,000 --> 00:17:15,000
Okay.

243
00:17:15,000 --> 00:17:16,000
So, let's see.

244
00:17:16,000 --> 00:17:17,000
Okay.

245
00:17:47,000 --> 00:17:48,000
Okay.

246
00:17:48,000 --> 00:17:49,000
Done, right?

247
00:17:49,000 --> 00:17:50,000
Okay, awesome.

248
00:17:50,000 --> 00:17:54,519
I think we are all set.

249
00:17:54,519 --> 00:17:57,519
So now, you can build your pass.

250
00:17:57,519 --> 00:17:58,519
Cool.

251
00:17:58,519 --> 00:18:00,559
Now, the next step is to load your pass.

252
00:18:00,559 --> 00:18:05,599
Now you have to make LLVM know that such a pass exists and it should be able to pick

253
00:18:05,599 --> 00:18:07,279
up the code and run it.

254
00:18:07,279 --> 00:18:10,079
To do that, essentially you have to tell LLVM where you are.

255
00:18:10,079 --> 00:18:11,079
Okay.

256
00:18:11,079 --> 00:18:12,079
So, now this is a shared library.

257
00:18:12,079 --> 00:18:16,200
So, whenever you have shared libraries, you have to tell the system.

258
00:18:16,200 --> 00:18:18,920
So, do you guys know what a shared library is?

259
00:18:18,920 --> 00:18:21,039
What libraries are, what shared libraries are?

260
00:18:21,039 --> 00:18:22,039
Okay.

261
00:18:22,039 --> 00:18:26,240
So, shared libraries are basically libraries which are loaded on demand.

262
00:18:26,240 --> 00:18:32,240
So, if you, let's say you are, let's say you write a library and you know that on certain

263
00:18:32,240 --> 00:18:36,640
conditions you might have to, you need that particular library to be used.

264
00:18:36,640 --> 00:18:41,960
Now, one option is to compile the whole code of that library and attach it with your whole

265
00:18:41,960 --> 00:18:42,960
program, right?

266
00:18:42,960 --> 00:18:43,960
And ship that program across.

267
00:18:44,720 --> 00:18:49,120
Problem is it will be a big executable, right?

268
00:18:49,120 --> 00:18:53,920
Instead what you can do is if you know, for instance, that let's say our G-Lib-C libraries,

269
00:18:53,920 --> 00:18:54,920
right?

270
00:18:54,920 --> 00:18:57,840
All of us need that library, printf, scanf, string libraries.

271
00:18:57,840 --> 00:18:59,720
We are all going to use those libraries.

272
00:18:59,720 --> 00:19:04,840
So, is it not good that, now think about it, think about the situation where I write some

273
00:19:04,840 --> 00:19:07,840
code and I want to share that code with you guys.

274
00:19:07,840 --> 00:19:12,600
One option is I compile it with all the G-Lib-C library, the whole binary is one package and

275
00:19:12,600 --> 00:19:13,600
I send it to you.

276
00:19:14,240 --> 00:19:15,240
It will be a huge binary.

277
00:19:15,240 --> 00:19:18,759
Like, think about how much time you will take to download it.

278
00:19:18,759 --> 00:19:22,879
My code might be three lines, like hello world, printf hello world.

279
00:19:22,879 --> 00:19:26,959
Instead the option is that you guys install the shared libraries on your machines.

280
00:19:26,959 --> 00:19:33,559
I just give you my code and that code knows where to pick up the G-Lib-C library on your

281
00:19:33,559 --> 00:19:36,000
particular machine, right?

282
00:19:36,000 --> 00:19:40,559
So that's, so essentially the idea is that certain code is there on the host machine

283
00:19:40,799 --> 00:19:45,559
and certain code is sent to you and they all work seamlessly nicely.

284
00:19:45,559 --> 00:19:50,159
Problem is that on your machine you should be able to know where the shared libraries

285
00:19:50,159 --> 00:19:51,159
are, right?

286
00:19:51,159 --> 00:19:55,399
Because in the system where does it start looking for that library?

287
00:19:55,399 --> 00:20:00,240
So there is this variable called LDLibraryPath which tells you the search path for a shared

288
00:20:00,240 --> 00:20:04,359
library, tells you that search a shared library at these locations, right?

289
00:20:04,359 --> 00:20:13,359
So here if you, like for instance, the way to load this thing is, the way to load your

290
00:20:13,359 --> 00:20:20,459
shared library is that you can say minus OPT, sorry OPT minus load, give the name of your

291
00:20:20,459 --> 00:20:31,279
library hello.so, invoke your library, okay we'll do that later, hello.so and then give

292
00:20:31,359 --> 00:20:43,839
the name of your, of the object file that you want to analyze, let's say a.bc and redirect

293
00:20:43,839 --> 00:20:49,559
it to Dev Null, right?

294
00:20:49,559 --> 00:20:58,680
What does it give you if you run this?

295
00:20:58,680 --> 00:21:04,799
Cannot find shared library, right?

296
00:21:04,799 --> 00:21:08,200
So we have to make it recognize where the shared library is, tell it where the shared

297
00:21:08,200 --> 00:21:09,560
library is.

298
00:21:09,560 --> 00:21:18,799
So the way to do that is to you can just say export LDLibraryPath equals, if you already

299
00:21:18,799 --> 00:21:28,440
have LDLibraryPath you can just keep that, probably will not have anything here anyway.

300
00:21:29,160 --> 00:21:37,640
And append, like one simple option is I just say present directory, dot, right?

301
00:21:37,640 --> 00:21:44,600
So if I do this, then see it is able to load it, there it does not come anymore.

302
00:21:44,600 --> 00:21:51,799
So it's able to find that whatever hello.so pass.

303
00:21:51,799 --> 00:21:57,000
Works for you?

304
00:21:57,000 --> 00:22:20,039
I think you are, this thing is not built, you do not have the packages.

305
00:22:20,039 --> 00:22:25,799
I think they just built Clang, they may not have built LLVM.

306
00:22:25,799 --> 00:22:28,039
Is it giving an error?

307
00:22:28,039 --> 00:22:32,680
Guys, the same error is it?

308
00:22:32,680 --> 00:22:44,720
Okay, so we'll have to fix that.

309
00:22:44,720 --> 00:22:49,919
Maybe you guys can do it over the lunch break, I would request the TAs to help out the students.

310
00:22:49,920 --> 00:22:54,720
Looks like they do not have all the libraries, all the libraries.

311
00:22:54,720 --> 00:22:58,160
Or maybe it is there, just search for this particular directory, whatever the include

312
00:22:58,160 --> 00:23:04,000
directories are, there would be a lib directory there.

313
00:23:04,000 --> 00:23:06,200
Is there a lib there?

314
00:23:06,200 --> 00:23:18,640
Do you have some files there in that, in that path instead of include, say lib?

315
00:23:19,640 --> 00:23:26,400
Okay, so what you should do is in the LD library path, you just append those paths, the same

316
00:23:26,400 --> 00:23:32,000
prefix that the eyes had, but instead of include, say lib, right?

317
00:23:32,000 --> 00:23:43,920
So in like wherever I'm setting the cell delivery part, I set it as dot, you give those paths

318
00:23:43,920 --> 00:23:45,840
and you can template it by colons.

319
00:23:45,840 --> 00:23:54,240
The same path that you gave for i, minus i, the same path replacing include by lib, right?

320
00:23:54,240 --> 00:23:59,600
So now if you load it, essentially what happens is that this guy does, like is able to load

321
00:23:59,600 --> 00:24:04,680
it, does not give an error, but essentially if you really want, but it is not doing anything.

322
00:24:04,680 --> 00:24:09,440
So to make LLVM do something, remember there was this switch, so you have to say that do

323
00:24:09,440 --> 00:24:11,019
something for this pass.

324
00:24:11,019 --> 00:24:15,240
So you can say minus hello.

325
00:24:15,240 --> 00:24:16,579
So this is the name of the pass.

326
00:24:16,579 --> 00:24:19,900
Whenever you say minus hello, that pass would be invoked, right?

327
00:24:19,900 --> 00:24:26,379
So essentially LLVM allows you to like construct an array of passes, right?

328
00:24:26,379 --> 00:24:29,980
You can say apply pass one, then pass two, then pass three, in that sequence you can

329
00:24:29,980 --> 00:24:31,819
put your passes.

330
00:24:31,819 --> 00:24:36,480
So if you do this, then see what it does, it gives you hello and mean.

331
00:24:36,480 --> 00:24:42,700
So it basically shows the name of all functions that are there in this file.

332
00:24:42,700 --> 00:24:47,400
So there was unfortunately only one function, had there been more functions, it would have

333
00:24:47,400 --> 00:24:50,720
shown all of them, right?

334
00:24:50,720 --> 00:24:54,039
So this is something that you should do.

335
00:24:54,039 --> 00:24:57,039
Then you can analyze your program and you will be able to see the output here.

336
00:24:57,039 --> 00:24:58,819
Okay, that is one part.

337
00:24:58,819 --> 00:25:03,240
Second part is that let us see how to write this pass, right?

338
00:25:03,240 --> 00:25:10,160
So let's try to analyze the, I hope all of you have the hello world pass with you.

339
00:25:10,160 --> 00:25:16,319
Right, so this is the hello world pass.

340
00:25:16,319 --> 00:25:19,880
Namespace and all, I hope you guys know C++, so I will not get into this.

341
00:25:19,880 --> 00:25:24,279
So the important part is that you have to give, so you have to derive.

342
00:25:24,279 --> 00:25:29,759
So there are multiple different ways you can construct a pass in LLVM.

343
00:25:29,759 --> 00:25:34,900
So there is something called a module pass, wherein, which allows you to analyze all the

344
00:25:34,900 --> 00:25:38,440
functions of the program.

345
00:25:38,440 --> 00:25:44,119
There is a function pass which will allow you to call every function separately.

346
00:25:44,119 --> 00:25:47,480
So for the moment, let's just concentrate on the function pass.

347
00:25:47,480 --> 00:25:52,519
So the function pass has this special method called runOn function.

348
00:25:52,519 --> 00:25:58,759
So what the program does is that on the binary that you give it to analyze, the bitcode that

349
00:25:58,799 --> 00:26:06,599
it analyzes, it will call this function runOn function for each of the methods.

350
00:26:06,599 --> 00:26:10,299
So it's a virtual function and this function has to be overridden.

351
00:26:10,299 --> 00:26:12,640
So you have to override it.

352
00:26:12,640 --> 00:26:18,000
So it will, for whenever you have your pass, it will call your pass on every function in

353
00:26:18,000 --> 00:26:21,720
that file and that function will be passed here.

354
00:26:21,720 --> 00:26:26,720
This function ampersand f you see, right?

355
00:26:26,720 --> 00:26:33,279
So your pass must derive from function pass and override this method.

356
00:26:33,279 --> 00:26:37,559
That is all that there is to it.

357
00:26:37,559 --> 00:26:38,559
Make sense?

358
00:26:38,559 --> 00:26:39,559
Right?

359
00:26:39,559 --> 00:26:45,900
So now on, so now you get this f, you can query f for the name.

360
00:26:45,900 --> 00:26:46,900
You can say f dot getName.

361
00:26:46,900 --> 00:26:51,440
It will just give you the name of this function and it just comes out.

362
00:26:51,440 --> 00:26:54,440
It just says hello, gives the name of the function, comes out.

363
00:26:54,440 --> 00:26:55,440
That is all it does.

364
00:26:55,440 --> 00:26:56,440
Right?

365
00:26:56,440 --> 00:26:59,440
So essentially what will happen is it will get called for every function.

366
00:26:59,440 --> 00:27:01,799
For every function it will print the name and come out.

367
00:27:01,799 --> 00:27:07,400
So it will say hello function 1, hello function 2, hello function 3, hello function 4, hello

368
00:27:07,400 --> 00:27:08,400
function 5.

369
00:27:08,400 --> 00:27:09,400
Then there is this id.

370
00:27:09,400 --> 00:27:10,400
Don't worry about it.

371
00:27:10,400 --> 00:27:11,400
You keep it here.

372
00:27:11,400 --> 00:27:14,080
But essentially the other important thing is you have to register your pass.

373
00:27:14,080 --> 00:27:15,080
Right?

374
00:27:15,080 --> 00:27:19,440
So you have to register the pass saying that I have a new pass hello.

375
00:27:19,440 --> 00:27:21,759
Where is this class name coming from?

376
00:27:21,759 --> 00:27:24,320
This is the class name that you gave.

377
00:27:24,319 --> 00:27:27,159
So you created this class, this hello class.

378
00:27:27,159 --> 00:27:28,379
Right?

379
00:27:28,379 --> 00:27:31,000
So you say register pass.

380
00:27:31,000 --> 00:27:34,639
I have a new pass that has to be registered.

381
00:27:34,639 --> 00:27:36,799
I have some instance of it.

382
00:27:36,799 --> 00:27:42,639
And this is the command line option that you have to run this pass.

383
00:27:42,639 --> 00:27:45,919
So if you say minus hello, it will run your thing.

384
00:27:45,919 --> 00:27:49,319
So if you say example here, you have to give an option minus example.

385
00:27:49,319 --> 00:27:54,039
Whatever option you give here, it will run your pass with that on that particular switch.

386
00:27:55,000 --> 00:27:56,000
Make sense?

387
00:27:56,000 --> 00:27:57,000
Okay.

388
00:27:57,000 --> 00:28:00,440
This is the command line.

389
00:28:00,440 --> 00:28:04,279
This is the description of your pass, the textual description of your pass.

390
00:28:04,279 --> 00:28:09,519
So when you say OPT help, it will show your pass and give you give this description against

391
00:28:09,519 --> 00:28:10,519
your pass.

392
00:28:10,519 --> 00:28:11,519
Right?

393
00:28:11,519 --> 00:28:15,920
So let's see this and the other two things you can ignore for the moment.

394
00:28:15,920 --> 00:28:18,759
Let us say tomorrow we might need it.

395
00:28:18,759 --> 00:28:41,799
So now if I say minus minus help.

396
00:28:41,799 --> 00:28:42,799
See?

397
00:28:42,799 --> 00:28:47,799
Yahoo!

398
00:28:47,839 --> 00:28:49,639
I have a new hello pass.

399
00:28:49,639 --> 00:28:50,639
Right?

400
00:28:50,639 --> 00:28:51,960
So LLVM recognizes this pass.

401
00:28:51,960 --> 00:28:57,680
But interestingly, if you do not, of course, I mean, if you do not give it this load, LLVM

402
00:28:57,680 --> 00:29:03,960
will not load it and it will not show your pass.

403
00:29:03,960 --> 00:29:08,759
So this is a dynamic pass, like it's a dynamic shared pass compatible shared object.

404
00:29:08,759 --> 00:29:12,319
Only if you ask LLVM to load it, it will know about this pass.

405
00:29:12,319 --> 00:29:16,639
If you do not tell LLVM about it, it will not even know that such a pass exists.

406
00:29:16,640 --> 00:29:20,680
This is a very nice way of isolating your pass from the rest of the LLVM system.

407
00:29:20,680 --> 00:29:23,400
You don't really have to tell it these passes exist.

408
00:29:23,400 --> 00:29:28,000
There's no need to bloat your LLVM with all the passes that you're writing.

409
00:29:28,000 --> 00:29:34,280
So load whatever pass you're writing and use it when you need it.

410
00:29:34,280 --> 00:29:36,280
Right?

411
00:29:37,279 --> 00:29:45,279
So over lunch, the task is that you guys should get LLVM running.

412
00:29:45,279 --> 00:29:49,279
If it allows NFS mounting, then you can do it.

413
00:29:49,279 --> 00:29:56,279
Otherwise, no, then all of you will have to switch with the same user.

414
00:29:56,279 --> 00:30:00,279
Otherwise, you will have all of you have users on that.

415
00:30:00,279 --> 00:30:04,279
All of you have got users on that.

416
00:30:04,279 --> 00:30:06,279
Then you can we can use that also.

417
00:30:06,279 --> 00:30:07,279
That's not a problem.

418
00:30:07,279 --> 00:30:09,279
So over lunch, I'll try to sit with one of you if possible.

419
00:30:09,279 --> 00:30:12,279
And I'll try to see if we are able to install the packages on this.

420
00:30:12,279 --> 00:30:15,279
If you can, then we have a decentralized thing.

421
00:30:15,279 --> 00:30:16,279
You can easily work.

422
00:30:16,279 --> 00:30:20,279
If not, then I'll try to see if we can use that particular server.

423
00:30:20,279 --> 00:30:23,279
Any questions on this so far?

424
00:30:23,279 --> 00:30:24,279
Are we clear on this?

425
00:30:24,279 --> 00:30:28,279
So first is use LLVM to compile it into a binary.

426
00:30:28,279 --> 00:30:32,279
Second is compile your pass as a shared library.

427
00:30:32,279 --> 00:30:41,279
Third is load LLVM, load your library, your pass into LLVM using minus load option.

428
00:30:41,279 --> 00:30:44,279
Fourth is invoke your pass using the option that you provide.

429
00:30:44,279 --> 00:30:46,279
Fifth is how to write a pass, right?

430
00:30:46,279 --> 00:30:53,279
Derive from the function pass and override the run on function method and register your pass.

431
00:30:53,279 --> 00:30:58,279
What is a pass? What should you register?

432
00:30:58,279 --> 00:31:00,279
Excellent question. Maybe I should have said more.

433
00:31:00,279 --> 00:31:03,279
So how is a compiler designed?

434
00:31:03,279 --> 00:31:11,279
So the compiler has a front end which compiles the source code into some sort of an intermediate representation.

435
00:31:11,279 --> 00:31:13,279
What is an intermediate representation?

436
00:31:13,279 --> 00:31:19,279
An intermediate representation is just a data structure, a data structure which holds the program, right?

437
00:31:19,279 --> 00:31:28,279
And towards the end of the compiler, there is a back end pass which essentially takes this data structure, right?

438
00:31:28,279 --> 00:31:32,279
And compiles it down to a target language.

439
00:31:32,279 --> 00:31:36,279
X86, MIPS, whatever you have, whatever you need.

440
00:31:36,279 --> 00:31:41,279
So between these passes sits a lot of transformations, a lot of optimizations.

441
00:31:41,279 --> 00:31:47,279
We try to make the program better for users, like maybe for better speed, for less memory, whatever it is.

442
00:31:47,279 --> 00:31:52,279
Now these passes, so these are called optimization passes, right?

443
00:31:52,279 --> 00:31:57,279
Now these optimization passes are structured as, so it's like a train, right?

444
00:31:57,279 --> 00:32:05,279
So the IR enters through one end of the pass and exits through the other end of the pass.

445
00:32:05,279 --> 00:32:09,279
Again enters the next coach and exits out of the next coach.

446
00:32:09,279 --> 00:32:11,279
So it just flows through the passes like this.

447
00:32:11,279 --> 00:32:15,279
So passes are like a train, they are like joined with each other.

448
00:32:15,279 --> 00:32:21,279
And this joining of coaches or passes you can do in any manner you wish, right?

449
00:32:21,279 --> 00:32:28,279
So in LLVM if you give it the option in that sequence, it will put up those passes in that sequence, right?

450
00:32:28,279 --> 00:32:36,279
Every pass accepts an IR, the IR data structure and emits an IR data structure.

451
00:32:36,279 --> 00:32:39,279
It's an in-memory data structure, right?

452
00:32:39,279 --> 00:32:43,279
So it takes in a data structure and exits the same data structure back.

453
00:32:43,279 --> 00:32:48,279
But in the meanwhile, it is allowed to change the data structure, right?

454
00:32:48,279 --> 00:32:50,279
It can, like now it's a data structure.

455
00:32:50,279 --> 00:32:53,279
So what does an IR data structure look like for this particular IR?

456
00:32:53,279 --> 00:33:01,279
It can simply be a linked list of, so every node in the linked list being a statement and it's a linked list of statements.

457
00:33:01,279 --> 00:33:03,279
As simple as that, right?

458
00:33:03,279 --> 00:33:11,279
That list is passed as an input to every pass and that linked list goes out from every pass and enters the next pass.

459
00:33:11,279 --> 00:33:16,279
In between this pass, if it is, for instance, does dead code elimination, what will it do?

460
00:33:16,279 --> 00:33:21,279
It will simply remove one node in the linked list, right?

461
00:33:21,279 --> 00:33:23,279
It has transformed the program.

462
00:33:23,279 --> 00:33:27,279
So the program has not been written yet, but it has only been in memory.

463
00:33:27,279 --> 00:33:30,279
We are changing the program, right?

464
00:33:30,279 --> 00:33:36,279
So each of these coaches in my train is basically a pass, is referred to as a pass.

465
00:33:36,279 --> 00:33:40,279
Now I can exploit the same architecture even to do analysis.

466
00:33:40,279 --> 00:33:42,279
I don't care.

467
00:33:42,279 --> 00:33:44,279
I'll not change the representation.

468
00:33:44,279 --> 00:33:46,279
But I can still look at the representation, right?

469
00:33:46,279 --> 00:33:51,279
I can still look at the representation and I can dump the output onto the screen or add it to a file.

470
00:33:51,279 --> 00:33:54,279
I'll not change that representation.

471
00:33:54,279 --> 00:34:00,279
So instead of doing an optimization which will change the representation of the program or change the program,

472
00:34:00,279 --> 00:34:07,279
it will simply look at the program, analyze the program, and write the result to a file or to the target output.

473
00:34:07,279 --> 00:34:09,279
So these are called passes.

474
00:34:09,280 --> 00:34:15,280
So now LLVM has to know, see, because it has such a strict notion of LLVM must know from it.

475
00:34:15,280 --> 00:34:17,280
So think about it.

476
00:34:17,280 --> 00:34:19,280
What is LLVM doing internally?

477
00:34:19,280 --> 00:34:26,280
So internally LLVM, whenever you say a register pass, LLVM is maintaining some sort of a hash table which says that,

478
00:34:26,280 --> 00:34:34,280
OK, I have a new pass and a function pointer to the run on function method for it, right?

479
00:34:34,280 --> 00:34:42,280
So whenever on the command line you give that pass, it fetches that function pointer and calls that run on method, run on function method for that.

480
00:34:42,280 --> 00:34:49,280
So there is a loop inside LLVM which will simply call the run on function method for every pass that you have mentioned on the command line.

481
00:34:49,280 --> 00:34:50,280
Just a loop.

482
00:34:50,280 --> 00:34:51,280
We're just calling it one after the other.

483
00:34:51,280 --> 00:34:54,280
That is all it is doing with every function that it has.

484
00:34:54,280 --> 00:35:00,280
So to be able to call that method, it is important that LLVM knows that what is the method to be called.

485
00:35:00,280 --> 00:35:04,280
That is why we have overwritten a derived classes method.

486
00:35:04,280 --> 00:35:09,280
So everybody must derive from that function pass so that I can run that loop.

487
00:35:09,280 --> 00:35:16,280
And I must be overriding this particular method, run on function, because it will be running the loop on that particular function.

488
00:35:16,280 --> 00:35:17,280
Does it make sense?

489
00:35:17,280 --> 00:35:20,280
That is, yeah, you had a question?

490
00:35:20,280 --> 00:35:23,280
Sir, every compiler has its own set of passes.

491
00:35:23,280 --> 00:35:24,280
Yes.

492
00:35:24,280 --> 00:35:29,280
Every compiler has its own set of passes and every compiler has its own intermediate representation.

493
00:35:29,280 --> 00:35:30,280
Right?

494
00:35:30,280 --> 00:35:33,280
And that is why I said there is no the intermediate representation.

495
00:35:33,280 --> 00:35:35,280
There is only a intermediate representation.

496
00:35:35,280 --> 00:35:41,280
If you write your own compiler, you can come up with whatever intermediate representation you think you want to come up with.

497
00:35:41,280 --> 00:35:45,280
So in intermediate representation, there can be many, many types of intermediate representations.

498
00:35:45,280 --> 00:35:49,280
There is something known as a HIR or high level intermediate representation.

499
00:35:49,280 --> 00:35:52,280
These are representations which are look very close to the source code.

500
00:35:52,280 --> 00:35:54,280
They look almost similar to the source code.

501
00:35:54,280 --> 00:35:55,280
They might even have.

502
00:35:55,280 --> 00:36:06,280
So what all they might do is they might remove for loop, then do while loop, repeat until they might remove those and it may replace it by one loop statement.

503
00:36:06,280 --> 00:36:07,280
Right?

504
00:36:07,280 --> 00:36:08,280
But it is still a loop.

505
00:36:08,280 --> 00:36:10,280
It is still not a if then else.

506
00:36:10,280 --> 00:36:11,280
Right?

507
00:36:11,280 --> 00:36:14,280
So it can still preserve the structure of the code.

508
00:36:14,280 --> 00:36:18,280
But array indices, the array offsets, everything might be maintained.

509
00:36:18,280 --> 00:36:22,280
Arrays might be even if they're multi-dimensional arrays, it might still maintain that.

510
00:36:22,280 --> 00:36:29,280
Then there is something called MIR or medium level intermediate representation, which is generally a three-address code.

511
00:36:29,280 --> 00:36:30,280
Right?

512
00:36:30,280 --> 00:36:31,280
Again, there can be variants of that MIR.

513
00:36:31,280 --> 00:36:33,280
Somewhere you might want to keep arrays.

514
00:36:33,280 --> 00:36:35,280
Somewhere you might say that I do not have multi-dimensional arrays.

515
00:36:35,280 --> 00:36:37,280
I only have single dimensional arrays.

516
00:36:37,280 --> 00:36:39,280
Somewhere you might say I don't even want an array.

517
00:36:39,280 --> 00:36:41,280
I just look to a point of the difference.

518
00:36:41,280 --> 00:36:42,280
Right?

519
00:36:42,280 --> 00:36:49,280
And eventually you can have a low level IR, LIR, which is very similar to what LLBM has, which looks very close to the machine code.

520
00:36:49,280 --> 00:36:53,280
So if you look at it, this is actually looks like machine code.

521
00:36:53,280 --> 00:36:54,280
Right?

522
00:36:54,280 --> 00:37:02,280
So you when you write your compiler, you write your own passes, you write your own data structure or IR on which you are going to work on.

523
00:37:02,280 --> 00:37:03,280
Again, a very good question.

524
00:37:03,280 --> 00:37:11,280
So seeing which order a set of passes have to be done is a very difficult problem.

525
00:37:11,280 --> 00:37:13,280
So this is what a phase ordering problem.

526
00:37:13,280 --> 00:37:14,280
So I'll not get into it.

527
00:37:14,280 --> 00:37:21,280
But essentially one option is that you tell the compiler that this is the order you want to pass this to be on.

528
00:37:21,280 --> 00:37:23,280
So you can on this command line, you can specify it.

529
00:37:23,280 --> 00:37:33,280
Otherwise, what compilers do it is that they already have a predefined sequence which seems to work well for most cases.

530
00:37:33,280 --> 00:37:34,280
Right?

531
00:37:34,280 --> 00:37:40,280
So compiler experts will come together, scratch their heads, tear their head apart, fight with each other and decide that, OK, on my compiler,

532
00:37:40,280 --> 00:37:45,280
this sequence of this sequence of running the passes works very well.

533
00:37:45,280 --> 00:37:51,280
And these are the passes that you see in a traditional compiler like like even LLBM or even for that matter, GCC.

534
00:37:51,280 --> 00:38:01,280
If you give the option minus O2 or minus O3, what it does is basically pull some sequence of some some order of these passes.

535
00:38:01,280 --> 00:38:04,280
It says that, well, I'll run these passes and I'll run them in this order.

536
00:38:04,280 --> 00:38:06,280
So you just say O2, it will do something good for you.

537
00:38:06,280 --> 00:38:07,280
That is all you know.

538
00:38:07,280 --> 00:38:08,280
That will not be best for you.

539
00:38:08,280 --> 00:38:11,280
If you really know what your program is doing, you may be able to do it better.

540
00:38:11,280 --> 00:38:14,280
But that is known to be doing well for most programs.

541
00:38:14,280 --> 00:38:20,280
In fact, figuring out what is the best ordering on passes is a very important question and an open question.

542
00:38:20,280 --> 00:38:21,280
Excellent question.

543
00:38:21,280 --> 00:38:22,280
Anything else?

544
00:38:22,280 --> 00:38:26,280
So do we understand the high level idea of what's going on and even the low level idea how to get it done?

545
00:38:26,280 --> 00:38:28,280
Works for you?

546
00:38:28,280 --> 00:38:33,280
OK, so now let's do one more small thing before we break.

547
00:38:33,280 --> 00:38:34,280
When do we break for lunch?

548
00:38:34,280 --> 00:38:36,280
One thirty.

549
00:38:36,280 --> 00:38:37,280
One thirty.

550
00:38:37,280 --> 00:38:38,280
One.

551
00:38:38,280 --> 00:38:40,280
Still not hungry.

552
00:38:43,280 --> 00:38:47,280
OK, so right.

553
00:38:47,280 --> 00:38:51,280
So let us now look at trying to do some control for analysis.

554
00:38:51,280 --> 00:38:53,280
How will we do control for analysis?

555
00:38:53,280 --> 00:38:59,280
So I don't really have too much of code, but I'll just show you something.

556
00:38:59,280 --> 00:39:06,280
So essentially now I can write this as a control flow again as a function pass.

557
00:39:06,280 --> 00:39:13,280
So because I will be doing control for analysis on a function to function basis, we are going to do intra procedural analysis.

558
00:39:13,280 --> 00:39:16,280
So so there are some IR.

559
00:39:16,280 --> 00:39:20,280
So you will see some new sorry, some include files and you'll see some new include files.

560
00:39:20,280 --> 00:39:23,280
So there is include file on basic blocks.

561
00:39:23,280 --> 00:39:24,280
You know what a basic block is.

562
00:39:24,280 --> 00:39:26,280
There is include file for a CFG.

563
00:39:26,280 --> 00:39:27,280
You know what a CFG is.

564
00:39:27,280 --> 00:39:30,280
So LLVM already constructs these data structures for you.

565
00:39:30,280 --> 00:39:33,280
You can directly use it as it is.

566
00:39:33,280 --> 00:39:47,280
Then so when you say run on function, essentially you can say FCAG get entry block, which will give you the entry basic block of your control flow graph of your CFG.

567
00:39:47,280 --> 00:39:48,280
Right.

568
00:39:48,280 --> 00:39:54,280
Then it has these methods successor begin and successor end.

569
00:39:54,280 --> 00:40:04,280
So if you say successor begin on a basic block, it will give an iterator over the successor successors of the basic block.

570
00:40:04,280 --> 00:40:09,280
Similarly, you can do it on predecessors also if you want to.

571
00:40:09,280 --> 00:40:10,280
Right.

572
00:40:10,280 --> 00:40:20,280
Plus it has support for like sets and stacks and all these things, whatever data structures you would like to get it running.

573
00:40:20,280 --> 00:40:26,280
So now what we would like to do is we will try to build one simple control flow analysis.

574
00:40:26,280 --> 00:40:34,280
Let us try to do the figuring out the basic blocks in a in a loop, then finding out a natural loop of a program.

575
00:40:34,280 --> 00:40:37,280
It's a simple algorithm that is not much there.

576
00:40:37,280 --> 00:40:40,280
Right. It's like maybe eight to nine lines of code.

577
00:40:40,280 --> 00:40:44,280
Right. But you will still end up writing some code in LLVM.

578
00:40:44,280 --> 00:40:46,280
And all you need is almost here.

579
00:40:46,280 --> 00:40:47,280
Right.

580
00:40:47,280 --> 00:40:50,280
Successor begins successor end. Instead, you do predecessor begin.

581
00:40:50,280 --> 00:40:55,280
So put it in a stack and then pop it off the stack and keep on iterating.

582
00:40:55,280 --> 00:40:58,280
After we have done this, we will spend some time on this.

583
00:40:58,280 --> 00:41:00,280
And after that, we will start with data flow analysis.

