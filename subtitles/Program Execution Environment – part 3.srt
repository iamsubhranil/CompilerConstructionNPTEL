1
00:00:00,000 --> 00:00:09,439
The next topic which we are going to dive into is the object files.

2
00:00:09,439 --> 00:00:14,099
So remember the compilation steps which we saw earlier.

3
00:00:14,099 --> 00:00:21,480
So the compiler produced the textual assembly file, which was fed to the assembler to produce

4
00:00:21,480 --> 00:00:22,780
the object file.

5
00:00:22,780 --> 00:00:27,719
So we will first look at what is object file and what all it contains and then we will

6
00:00:27,719 --> 00:00:33,039
go into details of assembler and linker on how they operate with these files.

7
00:00:33,039 --> 00:00:39,759
So object file is essentially a file which has the machine code which is produced by

8
00:00:39,759 --> 00:00:44,200
the assembler and whatever is the related data for it.

9
00:00:44,200 --> 00:00:50,120
Now in most common cases the object file itself will be stored as a binary file.

10
00:00:50,120 --> 00:00:52,920
It will not be a text file.

11
00:00:52,920 --> 00:00:56,060
But there is no rule that object file has to be a binary file.

12
00:00:56,620 --> 00:01:02,820
In most common cases it is done that way because it allows linker to efficiently process that

13
00:01:02,820 --> 00:01:03,820
input.

14
00:01:03,820 --> 00:01:08,980
If you had an object file which was textual then linker needed to deal with lot of strings

15
00:01:08,980 --> 00:01:11,859
and ASCII which slows it down.

16
00:01:11,859 --> 00:01:17,260
So in most common cases you will find that the object files are in actually binary form.

17
00:01:17,260 --> 00:01:18,680
And what is in the object file?

18
00:01:18,680 --> 00:01:24,879
So we need some way to hold the instructions which were generated by the assembler.

19
00:01:24,879 --> 00:01:29,399
So MOV instruction in its binary encoding form.

20
00:01:29,399 --> 00:01:35,199
We need some way to say that there is a variable called GBL which was initialized to value

21
00:01:35,199 --> 00:01:37,840
5, 6, 7 whatever.

22
00:01:37,840 --> 00:01:42,439
So this is the core information which we need to store in the object file.

23
00:01:42,439 --> 00:01:46,879
Whatever is the data of your program and whatever are the set of instructions which it is supposed

24
00:01:46,879 --> 00:01:48,640
to run.

25
00:01:48,640 --> 00:01:53,519
But object file needs to have some more details for linker to operate correctly.

26
00:01:53,519 --> 00:01:58,759
For example object file needs to have information in terms of what all is defined in this object

27
00:01:58,759 --> 00:02:03,560
file and what all is referenced in this object file but not defined.

28
00:02:03,560 --> 00:02:10,439
For example remember we had int GBL in one file and extern int GBL in other file.

29
00:02:10,439 --> 00:02:15,479
So somehow we need to record the information in the object file that GBL is referenced

30
00:02:15,479 --> 00:02:18,219
in this file but it is not defined here.

31
00:02:18,219 --> 00:02:24,180
And in the other files, in the other object file we need to say GBL is defined here and

32
00:02:24,180 --> 00:02:29,379
that will be used by linker to actually merge the inputs together.

33
00:02:29,379 --> 00:02:34,659
So there are three forms of an object file.

34
00:02:34,659 --> 00:02:37,699
The first one is called as relocatable object file.

35
00:02:37,699 --> 00:02:42,419
So someone had question at very beginning of the session on what is a relocatable object

36
00:02:42,419 --> 00:02:43,699
file.

37
00:02:43,699 --> 00:02:48,819
So relocatable object file is the one which is actually produced by the assembler or compiler

38
00:02:48,819 --> 00:02:50,859
for that matter.

39
00:02:50,859 --> 00:02:56,859
It represents that it is not the final thing which can be loaded into the memory.

40
00:02:56,859 --> 00:03:04,000
So it is an object file which may have references which are not defined in that object file.

41
00:03:04,000 --> 00:03:09,099
So for example when you compile something and if it has a external reference which will

42
00:03:10,099 --> 00:03:15,579
by another object file then this file cannot be run directly because we have to first resolve

43
00:03:15,579 --> 00:03:17,060
that dependency.

44
00:03:17,060 --> 00:03:22,579
So dependencies are not resolved and that is typically an relocatable object file.

45
00:03:22,579 --> 00:03:29,299
It is called relocatable because it gets relocated first before it can be loaded into the memory

46
00:03:29,299 --> 00:03:37,219
and we will get into details of what exactly relocatable means as we learn the linker part.

47
00:03:37,219 --> 00:03:39,580
Then there is a executable object file.

48
00:03:39,580 --> 00:03:44,659
So executable object file is the one which has all the dependencies sorted out and is

49
00:03:44,659 --> 00:03:47,539
something which is now ready to run.

50
00:03:47,539 --> 00:03:53,300
So when you produce a.out in your program it is actually an executable file.

51
00:03:53,300 --> 00:03:58,020
When you produce .o file it is a relocatable object file.

52
00:03:58,020 --> 00:04:02,759
Then there is something called a shared object file which is essentially you might have seen

53
00:04:02,759 --> 00:04:10,000
these files on your Linux or Windows machine which have .dll extension, something .dll

54
00:04:10,000 --> 00:04:11,759
or something .so.

55
00:04:11,759 --> 00:04:17,899
So these will be the shared object files and we will get into details of why they are needed.

56
00:04:17,899 --> 00:04:22,759
So let us say I told you that it is in the binary form.

57
00:04:22,759 --> 00:04:25,360
So what format it actually follows.

58
00:04:25,360 --> 00:04:28,199
So again this is a platform specific things.

59
00:04:28,199 --> 00:04:31,959
Different platforms will have different object files.

60
00:04:31,959 --> 00:04:37,159
There is something called as .cof, a binary file format called .cof which stands for common

61
00:04:37,159 --> 00:04:39,639
object file format.

62
00:04:39,639 --> 00:04:44,839
This was actually introduced in the first Unix implementations.

63
00:04:44,839 --> 00:04:49,959
Then there is something called as .pe which is portable executable.

64
00:04:49,959 --> 00:04:54,319
This is the format which is actually used on Windows.

65
00:04:54,319 --> 00:05:01,319
So the .exe which is produced on Windows files, Windows platforms is actually in .pe

66
00:05:01,319 --> 00:05:04,839
format and it is a derivative of .cof.

67
00:05:04,839 --> 00:05:10,800
So .cof format defines something and then .exe format is very similar to that.

68
00:05:10,800 --> 00:05:15,339
Then there is something called as .elf which is what we will actually study in this class.

69
00:05:15,339 --> 00:05:22,879
So .elf is actually a binary format which is used on Linux and related operating system.

70
00:05:22,879 --> 00:05:28,600
So anything which is a derivative of Unix like Solaris other things use .elf.

71
00:05:28,600 --> 00:05:31,519
.elf is also used by lot of other things.

72
00:05:31,519 --> 00:05:37,519
For example, CUDA from NVIDIA uses .elf format for storing the binaries.

73
00:05:37,519 --> 00:05:42,399
PlayStation 3, PlayStation 4 binaries are stored in the .elf format.

74
00:05:42,399 --> 00:05:47,439
So it is kind of very widely used and that is why we will focus mostly on .elf in this

75
00:05:47,439 --> 00:05:48,439
class.

76
00:05:48,439 --> 00:05:53,240
Whatever concepts we are teaching on what goes into the object file, the same things

77
00:05:53,240 --> 00:05:58,399
will need to be stored in .cof as well as .pe just that the format in which they are

78
00:05:58,399 --> 00:06:01,040
stored will be different.

79
00:06:01,040 --> 00:06:06,560
And then there is Maco which is essentially used on the Mac platform.

80
00:06:06,560 --> 00:06:12,420
So given a file, how do you determine which file I am dealing with?

81
00:06:12,420 --> 00:06:15,360
So there is a Unix command called file.

82
00:06:15,360 --> 00:06:23,240
So if you do file on something, it tells you actually what type of file it is.

83
00:06:23,240 --> 00:06:32,639
To show this as a demo, so let us say I had this program.

84
00:06:32,639 --> 00:06:39,680
So when I do gcc-c sample.c, I have produced sample.o file.

85
00:06:39,759 --> 00:06:51,079
And if I do file on sample.o, it says it is a .elf file which is 64 bit and it is relocatable,

86
00:06:51,079 --> 00:06:53,000
which is what we had seen earlier.

87
00:06:53,000 --> 00:07:00,879
Now if I do say dash m32 which tells gcc to compile for 32 bit and if I do file again,

88
00:07:00,879 --> 00:07:06,040
you will see now it is .elf which is 32 bit and relocatable.

89
00:07:06,040 --> 00:07:11,120
So there is some information in the object file which is helping file command determine

90
00:07:11,120 --> 00:07:13,800
what type of file it is.

91
00:07:13,800 --> 00:07:16,960
Now let us look at gcc-sample.c.

92
00:07:16,960 --> 00:07:22,680
I produce an executable file and I do file a.out.

93
00:07:22,680 --> 00:07:29,240
I see it is a .elf file, but it is an executable.

94
00:07:29,240 --> 00:07:32,040
It is not relocatable.

95
00:07:32,040 --> 00:07:34,900
And then there is a bunch of other information.

96
00:07:34,899 --> 00:07:40,299
The file command helps you determine what type of file it is.

97
00:07:40,299 --> 00:07:48,620
Now there are various tools which you can use on Linux to examine the contents of the

98
00:07:48,620 --> 00:07:51,339
object files.

99
00:07:51,339 --> 00:07:56,699
There is a command called objdump which we will heavily use in this class.

100
00:07:56,699 --> 00:08:03,219
So objdump is essentially will dump the content of the object files.

101
00:08:03,220 --> 00:08:06,140
And objdump works on any type of object file.

102
00:08:06,140 --> 00:08:09,180
It is not sensitive to a particular format.

103
00:08:09,180 --> 00:08:13,340
For example, I can use objdump on a.exe.

104
00:08:13,340 --> 00:08:20,660
Just to show you, so I have windows also on my, so my machine is actually windows.

105
00:08:20,660 --> 00:08:25,220
So I will create.

106
00:08:26,220 --> 00:08:45,379
So let us say I have, so say I create some program.

107
00:08:45,379 --> 00:08:51,620
I am using gcc even on windows because I have sigwin installed, but it could be a Microsoft

108
00:08:51,620 --> 00:08:52,700
compiler.

109
00:08:52,700 --> 00:08:59,140
Now if I do a.exe, you can see actually file command was able to detect it is a pe file.

110
00:08:59,140 --> 00:09:03,540
It did not say it is a .elf file because this was on windows.

111
00:09:03,540 --> 00:09:11,300
And objdump is actually capable of dumping this, something about it.

112
00:09:11,300 --> 00:09:12,820
We will see more details.

113
00:09:12,820 --> 00:09:18,759
And similarly objdump can dump even for this.

114
00:09:18,759 --> 00:09:27,720
So objdump is a tool which can be used to dump contents of any object file.

115
00:09:27,720 --> 00:09:38,639
Nm is a command which can be used to dump various symbols from the object files.

116
00:09:38,639 --> 00:09:43,179
Then there is something called as readelf which is essentially specific to elf.

117
00:09:43,179 --> 00:09:48,399
If you know that object file is elf, then you can use readelf to read various parts

118
00:09:48,399 --> 00:09:50,120
of the elf file.

119
00:09:50,120 --> 00:09:54,240
Similarly there is something called as dumpbin which is on Microsoft windows which can be

120
00:09:54,240 --> 00:09:57,799
used to dump various contents of the pe file.

121
00:09:57,799 --> 00:10:02,159
In this class we will mostly use objdump and readelf.

122
00:10:02,159 --> 00:10:07,139
But I just wanted to list these so that you are aware that there are various tools.

123
00:10:07,139 --> 00:10:09,279
Now let us look at elf.

124
00:10:09,279 --> 00:10:15,659
So elf is actually a format which can be used for all the three types of object files.

125
00:10:15,659 --> 00:10:22,139
So elf can be used to represent a relocatable file and typically has extension dot o.

126
00:10:22,139 --> 00:10:27,980
Elf can be used to represent an executable file which typically has extension dot out.

127
00:10:27,980 --> 00:10:35,279
And elf can also be used to represent shared object file which typically has dot so extension.

128
00:10:35,279 --> 00:10:41,039
Now if you look at the elf structure itself, this is how elf organizes information in

129
00:10:41,039 --> 00:10:43,019
the object file.

130
00:10:43,019 --> 00:10:50,159
So the content of the object file can be thought of as set of instructions which were produced

131
00:10:50,159 --> 00:10:56,539
by the assembler, set of various data elements which were present in the object file.

132
00:10:56,539 --> 00:11:00,759
All of this is organized into sections.

133
00:11:00,759 --> 00:11:06,000
So there are sections, one section representing one type of data.

134
00:11:06,000 --> 00:11:10,779
So there will be a text section which will have whose content will be the binary encoding

135
00:11:10,779 --> 00:11:12,779
of the instructions.

136
00:11:12,779 --> 00:11:18,559
There will be data section whose content will be whatever global variables etc you have

137
00:11:18,559 --> 00:11:20,819
declared in your program.

138
00:11:20,819 --> 00:11:26,379
Now what elf does is elf has something called as elf header at the start.

139
00:11:26,379 --> 00:11:33,500
Elf header describes various information on where to locate other parts of the elf file.

140
00:11:33,500 --> 00:11:36,779
There is something called as a section header.

141
00:11:36,779 --> 00:11:41,919
So section header will describe the information about various sections.

142
00:11:41,919 --> 00:11:46,219
So section headers will have information about where is the text section present, where is

143
00:11:46,219 --> 00:11:48,599
the data section present and so on.

144
00:11:48,599 --> 00:11:51,819
And section headers will essentially point to the contents.

145
00:11:51,819 --> 00:11:55,559
There is also something called as program headers which we will get to when we actually

146
00:11:55,559 --> 00:11:58,979
look at how programs are executed.

147
00:11:58,979 --> 00:12:02,559
So if you look at elf, this is how it looks.

148
00:12:02,559 --> 00:12:05,980
So elf starts with an elf header.

149
00:12:05,980 --> 00:12:08,599
Then there is an optional program header.

150
00:12:08,600 --> 00:12:13,779
Then there are various sections in which the data is actually organized.

151
00:12:13,779 --> 00:12:16,800
And then there is something called as a section header table.

152
00:12:16,800 --> 00:12:23,860
So section elf header actually has information on where to locate the section header table.

153
00:12:23,860 --> 00:12:30,639
So elf header will tell information about where is the section header table present.

154
00:12:30,639 --> 00:12:37,200
Section header table will have pointers to various sections from which you can locate

155
00:12:37,240 --> 00:12:39,340
the sections.

156
00:12:39,340 --> 00:12:41,920
And this is what linker sees.

157
00:12:41,920 --> 00:12:47,879
So the linking view is what is in the relocatable elf.

158
00:12:47,879 --> 00:12:52,720
Relocatable elf will have information in this format where you will have information organized

159
00:12:52,720 --> 00:12:57,160
into sections and there will be a section header table.

160
00:12:57,160 --> 00:13:04,440
When elf is produced as an executable file, it has something called as segments which

161
00:13:04,440 --> 00:13:09,460
you can think of as something formed out of collection of sections.

162
00:13:09,460 --> 00:13:12,560
So segments are collection of sections.

163
00:13:12,560 --> 00:13:17,240
And then there is a program header table which has information about where the different

164
00:13:17,240 --> 00:13:21,400
segments are.

165
00:13:21,400 --> 00:13:23,880
Is it clear?

166
00:13:23,880 --> 00:13:28,780
So just to summarize, the elf will have elf header which will have pointer to section

167
00:13:28,780 --> 00:13:30,240
header table.

168
00:13:30,240 --> 00:13:34,720
And section header table will have information about various sections, where to find them

169
00:13:34,720 --> 00:13:36,480
and so on.

170
00:13:36,480 --> 00:13:41,960
Now if you look at the elf header itself, elf header always starts at byte 0 of the

171
00:13:41,960 --> 00:13:42,960
file.

172
00:13:42,960 --> 00:13:49,080
So if I have the elf file, the byte 0 will actually always be start of the elf header.

173
00:13:49,080 --> 00:13:51,960
So elf header is always at the deterministic position.

174
00:13:51,960 --> 00:13:57,200
Rest of the things in the elf could be at any place, but the elf header always has to

175
00:13:57,200 --> 00:14:00,080
be at 0th position.

176
00:14:00,080 --> 00:14:08,560
And it has information about what type of machine the elf is produced for, what type

177
00:14:08,560 --> 00:14:14,920
of ABI it is following, where is the section header table and so on.

178
00:14:14,920 --> 00:14:16,600
So you can actually do this.

179
00:14:16,600 --> 00:14:29,620
So if I compile any program, so I have compiled a program with dash c.

180
00:14:29,740 --> 00:14:37,899
If I do readelf dash h sample.o, readelf is the command which is used to read the elf

181
00:14:37,899 --> 00:14:38,899
file.

182
00:14:38,899 --> 00:14:44,480
Dash h is telling headers, display me the header from sample.o.

183
00:14:44,480 --> 00:14:48,019
You will see an output like this.

184
00:14:48,019 --> 00:14:52,940
Now to demystify this output, let us look at some interesting aspect.

185
00:14:52,940 --> 00:14:57,860
So it is saying that the class of this file is elf32.

186
00:14:57,860 --> 00:15:02,539
It is saying version of this file is 1.

187
00:15:02,539 --> 00:15:05,419
There is something called as os slash ABI.

188
00:15:05,419 --> 00:15:09,580
It is saying it is a Unix system 5 binary.

189
00:15:09,580 --> 00:15:11,419
The ABI version is 0.

190
00:15:11,419 --> 00:15:12,980
Type is rel.

191
00:15:12,980 --> 00:15:17,060
rel is essentially indicating it is a relocatable file.

192
00:15:17,060 --> 00:15:24,460
And the machine for which this file is present is intel 80386.

193
00:15:24,460 --> 00:15:31,860
All of this information is present in header because this can help eliminate mismatching

194
00:15:31,860 --> 00:15:32,860
elves.

195
00:15:32,860 --> 00:15:41,580
For example, let us say I give linker one file which was produced for windows and one

196
00:15:41,580 --> 00:15:45,019
elf file which was produced for Linux.

197
00:15:45,019 --> 00:15:49,420
Can linker link them together?

198
00:15:49,419 --> 00:15:54,819
It cannot link them together for one reason because windows and Linux might be following

199
00:15:54,819 --> 00:15:55,819
different ABI.

200
00:15:55,819 --> 00:16:01,500
If they were following same ABI, linker in theory could link them together.

201
00:16:01,500 --> 00:16:06,419
Similarly, can you link x86 code with ARM code?

202
00:16:06,419 --> 00:16:10,059
No because these are going to be different processors.

203
00:16:10,059 --> 00:16:15,299
The same binary bits might be interpreted differently by different processor.

204
00:16:16,139 --> 00:16:23,579
If add means 5 to x86, add 5 might mean LD to ARM processor.

205
00:16:23,579 --> 00:16:25,819
You cannot mix and match things.

206
00:16:25,819 --> 00:16:29,620
That is why some of these information is present directly in header.

207
00:16:29,620 --> 00:16:39,419
Linker can ensure that whatever files are being fed to the linker have consistent information.

208
00:16:39,419 --> 00:16:43,899
And then there is something called as magic which you are seeing at the start.

209
00:16:43,899 --> 00:16:53,819
The first 4 bytes of the file will be these 7f, 40f5, 4c, 46.

210
00:16:53,819 --> 00:17:00,419
If you leave the 7f part out, this is actually ASCII value of elf.

211
00:17:00,419 --> 00:17:10,099
So 45 in hex is actually capital E, 4c is capital L and 46 is f.

212
00:17:10,099 --> 00:17:17,339
So elf, to identify a file as elf, you can simply read first 4 bytes of the file and

213
00:17:17,339 --> 00:17:24,779
see whether they are 7f, elf and that tells you that it is an elf file.

214
00:17:24,779 --> 00:17:29,099
And then remaining is the structure of the header.

215
00:17:29,099 --> 00:17:32,899
If you look at the actual structure, this is how it looks.

216
00:17:32,899 --> 00:17:38,259
So the first 4 bytes are magic which are telling elf.

217
00:17:38,259 --> 00:17:44,420
Then there is object file class, data encoding version, ABI version, what is the type of

218
00:17:44,420 --> 00:17:49,420
file, what is a machine, version and bunch of other things.

219
00:17:49,420 --> 00:17:55,819
The interesting thing is this shof which is essentially offset in the file where the section

220
00:17:55,819 --> 00:17:57,779
header table begins.

221
00:17:57,779 --> 00:18:04,819
So if this offset value is say 1000, that means if you read byte 1000, that is where

222
00:18:04,819 --> 00:18:07,539
the section header starts.

223
00:18:07,539 --> 00:18:09,299
Does that make sense?

224
00:18:09,299 --> 00:18:12,500
So you have an assignment to do now.

225
00:18:12,500 --> 00:18:16,019
This is actually coding assignment, you have to program things.

226
00:18:16,019 --> 00:18:24,579
Where you have to write a C program or C++ program which will take an elf file as an

227
00:18:24,579 --> 00:18:30,700
input, a relocatable elf file as an input from command line argument or you can hard

228
00:18:30,700 --> 00:18:37,119
code it, it does not matter how you take that file as the input and read the elf header

229
00:18:37,319 --> 00:18:38,799
from that file.

230
00:18:38,799 --> 00:18:44,759
And the structure of the elf header itself is documented at this location.

231
00:18:44,759 --> 00:18:46,699
Is the assignment clear?

232
00:18:46,699 --> 00:18:53,559
So you have to open that file for reading and you have to read size of the elf header

233
00:18:53,559 --> 00:19:01,079
data from the start of the file and interpret that data according to the structure given

234
00:19:01,079 --> 00:19:06,399
here and print out these 4 fields.

235
00:19:06,400 --> 00:19:10,840
I will keep this structure on the slide so you can see.

236
00:19:10,840 --> 00:19:14,840
But it is in user include elf.h.

237
00:19:14,840 --> 00:19:20,440
So the question is to be able to read, so your program should read a file which will

238
00:19:20,440 --> 00:19:25,880
be actually a relocatable elf which you might have produced using compiler.

239
00:19:25,880 --> 00:19:29,600
Read the content of the elf header.

240
00:19:29,600 --> 00:19:33,040
Remember header is always at the start of the elf file.

241
00:19:33,039 --> 00:19:42,319
So if you read this much structure in the file you will have read the elf header.

242
00:19:42,319 --> 00:19:44,319
Is the assignment clear?

243
00:19:44,319 --> 00:19:47,440
Are we good with it?

244
00:19:47,440 --> 00:19:50,039
Can we move on?

245
00:19:50,039 --> 00:19:59,039
So now let us look at various aspects of program and how they map to various things in the

246
00:19:59,039 --> 00:20:00,399
elf.

247
00:20:00,400 --> 00:20:02,759
So let us say I have this program.

248
00:20:02,759 --> 00:20:11,080
I have bunch of variables which are defined here and then I have main function and I am

249
00:20:11,080 --> 00:20:18,600
doing some stack allocation and then calling a function printf.

250
00:20:18,600 --> 00:20:24,220
Now whatever is the content of the function is going to be instructions.

251
00:20:24,220 --> 00:20:30,980
So that will go into a section called as text section because that is where code goes.

252
00:20:30,980 --> 00:20:35,660
Then there is something called data section which is where all the initialized variables

253
00:20:35,660 --> 00:20:39,299
go.

254
00:20:39,299 --> 00:20:46,900
Then there is something called as bss where uninitialized variables are stored.

255
00:20:46,900 --> 00:20:53,860
Any idea why uninitialized versus initialized there is a distinction?

256
00:20:53,859 --> 00:21:06,659
Why cannot we have all of them stored in data section?

257
00:21:06,659 --> 00:21:12,419
So essentially all the uninitialized, so if there is a global variable which is uninitialized

258
00:21:12,419 --> 00:21:15,699
by default it will be 0.

259
00:21:15,700 --> 00:21:23,980
Now you have bunch of 0s and do you really want to store them in the file?

260
00:21:23,980 --> 00:21:30,140
Because see this value you will actually have to store in the object file saying that somewhere

261
00:21:30,140 --> 00:21:35,940
there is 2 in the data section, somewhere there is 10, 11, 12 in the data section.

262
00:21:35,940 --> 00:21:42,140
But for uninitialized variables you just need to have the information that we need these

263
00:21:42,140 --> 00:21:43,460
many 0s.

264
00:21:43,460 --> 00:21:46,620
So I need 4 0s or I need 100 0s.

265
00:21:46,620 --> 00:21:52,500
So imagine if I had an array of 100 elements which was uninitialized do I really want to

266
00:21:52,500 --> 00:21:54,980
store 100 0s?

267
00:21:54,980 --> 00:21:56,860
It is just a waste of space.

268
00:21:56,860 --> 00:22:04,100
So bss actually stands for block started by symbol but you can better remember it as better

269
00:22:04,100 --> 00:22:10,220
safe space because it is saving space in the object file.

270
00:22:10,220 --> 00:22:19,100
It is saving space without having to store 0s and it obviously does not occupy space

271
00:22:19,100 --> 00:22:21,100
in the object file.

272
00:22:21,100 --> 00:22:26,019
And then there is something called as ro data which is read only data.

273
00:22:26,019 --> 00:22:33,740
Now the string which is this actually goes on to read only data section.

274
00:22:33,740 --> 00:22:39,740
So any strings which you are using will actually go into read only data sections.

275
00:22:39,740 --> 00:22:45,500
So for example, I do not know how many of you are aware but let us say I have code something

276
00:22:45,500 --> 00:23:00,900
like this const char or rather char star ptr is equal to hello world.

277
00:23:00,900 --> 00:23:06,500
Can I do star ptr is equal to g?

278
00:23:06,500 --> 00:23:08,620
Can I do this?

279
00:23:08,619 --> 00:23:09,619
Why?

280
00:23:09,619 --> 00:23:24,619
Now you understand what makes it non accessible for writing because this string will actually

281
00:23:24,619 --> 00:23:26,899
go into ro data.

282
00:23:26,899 --> 00:23:35,859
Unlike this string hello will actually not be in ro data.

283
00:23:36,819 --> 00:23:39,419
data section.

284
00:23:39,419 --> 00:23:46,619
So that is why a pointer to a literal string is not same as array containing that string

285
00:23:46,619 --> 00:23:50,919
because this will actually put it in data section.

286
00:23:50,919 --> 00:23:54,099
This will actually put it in read only data sections.

287
00:23:54,099 --> 00:24:00,619
That is why you cannot modify this.

288
00:24:00,619 --> 00:24:02,939
What about variable x?

289
00:24:02,939 --> 00:24:05,619
Where does it go?

290
00:24:05,619 --> 00:24:21,299
Variable x which is here.

291
00:24:21,299 --> 00:24:26,539
How many of you think it needs to be in data section?

292
00:24:26,539 --> 00:24:30,500
How many of you think it needs to be somewhere else?

293
00:24:30,500 --> 00:24:32,500
Where?

294
00:24:32,500 --> 00:24:36,539
Correct.

295
00:24:36,539 --> 00:24:39,660
So x is actually a local variable.

296
00:24:39,660 --> 00:24:47,180
It will be on stack and stack is not stored as part of data section.

297
00:24:47,180 --> 00:24:57,259
Stack is separate which somehow so there is no information about x in the object file.

298
00:24:57,259 --> 00:24:58,980
There are couple of reasons for that.

299
00:24:59,460 --> 00:25:05,220
What had happened is all the references to x would have been changed to either esp plus

300
00:25:05,220 --> 00:25:08,500
something or ebp minus something or something.

301
00:25:08,500 --> 00:25:14,700
So there is no entity x which needs to live in the object file.

302
00:25:14,700 --> 00:25:21,860
Linker has nothing to do with x because x cannot be referenced from outside.

303
00:25:21,860 --> 00:25:27,059
So linker has no job with it.

304
00:25:27,059 --> 00:25:30,179
Now let us look at content of the text section.

305
00:25:30,179 --> 00:25:34,179
So just like we saw there is elf header.

306
00:25:34,179 --> 00:25:39,179
Elf header will have a pointer to section header table and there will be a section called

307
00:25:39,179 --> 00:25:40,460
as text section.

308
00:25:40,460 --> 00:25:43,659
So how do you examine content of the text section?

309
00:25:43,659 --> 00:25:53,259
So I will simply compile my program and use command objdump dash d sample dot o.

310
00:25:53,259 --> 00:25:56,000
This is the content.

311
00:25:56,000 --> 00:26:02,859
Now if you look at it, this what you are seeing here is the binary encoding corresponding

312
00:26:02,859 --> 00:26:04,500
to this instruction.

313
00:26:04,500 --> 00:26:13,680
So when 55 is being read by the x86 hardware, it assumes it is an instruction push ebp.

314
00:26:13,680 --> 00:26:20,200
So push ebp is translated by assembler into 55.

315
00:26:20,200 --> 00:26:25,839
Push ecx is translated by assembler into 51.

316
00:26:25,839 --> 00:26:31,519
Proof this is translated by assemblers to something like this.

317
00:26:31,519 --> 00:26:33,119
Is it clear?

318
00:26:33,119 --> 00:26:38,679
So what assembler, this was the textual program which you must have written.

319
00:26:38,679 --> 00:26:42,839
And assembler translated it into these binary encodings.

320
00:26:42,839 --> 00:26:50,059
And what objdump dash d did is disassembled it so that it is doing a reverse mapping of

321
00:26:50,059 --> 00:26:54,519
binary number to the actual text.

322
00:26:54,519 --> 00:26:57,119
Is it clear?

323
00:26:57,119 --> 00:26:58,119
Yes.

324
00:26:58,119 --> 00:26:59,119
I am supposed to do this.

325
00:26:59,119 --> 00:27:02,119
We have got gdb and we have got disassembly.

326
00:27:02,119 --> 00:27:03,119
Correct.

327
00:27:03,119 --> 00:27:11,639
So that disassembly is essentially that we have to source and get so this is it.

328
00:27:11,639 --> 00:27:17,559
You are talking about source or looking at assembly instructions.

329
00:27:17,559 --> 00:27:19,960
So during gdb you can see both things.

330
00:27:19,960 --> 00:27:25,680
You can see the actual c source or you can see the x86 assembly.

331
00:27:25,680 --> 00:27:35,519
So which one are you talking about?

332
00:27:35,519 --> 00:27:36,960
It is exactly same.

333
00:27:36,960 --> 00:27:40,319
So both of these just to give internal details.

334
00:27:40,319 --> 00:27:44,140
So there is something called as bfd library.

335
00:27:44,140 --> 00:27:48,000
Binary file descriptor library which exists on Linux.

336
00:27:48,000 --> 00:27:53,599
Which is essentially used by all the clients like kuda gdb, objdump and other things to

337
00:27:53,599 --> 00:27:55,319
actually read stuff.

338
00:27:55,319 --> 00:28:10,400
So all of them end up executing same piece of library code to be able to achieve this.

339
00:28:10,400 --> 00:28:14,799
I do not know their specific implementation but there is nothing sacred about this.

340
00:28:14,799 --> 00:28:17,500
x86 publishes the encoding information.

341
00:28:17,500 --> 00:28:26,240
So anyone can write a disassembler on their own.

342
00:28:26,240 --> 00:28:29,259
Now let us look at the data section.

343
00:28:29,259 --> 00:28:34,119
Now in data section we said init where an arr needs to be there.

344
00:28:34,119 --> 00:28:40,880
That means somehow I should be able to see 2, 10, 11, 12 somewhere in the data section.

345
00:28:40,880 --> 00:28:48,360
So if I do objdump dash dash section dot data I can actually see that.

346
00:28:48,360 --> 00:28:59,020
So I see that there is 2, there is a which is 10, 11, 12.

347
00:28:59,020 --> 00:29:06,480
So I can see somehow if I examine the object file I am able to see this content.

348
00:29:06,480 --> 00:29:20,160
Can anyone tell me why it is 0 to 0000 and not 000002?

349
00:29:20,160 --> 00:29:32,720
What is Indianness?

350
00:29:33,720 --> 00:29:37,360
So this has to do with the Indianness and Indianness information is also present as

351
00:29:37,360 --> 00:29:39,799
part of the elf header.

352
00:29:39,799 --> 00:29:44,480
So if you read the other bytes of the magic they are actually representing that type of

353
00:29:44,480 --> 00:29:45,480
information.

354
00:29:45,480 --> 00:29:48,000
What is the Indianness in which the file is?

355
00:29:48,000 --> 00:30:00,079
So for example if you look at the header it does say it is 2's complement littleindie.

356
00:30:00,079 --> 00:30:05,139
So you have to be able to read all these fields to be able to interpret the section

357
00:30:05,139 --> 00:30:06,619
content correctly.

358
00:30:06,619 --> 00:30:10,319
If you didn't know whether it was littleindie or bigindie you don't know how to interpret

359
00:30:10,319 --> 00:30:15,859
contents of the data section.

360
00:30:15,859 --> 00:30:24,579
Now just like data we should be able to somehow see this output as %d in RO data and we do

361
00:30:24,579 --> 00:30:25,579
see that.

362
00:30:25,779 --> 00:30:41,379
So this is actually ASCII corresponding to this.

363
00:30:41,379 --> 00:30:45,779
What strings command essentially does is it looks at all these sections and tries to interpret

364
00:30:45,779 --> 00:30:49,519
whatever forms ASCII string and dumpster.

365
00:30:49,519 --> 00:31:05,839
So just to show an example, so this is the code which we had.

366
00:31:05,839 --> 00:31:29,579
So if I do redelve...

367
00:31:29,579 --> 00:31:34,539
So we can see the %d string here which was used in this code.

368
00:31:34,539 --> 00:31:39,019
So essentially I can do strings command which essentially lists the various strings which

369
00:31:39,019 --> 00:31:41,339
are present in the object file.

370
00:31:41,339 --> 00:31:48,659
We could see there is a string called main, printf, bunch of other things but this string

371
00:31:48,659 --> 00:31:55,559
didn't appear there.

372
00:31:55,559 --> 00:31:58,420
Now let's look at the section header table itself.

373
00:31:58,420 --> 00:32:05,180
So remember the sh of field in the elf header had a pointer to section header.

374
00:32:05,180 --> 00:32:13,220
That means if I read that value and if I read starting from that byte a structure of this

375
00:32:13,220 --> 00:32:16,820
size I will get the elf section header.

376
00:32:16,820 --> 00:32:18,980
Does that make sense?

377
00:32:18,980 --> 00:32:21,300
No?

378
00:32:21,300 --> 00:32:26,060
What's the doubt?

379
00:32:26,059 --> 00:32:35,419
So let's look at the read.

380
00:32:35,419 --> 00:32:42,539
So here we get start of the section header which says 976.

381
00:32:42,539 --> 00:32:51,539
What this is saying is if I read from start of the file after 976 byte I will expect section

382
00:32:51,539 --> 00:32:53,740
headers to be present.

383
00:32:53,740 --> 00:33:02,980
So if I somehow move forward by file pointer to 976 and read a structure of this type I

384
00:33:02,980 --> 00:33:06,940
will get the section header table.

385
00:33:06,940 --> 00:33:14,740
Now section header table itself has information in chunks of records.

386
00:33:14,740 --> 00:33:20,940
So each of the section has a section header which describes the section.

387
00:33:20,940 --> 00:33:22,900
Each section will have a name.

388
00:33:22,900 --> 00:33:27,900
Name could be .data, .text, .rodata and so on.

389
00:33:27,900 --> 00:33:33,779
Then there is a type of section which is saying what type of information this section has.

390
00:33:33,779 --> 00:33:40,220
Then there are various flags of the sections and then there is offset where the content

391
00:33:40,220 --> 00:33:45,740
of that section lives and bunch of other information.

392
00:33:45,740 --> 00:33:52,160
So for example if you look at this file we get these section headers.

393
00:33:52,160 --> 00:33:59,299
So what I was saying is if the elf header had a pointer saying 976 from 976 I will get

394
00:33:59,299 --> 00:34:01,940
this data.

395
00:34:01,940 --> 00:34:09,059
And each of the entry in this section header table is of this structure form.

396
00:34:09,059 --> 00:34:16,940
Now what we can see here is essentially there is a section name which is .text, .rodata,

397
00:34:16,940 --> 00:34:17,940
etc.

398
00:34:17,940 --> 00:34:21,980
Each section has a flag.

399
00:34:21,980 --> 00:34:26,860
So flag is essentially saying what type of function section it is.

400
00:34:26,860 --> 00:34:31,820
So A here is saying it is an allocatable section.

401
00:34:31,820 --> 00:34:37,019
Allocatable section essentially implies that it is a section which will occupy memory when

402
00:34:37,019 --> 00:34:38,019
running.

403
00:34:38,019 --> 00:34:44,380
As it is the content of the section will be loaded into the memory and it will occupy

404
00:34:44,380 --> 00:34:48,139
space during the execution.

405
00:34:48,139 --> 00:34:53,739
X here is indicating the content of this section is executable.

406
00:34:53,739 --> 00:34:58,239
That means this section holds instructions which need to be executed.

407
00:34:58,239 --> 00:35:03,980
So if you look at .rodata, .rodata does not have X flag.

408
00:35:03,980 --> 00:35:10,619
So you cannot put instructions into .rodata section and start executing it because it

409
00:35:10,619 --> 00:35:15,980
will not be executable.

410
00:35:15,980 --> 00:35:21,659
Similarly you can see that every section has size.

411
00:35:21,659 --> 00:35:27,059
If you look at data section it has size 10 which is in actually hexadecimal that means

412
00:35:27,059 --> 00:35:29,300
it has size of 16.

413
00:35:29,300 --> 00:35:39,220
Now if you look at Y16 so this is 12 bytes and this is 4 bytes.

414
00:35:39,220 --> 00:35:47,420
Similarly RO data has size which is actually string length of this which is E.

415
00:35:47,420 --> 00:35:50,620
Each of the section has offset.

416
00:35:50,620 --> 00:35:54,940
This offset is telling where the data of this section lives.

417
00:35:54,940 --> 00:36:00,440
So at offset 78 the content of .data section is present.

418
00:36:00,440 --> 00:36:09,619
So within the file if I read at offset 78 I will get content of the .data section.

419
00:36:09,619 --> 00:36:14,940
Now to try out this actually happens I can actually do a command called od.

420
00:36:14,940 --> 00:36:17,980
So od is just a binary reader of some sort.

421
00:36:17,980 --> 00:36:21,000
It is not trying to interpret it as L for anything.

422
00:36:21,000 --> 00:36:28,280
What I am simply doing is to od I am saying read 16 bytes of data because 16 was the size

423
00:36:28,280 --> 00:36:32,900
and the start offset is 0x78.

424
00:36:32,900 --> 00:36:37,179
And if I look at that content it is actually content of the data section which we have

425
00:36:37,179 --> 00:36:43,280
seen 2ABC.

426
00:36:43,280 --> 00:36:44,480
Does that make sense?

427
00:36:45,119 --> 00:36:52,079
So remember this every section had a file offset which told where the content of that

428
00:36:52,079 --> 00:36:54,440
section began.

429
00:36:54,440 --> 00:37:02,159
And if I read that offset into the file then I actually see the content which was present

430
00:37:02,159 --> 00:37:04,740
in the data section.

431
00:37:04,740 --> 00:37:11,719
Similarly I can now simply execute this command where I say read starting from offset 88 in

432
00:37:11,719 --> 00:37:17,919
the file then I will get this string which is output is percent D.

433
00:37:17,919 --> 00:37:22,399
So remember this so far what we have seen is from ELF header we somehow can come to

434
00:37:22,399 --> 00:37:24,119
the ELF section header.

435
00:37:24,119 --> 00:37:31,319
ELF section header has offsets pointers to where the actual content is living and I can

436
00:37:31,319 --> 00:37:36,119
read those contents to see the actual data within the section.

437
00:37:36,119 --> 00:37:37,119
Is it clear?

438
00:37:42,399 --> 00:37:51,480
So this command is od dash x n is telling the number of bytes to read which is 16 then

439
00:37:51,480 --> 00:37:58,119
it has some different syntax so I was using traditional command and then sample.o and

440
00:37:58,119 --> 00:37:59,119
the offset.

441
00:37:59,119 --> 00:38:06,679
So what this command is trying to do is from sample.o starting offset 78 read 16 bytes

442
00:38:06,679 --> 00:38:08,719
and dump it.

443
00:38:08,719 --> 00:38:09,719
Ok.

444
00:38:09,719 --> 00:38:10,719
Yes.

445
00:38:10,719 --> 00:38:11,719
Correct.

446
00:38:11,719 --> 00:38:23,039
So any hex dump or hex editor should be able to show you the same thing.

447
00:38:23,039 --> 00:38:28,079
Now one of the things is we have seen that each section has a name.

448
00:38:28,079 --> 00:38:34,000
But if you look at the structure which I showed you earlier name is actually a word it is

449
00:38:34,000 --> 00:38:37,519
not a string.

450
00:38:37,519 --> 00:38:42,679
So it is not really storing string in the section header table itself it is holding

451
00:38:42,679 --> 00:38:44,440
a word.

452
00:38:44,440 --> 00:38:50,679
Now this word itself is an offset into another section.

453
00:38:50,679 --> 00:38:55,920
So strings are not really stored in the section header table.

454
00:38:55,920 --> 00:39:01,079
What is stored is offset of the string and the strings themselves are stored in some

455
00:39:01,079 --> 00:39:03,519
different section.

456
00:39:03,519 --> 00:39:10,920
So there is a section called sh str tab which actually holds all the section header strings

457
00:39:10,920 --> 00:39:16,460
and then there is a section called as str tab which holds all the other strings.

458
00:39:16,460 --> 00:39:23,000
And if I dump the content of that I will actually see all these strings.

459
00:39:23,000 --> 00:39:31,119
So to show an example so let us say so we had this elf header file.

460
00:39:31,119 --> 00:39:34,559
So we know that section header starts at this offset.

461
00:39:34,559 --> 00:39:42,000
If I actually look at the sections so it has these sections.

462
00:39:42,000 --> 00:39:45,639
So there is text, trail, data something something.

463
00:39:45,639 --> 00:39:50,920
These names themselves are not really stored in the section header and offset of this is

464
00:39:50,920 --> 00:39:51,920
actually stored.

465
00:39:51,920 --> 00:40:05,920
So if I read.

466
00:40:05,920 --> 00:40:13,000
So what is the content here is essentially content of the section sh str tab.

467
00:40:13,000 --> 00:40:21,159
And sh str tab has at offset 1 a string called sim tab then at offset 9 a string called str

468
00:40:21,159 --> 00:40:22,159
tab.

469
00:40:22,159 --> 00:40:29,759
And what is section header storing is 1, 9, 11, 1b and so on.

470
00:40:29,759 --> 00:40:32,159
Is it clear?

471
00:40:32,159 --> 00:40:41,480
So you need these string names for linker to work.

472
00:40:41,480 --> 00:40:46,759
For example linker needs to know that this is a section name this type and it will do

473
00:40:46,759 --> 00:40:49,599
something with it.

474
00:40:49,599 --> 00:40:56,159
So take 5 minutes write some sample program and try following commands.

475
00:40:56,159 --> 00:40:58,279
So you should try following commands.

476
00:40:58,279 --> 00:41:04,539
One is readelf-h sample.o.

477
00:41:04,539 --> 00:41:07,119
So you can see the elf header.

478
00:41:07,119 --> 00:41:22,359
So this is section headers.

479
00:41:22,360 --> 00:41:36,960
Then you should see then you should try this command od-n some

480
00:41:36,960 --> 00:41:41,480
size dash dash.

481
00:41:41,480 --> 00:41:53,119
sample sample dot o and offset of data section.

482
00:41:53,119 --> 00:42:04,199
So write some sample program where you can actually observe these things.

483
00:42:04,199 --> 00:42:10,199
But how to actually associate that with the symbols.

484
00:42:10,199 --> 00:42:16,439
So for example I saw in this program 1, 2 and 5.

485
00:42:16,439 --> 00:42:23,399
But how do I know 1, 2 is actually content of a symbol called arr and 5 is content of

486
00:42:23,399 --> 00:42:24,679
a variable called x.

487
00:42:24,679 --> 00:42:31,759
Or even in earlier case when I had global variables I need some way to say that this

488
00:42:31,759 --> 00:42:34,539
data belongs to this symbol.

489
00:42:34,539 --> 00:42:39,960
I can't simply have data without having a reference to those data points.

490
00:42:39,960 --> 00:42:47,720
So that's where elf also has symbols.

491
00:42:47,720 --> 00:42:55,880
So elf actually has a symbol table which contains various symbols which are defined in the program.

492
00:42:55,880 --> 00:43:05,320
And symbol is actually representing a location within the section where it is defined.

493
00:43:06,320 --> 00:43:12,720
A thing to note is elf does not hold all the variables which you had defined in your program.

494
00:43:12,720 --> 00:43:19,400
It only holds variables which are relevant for linker.

495
00:43:19,400 --> 00:43:24,920
So it holds all the symbols which are global.

496
00:43:24,920 --> 00:43:30,519
So any module scope variable which you declare as a global variable will be in the elf symbol

497
00:43:30,519 --> 00:43:33,580
table.

498
00:43:33,579 --> 00:43:41,980
So any non-static function like main, foo, printf, whatever all of them will be part

499
00:43:41,980 --> 00:43:43,960
of the elf symbol table.

500
00:43:43,960 --> 00:43:51,699
Any module scope variables which you define will be part of the symbol table.

501
00:43:51,699 --> 00:43:55,920
Then it will also have all the external symbols.

502
00:43:55,920 --> 00:44:02,099
External will mean any symbol which is simply used but not defined.

503
00:44:02,099 --> 00:44:08,299
For example, printf or any variable if you say external in c then c will be an external

504
00:44:08,299 --> 00:44:11,299
symbol.

505
00:44:11,299 --> 00:44:18,940
And it will hold any static variables which were defined in the local scope.

506
00:44:18,940 --> 00:44:21,099
So it holds three symbols.

507
00:44:21,099 --> 00:44:30,659
All the functions, all the variables which were declared and module scope, all the symbols

508
00:44:30,659 --> 00:44:37,339
of the external things it could be a function or data and it could be a local symbol in

509
00:44:37,339 --> 00:44:44,679
which case it will be a static variable.

510
00:44:44,679 --> 00:44:52,659
So an elf symbol table itself holds the information in this format where every symbol has a name.

511
00:44:52,659 --> 00:44:57,980
Again name is not really stored as string but it is again a pointer into a different

512
00:44:58,579 --> 00:45:01,059
called str tab.

513
00:45:01,059 --> 00:45:05,099
It has value which we will get to a later.

514
00:45:05,099 --> 00:45:06,539
It has size.

515
00:45:06,539 --> 00:45:12,340
So size is essentially whatever is the size of symbol 4 bytes, 8 bytes, 20 bytes and then

516
00:45:12,340 --> 00:45:15,699
it has type and some other things.

517
00:45:15,699 --> 00:45:23,480
So if I look at this program I can dump this symbol table using redelf dash s.

518
00:45:23,480 --> 00:45:25,480
Note s is small here.

519
00:45:25,480 --> 00:45:37,179
For section headers we were using capital S and this is how the symbol table looks.

520
00:45:37,179 --> 00:45:43,920
Now first thing you have to realize is for every symbol there is a type.

521
00:45:43,920 --> 00:45:47,139
Type is indicating what type of symbol it is.

522
00:45:47,139 --> 00:45:51,699
So main has a type called funk.

523
00:45:51,699 --> 00:45:55,879
So it is saying main is some function symbol.

524
00:45:55,879 --> 00:46:00,079
Arr is some sort of object symbol.

525
00:46:00,079 --> 00:46:07,939
So any variable is called as object in elf and any function is called funk.

526
00:46:07,939 --> 00:46:10,579
So every symbol has a type.

527
00:46:10,579 --> 00:46:11,980
Every symbol has a size.

528
00:46:11,980 --> 00:46:17,039
So for example in it where you can see it has size of 4.

529
00:46:17,759 --> 00:46:24,440
Arr has size of 12 and in it where has size of 4.

530
00:46:24,440 --> 00:46:29,960
So size is size in bytes of that symbol.

531
00:46:29,960 --> 00:46:33,679
Then there is something called as value.

532
00:46:33,679 --> 00:46:42,380
Now value is unlike the term value it is not really representing content of the symbol.

533
00:46:42,380 --> 00:46:53,099
So if you look at var 1 it says 10 which is 0x10 but it is not really the value of var

534
00:46:53,099 --> 00:46:54,099
1.

535
00:46:54,099 --> 00:47:01,680
It is really the offset within the data section of var.

536
00:47:01,680 --> 00:47:08,000
So value is essentially representing offset within the section.

537
00:47:08,000 --> 00:47:09,619
Is that clear?

538
00:47:09,619 --> 00:47:16,739
So if you look at it that way so what this is saying is in it where is at offset 0 in

539
00:47:16,739 --> 00:47:19,000
the data section.

540
00:47:19,000 --> 00:47:26,539
So if you now print data section of this the first thing which you should see at 0 byte

541
00:47:26,539 --> 00:47:28,980
is actually content of in it where.

542
00:47:28,980 --> 00:47:32,219
That means you will see 2 first.

543
00:47:32,219 --> 00:47:35,299
Then it says Arr is at offset 4.

544
00:47:35,299 --> 00:47:36,299
Why 4?

545
00:47:36,420 --> 00:47:42,100
In it where is 4 bytes so Arr must start at 4 bytes after that.

546
00:47:42,100 --> 00:47:53,100
Then it says there is var 1 because this is occupying 12 bytes so this must start at 16

547
00:47:53,100 --> 00:47:57,900
and there is something y which is starting 4 bytes after that.

548
00:47:57,900 --> 00:48:03,700
So the content of data section according to this symbol table is organized such that first

549
00:48:03,699 --> 00:48:08,899
the value of in it where is stored then the value of Arr 3 is stored then the value of

550
00:48:08,899 --> 00:48:12,259
var 1 is stored and then the value of y is stored.

551
00:48:12,259 --> 00:48:17,739
So if you actually dump the content for this program you should see content in that order

552
00:48:17,739 --> 00:48:20,000
in the data section.

553
00:48:20,000 --> 00:48:21,000
Is it clear?

554
00:48:21,000 --> 00:48:25,299
How to interpret this field?

555
00:48:25,299 --> 00:48:29,699
Now every variable also has a section.

556
00:48:29,699 --> 00:48:36,980
So if you look at this ndx field it is called a section index.

557
00:48:36,980 --> 00:48:40,579
This is actually an index into the section table.

558
00:48:40,579 --> 00:48:45,579
So what this is saying is in it where has section index of 3.

559
00:48:45,579 --> 00:48:51,619
What that means is if you look at the section header it is the section header 3 actually

560
00:48:51,619 --> 00:48:54,299
holds dot data.

561
00:48:54,300 --> 00:49:00,660
So what this is saying is in it where is a symbol which is defined in dot data section

562
00:49:00,660 --> 00:49:03,660
at offset 0.

563
00:49:03,660 --> 00:49:14,260
Arr is a symbol which is defined in dot data section at offset 4.

564
00:49:14,260 --> 00:49:18,140
Is that clear how we are trying to relate all the fields together now?

565
00:49:18,139 --> 00:49:24,579
So for every symbol you had some data which belonged in dot data section but how do you

566
00:49:24,579 --> 00:49:33,779
know symbol and dot data section are associated by this ndx field.

567
00:49:33,779 --> 00:49:40,460
Now if you look at this something called as printf it actually has u and d.

568
00:49:40,460 --> 00:49:47,019
This is telling that printf is actually not defined in this file because there is no section

569
00:49:47,300 --> 00:49:50,659
which holds the content of printf.

570
00:49:50,659 --> 00:49:57,900
If you look at main, main actually has one which means it belongs into dot text section.

571
00:49:57,900 --> 00:50:01,179
So main is defined in dot text section.

572
00:50:01,179 --> 00:50:06,739
Printf there is nothing to define because we do not know what is the text section for

573
00:50:06,739 --> 00:50:09,579
printf because it will come from somewhere else.

574
00:50:09,579 --> 00:50:12,820
That is why it is marked as u and d.

575
00:50:12,820 --> 00:50:18,260
This uninit where is uninitialized and it goes into something called as com which we

576
00:50:18,260 --> 00:50:23,059
will see later.

577
00:50:23,059 --> 00:50:24,580
Is it clear?

578
00:50:24,580 --> 00:50:32,820
So now what you should do is write this program and examine what is the value of a symbol

579
00:50:32,820 --> 00:50:38,140
and whether you see the dot section content according to those values.

580
00:50:38,140 --> 00:50:41,380
So declare 4-5 variables with different values.

581
00:50:41,380 --> 00:50:47,940
So you can actually see and you can simply do this command.

582
00:50:47,940 --> 00:51:08,220
So what you can do is obj dump dash dash section equal to dot data and sample dot o.

583
00:51:08,219 --> 00:51:16,939
So let's say I have file 1 dot c where I declare something as static int myvar is equal to

584
00:51:16,939 --> 00:51:32,059
5 and then I do int main byte and say I do printf percent d slash n myvar and then I

585
00:51:32,059 --> 00:51:49,259
call a function foo and I return 0 and here I define external void foo.

586
00:51:50,260 --> 00:52:11,860
So just to show you the code.

587
00:52:11,860 --> 00:52:16,940
So this code says that there is something called as foo which is external then there

588
00:52:16,940 --> 00:52:25,700
is something called as myvar which is static and then uses myvar prints myvar and then

589
00:52:25,700 --> 00:52:26,700
calls foo.

590
00:52:26,700 --> 00:52:32,619
File 2 says myvar is external and then defines foo.

591
00:52:32,619 --> 00:52:34,860
Now let's try compiling this.

592
00:52:34,860 --> 00:52:45,300
So I do gcc file 1 dot c dash o file 1 dot o.

593
00:52:45,660 --> 00:52:54,019
Similarly I do file 2 dot o and then I try to link these two programs.

594
00:52:54,019 --> 00:53:02,860
What will happen?

595
00:53:02,860 --> 00:53:04,860
It will generate an error.

596
00:53:04,860 --> 00:53:12,700
So it says that there is something called as myvar which is undefined.

597
00:53:12,700 --> 00:53:14,300
Why did it say that?

598
00:53:14,300 --> 00:53:19,940
I had myvar which was defined.

599
00:53:19,940 --> 00:53:29,620
It was because static because if you look at redel's output file 1 dot o it said myvar

600
00:53:29,620 --> 00:53:31,820
is local.

601
00:53:31,820 --> 00:53:37,980
So linker is not trying to say the myvar which is in file 2 dot o is same as myvar in file

602
00:53:37,980 --> 00:53:39,019
1 dot o.

603
00:53:39,019 --> 00:53:43,900
It says these are some different things and it ultimately didn't find any reference to

604
00:53:43,900 --> 00:53:47,380
myvar which was supposed to be global.

605
00:53:47,380 --> 00:53:50,700
So that's why linker said something is undefined here.

606
00:53:50,700 --> 00:53:59,780
Whereas if I simply change this to normal variable and I compile my file again.

607
00:53:59,780 --> 00:54:01,720
Now look at what happens.

608
00:54:01,720 --> 00:54:10,260
Now myvar is actually global and I do gcc file 1 dot o file 2 dot o and the program

609
00:54:10,260 --> 00:54:12,099
links.

610
00:54:12,099 --> 00:54:18,380
So linker is using the information of local versus global to determine what can be external

611
00:54:18,380 --> 00:54:22,659
in other things and what is specific to this file only.

612
00:54:22,659 --> 00:54:25,179
Is that clear?

613
00:54:25,179 --> 00:54:32,819
Now one strange thing is why for some reason has this name y1940.

614
00:54:32,819 --> 00:54:37,299
Any idea why?

615
00:54:38,140 --> 00:54:51,500
So if I declare a static variable which was y here in main its name came as y dot 1940.

616
00:54:51,500 --> 00:54:53,140
But why is that needed?

617
00:54:53,140 --> 00:55:01,980
Like var 1 didn't have var 1 was also static.

618
00:55:02,539 --> 00:55:04,420
Why does it need that?

619
00:55:04,420 --> 00:55:05,420
Correct.

620
00:55:05,420 --> 00:55:10,539
So there are couple of reasons.

621
00:55:10,539 --> 00:55:18,059
One is I couldn't have a function called foo which also can say static int y.

622
00:55:18,059 --> 00:55:22,460
So I have two y variables which are actually different.

623
00:55:22,460 --> 00:55:27,099
So I need some way to distinguish y in foo versus y in main.

624
00:55:27,099 --> 00:55:33,219
That's why I need to change the name to something random and in this case it chooses

625
00:55:33,219 --> 00:55:36,819
1940.

626
00:55:36,819 --> 00:55:41,420
Now to summarize the elf structure, this is how it looks.

627
00:55:41,420 --> 00:55:45,980
So we had elf header which was at the start of the file.

628
00:55:45,980 --> 00:55:50,839
It had a pointer to section header table.

629
00:55:50,840 --> 00:55:56,280
Section header table consists of individual section entries.

630
00:55:56,280 --> 00:56:01,840
Each section header table has a field called offset.

631
00:56:01,840 --> 00:56:08,079
Offset actually points to the content of the section and each section has a size which

632
00:56:08,079 --> 00:56:13,640
tells how much data lives in that section.

633
00:56:13,839 --> 00:56:22,799
Name of the section itself comes as an index into another section called sh str tab.

634
00:56:22,799 --> 00:56:30,480
Then there is elf symbol whose name again comes from another section called str tab.

635
00:56:30,480 --> 00:56:39,839
shn index field of the elf symbol table points to the section in which it is defined.

636
00:56:39,840 --> 00:56:44,480
So every symbol is defined in some section.

637
00:56:44,480 --> 00:56:50,960
Value of the symbol table is representing offset within the section where the data of

638
00:56:50,960 --> 00:56:58,880
that symbol belongs and size is representing the size of that variable.

639
00:56:58,880 --> 00:57:00,039
Is this clear?

640
00:57:00,039 --> 00:57:05,840
Because if you understand this metadata, you should be able to traverse elf file and read

641
00:57:05,840 --> 00:57:09,200
elf file using a program.

642
00:57:09,199 --> 00:57:12,119
You don't need a tool like read elf.

643
00:57:12,119 --> 00:57:20,039
So just to reiterate, elf header will give you offset to the section header table.

644
00:57:20,039 --> 00:57:24,319
Section header table will have the offset which is where the content of the section

645
00:57:24,319 --> 00:57:30,039
begins and the name itself comes from sh str tab.

646
00:57:30,039 --> 00:57:37,359
Symbol is nothing but offset within the section where data of that particular symbol starts

647
00:57:37,599 --> 00:57:42,280
and the size essentially gives how much is the size within that section associated with

648
00:57:42,280 --> 00:57:44,160
that symbol.

649
00:57:44,160 --> 00:57:49,280
Is that clear?

650
00:57:49,280 --> 00:57:52,079
Now quiz.

651
00:57:52,079 --> 00:57:57,280
So I have this code where I define a function called foo as extern.

652
00:57:57,280 --> 00:58:04,599
I define a variable called int var 1 and I call foo and then in the other file I say

653
00:58:04,839 --> 00:58:11,360
extern float var and I do var is equal to 5.0.

654
00:58:11,360 --> 00:58:34,519
What will happen in this code when I link together?

655
00:58:34,519 --> 00:58:37,280
One person thinks it will give an error.

656
00:58:37,280 --> 00:58:41,679
How many of you think it is an error?

657
00:58:41,679 --> 00:58:42,679
Quite a few people.

658
00:58:42,679 --> 00:58:54,079
What do others think?

659
00:58:54,079 --> 00:59:00,679
What do you mean by type will be default for both the elfs?

660
00:59:00,679 --> 00:59:05,679
Correct.

661
00:59:05,679 --> 00:59:12,799
So one thing you have to realize is see linker is dealing with object files.

662
00:59:12,799 --> 00:59:16,399
Linker is not looking at main.c and foo.c.

663
00:59:16,399 --> 00:59:21,440
So linker is dealing with the information which is present in the object file.

664
00:59:21,440 --> 00:59:23,039
Does that make sense?

665
00:59:23,039 --> 00:59:26,279
Now let us look at this code.

666
00:59:26,280 --> 00:59:28,920
Let us say I write this code in file 1.c.

667
00:59:28,920 --> 00:59:51,559
Gcc dash c dash m32 file 1 dot.

668
00:59:51,779 --> 01:00:08,440
Now let me read the symbol table.

669
01:00:08,440 --> 01:00:14,000
So it says that var is of some variable of size 4 bytes.

670
01:00:14,000 --> 01:00:19,079
Does it say it is var which is integer?

671
01:00:19,079 --> 01:00:23,599
Does it say that?

672
01:00:23,599 --> 01:00:32,920
So does linker know that main.c is defining var to be integer?

673
01:00:32,920 --> 01:00:33,920
No.

674
01:00:33,920 --> 01:00:43,679
Similarly, when it compiles foo does it know that var is float?

675
01:00:43,679 --> 01:00:54,199
So linker has no idea that there is var which is integer here and float here and to be able

676
01:00:54,199 --> 01:00:55,199
to issue the error.

677
01:00:55,199 --> 01:01:01,960
There is no way linker can issue that error.

678
01:01:01,960 --> 01:01:03,279
It is not even runtime error.

679
01:01:03,279 --> 01:01:10,079
For example, if you run this code var will actually hold whatever is the IEEE 5.0 32

680
01:01:10,079 --> 01:01:11,559
bit encoding.

681
01:01:11,559 --> 01:01:13,519
So it is a logical error.

682
01:01:13,519 --> 01:01:16,079
There is no crash or anything which will happen.

683
01:01:16,079 --> 01:01:21,159
32 bits.

684
01:01:21,159 --> 01:01:25,320
So var is simply saying print the 32 bit content.

685
01:01:25,320 --> 01:01:26,559
Whatever that is.

686
01:01:26,559 --> 01:01:32,679
And 5.0 has some representation in 32 bits in the floating point numbering system.

687
01:01:32,679 --> 01:01:39,799
It will simply print that number.

688
01:01:39,799 --> 01:01:40,799
Coming to that.

689
01:01:40,800 --> 01:01:45,320
Next question.

690
01:01:45,320 --> 01:01:49,360
So now I have int x which has size 4.

691
01:01:49,360 --> 01:01:52,400
Here I define it to be double.

692
01:01:52,400 --> 01:01:58,519
No, but can it issue error in this case?

693
01:01:58,519 --> 01:02:03,080
Does it have information to issue error?

694
01:02:03,080 --> 01:02:05,660
Size information is there.

695
01:02:05,660 --> 01:02:08,680
So here it knows x is 4 bytes.

696
01:02:08,679 --> 01:02:12,179
Here it knows it is x bytes, 8 bytes.

697
01:02:12,179 --> 01:02:13,960
So let us try that.

698
01:02:13,960 --> 01:02:15,239
Let us try this.

699
01:02:15,239 --> 01:02:26,319
So I have int var 1 and let me print y.

700
01:02:26,320 --> 01:02:42,740
Now here I define this to be x turned double of var.

701
01:02:42,740 --> 01:02:45,680
Now var is equal to 5.0.

702
01:02:45,680 --> 01:02:49,280
Now in this case we expect linker to give error.

703
01:02:49,280 --> 01:02:53,120
Because it is defined to be double here and defined to be integer there.

704
01:02:53,119 --> 01:02:57,239
There is size mismatch.

705
01:02:57,239 --> 01:03:03,920
File 1.c, file 2.c.

706
01:03:03,920 --> 01:03:05,500
It didn't.

707
01:03:05,500 --> 01:03:08,739
So linker didn't issue error for this case either.

708
01:03:08,739 --> 01:03:12,139
And if we print, it printed something.

709
01:03:12,139 --> 01:03:18,440
So what actually happened is y was also overwritten.

710
01:03:18,440 --> 01:03:26,159
Because this statement wrote 8 bytes of data which ended up writing 4 bytes here and 4

711
01:03:26,159 --> 01:03:27,480
bytes here.

712
01:03:27,480 --> 01:03:30,400
So y was also overwritten.

713
01:03:30,400 --> 01:03:35,880
So not only linker didn't catch the error, it also overwrote something which it was not

714
01:03:35,880 --> 01:03:37,960
intended to.

715
01:03:37,960 --> 01:03:44,679
Now can you tell me why linker didn't catch it?

716
01:03:44,679 --> 01:03:48,839
Linker had the size information.

717
01:03:48,839 --> 01:03:54,559
No, so let us look at it.

718
01:03:54,559 --> 01:03:59,359
So best way to answer these questions is examine object files.

719
01:03:59,359 --> 01:04:00,879
So let us look at it.

720
01:04:00,879 --> 01:04:08,239
So I will do GC's.

721
01:04:08,239 --> 01:04:12,839
So let us look at the symbol table of file 1.o.

722
01:04:12,840 --> 01:04:20,100
So it says var is a 4 byte variable and y is a 4 byte variable.

723
01:04:20,100 --> 01:04:25,680
So it has the information that both are 4 4 bytes each.

724
01:04:25,680 --> 01:04:31,240
Now let us look at the same thing for file 2.

725
01:04:31,239 --> 01:04:44,319
So file 2 says var has size 0.

726
01:04:44,319 --> 01:04:49,559
It didn't say it has size 8.

727
01:04:49,559 --> 01:04:57,199
And then linker says that whatever is 0 could be 4 or 8 or whatever.

728
01:04:57,199 --> 01:05:07,559
So the assembler produced elf actually didn't hold the information that var is 8 byte value

729
01:05:07,559 --> 01:05:10,079
in this program.

730
01:05:10,079 --> 01:05:14,480
Although it was extern double.

731
01:05:14,480 --> 01:05:20,279
Now it's an exercise for you to figure out why assembler didn't store this information

732
01:05:20,280 --> 01:05:28,280
even when it had that information.

733
01:05:28,280 --> 01:05:33,160
Now an interesting thing I will show something more interesting.

734
01:05:33,160 --> 01:05:37,560
So here I simply said var is actually a variable.

735
01:05:37,560 --> 01:05:41,760
I could be more evil and say something like this.

736
01:05:41,760 --> 01:05:49,280
So var is a function which is of type void.

737
01:05:49,280 --> 01:05:57,280
And I will call that function.

738
01:05:57,280 --> 01:06:01,980
Now let us look at it.

739
01:06:01,980 --> 01:06:08,680
So I will now link file 1.o which defined var to be a variable.

740
01:06:08,679 --> 01:06:18,960
And file 2.o which defined variable to be a function.

741
01:06:18,960 --> 01:06:21,879
Linker still happily linked things together.

742
01:06:21,879 --> 01:06:26,480
So linker says var variable var function I don't care.

743
01:06:26,480 --> 01:06:28,500
I will just link them.

744
01:06:28,500 --> 01:06:32,079
And then when I execute I get segmentation fault.

745
01:06:32,920 --> 01:06:43,519
Segmentation fault is because when I start executing this I will jump into the data segment.

746
01:06:43,519 --> 01:07:00,519
And if you look at the data segment.

747
01:07:00,519 --> 01:07:04,780
If you look at the data segment it doesn't have execute permission.

748
01:07:04,780 --> 01:07:09,840
That's why it's set faulted.

749
01:07:09,840 --> 01:07:14,800
So linker is really lazy in figuring out what matches with what.

750
01:07:14,800 --> 01:07:16,680
It simply looks name.

751
01:07:16,680 --> 01:07:18,559
Okay var var.

752
01:07:18,559 --> 01:07:21,860
Does not do any other things.

753
01:07:21,860 --> 01:07:26,320
And it's your exercise to figure out why for the functions it couldn't do it.

754
01:07:26,320 --> 01:07:30,559
And why for the external variable it stored the size as 0.

