1
00:00:00,000 --> 00:00:07,719
Good morning to all of you.

2
00:00:07,719 --> 00:00:10,200
So this is an optimization of virtual function calls.

3
00:00:10,200 --> 00:00:14,720
So I am really not going to explain how the optimization is done, but what I am trying

4
00:00:14,720 --> 00:00:18,320
to do is I am trying to explain what are the issues here.

5
00:00:18,320 --> 00:00:27,320
So we will begin by looking at C++ inheritance, how the data is stored and in particular how

6
00:00:27,320 --> 00:00:33,399
does a compiler deal with virtual functions, how does a compiler handle virtual functions

7
00:00:33,399 --> 00:00:40,200
and then we will just look at what optimizations can be done although it is beyond the scope

8
00:00:40,200 --> 00:00:48,480
of this lecture to get into the details of how these optimizations are done.

9
00:00:48,480 --> 00:00:53,359
So we are going to look at internal representation of a class, we will talk about translating

10
00:00:53,359 --> 00:01:00,439
virtual function calls and we will talk about what the proposed optimization is.

11
00:01:00,439 --> 00:01:08,439
So here is a certain class, it has some members, public members int y and z and there is a

12
00:01:08,439 --> 00:01:16,039
private data member x and it has a private function f2 which essentially increments its

13
00:01:16,240 --> 00:01:24,440
argument and f1 calls f2 with its argument and multiplies it by 2.

14
00:01:24,440 --> 00:01:31,000
So I am just trying to show what exactly happens internally, what does a compiler do with this

15
00:01:31,000 --> 00:01:38,440
kind of a code with something being private, something being public, something being data,

16
00:01:38,440 --> 00:01:39,840
something being function.

17
00:01:39,840 --> 00:01:43,340
So we want to look at exactly what happens under the hood.

18
00:01:43,340 --> 00:01:49,460
So we have data memory and code memory, we saw the organization yesterday, there is a

19
00:01:49,460 --> 00:01:53,939
code memory, there is a data memory and data memory, we have static stack and heap.

20
00:01:53,939 --> 00:01:58,900
So here we are not making that distinction but we are basically looking at the data and

21
00:01:58,900 --> 00:02:00,219
code memory.

22
00:02:00,219 --> 00:02:11,500
So we have two variables declared, small a of the class a and b again of the class a

23
00:02:12,340 --> 00:02:18,900
The important point is in the code memory we will have this function a of f1 and in

24
00:02:18,900 --> 00:02:22,580
the data memory we will have object a and object b.

25
00:02:22,580 --> 00:02:30,199
So the data members and the function members get distributed in the memory, the function

26
00:02:30,199 --> 00:02:35,719
members go in the code memory and the data members go in the data memory.

27
00:02:35,719 --> 00:02:41,879
So in the data memory we have x, y, z, note that in the data memory there is no tag of

28
00:02:41,879 --> 00:02:45,800
which one is private and which one is public.

29
00:02:45,800 --> 00:02:52,919
All this is a matter of scope resolution during parsing and type checking.

30
00:02:52,919 --> 00:02:58,759
So when this code is translated there is no notion of private or public.

31
00:02:58,759 --> 00:03:04,959
So we have x, y, z for object a, x, y, z for object b, both of them are for the same

32
00:03:04,959 --> 00:03:13,919
class and we have this function, we have this function f1, we have this function f2.

33
00:03:13,919 --> 00:03:22,199
So every function with n parameters is translated to a function with n plus 1 parameters and

34
00:03:22,239 --> 00:03:29,239
the first parameter always happens to be what we call as this pointer which is a pointer

35
00:03:30,679 --> 00:03:37,679
to the receiver object, the object on which the certain function is being called.

36
00:03:39,519 --> 00:03:43,399
So effectively this is nothing but a C program.

37
00:03:43,399 --> 00:03:50,399
So C++ is at an intuitive level is translated into a C program and that is exactly how it

38
00:03:51,280 --> 00:03:57,920
used to be earlier, now it is not so but at an abstract level you can see a C++ program

39
00:03:57,920 --> 00:04:02,520
as a C program with a clever use of pointers.

40
00:04:02,520 --> 00:04:09,520
So we have this which is the object, pointer to the object.

41
00:04:09,960 --> 00:04:16,960
So when this function says x is equal to something is going to translate it as this arrow x equal

42
00:04:16,960 --> 00:04:18,639
to something.

43
00:04:18,639 --> 00:04:23,879
So effectively this function it says return i that is a parameter so it is not an object.

44
00:04:23,879 --> 00:04:28,879
So effectively this function ignores this argument.

45
00:04:28,879 --> 00:04:31,879
So this is the whole point.

46
00:04:31,879 --> 00:04:36,639
Now let us see how execution happens.

47
00:04:36,639 --> 00:04:43,639
So we say let us say we call a of f1 is equal to 5, what will be the output of what will

48
00:04:43,919 --> 00:04:50,919
happen because of this call a dot f1 5, spend a few minutes and tell me what would happen.

49
00:04:53,240 --> 00:05:00,240
f1 will get called with 5, so it is going to call f2 with 5, f2 is going to return 6.

50
00:05:03,360 --> 00:05:10,360
So this will multiply 6 by 2, result will be 12, so we will have x equal to 12, the

51
00:05:10,840 --> 00:05:13,840
question is which x will be a is private.

52
00:05:13,840 --> 00:05:16,699
So we should have 12 written here.

53
00:05:16,699 --> 00:05:23,139
So the way it gets translated is that this f1 5 this call gets translated like this.

54
00:05:23,139 --> 00:05:29,319
The address of object a is passed and because the address of object a is passed it says

55
00:05:29,319 --> 00:05:36,319
a arrow x is equal to and note that this is translated as a colon colon f2 this.

56
00:05:37,319 --> 00:05:44,319
So we get so we know that we are doing something for object a and therefore we will end up

57
00:05:44,319 --> 00:05:49,319
this x corresponds to this x and we will end up writing 12 in that x.

58
00:05:49,319 --> 00:05:53,319
Is the overall arrangement clear?

59
00:05:53,319 --> 00:06:00,319
Next one easy easy what will happen with b dot f1 with 10, we will write 22 where in

60
00:06:00,319 --> 00:06:07,319
this x. So we will once again have in this call for the next call address of b is passed

61
00:06:13,680 --> 00:06:19,719
and then it becomes b arrow x and therefore we will end up right that is the arrangement

62
00:06:19,719 --> 00:06:22,659
of c plus plus.

63
00:06:22,659 --> 00:06:29,120
Now what we want to see is what happens when there is inheritance and in particular what

64
00:06:29,120 --> 00:06:36,120
happens when there is there are virtual functions in an inheritance hierarchy.

65
00:06:39,519 --> 00:06:43,600
So this was the easy stuff warming up exercise.

66
00:06:43,600 --> 00:06:47,800
So now let us say I am just trying to show how inheritance happens.

67
00:06:47,800 --> 00:06:52,980
So we have three classes white blue and pink.

68
00:06:52,980 --> 00:06:59,980
This is the base class, class white has just w1 with and this is the object w for white,

69
00:07:00,700 --> 00:07:02,819
b for blue and p for pink.

70
00:07:02,819 --> 00:07:09,819
So this is the object for w1 and now this class blue says public white which means that

71
00:07:10,259 --> 00:07:16,500
is going to inherit everything from white and additionally going to include these b1

72
00:07:16,500 --> 00:07:17,220
and b2.

73
00:07:17,220 --> 00:07:24,220
So b this small b would be it would have something called w1 which is this field and b1 and b2

74
00:07:24,220 --> 00:07:30,240
which is this field right and then we have class pink which derives from class blue.

75
00:07:30,240 --> 00:07:36,700
So it will have everything that class blue has but additionally it will have p1 and p2

76
00:07:36,700 --> 00:07:39,040
the two pink members right.

77
00:07:39,040 --> 00:07:45,540
So this is how the inheritance of data takes place clear.

78
00:07:45,540 --> 00:07:51,379
Every derived class would have everything that comes from the base class and the size

79
00:07:51,379 --> 00:07:56,500
of the derived class will keep growing as we derive more and more we will have more

80
00:07:56,500 --> 00:07:59,680
things coming in right.

81
00:07:59,680 --> 00:08:01,140
So this is the inheritance of data.

82
00:08:01,140 --> 00:08:04,100
Now we want to look at inheritance of functions.

83
00:08:04,100 --> 00:08:06,820
What happens in case of inheritance of functions?

84
00:08:06,820 --> 00:08:11,879
So non-virtual functions are inherited much like data members.

85
00:08:11,879 --> 00:08:18,879
So there is no difference between non-virtual functions and data members except that because

86
00:08:19,159 --> 00:08:25,680
it is the same function that is inherited there is one copy of the code across the entire

87
00:08:25,680 --> 00:08:26,920
hierarchy.

88
00:08:26,920 --> 00:08:31,019
You don't keep separate copies of and of course these functions go in the function

89
00:08:31,019 --> 00:08:33,960
memory they don't go in the data memory right.

90
00:08:33,960 --> 00:08:36,480
Can you all visualize it?

91
00:08:36,480 --> 00:08:38,559
Data is of course different.

92
00:08:38,559 --> 00:08:42,199
So we have to create separate space for this data.

93
00:08:42,199 --> 00:08:47,199
This b1 is different from this b1 and this w1 is different from this w1 which in turn

94
00:08:47,199 --> 00:08:54,199
is different from w1 but that doesn't happen for inherited function members in particular

95
00:08:54,399 --> 00:08:57,079
non-virtual function members right.

96
00:08:57,079 --> 00:09:00,079
So inheritance of data is easy.

97
00:09:00,079 --> 00:09:03,519
Inheritance of non-virtual function members is easy.

98
00:09:03,519 --> 00:09:08,000
Inheritance of virtual functions is where some interesting things happen and which is

99
00:09:08,000 --> 00:09:09,559
what we want to understand.

100
00:09:09,559 --> 00:09:15,120
How does the compiler set up the things in order to make sure that the right function

101
00:09:15,120 --> 00:09:16,279
is being called?

102
00:09:16,279 --> 00:09:25,279
That is the problem that we want to look at in the next half an hour or so.

103
00:09:25,279 --> 00:09:26,279
What is a virtual function?

104
00:09:26,279 --> 00:09:28,279
Maybe I should have asked you.

105
00:09:28,279 --> 00:09:34,519
How many of you have not used C++ before?

106
00:09:34,519 --> 00:09:38,319
So everyone has used.

107
00:09:38,319 --> 00:09:39,840
Would anyone like to answer that question?

108
00:09:39,840 --> 00:09:41,319
What is a virtual function?

109
00:09:41,319 --> 00:09:47,319
Yes, yes and a standard example there is which I think I can take.

110
00:09:47,319 --> 00:09:51,919
Every C++ book would have the standard example.

111
00:09:51,919 --> 00:09:58,919
We first create a class called shape which among other things has this function called

112
00:09:58,919 --> 00:09:59,919
draw.

113
00:09:59,919 --> 00:10:00,919
Now what does a draw do?

114
00:10:00,919 --> 00:10:01,919
It depends on what the shape is.

115
00:10:01,919 --> 00:10:08,919
You cannot draw an arbitrary shape and then when we say class square public, I do not

116
00:10:08,919 --> 00:10:34,399
remember the syntax, yes, public shape when it derives when a square derives from shape

117
00:10:34,399 --> 00:10:37,240
it draws something like this.

118
00:10:38,240 --> 00:10:50,200
In a similar manner when we have a circle, circle derives from shape it will draw something

119
00:10:50,200 --> 00:10:51,200
like this.

120
00:10:51,200 --> 00:11:01,680
So, the whole idea is that we want a certain functionality which is common to the class,

121
00:11:02,679 --> 00:11:10,399
hierarchy, but that functionality has to be distinguished based on the particular instance

122
00:11:10,399 --> 00:11:11,399
in the hierarchy.

123
00:11:11,399 --> 00:11:17,719
So, I want to be able to say that every shape has a draw function, every shape has an area,

124
00:11:17,719 --> 00:11:25,759
every shape has a certain perimeter, but what it is depends on the particular instance of

125
00:11:25,759 --> 00:11:30,120
the class and therefore, we use virtual functions.

126
00:11:30,560 --> 00:11:34,720
Because a draw here does not mean anything or area here does not mean anything until

127
00:11:34,720 --> 00:11:39,720
you tell me what the shape is, I cannot tell you how to draw it, I cannot tell you what

128
00:11:39,720 --> 00:11:40,720
the area is.

129
00:11:40,720 --> 00:11:46,960
So, it is so the idea is to say that there is a function draw, but and often what happens

130
00:11:46,960 --> 00:11:56,039
is we say draw equal to 0 which is a pure virtual function which means that this is

131
00:11:56,039 --> 00:11:57,039
an abstract class.

132
00:11:57,159 --> 00:12:03,719
There cannot be an object corresponding to this and every derived class must necessarily

133
00:12:03,719 --> 00:12:05,240
give this function.

134
00:12:05,240 --> 00:12:11,559
This is a functionality which is common to the classes that are derived, but at an abstract

135
00:12:11,559 --> 00:12:16,279
level we cannot really execute that functionality.

136
00:12:16,279 --> 00:12:18,079
We do not know how to execute that functionality.

137
00:12:18,079 --> 00:12:24,599
So, when you put equal to 0 it means pure virtual function and if this draw has not

138
00:12:24,639 --> 00:12:29,519
been defined in a derived class the compiler will give an error.

139
00:12:29,519 --> 00:12:33,720
If you do not put a pure virtual function the compiler will not give you an error.

140
00:12:33,720 --> 00:12:36,320
So, that is a virtual function.

141
00:12:36,320 --> 00:12:40,080
Virtual function is a function which is virtual.

142
00:12:40,080 --> 00:12:41,960
Now in what sense is it virtual?

143
00:12:41,960 --> 00:12:50,120
It is a function, but whose functionality is defined by the classes down in the hierarchy.

144
00:12:50,120 --> 00:12:56,080
Any other question about virtual functions or inheritance or C plus plus in general related

145
00:12:56,080 --> 00:12:57,600
to this before I proceed?

146
00:12:57,600 --> 00:12:59,720
It is important that you stop me.

147
00:12:59,720 --> 00:13:06,720
It is possible that I might be assuming some things and that assumption may not be true.

148
00:13:06,720 --> 00:13:12,120
So, please feel free to stop me at any point of time when you have a question.

149
00:13:12,120 --> 00:13:13,120
Can we proceed now?

150
00:13:13,120 --> 00:13:14,120
Is it ok?

151
00:13:14,120 --> 00:13:15,120
Ok.

152
00:13:15,120 --> 00:13:17,879
So, that is a virtual function.

153
00:13:17,879 --> 00:13:23,320
Now let us look at the difference between virtual and non-virtual function.

154
00:13:23,320 --> 00:13:29,939
If draw had been a non-virtual function it means that this class itself will tell me

155
00:13:29,939 --> 00:13:31,720
how it has to be executed.

156
00:13:31,720 --> 00:13:35,600
The rest of the classes will simply get it.

157
00:13:35,600 --> 00:13:44,320
What happens within draw if it was a non-virtual function does not depend on the object, does

158
00:13:44,320 --> 00:13:47,440
not depend on the class of the object.

159
00:13:47,440 --> 00:13:51,200
It simply depends on the class in which it has been declared.

160
00:13:51,200 --> 00:14:00,440
Whereas for a virtual function because a pointer to a base class could hold an object every

161
00:14:00,440 --> 00:14:05,040
shape every square is a shape every circle is a shape.

162
00:14:05,040 --> 00:14:09,920
Therefore a pointer to shape can point to a circle therefore pointer to shape can point

163
00:14:09,920 --> 00:14:12,360
to a square.

164
00:14:12,360 --> 00:14:21,480
And therefore virtual functions take a different avatar depending upon the particular object

165
00:14:21,480 --> 00:14:25,399
that the pointer points to and this is a runtime decision.

166
00:14:25,399 --> 00:14:32,039
So you might say x arrow draw if x points to a circle you will end up drawing this if

167
00:14:32,039 --> 00:14:35,240
x points to a square you will end up drawing this.

168
00:14:35,240 --> 00:14:36,759
This looks like a runtime activity.

169
00:14:36,759 --> 00:14:39,720
It is a runtime decision.

170
00:14:39,720 --> 00:14:42,440
That compiler can do something.

171
00:14:42,440 --> 00:14:47,720
So we talk about yesterday we talked about advancing binding compilation and optimization

172
00:14:47,720 --> 00:14:51,120
is all about advancing bindings.

173
00:14:51,120 --> 00:14:55,720
I mentioned yesterday that I belong to that school of thought which says do not put off

174
00:14:55,720 --> 00:15:01,060
until runtime what you can do with compile time that exactly is advancing binding.

175
00:15:01,060 --> 00:15:07,759
So one option is to leave this decision completely to runtime and the other option is to leave

176
00:15:07,799 --> 00:15:14,639
the minimal decision to runtime and do as much possible at compile time at static time.

177
00:15:14,639 --> 00:15:21,360
And as I said yesterday these are the things that make interesting ideas require interesting

178
00:15:21,360 --> 00:15:31,639
ideas and this session is aimed at showing yet another beautiful idea of runtime behavior

179
00:15:31,639 --> 00:15:34,879
for that a lot of work being done at compile time.

180
00:15:35,000 --> 00:15:38,000
So when you see the signature all business is external.

181
00:15:38,000 --> 00:15:40,000
You know compile is the angle of everything.

182
00:15:40,000 --> 00:15:42,000
Scope etc is all external.

183
00:15:42,000 --> 00:15:45,720
When you look at the intermediate code or when you look at the machine code there is

184
00:15:45,720 --> 00:15:46,720
no scope.

185
00:15:46,720 --> 00:15:47,720
Where is the scope?

186
00:15:47,720 --> 00:15:50,519
You might have a compound statement or local declaration.

187
00:15:50,519 --> 00:15:52,480
Show me that in the generated code?

188
00:15:52,480 --> 00:15:53,480
No.

189
00:15:53,480 --> 00:15:56,960
So all these things are for checking.

190
00:15:56,960 --> 00:16:01,159
You know validating the input not for generating code and putting some restrictions on the

191
00:16:01,159 --> 00:16:02,159
code.

192
00:16:02,159 --> 00:16:05,319
So what is generated that information is lost.

193
00:16:05,319 --> 00:16:06,639
Which is what I want to show you.

194
00:16:06,639 --> 00:16:10,759
How it happens in the case of virtual functions.

195
00:16:10,759 --> 00:16:15,360
Any other question?

196
00:16:15,360 --> 00:16:18,759
So this is clear how data members are inherited.

197
00:16:18,759 --> 00:16:19,759
Pretty simple.

198
00:16:19,759 --> 00:16:21,879
No big deal.

199
00:16:21,879 --> 00:16:25,159
Non-virtual functions again pretty simple.

200
00:16:25,159 --> 00:16:26,240
No big deal.

201
00:16:26,240 --> 00:16:30,399
So virtual functions create interesting possibilities based on the object to which a pointer points

202
00:16:30,399 --> 00:16:31,399
to.

203
00:16:31,639 --> 00:16:35,559
A pointer to base class may point to an object of any derived class in the class hierarchy

204
00:16:35,559 --> 00:16:39,159
and the virtual function should be picked up for that object.

205
00:16:39,159 --> 00:16:45,919
And we want to do as much decision at compile time as possible leaving very little to the

206
00:16:45,919 --> 00:16:46,919
run time.

207
00:16:46,919 --> 00:16:48,379
So what is this arrangement?

208
00:16:48,379 --> 00:16:51,919
What is this static plus dynamic arrangement which enables this?

209
00:16:51,919 --> 00:16:59,319
It can't be pure in general it can't be purely compile time but virtual function optimization

210
00:16:59,320 --> 00:17:03,240
means try to do it purely at compile time.

211
00:17:03,240 --> 00:17:07,480
So let's look at some example of a virtual function and I am going to explain this.

212
00:17:07,480 --> 00:17:15,400
So we have class A, B derives from A and C derives from B. We have this function F. In

213
00:17:15,400 --> 00:17:18,720
A we have F without an argument.

214
00:17:18,720 --> 00:17:21,539
We have F with an argument so there is overloading.

215
00:17:21,539 --> 00:17:27,519
So depending upon the parameter we call different F and there is a G. All these are virtual

216
00:17:27,519 --> 00:17:32,440
functions none of them is a null virtual function and because they are not null virtual functions

217
00:17:32,440 --> 00:17:36,240
we should have their bodies and we will look at their bodies.

218
00:17:36,240 --> 00:17:38,220
But let's look at what this does.

219
00:17:38,220 --> 00:17:45,079
Class B defines a G and says it's virtual.

220
00:17:45,079 --> 00:17:54,680
It also defines F. So when B is called with F it should call this F and not this F. Because

221
00:17:55,000 --> 00:18:01,320
this F is virtual when there is object of class B F we will look at this in more example

222
00:18:01,320 --> 00:18:10,180
and C in turns only defines F. So the complex arrangement of virtual and non-virtual functions

223
00:18:10,180 --> 00:18:13,160
and we want to see what can a compiler do with it.

224
00:18:13,160 --> 00:18:15,820
So let's first look at their bodies.

225
00:18:15,820 --> 00:18:24,340
So this function F because it's in A it simply prints A colon F. This function prints

226
00:18:24,339 --> 00:18:31,459
A colon F and also prints the string the argument and this function simply says A colon G. So

227
00:18:31,459 --> 00:18:36,059
most of function simply say where they have been invoked from.

228
00:18:36,059 --> 00:18:42,339
This function G says that this function belongs to B colon G. This function F says that this

229
00:18:42,339 --> 00:18:48,779
belongs to B so it's B colon F and this says this is C colon F. So a simple idea behind

230
00:18:48,779 --> 00:18:52,259
just to identify which function is being called at what time.

231
00:18:52,819 --> 00:18:59,140
Is the arrangement of functions clear? Now let's see what happens when we look at execution.

232
00:18:59,140 --> 00:19:08,220
So these are the virtual functions. So let's look at this. We have this A, B, C three objects of

233
00:19:08,220 --> 00:19:14,019
respective classes A, B, C and now we are doing certain things and we want to imagine what's

234
00:19:14,019 --> 00:19:23,460
going to get printed. We want to see some calls. So here we have P points to an object of type A

235
00:19:23,460 --> 00:19:34,379
and then we call P arrow F with this string class A. This P arrow F, this P arrow G. So this

236
00:19:34,380 --> 00:19:44,940
function is going to print AF dot class A. Let's look at the function body. It says AF dot that

237
00:19:44,940 --> 00:19:58,100
particular string. So this will print AF class A. Easy? No doubts about that? This F will simply say

238
00:19:58,219 --> 00:20:05,419
this is an F in class A, the one without the argument and this will say this is a G in class

239
00:20:05,419 --> 00:20:12,740
A. So this is a pointer to the base class anyway. So we will have everything printed for the base

240
00:20:12,740 --> 00:20:18,579
class. So that's not so much of an interesting thing. Let's make the situation a little more

241
00:20:18,579 --> 00:20:27,259
interesting by having a pointer pointing to address of class B. What do you think should

242
00:20:27,259 --> 00:20:39,539
be printed here now? This should be because there is no string function here. So the string

243
00:20:39,539 --> 00:20:47,619
function of A dot F should get invoked. What should this print? B dot F. What should this

244
00:20:47,619 --> 00:20:57,339
print? B dot G. So it prints the following. A dot F class B because parameter is class B.

245
00:20:57,339 --> 00:21:09,459
So you are passing the name of class B to a function which is virtual but it has not been

246
00:21:09,460 --> 00:21:18,059
defined in B and since it has not been defined in B, it is going to pick up the copy from A and

247
00:21:18,059 --> 00:21:28,140
therefore it says A dot F with the parameter class B. Now we are calling F which is a virtual

248
00:21:28,140 --> 00:21:34,420
function which has been defined in B. So it is not going to pick up the value from A. Instead it is

249
00:21:34,420 --> 00:21:43,940
going to pick up the function body from B and therefore it will print B dot F. Similarly for

250
00:21:43,940 --> 00:21:51,460
G. So it is going to print B dot G. Easy? No doubts in anybody's mind? All of you with me?

251
00:21:51,460 --> 00:22:00,820
Wonderful. Let's make the situation even more interesting by picking up a pointer to C. So

252
00:22:00,819 --> 00:22:13,179
when we have a pointer to C, now what will be printed? This will print. This function will

253
00:22:13,179 --> 00:22:21,619
have to come only from here because there is no F with string anywhere. What will this print?

254
00:22:21,619 --> 00:22:40,339
P is B equal to and C. P is a pointer of P has been declared a pointer to A but it holds object

255
00:22:40,339 --> 00:22:54,259
of C. What should be printed? Tell me. So this will be AF. What will be this? C dot F and what will be this?

256
00:22:54,259 --> 00:23:17,379
Have I managed to divide the class? How many of you think this will be A dot G? No one. How many

257
00:23:17,380 --> 00:23:26,300
of you think this will be B dot G? Anyone who thinks it will be C dot G? No because there is

258
00:23:26,300 --> 00:23:41,500
no G in C. And this F, how many of you think it will be A dot F? None. B dot F? Why will it be B

259
00:23:41,500 --> 00:24:07,259
dot F? There is an F defined here. Pointer doesn't point to A, pointer points to C. So

260
00:24:07,259 --> 00:24:22,379
let us see what does my output say? It would have picked up this F. I don't know whether this

261
00:24:22,380 --> 00:24:42,740
should have been virtual. I don't remember that. So this will override this function. It will

262
00:24:42,740 --> 00:24:50,700
override this function. So there is overriding and there is a virtual business. Now let us see

263
00:24:50,700 --> 00:25:00,180
how is this complex arrangement implemented? That is the overall idea. Now let us get back to,

264
00:25:00,180 --> 00:25:08,539
so if this is the virtual function, if no virtual function, it will always be based on the declaration

265
00:25:08,539 --> 00:25:16,660
of the pointer. It will always be A dot F. So virtual function resolution is partially static

266
00:25:16,660 --> 00:25:22,820
and partially dynamic activity. At compile time, a compiler creates what it calls a virtual function

267
00:25:22,820 --> 00:25:28,620
table. There is a virtual function table for every class in the class hierarchy, a separate

268
00:25:28,620 --> 00:25:34,980
virtual function table for every class. And a compiler generates code to pick up the appropriate

269
00:25:34,980 --> 00:25:40,779
function by indexing into the virtual table for each class. So it is very efficient. In one table,

270
00:25:40,779 --> 00:25:45,980
at the second position, you want to put the function, at the third position you want to put

271
00:25:45,980 --> 00:25:50,220
the function and that function will be called. And we want to see how this arrangement is made.

272
00:25:50,220 --> 00:26:03,180
Okay, so again the same code with, so we have naive code looks like this. We have these three

273
00:26:03,180 --> 00:26:10,779
functions. V stands for virtual. We have these functions and so this class has inherited all

274
00:26:10,779 --> 00:26:17,420
these functions and then there are local functions of this and this class has inherited everything

275
00:26:17,420 --> 00:26:23,980
that V has and additionally has F, the same arrangement. And now we want to first look at

276
00:26:23,980 --> 00:26:29,619
some examples before we actually look at the arrangement. Okay, so first look at this case.

277
00:26:29,619 --> 00:26:39,460
P is a pointer to class A, okay, but we do not know what P actually holds. It is a pointer to

278
00:26:39,460 --> 00:26:46,380
class A, but it may be holding an object of class B or an object of class C. Anything is possible.

279
00:26:46,380 --> 00:26:56,940
So we do not know which class is. Okay, and now we are calling P F. Okay, so at compile time,

280
00:26:56,940 --> 00:27:05,380
in general, which object, what is the object whose address is being held in a pointer is a

281
00:27:05,380 --> 00:27:13,380
runtime activity in general. At compile time, we do not know that. Okay, so we do not know the class

282
00:27:13,380 --> 00:27:21,980
of the pointy of P. So it may be this F, right. If it happens to be a pointer to class B, it is

283
00:27:21,980 --> 00:27:28,500
going to be one of these two. Okay, if it happens to be a pointer to this class, it is going to be

284
00:27:28,500 --> 00:27:32,460
one of these and we will rule out which one is based on virtual function, but in general,

285
00:27:32,460 --> 00:27:39,539
that is a possibility. So we are looking at what are the decisions that can be taken without any

286
00:27:39,539 --> 00:27:48,420
runtime information. Here, without the runtime information, the idea is no decision can be taken.

287
00:27:48,420 --> 00:27:59,180
Let us look at this situation. Now Q is a pointer to class B. Now, if I do not know what this points

288
00:27:59,180 --> 00:28:12,299
to. Okay, can Q hold the object, can Q hold the address of an object of class A? No, it is not

289
00:28:12,299 --> 00:28:20,900
allowed. By typing, it is not allowed, right. So therefore, compiler can simply rule this out. No

290
00:28:20,900 --> 00:28:27,299
runtime information needed. It cannot be this function. Even if I do not know what the class is.

291
00:28:27,299 --> 00:28:33,339
If the program is type correct, it can never be this function, right. So I am showing what are

292
00:28:33,339 --> 00:28:38,379
the things that can be easily derived at compile time. What are the things that need runtime

293
00:28:38,379 --> 00:28:43,940
decision and where things require compile time plus runtime decision, what the arrangement is

294
00:28:43,940 --> 00:28:52,500
made. That is the way in which the story is progressing, right. Now, it could be an object

295
00:28:52,500 --> 00:28:56,460
of B. So then we have to choose between these two and we will see how do we choose that.

296
00:28:56,460 --> 00:29:07,259
Or it could be these. Third situation is we have a pointer R which is a pointer to C. Now,

297
00:29:07,259 --> 00:29:17,140
by the type system, this object can never be an object of class A or an object of class B. So,

298
00:29:17,140 --> 00:29:23,420
a compiler can rule this out completely. Similarly, a compiler can rule this out also completely.

299
00:29:23,420 --> 00:29:31,019
Not possible. The only thing that is possible is here, right. So there are certain things based

300
00:29:31,019 --> 00:29:38,779
on the declaration of the pointer, there are certain decisions that are taken, okay. So,

301
00:29:38,779 --> 00:29:46,820
if we have a pointer to one of the derived classes, certain decisions are taken. What happens when we

302
00:29:46,820 --> 00:29:51,420
have a pointer to the base class? We saw all these possibilities. How do we pick up the right

303
00:29:51,420 --> 00:30:00,259
possibility, right, without knowing what that object is? So, that is the arrangement that we

304
00:30:00,259 --> 00:30:08,340
want to see, okay. So, non-virtual function, let me just skip it. I think it is all the same story.

305
00:30:08,340 --> 00:30:14,740
Let me just, so, yeah. So, resolution of virtual function depends on the class of the pointy object.

306
00:30:14,740 --> 00:30:19,460
It needs some dynamic information. Resolution of non-virtual function depends on the class

307
00:30:19,460 --> 00:30:26,100
of the pointer and compile time information is sufficient. In either case, a pointy cannot

308
00:30:26,100 --> 00:30:35,259
belong to a higher class in the hierarchy, okay. So, we are back to the same story and consider a

309
00:30:35,259 --> 00:30:40,620
pointer to an object of class A. Now, we are ruling out the possibility that pointer is a

310
00:30:40,620 --> 00:30:46,340
pointer to these. Although it could hold an object of this, but by declaration, it is a pointer to

311
00:30:46,500 --> 00:30:53,220
class A, okay. And this pointer could point to an object of class A, B or C. So, that is the

312
00:30:53,220 --> 00:31:00,859
situation that we want to look at, okay. So, we have these functions in A, these functions in B

313
00:31:00,859 --> 00:31:08,419
and these functions in C, okay. And now, let us see what game we can play with this information,

314
00:31:08,419 --> 00:31:15,659
okay. So, now, we have these and we are trying to see how we can create a virtual function table

315
00:31:15,660 --> 00:31:22,980
in order to rule out things that are not possible, okay. So, if we have these functions,

316
00:31:22,980 --> 00:31:31,540
so now, we say that for each functions there is a single copy. This A dot F, if at all this function

317
00:31:31,540 --> 00:31:37,060
is called, we will refer to this. If at all this function is called, we will refer to this. So,

318
00:31:37,060 --> 00:31:44,740
we remove the replicated functions. We write only the functions that are not replicated and

319
00:31:45,019 --> 00:31:50,420
then make an arrangement so that these functions can be appropriately called. The reason why we

320
00:31:50,420 --> 00:31:56,140
want to do that is unlike data members, function members are not really replicated. It is the data

321
00:31:56,140 --> 00:32:02,339
that is replicated. Data has separate space. Function has only one function per class, right.

322
00:32:02,339 --> 00:32:09,579
So, we have this. So, these are the functions and now, we want to set up the pointers appropriately.

323
00:32:10,139 --> 00:32:17,339
If we have an object of this class, it can be any. So, this function will call this,

324
00:32:17,339 --> 00:32:25,059
this function will call this, this function will call this, clear. If the object is of class A,

325
00:32:25,059 --> 00:32:35,539
right. If the object is of class B, then it could call this function or it could call this function.

326
00:32:35,539 --> 00:32:43,940
What is the right thing to do? Right thing to do is to call this function, right. So,

327
00:32:43,940 --> 00:32:52,659
therefore, we remove that function. We say B dot F will always, A dot F is over A colon colon F is

328
00:32:52,659 --> 00:33:05,259
overridden by B colon colon F, right. Easy. So, now, we set up this pointer, okay. If we call this,

329
00:33:05,339 --> 00:33:13,180
this is the only function. There is no function F with a parameter, right. There is no function F

330
00:33:13,180 --> 00:33:21,579
with a parameter here. So, we say A colon colon F is inherited. So, for an object of class B,

331
00:33:21,579 --> 00:33:27,900
when F is called, it will call this. For an object of class B, F i is called, it will call this.

332
00:33:27,900 --> 00:33:37,019
Easy to see, right. And when G is called, there are two possibilities, this or this.

333
00:33:37,019 --> 00:33:44,740
Clearly, we are going to remove this. We say A colon colon G is overridden by B colon colon G.

334
00:33:44,740 --> 00:33:51,180
So, we now have determined. So, what are we doing? We are saying for every class,

335
00:33:51,340 --> 00:34:00,100
if I call F or if I call F i or if I call G, which function is going to be called? I want to make my

336
00:34:00,100 --> 00:34:06,940
arrangement. So, what I am trying to do is, what this system is trying to do is that we want to

337
00:34:06,940 --> 00:34:24,579
create a table. If we have an object of class A, what is F, what is F i and what is G? If I have

338
00:34:24,579 --> 00:34:36,980
an object of class B, what is F, what is F i and what is G? So, we are essentially setting function

339
00:34:36,980 --> 00:34:46,059
pointers. If we have an object of class B, what is F, what is F i and what is G? So, we want to set up

340
00:34:46,259 --> 00:34:54,460
these function pointers. We want to set up an array of function pointers. So, here we have said

341
00:34:54,460 --> 00:35:00,739
that this function pointer actually points to that function, whereas for these two function pointers,

342
00:35:00,739 --> 00:35:08,980
they point to this function, right. Clear? Now, let us come to class C, object of class C.

343
00:35:08,980 --> 00:35:19,059
There are three possibilities, this, this or this. Which one will retain? Obviously, the last one,

344
00:35:19,059 --> 00:35:25,820
right. So, the first two are gone. Both A colon colon F and B colon colon F are written overwritten

345
00:35:25,820 --> 00:35:33,139
by C colon colon F, right. So, now, in this table, we are setting up pointers here. So,

346
00:35:33,139 --> 00:35:43,460
we say this F is C colon colon F, ok. If it is F i, a parameter, a function F with parameter i,

347
00:35:43,460 --> 00:35:54,059
then the only option is this, right. So, we say A colon F i is inherited, right. And then,

348
00:35:54,059 --> 00:36:02,019
when we have G, we have this G, we have this G and we have this G, ok. But, this G has not been

349
00:36:02,019 --> 00:36:08,860
defined here. So, we are going to pick up this G and therefore, we will say A colon colon G is

350
00:36:08,860 --> 00:36:18,259
overwritten by B colon colon G, which is inherited in C, right. So, we are talking about all these

351
00:36:18,259 --> 00:36:27,460
three things. Something is overwritten, something is inherited, ok. So, with this arrangement,

352
00:36:27,780 --> 00:36:39,179
now, we have exactly one function per class. Is that clear? So, all these decisions can be taken

353
00:36:39,179 --> 00:36:46,380
at compile time. This is a virtual function table. Now, we have this virtual function table. Now,

354
00:36:46,380 --> 00:36:52,619
the advantage of this is that in the entire class hierarchy, we make the size of the virtual

355
00:36:52,619 --> 00:37:04,380
function table same. And then, we know F is at index 0, F i is at index 1 and G is at index 2,

356
00:37:04,380 --> 00:37:14,460
right. All we have to do is based on the object at runtime, we get the address of the right virtual

357
00:37:14,460 --> 00:37:20,420
function table. No, no, whether a function is virtual or not, that is declared by the programmer,

358
00:37:20,420 --> 00:37:25,820
is the programmer's intent. There is a virtual keyword appearing in the class. Let me try to

359
00:37:25,820 --> 00:37:32,340
understand your question well. Let us go back to that situation. Now, tell me. See, what happens

360
00:37:32,340 --> 00:37:40,019
is the following. Because this is non-virtual, if this function has been defined here, ok,

361
00:37:40,019 --> 00:37:48,139
this function will be picked up. If this function has not, I mean, and the pointer is to this. If

362
00:37:48,219 --> 00:37:52,699
it is a pointer to the class hierarchy, it is going to pick up the function at the top level,

363
00:37:52,699 --> 00:38:00,699
right. So, that overriding will happen based on the declaration. So, it will not happen. So,

364
00:38:00,699 --> 00:38:05,019
this I should put a virtual here. I think there is a mistake here. I will just correct that slide.

365
00:38:05,019 --> 00:38:11,339
Because that overriding happens not, it is not a runtime decision. It is a compile time decision

366
00:38:11,340 --> 00:38:19,059
based on the type of the declared type of the pointer, ok. I will check it once. Please note

367
00:38:19,059 --> 00:38:24,740
it down. I think this is an error here. I will run this program once again. Check it and just

368
00:38:24,740 --> 00:38:29,500
want to make sure that I am not making one more mistake. So, let us assume for the time being

369
00:38:29,500 --> 00:38:35,460
that there is a possibility of a mistake there. Now, let us see when we have constructed virtual

370
00:38:35,460 --> 00:38:40,659
function table, how do we use it? So, we have created this virtual function table, ok.

371
00:38:40,659 --> 00:38:46,980
Now, at runtime we need 2D references. Basically, we are going to talk about this. At runtime,

372
00:38:46,980 --> 00:38:56,860
we need 2D references. One is to get the virtual function table, find out what is the virtual

373
00:38:56,860 --> 00:39:05,620
function table and the second is the index in the virtual function table, ok. So, this is,

374
00:39:05,620 --> 00:39:11,620
let me skip this, ok. So, what is the compile time activity? The compile time activity is to

375
00:39:11,620 --> 00:39:16,220
collect all virtual functions across a class hierarchy, ignore non-virtual functions,

376
00:39:16,220 --> 00:39:21,380
analyze the class hierarchy to locate the appropriate function with a given permission

377
00:39:21,380 --> 00:39:28,740
of argument types and execution time activity is dereference object pointer to access the virtual

378
00:39:28,740 --> 00:39:34,460
function table. So, within the body of the object, there will be a pointer to a virtual function.

379
00:39:34,460 --> 00:39:42,740
So, the way we have x, y, z data members, we will have a hidden field called pointer to virtual

380
00:39:42,740 --> 00:39:48,539
function, right. So, as soon as, because you have the object, you have pointer to the virtual

381
00:39:48,539 --> 00:39:55,300
function, you dereference it, you access the right virtual function and then you get the right index,

382
00:39:55,300 --> 00:40:04,940
ok. So, this is how the translated code would look like. For here, we will get this underscore

383
00:40:04,940 --> 00:40:11,259
vptr is a pointer to the virtual function table. So, you get the pointer to virtual function table.

384
00:40:11,260 --> 00:40:19,980
For this function, you take index a, you take index 0, 1, 2, 1, 0, 2, whatever that arrangement

385
00:40:19,980 --> 00:40:26,460
is, I do not remember. So, these indices are fixed, you pick up the things at the right index and

386
00:40:26,460 --> 00:40:35,460
then that is going to lead to, so this is a function, a call on a function pointer. So,

387
00:40:35,460 --> 00:40:41,340
this is a pointer to a function and these are the arguments to that function and this

388
00:40:41,340 --> 00:40:49,340
table essentially contains pointers to the functions, right. This is what happens internally.

389
00:40:49,340 --> 00:40:59,059
This is the code that compiler generates, ok. Now, you will see that there are some runtime

390
00:40:59,059 --> 00:41:07,179
overheads, ok. There are untied, first of all every call has 2 dereferences. More than that,

391
00:41:07,179 --> 00:41:14,619
I mean Anshuman today talked about the call graph. What will be the call graph here? At this point

392
00:41:14,619 --> 00:41:23,420
of call or at this point of call, you will say all three functions are possible. So, you have a call

393
00:41:23,420 --> 00:41:34,579
graph that is imprecise. It is highly desirable to eliminate the spurious information from call

394
00:41:34,579 --> 00:41:47,780
graph. Can we at compile time do some kind of analysis and eliminate the, so if we are calling

395
00:41:47,940 --> 00:41:55,100
three functions, it is ideally we would like to say, I am not calling A colon colon F, B colon,

396
00:41:55,100 --> 00:42:02,540
I am, these three are not possible. I am calling this particular function. So, there are indirect

397
00:42:02,540 --> 00:42:09,140
calls. Those indirect calls can be converted to direct calls. This is a desirable activity.

398
00:42:09,140 --> 00:42:14,980
Sometimes it may not be possible to convert those calls to direct calls. In that case,

399
00:42:15,219 --> 00:42:20,179
we can say at this call point, instead of these possible 10 functions, I am calling only these

400
00:42:20,179 --> 00:42:26,980
two functions, then the interprocedural analysis results can be more precise. So,

401
00:42:26,980 --> 00:42:31,980
the optimization that I am talking about is the following. Each function call in,

402
00:42:31,980 --> 00:42:37,460
so this is the runtime overhead and no function call can be resolved at link time. So, call graph

403
00:42:37,460 --> 00:42:44,900
is not known and hence interprocedural optimizations are prohibited. So, we, the optimization here,

404
00:42:45,300 --> 00:42:52,980
because we know the object, all indirect calls have been replaced by direct calls.

405
00:42:54,780 --> 00:43:04,220
Here, this is easy. Here, this is easy and I do not know whether LLVM and GCC does it. Perhaps,

406
00:43:04,220 --> 00:43:10,619
in these simple cases, it may be able to do it. Here, there are no indirect calls and now,

407
00:43:10,619 --> 00:43:19,019
I know I have a precise call graph. Here, it is very easy because the pointer assignment is

408
00:43:19,019 --> 00:43:25,659
right here within the same function. What happens if the pointer has been set up somewhere else and

409
00:43:25,659 --> 00:43:32,500
you are passing that pointer as an argument? So, you have virtual function call x arrow f and the

410
00:43:32,500 --> 00:43:38,460
pointer has been set up somewhere in some caller's body or some function that has been executed

411
00:43:38,460 --> 00:43:48,059
before. Can you still resolve virtual functions? Can you still do something? That was the topic

412
00:43:48,059 --> 00:43:55,019
of another PhD student in my group. She submitted the thesis just now and she has come up with a

413
00:43:55,019 --> 00:44:01,260
very nice analysis which is able to do virtual function resolution which is much more precise

414
00:44:01,260 --> 00:44:07,579
than any of the existing things. Obviously, it takes care of these simplest cases, but it also

415
00:44:07,579 --> 00:44:13,259
takes care of the more general cases, most of the more general cases and certainly more precise

416
00:44:13,259 --> 00:44:19,900
than any other approach to virtual function resolution. So, that is a small part of a thesis.

417
00:44:19,900 --> 00:44:25,619
Then, the thesis goes on to build theory of bi-directional analysis. She does it in demand

418
00:44:25,619 --> 00:44:31,860
driven manner for efficiency. So, lots and lots of things which are at the moment irrelevant to

419
00:44:31,860 --> 00:44:38,380
our discussion, but this was optimization. So, optimization that I want to describe was whenever

420
00:44:38,380 --> 00:44:45,780
you have a virtual function call, try to do one of these two things. A, try to find out a single

421
00:44:45,780 --> 00:44:52,539
callee and replace the virtual function call by a direct callee if possible which is what has

422
00:44:52,539 --> 00:44:59,900
happened in all these cases. Thus, if you cannot do that, it is possible that you may not have

423
00:44:59,900 --> 00:45:06,019
information about the object or you might have information about two objects from different paths.

424
00:45:06,019 --> 00:45:13,260
A might hold a pointer to, a P might hold the address of a pointer to A along this path,

425
00:45:13,260 --> 00:45:18,440
but address of a pointer to B along this path. Then, you cannot say compile time which path is

426
00:45:18,440 --> 00:45:24,099
going to get executed and then you have to say it could be this function or that function which

427
00:45:24,099 --> 00:45:32,219
is also useful because the inter procedural path certainly becomes inter procedural control. The

428
00:45:32,219 --> 00:45:37,380
call graph for inter procedural analysis certainly becomes more precise and therefore,

429
00:45:37,380 --> 00:45:47,179
all inter procedural optimizations can benefit. So, this is what we wanted to, I wanted to

430
00:45:47,179 --> 00:45:52,900
describe and I will check that virtual business. Just give me a few minutes. Most of these

431
00:45:52,900 --> 00:46:02,139
decisions cannot depend on whether it is two level or three level. I mean, unless in two levels,

432
00:46:02,139 --> 00:46:07,860
it is able to find out in three levels, it is not able to find out, but you are saying the other way

433
00:46:07,860 --> 00:46:16,539
round. In three levels, it is able to find out. I will take a look at it. I have to understand

434
00:46:16,659 --> 00:46:29,619
any other question. So, the slides for yesterday have been uploaded already on the workshop page

435
00:46:29,619 --> 00:46:36,259
and Nimisha will be uploading these slides as well, but let me first correct. Let me just check this.

436
00:46:36,259 --> 00:46:40,340
You already uploaded? Okay, fine. So, she will upload once again if there is a correction,

437
00:46:40,340 --> 00:46:48,140
but there is a possibility that I may have to make a correction here. Can destructor be made

438
00:46:48,140 --> 00:46:56,019
virtual? I do not know. See, destructor, it is definitely the case that destructor of a derived

439
00:46:56,019 --> 00:47:02,980
class internally calls destructor of a base class because destructor, because we are also getting

440
00:47:02,980 --> 00:47:13,340
the data, the data members of the base class. So, you are saying that then the memory allocated

441
00:47:13,340 --> 00:47:23,300
in the base class may not get freed, allocated in the derived class may not get freed possible.

