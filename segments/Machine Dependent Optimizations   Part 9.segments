[{'id': 0, 'seek': 0, 'start': 0.0, 'end': 12.620000000000001, 'text': ' So, let us now see the details of how exactly we do the schedule, right. So, to model the', 'tokens': [50364, 407, 11, 718, 505, 586, 536, 264, 4365, 295, 577, 2293, 321, 360, 264, 7567, 11, 558, 13, 407, 11, 281, 2316, 264, 50995], 'temperature': 0.0, 'avg_logprob': -0.13391985658739433, 'compression_ratio': 1.6809815950920246, 'no_speech_prob': 0.033926207572221756}, {'id': 1, 'seek': 0, 'start': 12.620000000000001, 'end': 18.02, 'text': ' resource constraints in the software pipeline schedule, similar to the resource allocation', 'tokens': [50995, 7684, 18491, 294, 264, 4722, 15517, 7567, 11, 2531, 281, 264, 7684, 27599, 51265], 'temperature': 0.0, 'avg_logprob': -0.13391985658739433, 'compression_ratio': 1.6809815950920246, 'no_speech_prob': 0.033926207572221756}, {'id': 2, 'seek': 0, 'start': 18.02, 'end': 23.86, 'text': ' table that we talked in the case of instruction scheduling, we have a reservation table which', 'tokens': [51265, 3199, 300, 321, 2825, 294, 264, 1389, 295, 10951, 29055, 11, 321, 362, 257, 28922, 3199, 597, 51557], 'temperature': 0.0, 'avg_logprob': -0.13391985658739433, 'compression_ratio': 1.6809815950920246, 'no_speech_prob': 0.033926207572221756}, {'id': 3, 'seek': 2386, 'start': 23.86, 'end': 31.38, 'text': ' is called the modulo reservation table, right. And this reservation table has exactly, it', 'tokens': [50364, 307, 1219, 264, 1072, 13455, 28922, 3199, 11, 558, 13, 400, 341, 28922, 3199, 575, 2293, 11, 309, 50740], 'temperature': 0.0, 'avg_logprob': -0.16000808775424957, 'compression_ratio': 1.670731707317073, 'no_speech_prob': 0.03293542563915253}, {'id': 4, 'seek': 2386, 'start': 31.38, 'end': 39.94, 'text': ' has as many columns as the number of resources, but what would be the number of rows? The', 'tokens': [50740, 575, 382, 867, 13766, 382, 264, 1230, 295, 3593, 11, 457, 437, 576, 312, 264, 1230, 295, 13241, 30, 440, 51168], 'temperature': 0.0, 'avg_logprob': -0.16000808775424957, 'compression_ratio': 1.670731707317073, 'no_speech_prob': 0.03293542563915253}, {'id': 5, 'seek': 2386, 'start': 39.94, 'end': 46.260000000000005, 'text': ' number of rows should be equal to the initiation interval, right, because you are only talking', 'tokens': [51168, 1230, 295, 13241, 820, 312, 2681, 281, 264, 43569, 15035, 11, 558, 11, 570, 291, 366, 787, 1417, 51484], 'temperature': 0.0, 'avg_logprob': -0.16000808775424957, 'compression_ratio': 1.670731707317073, 'no_speech_prob': 0.03293542563915253}, {'id': 6, 'seek': 4626, 'start': 46.26, 'end': 55.54, 'text': ' about a schedule of length ii, right. So, this modulo reservation table is of ii columns', 'tokens': [50364, 466, 257, 7567, 295, 4641, 741, 72, 11, 558, 13, 407, 11, 341, 1072, 13455, 28922, 3199, 307, 295, 741, 72, 13766, 50828], 'temperature': 0.0, 'avg_logprob': -0.16744069910761136, 'compression_ratio': 1.560693641618497, 'no_speech_prob': 0.04964711517095566}, {'id': 7, 'seek': 4626, 'start': 55.54, 'end': 62.3, 'text': ' and f rows, where f is the number of resources that you have, right. And it essentially talks', 'tokens': [50828, 293, 283, 13241, 11, 689, 283, 307, 264, 1230, 295, 3593, 300, 291, 362, 11, 558, 13, 400, 309, 4476, 6686, 51166], 'temperature': 0.0, 'avg_logprob': -0.16744069910761136, 'compression_ratio': 1.560693641618497, 'no_speech_prob': 0.04964711517095566}, {'id': 8, 'seek': 4626, 'start': 62.3, 'end': 67.66, 'text': ' about whether a particular resource is being used in that particular step in the modulo', 'tokens': [51166, 466, 1968, 257, 1729, 7684, 307, 885, 1143, 294, 300, 1729, 1823, 294, 264, 1072, 13455, 51434], 'temperature': 0.0, 'avg_logprob': -0.16744069910761136, 'compression_ratio': 1.560693641618497, 'no_speech_prob': 0.04964711517095566}, {'id': 9, 'seek': 6766, 'start': 68.5, 'end': 76.42, 'text': ' modulo schedule. So, for example, for our example ii was 2, so we have basically 2 rows', 'tokens': [50406, 1072, 13455, 7567, 13, 407, 11, 337, 1365, 11, 337, 527, 1365, 741, 72, 390, 568, 11, 370, 321, 362, 1936, 568, 13241, 50802], 'temperature': 0.0, 'avg_logprob': -0.2037500508626302, 'compression_ratio': 1.6097560975609757, 'no_speech_prob': 0.06718037277460098}, {'id': 10, 'seek': 6766, 'start': 76.42, 'end': 83.46, 'text': ' and we had 4 functional units, right. So, now when you do the scheduling, if an operation', 'tokens': [50802, 293, 321, 632, 1017, 11745, 6815, 11, 558, 13, 407, 11, 586, 562, 291, 360, 264, 29055, 11, 498, 364, 6916, 51154], 'temperature': 0.0, 'avg_logprob': -0.2037500508626302, 'compression_ratio': 1.6097560975609757, 'no_speech_prob': 0.06718037277460098}, {'id': 11, 'seek': 6766, 'start': 83.46, 'end': 91.58, 'text': ' is scheduled at time step t, then t mod ii is a time step in which it is needed in the', 'tokens': [51154, 307, 15678, 412, 565, 1823, 256, 11, 550, 256, 1072, 741, 72, 307, 257, 565, 1823, 294, 597, 309, 307, 2978, 294, 264, 51560], 'temperature': 0.0, 'avg_logprob': -0.2037500508626302, 'compression_ratio': 1.6097560975609757, 'no_speech_prob': 0.06718037277460098}, {'id': 12, 'seek': 9158, 'start': 91.58, 'end': 97.3, 'text': ' resource modulo reservation table, that is how you mark that thing, okay.', 'tokens': [50364, 7684, 1072, 13455, 28922, 3199, 11, 300, 307, 577, 291, 1491, 300, 551, 11, 1392, 13, 50650], 'temperature': 0.0, 'avg_logprob': -0.16614358241741473, 'compression_ratio': 1.9292035398230087, 'no_speech_prob': 0.047988224774599075}, {'id': 13, 'seek': 9158, 'start': 97.3, 'end': 103.78, 'text': ' So, when you do the modulo scheduling or software pipelining, you have to ensure that it satisfies', 'tokens': [50650, 407, 11, 562, 291, 360, 264, 1072, 13455, 29055, 420, 4722, 8489, 338, 1760, 11, 291, 362, 281, 5586, 300, 309, 44271, 50974], 'temperature': 0.0, 'avg_logprob': -0.16614358241741473, 'compression_ratio': 1.9292035398230087, 'no_speech_prob': 0.047988224774599075}, {'id': 14, 'seek': 9158, 'start': 103.78, 'end': 108.58, 'text': ' the resource constraints, it also satisfies the dependence constraints, both of which', 'tokens': [50974, 264, 7684, 18491, 11, 309, 611, 44271, 264, 31704, 18491, 11, 1293, 295, 597, 51214], 'temperature': 0.0, 'avg_logprob': -0.16614358241741473, 'compression_ratio': 1.9292035398230087, 'no_speech_prob': 0.047988224774599075}, {'id': 15, 'seek': 9158, 'start': 108.58, 'end': 114.66, 'text': ' we have to make sure it does. So, resource constraint is ensured by using the modulo', 'tokens': [51214, 321, 362, 281, 652, 988, 309, 775, 13, 407, 11, 7684, 25534, 307, 3489, 3831, 538, 1228, 264, 1072, 13455, 51518], 'temperature': 0.0, 'avg_logprob': -0.16614358241741473, 'compression_ratio': 1.9292035398230087, 'no_speech_prob': 0.047988224774599075}, {'id': 16, 'seek': 9158, 'start': 114.66, 'end': 120.78, 'text': ' reservation table. Let us see how that works. So, each entry in the table records a sequence', 'tokens': [51518, 28922, 3199, 13, 961, 505, 536, 577, 300, 1985, 13, 407, 11, 1184, 8729, 294, 264, 3199, 7724, 257, 8310, 51824], 'temperature': 0.0, 'avg_logprob': -0.16614358241741473, 'compression_ratio': 1.9292035398230087, 'no_speech_prob': 0.047988224774599075}, {'id': 17, 'seek': 12078, 'start': 120.78, 'end': 127.66, 'text': ' of reservations, right. And you say if again we will take the example and then write it', 'tokens': [50364, 295, 40222, 11, 558, 13, 400, 291, 584, 498, 797, 321, 486, 747, 264, 1365, 293, 550, 2464, 309, 50708], 'temperature': 0.0, 'avg_logprob': -0.17898033989800347, 'compression_ratio': 1.893048128342246, 'no_speech_prob': 0.006354707758873701}, {'id': 18, 'seek': 12078, 'start': 127.66, 'end': 135.22, 'text': ' down that might be easier. So, for example, let us say the load instruction, right, was', 'tokens': [50708, 760, 300, 1062, 312, 3571, 13, 407, 11, 337, 1365, 11, 718, 505, 584, 264, 3677, 10951, 11, 558, 11, 390, 51086], 'temperature': 0.0, 'avg_logprob': -0.17898033989800347, 'compression_ratio': 1.893048128342246, 'no_speech_prob': 0.006354707758873701}, {'id': 19, 'seek': 12078, 'start': 135.22, 'end': 142.38, 'text': ' scheduled at time step 0, right. Then we will say that in the modulo reservation table load', 'tokens': [51086, 15678, 412, 565, 1823, 1958, 11, 558, 13, 1396, 321, 486, 584, 300, 294, 264, 1072, 13455, 28922, 3199, 3677, 51444], 'temperature': 0.0, 'avg_logprob': -0.17898033989800347, 'compression_ratio': 1.893048128342246, 'no_speech_prob': 0.006354707758873701}, {'id': 20, 'seek': 12078, 'start': 142.38, 'end': 148.66, 'text': ' is scheduled at time step 0, right. Let us say if the store was scheduled at time step', 'tokens': [51444, 307, 15678, 412, 565, 1823, 1958, 11, 558, 13, 961, 505, 584, 498, 264, 3531, 390, 15678, 412, 565, 1823, 51758], 'temperature': 0.0, 'avg_logprob': -0.17898033989800347, 'compression_ratio': 1.893048128342246, 'no_speech_prob': 0.006354707758873701}, {'id': 21, 'seek': 14866, 'start': 148.7, 'end': 159.7, 'text': ' 5, right, store is also a load store operation, time step 5 is 5 mod 2 which is 1, right.', 'tokens': [50366, 1025, 11, 558, 11, 3531, 307, 611, 257, 3677, 3531, 6916, 11, 565, 1823, 1025, 307, 1025, 1072, 568, 597, 307, 502, 11, 558, 13, 50916], 'temperature': 0.0, 'avg_logprob': -0.2661469050816127, 'compression_ratio': 1.5950920245398772, 'no_speech_prob': 0.03597676008939743}, {'id': 22, 'seek': 14866, 'start': 160.22, 'end': 167.22, 'text': ' And let us say the floating point add was scheduled at time step 2, then over there,', 'tokens': [50942, 400, 718, 505, 584, 264, 12607, 935, 909, 390, 15678, 412, 565, 1823, 568, 11, 550, 670, 456, 11, 51292], 'temperature': 0.0, 'avg_logprob': -0.2661469050816127, 'compression_ratio': 1.5950920245398772, 'no_speech_prob': 0.03597676008939743}, {'id': 23, 'seek': 14866, 'start': 168.06, 'end': 173.94, 'text': ' right. Like this you put these operations in the modulo reservation table, right. Let', 'tokens': [51334, 558, 13, 1743, 341, 291, 829, 613, 7705, 294, 264, 1072, 13455, 28922, 3199, 11, 558, 13, 961, 51628], 'temperature': 0.0, 'avg_logprob': -0.2661469050816127, 'compression_ratio': 1.5950920245398772, 'no_speech_prob': 0.03597676008939743}, {'id': 24, 'seek': 17394, 'start': 174.02, 'end': 179.02, 'text': ' us say the subtract was scheduled at time step 4, then you put it over here, right,', 'tokens': [50368, 505, 584, 264, 16390, 390, 15678, 412, 565, 1823, 1017, 11, 550, 291, 829, 309, 670, 510, 11, 558, 11, 50618], 'temperature': 0.0, 'avg_logprob': -0.1757308724000282, 'compression_ratio': 1.745, 'no_speech_prob': 0.0046516587026417255}, {'id': 25, 'seek': 17394, 'start': 179.02, 'end': 186.02, 'text': ' the integer subtract. Now, what about the integer add, right, in our let us say if you', 'tokens': [50618, 264, 24922, 16390, 13, 823, 11, 437, 466, 264, 24922, 909, 11, 558, 11, 294, 527, 718, 505, 584, 498, 291, 50968], 'temperature': 0.0, 'avg_logprob': -0.1757308724000282, 'compression_ratio': 1.745, 'no_speech_prob': 0.0046516587026417255}, {'id': 26, 'seek': 17394, 'start': 186.02, 'end': 193.02, 'text': ' want to schedule the integer add in time step 2, 4 or 6, is it possible? No, because the', 'tokens': [50968, 528, 281, 7567, 264, 24922, 909, 294, 565, 1823, 568, 11, 1017, 420, 1386, 11, 307, 309, 1944, 30, 883, 11, 570, 264, 51318], 'temperature': 0.0, 'avg_logprob': -0.1757308724000282, 'compression_ratio': 1.745, 'no_speech_prob': 0.0046516587026417255}, {'id': 27, 'seek': 17394, 'start': 193.42, 'end': 200.22, 'text': ' subtract is already there. So, you can only try in the other time step, right. If it can,', 'tokens': [51338, 16390, 307, 1217, 456, 13, 407, 11, 291, 393, 787, 853, 294, 264, 661, 565, 1823, 11, 558, 13, 759, 309, 393, 11, 51678], 'temperature': 0.0, 'avg_logprob': -0.1757308724000282, 'compression_ratio': 1.745, 'no_speech_prob': 0.0046516587026417255}, {'id': 28, 'seek': 20022, 'start': 200.22, 'end': 204.78, 'text': ' so for example, if you are trying time step 4, it is not possible because subtract is', 'tokens': [50364, 370, 337, 1365, 11, 498, 291, 366, 1382, 565, 1823, 1017, 11, 309, 307, 406, 1944, 570, 16390, 307, 50592], 'temperature': 0.0, 'avg_logprob': -0.15515923904160323, 'compression_ratio': 1.8521739130434782, 'no_speech_prob': 0.011234121397137642}, {'id': 29, 'seek': 20022, 'start': 204.78, 'end': 209.78, 'text': ' already there. Then you will try time step 5 and then see whether it can be scheduled.', 'tokens': [50592, 1217, 456, 13, 1396, 291, 486, 853, 565, 1823, 1025, 293, 550, 536, 1968, 309, 393, 312, 15678, 13, 50842], 'temperature': 0.0, 'avg_logprob': -0.15515923904160323, 'compression_ratio': 1.8521739130434782, 'no_speech_prob': 0.011234121397137642}, {'id': 30, 'seek': 20022, 'start': 209.78, 'end': 215.78, 'text': ' If it can be scheduled, you put it there. If not, you go to the next time step, but', 'tokens': [50842, 759, 309, 393, 312, 15678, 11, 291, 829, 309, 456, 13, 759, 406, 11, 291, 352, 281, 264, 958, 565, 1823, 11, 457, 51142], 'temperature': 0.0, 'avg_logprob': -0.15515923904160323, 'compression_ratio': 1.8521739130434782, 'no_speech_prob': 0.011234121397137642}, {'id': 31, 'seek': 20022, 'start': 215.78, 'end': 222.78, 'text': ' that next time step is again time step 0. So, there is no point trying to do from t', 'tokens': [51142, 300, 958, 565, 1823, 307, 797, 565, 1823, 1958, 13, 407, 11, 456, 307, 572, 935, 1382, 281, 360, 490, 256, 51492], 'temperature': 0.0, 'avg_logprob': -0.15515923904160323, 'compression_ratio': 1.8521739130434782, 'no_speech_prob': 0.011234121397137642}, {'id': 32, 'seek': 20022, 'start': 222.78, 'end': 229.78, 'text': ' to, so you only need to do from t to t plus i i minus 1, no point going beyond t plus', 'tokens': [51492, 281, 11, 370, 291, 787, 643, 281, 360, 490, 256, 281, 256, 1804, 741, 741, 3175, 502, 11, 572, 935, 516, 4399, 256, 1804, 51842], 'temperature': 0.0, 'avg_logprob': -0.15515923904160323, 'compression_ratio': 1.8521739130434782, 'no_speech_prob': 0.011234121397137642}, {'id': 33, 'seek': 22978, 'start': 229.78, 'end': 234.58, 'text': ' i, right, because it is a modulo reservation table. So, this is essentially what we need', 'tokens': [50364, 741, 11, 558, 11, 570, 309, 307, 257, 1072, 13455, 28922, 3199, 13, 407, 11, 341, 307, 4476, 437, 321, 643, 50604], 'temperature': 0.0, 'avg_logprob': -0.21029302185656978, 'compression_ratio': 1.7136929460580912, 'no_speech_prob': 0.0015417983522638679}, {'id': 34, 'seek': 22978, 'start': 234.58, 'end': 238.78, 'text': ' to understand in terms of resource constraint, correct, okay.', 'tokens': [50604, 281, 1223, 294, 2115, 295, 7684, 25534, 11, 3006, 11, 1392, 13, 50814], 'temperature': 0.0, 'avg_logprob': -0.21029302185656978, 'compression_ratio': 1.7136929460580912, 'no_speech_prob': 0.0015417983522638679}, {'id': 35, 'seek': 22978, 'start': 238.78, 'end': 245.3, 'text': ' So, again the heuristic approach uses the earliest start time and the latest start time,', 'tokens': [50814, 407, 11, 797, 264, 415, 374, 3142, 3109, 4960, 264, 20573, 722, 565, 293, 264, 6792, 722, 565, 11, 51140], 'temperature': 0.0, 'avg_logprob': -0.21029302185656978, 'compression_ratio': 1.7136929460580912, 'no_speech_prob': 0.0015417983522638679}, {'id': 36, 'seek': 22978, 'start': 245.3, 'end': 251.62, 'text': ' right, and try to use that as some kind of a priority. Try to schedule nodes which have', 'tokens': [51140, 558, 11, 293, 853, 281, 764, 300, 382, 512, 733, 295, 257, 9365, 13, 6526, 281, 7567, 13891, 597, 362, 51456], 'temperature': 0.0, 'avg_logprob': -0.21029302185656978, 'compression_ratio': 1.7136929460580912, 'no_speech_prob': 0.0015417983522638679}, {'id': 37, 'seek': 22978, 'start': 251.62, 'end': 257.3, 'text': ' less slack first and then nodes which have more slack later, okay. And as I mentioned', 'tokens': [51456, 1570, 29767, 700, 293, 550, 13891, 597, 362, 544, 29767, 1780, 11, 1392, 13, 400, 382, 286, 2835, 51740], 'temperature': 0.0, 'avg_logprob': -0.21029302185656978, 'compression_ratio': 1.7136929460580912, 'no_speech_prob': 0.0015417983522638679}, {'id': 38, 'seek': 25730, 'start': 257.3, 'end': 261.74, 'text': ' earlier to schedule an operation, you have to see whether the resource is available.', 'tokens': [50364, 3071, 281, 7567, 364, 6916, 11, 291, 362, 281, 536, 1968, 264, 7684, 307, 2435, 13, 50586], 'temperature': 0.0, 'avg_logprob': -0.19859017475996868, 'compression_ratio': 1.7118644067796611, 'no_speech_prob': 0.009220252744853497}, {'id': 39, 'seek': 25730, 'start': 261.74, 'end': 267.66, 'text': ' You use the modulo reservation table and then you check a time step t minus i i, sorry t', 'tokens': [50586, 509, 764, 264, 1072, 13455, 28922, 3199, 293, 550, 291, 1520, 257, 565, 1823, 256, 3175, 741, 741, 11, 2597, 256, 50882], 'temperature': 0.0, 'avg_logprob': -0.19859017475996868, 'compression_ratio': 1.7118644067796611, 'no_speech_prob': 0.009220252744853497}, {'id': 40, 'seek': 25730, 'start': 267.66, 'end': 274.26, 'text': ' mod i i, not t minus i i, okay. This is again a bin packing problem because you have i i', 'tokens': [50882, 1072, 741, 741, 11, 406, 256, 3175, 741, 741, 11, 1392, 13, 639, 307, 797, 257, 5171, 20815, 1154, 570, 291, 362, 741, 741, 51212], 'temperature': 0.0, 'avg_logprob': -0.19859017475996868, 'compression_ratio': 1.7118644067796611, 'no_speech_prob': 0.009220252744853497}, {'id': 41, 'seek': 25730, 'start': 274.26, 'end': 279.54, 'text': ' cross f slots and you want to pack all your operations in that such that they satisfy', 'tokens': [51212, 3278, 283, 24266, 293, 291, 528, 281, 2844, 439, 428, 7705, 294, 300, 1270, 300, 436, 19319, 51476], 'temperature': 0.0, 'avg_logprob': -0.19859017475996868, 'compression_ratio': 1.7118644067796611, 'no_speech_prob': 0.009220252744853497}, {'id': 42, 'seek': 25730, 'start': 279.54, 'end': 285.26, 'text': ' the dependency constraints and it is NP complete, okay.', 'tokens': [51476, 264, 33621, 18491, 293, 309, 307, 38611, 3566, 11, 1392, 13, 51762], 'temperature': 0.0, 'avg_logprob': -0.19859017475996868, 'compression_ratio': 1.7118644067796611, 'no_speech_prob': 0.009220252744853497}, {'id': 43, 'seek': 28526, 'start': 285.74, 'end': 291.65999999999997, 'text': ' So, here is roughly how the iterative modulo scheduler works. Let us try to look at it.', 'tokens': [50388, 407, 11, 510, 307, 9810, 577, 264, 17138, 1166, 1072, 13455, 12000, 260, 1985, 13, 961, 505, 853, 281, 574, 412, 309, 13, 50684], 'temperature': 0.0, 'avg_logprob': -0.1473349070144912, 'compression_ratio': 1.7215686274509805, 'no_speech_prob': 0.01850409246981144}, {'id': 44, 'seek': 28526, 'start': 291.65999999999997, 'end': 297.46, 'text': ' So, you start from i i is equal to minimum i i and if you are not able to get a schedule', 'tokens': [50684, 407, 11, 291, 722, 490, 741, 741, 307, 2681, 281, 7285, 741, 741, 293, 498, 291, 366, 406, 1075, 281, 483, 257, 7567, 50974], 'temperature': 0.0, 'avg_logprob': -0.1473349070144912, 'compression_ratio': 1.7215686274509805, 'no_speech_prob': 0.01850409246981144}, {'id': 45, 'seek': 28526, 'start': 297.46, 'end': 303.3, 'text': ' in this i i, you will increase your i i by 1 and keep trying and you will keep trying', 'tokens': [50974, 294, 341, 741, 741, 11, 291, 486, 3488, 428, 741, 741, 538, 502, 293, 1066, 1382, 293, 291, 486, 1066, 1382, 51266], 'temperature': 0.0, 'avg_logprob': -0.1473349070144912, 'compression_ratio': 1.7215686274509805, 'no_speech_prob': 0.01850409246981144}, {'id': 46, 'seek': 28526, 'start': 303.3, 'end': 307.74, 'text': ' until some maximum amount of things that is possible. After that you are going to say', 'tokens': [51266, 1826, 512, 6674, 2372, 295, 721, 300, 307, 1944, 13, 2381, 300, 291, 366, 516, 281, 584, 51488], 'temperature': 0.0, 'avg_logprob': -0.1473349070144912, 'compression_ratio': 1.7215686274509805, 'no_speech_prob': 0.01850409246981144}, {'id': 47, 'seek': 28526, 'start': 307.74, 'end': 313.03999999999996, 'text': ' maybe it is not worth trying to do the software pipelining for this and then come out. So,', 'tokens': [51488, 1310, 309, 307, 406, 3163, 1382, 281, 360, 264, 4722, 8489, 338, 1760, 337, 341, 293, 550, 808, 484, 13, 407, 11, 51753], 'temperature': 0.0, 'avg_logprob': -0.1473349070144912, 'compression_ratio': 1.7215686274509805, 'no_speech_prob': 0.01850409246981144}, {'id': 48, 'seek': 31304, 'start': 313.04, 'end': 318.72, 'text': ' you select an operation with a higher priority and then for that operation between its as', 'tokens': [50364, 291, 3048, 364, 6916, 365, 257, 2946, 9365, 293, 550, 337, 300, 6916, 1296, 1080, 382, 50648], 'temperature': 0.0, 'avg_logprob': -0.1345741291238804, 'compression_ratio': 2.0186046511627906, 'no_speech_prob': 0.03298303857445717}, {'id': 49, 'seek': 31304, 'start': 318.72, 'end': 326.08000000000004, 'text': ' soon as possible time to as late as possible time, you try to schedule it, correct.', 'tokens': [50648, 2321, 382, 1944, 565, 281, 382, 3469, 382, 1944, 565, 11, 291, 853, 281, 7567, 309, 11, 3006, 13, 51016], 'temperature': 0.0, 'avg_logprob': -0.1345741291238804, 'compression_ratio': 2.0186046511627906, 'no_speech_prob': 0.03298303857445717}, {'id': 50, 'seek': 31304, 'start': 326.08000000000004, 'end': 329.72, 'text': ' And in the time step in which you are trying to schedule, you want to essentially make', 'tokens': [51016, 400, 294, 264, 565, 1823, 294, 597, 291, 366, 1382, 281, 7567, 11, 291, 528, 281, 4476, 652, 51198], 'temperature': 0.0, 'avg_logprob': -0.1345741291238804, 'compression_ratio': 2.0186046511627906, 'no_speech_prob': 0.03298303857445717}, {'id': 51, 'seek': 31304, 'start': 329.72, 'end': 335.08000000000004, 'text': ' sure that there is no resource conflict in the modulo reservation table. If there is', 'tokens': [51198, 988, 300, 456, 307, 572, 7684, 6596, 294, 264, 1072, 13455, 28922, 3199, 13, 759, 456, 307, 51466], 'temperature': 0.0, 'avg_logprob': -0.1345741291238804, 'compression_ratio': 2.0186046511627906, 'no_speech_prob': 0.03298303857445717}, {'id': 52, 'seek': 31304, 'start': 335.08000000000004, 'end': 339.6, 'text': ' no resource conflict in the modulo reservation table, then you try to add this operation', 'tokens': [51466, 572, 7684, 6596, 294, 264, 1072, 13455, 28922, 3199, 11, 550, 291, 853, 281, 909, 341, 6916, 51692], 'temperature': 0.0, 'avg_logprob': -0.1345741291238804, 'compression_ratio': 2.0186046511627906, 'no_speech_prob': 0.03298303857445717}, {'id': 53, 'seek': 33960, 'start': 339.6, 'end': 345.84000000000003, 'text': ' to the schedule by marking those resources in the modulo reservation table, right. If', 'tokens': [50364, 281, 264, 7567, 538, 25482, 729, 3593, 294, 264, 1072, 13455, 28922, 3199, 11, 558, 13, 759, 50676], 'temperature': 0.0, 'avg_logprob': -0.19327033568765514, 'compression_ratio': 1.7120622568093384, 'no_speech_prob': 0.042567238211631775}, {'id': 54, 'seek': 33960, 'start': 345.84000000000003, 'end': 352.16, 'text': ' your t is greater than your ALAP time, that means that you have only fixed this much from', 'tokens': [50676, 428, 256, 307, 5044, 813, 428, 7056, 4715, 565, 11, 300, 1355, 300, 291, 362, 787, 6806, 341, 709, 490, 50992], 'temperature': 0.0, 'avg_logprob': -0.19327033568765514, 'compression_ratio': 1.7120622568093384, 'no_speech_prob': 0.042567238211631775}, {'id': 55, 'seek': 33960, 'start': 352.16, 'end': 356.28000000000003, 'text': ' the start time, earlier start time to later start time, but if you have exceeded, then', 'tokens': [50992, 264, 722, 565, 11, 3071, 722, 565, 281, 1780, 722, 565, 11, 457, 498, 291, 362, 38026, 11, 550, 51198], 'temperature': 0.0, 'avg_logprob': -0.19327033568765514, 'compression_ratio': 1.7120622568093384, 'no_speech_prob': 0.042567238211631775}, {'id': 56, 'seek': 33960, 'start': 356.28000000000003, 'end': 362.72, 'text': ' maybe something has bad has happened and you can try to fix this by doing some backtracking.', 'tokens': [51198, 1310, 746, 575, 1578, 575, 2011, 293, 291, 393, 853, 281, 3191, 341, 538, 884, 512, 646, 6903, 14134, 13, 51520], 'temperature': 0.0, 'avg_logprob': -0.19327033568765514, 'compression_ratio': 1.7120622568093384, 'no_speech_prob': 0.042567238211631775}, {'id': 57, 'seek': 33960, 'start': 362.72, 'end': 369.12, 'text': ' So, what you are going to do is that I was unable to schedule it between my earliest', 'tokens': [51520, 407, 11, 437, 291, 366, 516, 281, 360, 307, 300, 286, 390, 11299, 281, 7567, 309, 1296, 452, 20573, 51840], 'temperature': 0.0, 'avg_logprob': -0.19327033568765514, 'compression_ratio': 1.7120622568093384, 'no_speech_prob': 0.042567238211631775}, {'id': 58, 'seek': 36912, 'start': 369.12, 'end': 374.36, 'text': ' start time to the latest start time. That is why my t is greater than latest start', 'tokens': [50364, 722, 565, 281, 264, 6792, 722, 565, 13, 663, 307, 983, 452, 256, 307, 5044, 813, 6792, 722, 50626], 'temperature': 0.0, 'avg_logprob': -0.15870713765642283, 'compression_ratio': 1.9906976744186047, 'no_speech_prob': 0.004825545474886894}, {'id': 59, 'seek': 36912, 'start': 374.36, 'end': 379.32, 'text': ' time. Then what I am going to do is that I will force it in the latest start time and', 'tokens': [50626, 565, 13, 1396, 437, 286, 669, 516, 281, 360, 307, 300, 286, 486, 3464, 309, 294, 264, 6792, 722, 565, 293, 50874], 'temperature': 0.0, 'avg_logprob': -0.15870713765642283, 'compression_ratio': 1.9906976744186047, 'no_speech_prob': 0.004825545474886894}, {'id': 60, 'seek': 36912, 'start': 379.32, 'end': 384.2, 'text': ' in order for me to force it in the latest start time, I may have to eject an already', 'tokens': [50874, 294, 1668, 337, 385, 281, 3464, 309, 294, 264, 6792, 722, 565, 11, 286, 815, 362, 281, 32520, 364, 1217, 51118], 'temperature': 0.0, 'avg_logprob': -0.15870713765642283, 'compression_ratio': 1.9906976744186047, 'no_speech_prob': 0.004825545474886894}, {'id': 61, 'seek': 36912, 'start': 384.2, 'end': 389.56, 'text': ' scheduled operation from the schedule, right. So, in the modulo reservation table if you', 'tokens': [51118, 15678, 6916, 490, 264, 7567, 11, 558, 13, 407, 11, 294, 264, 1072, 13455, 28922, 3199, 498, 291, 51386], 'temperature': 0.0, 'avg_logprob': -0.15870713765642283, 'compression_ratio': 1.9906976744186047, 'no_speech_prob': 0.004825545474886894}, {'id': 62, 'seek': 36912, 'start': 389.56, 'end': 394.08, 'text': ' go back, right. So, for example, let us say I was trying to do a schedule, but let us', 'tokens': [51386, 352, 646, 11, 558, 13, 407, 11, 337, 1365, 11, 718, 505, 584, 286, 390, 1382, 281, 360, 257, 7567, 11, 457, 718, 505, 51612], 'temperature': 0.0, 'avg_logprob': -0.15870713765642283, 'compression_ratio': 1.9906976744186047, 'no_speech_prob': 0.004825545474886894}, {'id': 63, 'seek': 39408, 'start': 394.64, 'end': 399.15999999999997, 'text': ' say there was already an operation in that slot, maybe this floating point add. Then', 'tokens': [50392, 584, 456, 390, 1217, 364, 6916, 294, 300, 14747, 11, 1310, 341, 12607, 935, 909, 13, 1396, 50618], 'temperature': 0.0, 'avg_logprob': -0.19379078763202556, 'compression_ratio': 1.6614173228346456, 'no_speech_prob': 0.02578417770564556}, {'id': 64, 'seek': 39408, 'start': 399.15999999999997, 'end': 403.8, 'text': ' what I need to do is that I have to eject, right and then introduce the new operation', 'tokens': [50618, 437, 286, 643, 281, 360, 307, 300, 286, 362, 281, 32520, 11, 558, 293, 550, 5366, 264, 777, 6916, 50850], 'temperature': 0.0, 'avg_logprob': -0.19379078763202556, 'compression_ratio': 1.6614173228346456, 'no_speech_prob': 0.02578417770564556}, {'id': 65, 'seek': 39408, 'start': 403.8, 'end': 408.12, 'text': ' here and then try to see if add can be scheduled in a different cycle.', 'tokens': [50850, 510, 293, 550, 853, 281, 536, 498, 909, 393, 312, 15678, 294, 257, 819, 6586, 13, 51066], 'temperature': 0.0, 'avg_logprob': -0.19379078763202556, 'compression_ratio': 1.6614173228346456, 'no_speech_prob': 0.02578417770564556}, {'id': 66, 'seek': 39408, 'start': 408.12, 'end': 414.32, 'text': ' So, this is essentially the backtracking that we talk about, right. Eject conflicting operations', 'tokens': [51066, 407, 11, 341, 307, 4476, 264, 646, 6903, 14134, 300, 321, 751, 466, 11, 558, 13, 462, 1020, 43784, 7705, 51376], 'temperature': 0.0, 'avg_logprob': -0.19379078763202556, 'compression_ratio': 1.6614173228346456, 'no_speech_prob': 0.02578417770564556}, {'id': 67, 'seek': 39408, 'start': 414.32, 'end': 421.28, 'text': ' from the MRT and then you compute the ASR PLAP time of the remaining operations and', 'tokens': [51376, 490, 264, 9808, 51, 293, 550, 291, 14722, 264, 7469, 49, 6999, 4715, 565, 295, 264, 8877, 7705, 293, 51724], 'temperature': 0.0, 'avg_logprob': -0.19379078763202556, 'compression_ratio': 1.6614173228346456, 'no_speech_prob': 0.02578417770564556}, {'id': 68, 'seek': 42128, 'start': 421.4, 'end': 426.08, 'text': ' you kind of repeat this process, right. So, for every operation you have what is called', 'tokens': [50370, 291, 733, 295, 7149, 341, 1399, 11, 558, 13, 407, 11, 337, 633, 6916, 291, 362, 437, 307, 1219, 50604], 'temperature': 0.0, 'avg_logprob': -0.1741146857921894, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.11987727880477905}, {'id': 69, 'seek': 42128, 'start': 426.08, 'end': 430.96, 'text': ' the earliest start time and latest start time starting from the earliest start time, you', 'tokens': [50604, 264, 20573, 722, 565, 293, 6792, 722, 565, 2891, 490, 264, 20573, 722, 565, 11, 291, 50848], 'temperature': 0.0, 'avg_logprob': -0.1741146857921894, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.11987727880477905}, {'id': 70, 'seek': 42128, 'start': 430.96, 'end': 437.03999999999996, 'text': ' try to schedule it at a particular time slot where there is no resource conflict, right.', 'tokens': [50848, 853, 281, 7567, 309, 412, 257, 1729, 565, 14747, 689, 456, 307, 572, 7684, 6596, 11, 558, 13, 51152], 'temperature': 0.0, 'avg_logprob': -0.1741146857921894, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.11987727880477905}, {'id': 71, 'seek': 42128, 'start': 437.03999999999996, 'end': 443.2, 'text': ' If you cannot find such a thing, then you try to force it at its last latest starting', 'tokens': [51152, 759, 291, 2644, 915, 1270, 257, 551, 11, 550, 291, 853, 281, 3464, 309, 412, 1080, 1036, 6792, 2891, 51460], 'temperature': 0.0, 'avg_logprob': -0.1741146857921894, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.11987727880477905}, {'id': 72, 'seek': 42128, 'start': 443.2, 'end': 448.15999999999997, 'text': ' time and that would mean that some operations would get ejected. That is ok. We will try', 'tokens': [51460, 565, 293, 300, 576, 914, 300, 512, 7705, 576, 483, 32520, 292, 13, 663, 307, 3133, 13, 492, 486, 853, 51708], 'temperature': 0.0, 'avg_logprob': -0.1741146857921894, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.11987727880477905}, {'id': 73, 'seek': 44816, 'start': 448.16, 'end': 452.48, 'text': ' to schedule them again. Then you compute the earliest start time and latest start time', 'tokens': [50364, 281, 7567, 552, 797, 13, 1396, 291, 14722, 264, 20573, 722, 565, 293, 6792, 722, 565, 50580], 'temperature': 0.0, 'avg_logprob': -0.1762984620422876, 'compression_ratio': 1.857677902621723, 'no_speech_prob': 0.03549971431493759}, {'id': 74, 'seek': 44816, 'start': 452.48, 'end': 457.96000000000004, 'text': ' of all operations, redo your priority and you keep iterating this. But it may so happen', 'tokens': [50580, 295, 439, 7705, 11, 29956, 428, 9365, 293, 291, 1066, 17138, 990, 341, 13, 583, 309, 815, 370, 1051, 50854], 'temperature': 0.0, 'avg_logprob': -0.1762984620422876, 'compression_ratio': 1.857677902621723, 'no_speech_prob': 0.03549971431493759}, {'id': 75, 'seek': 44816, 'start': 457.96000000000004, 'end': 463.04, 'text': ' that one operation will eject the other, that operation will again eject back this one.', 'tokens': [50854, 300, 472, 6916, 486, 32520, 264, 661, 11, 300, 6916, 486, 797, 32520, 646, 341, 472, 13, 51108], 'temperature': 0.0, 'avg_logprob': -0.1762984620422876, 'compression_ratio': 1.857677902621723, 'no_speech_prob': 0.03549971431493759}, {'id': 76, 'seek': 44816, 'start': 463.04, 'end': 467.20000000000005, 'text': ' If it happens for multiple times, then that is where your budget will exceed and once', 'tokens': [51108, 759, 309, 2314, 337, 3866, 1413, 11, 550, 300, 307, 689, 428, 4706, 486, 14048, 293, 1564, 51316], 'temperature': 0.0, 'avg_logprob': -0.1762984620422876, 'compression_ratio': 1.857677902621723, 'no_speech_prob': 0.03549971431493759}, {'id': 77, 'seek': 44816, 'start': 467.20000000000005, 'end': 472.04, 'text': ' your budget exceeds, you come out of that you increase your I I and you try for the', 'tokens': [51316, 428, 4706, 43305, 11, 291, 808, 484, 295, 300, 291, 3488, 428, 286, 286, 293, 291, 853, 337, 264, 51558], 'temperature': 0.0, 'avg_logprob': -0.1762984620422876, 'compression_ratio': 1.857677902621723, 'no_speech_prob': 0.03549971431493759}, {'id': 78, 'seek': 44816, 'start': 472.04, 'end': 476.56, 'text': ' next I I, ok. So, this is how the software pipelining algorithm', 'tokens': [51558, 958, 286, 286, 11, 3133, 13, 407, 11, 341, 307, 577, 264, 4722, 8489, 338, 1760, 9284, 51784], 'temperature': 0.0, 'avg_logprob': -0.1762984620422876, 'compression_ratio': 1.857677902621723, 'no_speech_prob': 0.03549971431493759}, {'id': 79, 'seek': 47656, 'start': 476.6, 'end': 483.6, 'text': ' works. So, again for our example, right, let us see what happens. We found that our minimum', 'tokens': [50366, 1985, 13, 407, 11, 797, 337, 527, 1365, 11, 558, 11, 718, 505, 536, 437, 2314, 13, 492, 1352, 300, 527, 7285, 50716], 'temperature': 0.0, 'avg_logprob': -0.13037912469161184, 'compression_ratio': 1.6635071090047393, 'no_speech_prob': 0.02867729961872101}, {'id': 80, 'seek': 47656, 'start': 484.24, 'end': 490.96, 'text': ' I I is 2. So, let us start off with I I is equal to 2, right and let us try each one', 'tokens': [50748, 286, 286, 307, 568, 13, 407, 11, 718, 505, 722, 766, 365, 286, 286, 307, 2681, 281, 568, 11, 558, 293, 718, 505, 853, 1184, 472, 51084], 'temperature': 0.0, 'avg_logprob': -0.13037912469161184, 'compression_ratio': 1.6635071090047393, 'no_speech_prob': 0.02867729961872101}, {'id': 81, 'seek': 47656, 'start': 490.96, 'end': 496.2, 'text': ' of these operations. So, first let us take the load operation and try to see whether', 'tokens': [51084, 295, 613, 7705, 13, 407, 11, 700, 718, 505, 747, 264, 3677, 6916, 293, 853, 281, 536, 1968, 51346], 'temperature': 0.0, 'avg_logprob': -0.13037912469161184, 'compression_ratio': 1.6635071090047393, 'no_speech_prob': 0.02867729961872101}, {'id': 82, 'seek': 47656, 'start': 496.2, 'end': 501.6, 'text': ' we can schedule it at time step 0, right. It is possible to schedule because no resources', 'tokens': [51346, 321, 393, 7567, 309, 412, 565, 1823, 1958, 11, 558, 13, 467, 307, 1944, 281, 7567, 570, 572, 3593, 51616], 'temperature': 0.0, 'avg_logprob': -0.13037912469161184, 'compression_ratio': 1.6635071090047393, 'no_speech_prob': 0.02867729961872101}, {'id': 83, 'seek': 50160, 'start': 501.68, 'end': 506.76000000000005, 'text': ' being used at this point. Then let us take the add operation. The add operation will', 'tokens': [50368, 885, 1143, 412, 341, 935, 13, 1396, 718, 505, 747, 264, 909, 6916, 13, 440, 909, 6916, 486, 50622], 'temperature': 0.0, 'avg_logprob': -0.1683824104175233, 'compression_ratio': 1.86864406779661, 'no_speech_prob': 0.02425622008740902}, {'id': 84, 'seek': 50160, 'start': 506.76000000000005, 'end': 511.28000000000003, 'text': ' have an earliest start time which is 2 cycles after the load operation. Therefore, it will', 'tokens': [50622, 362, 364, 20573, 722, 565, 597, 307, 568, 17796, 934, 264, 3677, 6916, 13, 7504, 11, 309, 486, 50848], 'temperature': 0.0, 'avg_logprob': -0.1683824104175233, 'compression_ratio': 1.86864406779661, 'no_speech_prob': 0.02425622008740902}, {'id': 85, 'seek': 50160, 'start': 511.28000000000003, 'end': 518.12, 'text': ' only be t equal to 2. Now, again if you try t equal to 2 at that particular slot, there', 'tokens': [50848, 787, 312, 256, 2681, 281, 568, 13, 823, 11, 797, 498, 291, 853, 256, 2681, 281, 568, 412, 300, 1729, 14747, 11, 456, 51190], 'temperature': 0.0, 'avg_logprob': -0.1683824104175233, 'compression_ratio': 1.86864406779661, 'no_speech_prob': 0.02425622008740902}, {'id': 86, 'seek': 50160, 'start': 518.12, 'end': 524.12, 'text': ' is a resource which is freely available. So, add can also be started at t equal to 2. Then', 'tokens': [51190, 307, 257, 7684, 597, 307, 16433, 2435, 13, 407, 11, 909, 393, 611, 312, 1409, 412, 256, 2681, 281, 568, 13, 1396, 51490], 'temperature': 0.0, 'avg_logprob': -0.1683824104175233, 'compression_ratio': 1.86864406779661, 'no_speech_prob': 0.02425622008740902}, {'id': 87, 'seek': 50160, 'start': 524.12, 'end': 529.96, 'text': ' the next is store. Store can only start at t sorry, store can only start at t equal to', 'tokens': [51490, 264, 958, 307, 3531, 13, 17242, 393, 787, 722, 412, 256, 2597, 11, 3531, 393, 787, 722, 412, 256, 2681, 281, 51782], 'temperature': 0.0, 'avg_logprob': -0.1683824104175233, 'compression_ratio': 1.86864406779661, 'no_speech_prob': 0.02425622008740902}, {'id': 88, 'seek': 52996, 'start': 529.96, 'end': 536.6800000000001, 'text': ' 5, right and 5 is essentially time step 1 in the modulo reservation table. So, you can', 'tokens': [50364, 1025, 11, 558, 293, 1025, 307, 4476, 565, 1823, 502, 294, 264, 1072, 13455, 28922, 3199, 13, 407, 11, 291, 393, 50700], 'temperature': 0.0, 'avg_logprob': -0.21742704076674377, 'compression_ratio': 1.7330508474576272, 'no_speech_prob': 0.00971735268831253}, {'id': 89, 'seek': 52996, 'start': 536.6800000000001, 'end': 541.08, 'text': ' put it there. Now, what about the integer add and the integer', 'tokens': [50700, 829, 309, 456, 13, 823, 11, 437, 466, 264, 24922, 909, 293, 264, 24922, 50920], 'temperature': 0.0, 'avg_logprob': -0.21742704076674377, 'compression_ratio': 1.7330508474576272, 'no_speech_prob': 0.00971735268831253}, {'id': 90, 'seek': 52996, 'start': 541.08, 'end': 546.88, 'text': ' subtract that times are given here and you can try to see that they are also not conflicting.', 'tokens': [50920, 16390, 300, 1413, 366, 2212, 510, 293, 291, 393, 853, 281, 536, 300, 436, 366, 611, 406, 43784, 13, 51210], 'temperature': 0.0, 'avg_logprob': -0.21742704076674377, 'compression_ratio': 1.7330508474576272, 'no_speech_prob': 0.00971735268831253}, {'id': 91, 'seek': 52996, 'start': 546.88, 'end': 551.9200000000001, 'text': ' Then lastly you have the branch instruction that is also not conflicting. You can put', 'tokens': [51210, 1396, 16386, 291, 362, 264, 9819, 10951, 300, 307, 611, 406, 43784, 13, 509, 393, 829, 51462], 'temperature': 0.0, 'avg_logprob': -0.21742704076674377, 'compression_ratio': 1.7330508474576272, 'no_speech_prob': 0.00971735268831253}, {'id': 92, 'seek': 52996, 'start': 551.9200000000001, 'end': 558.9200000000001, 'text': ' it in that, right. So, this is how you try to do software pipeline schedule, ok.', 'tokens': [51462, 309, 294, 300, 11, 558, 13, 407, 11, 341, 307, 577, 291, 853, 281, 360, 4722, 15517, 7567, 11, 3133, 13, 51812], 'temperature': 0.0, 'avg_logprob': -0.21742704076674377, 'compression_ratio': 1.7330508474576272, 'no_speech_prob': 0.00971735268831253}, {'id': 93, 'seek': 55892, 'start': 559.16, 'end': 566.0, 'text': ' So, what we can do is I have another 3 or 4 slides which is about register requirements', 'tokens': [50376, 407, 11, 437, 321, 393, 360, 307, 286, 362, 1071, 805, 420, 1017, 9788, 597, 307, 466, 7280, 7728, 50718], 'temperature': 0.0, 'avg_logprob': -0.1497194533254586, 'compression_ratio': 1.6963562753036436, 'no_speech_prob': 0.007727035786956549}, {'id': 94, 'seek': 55892, 'start': 566.0, 'end': 572.1999999999999, 'text': ' in modulo scheduling, ok in software pipeline schedule. Maybe I will just skip this thing', 'tokens': [50718, 294, 1072, 13455, 29055, 11, 3133, 294, 4722, 15517, 7567, 13, 2704, 286, 486, 445, 10023, 341, 551, 51028], 'temperature': 0.0, 'avg_logprob': -0.1497194533254586, 'compression_ratio': 1.6963562753036436, 'no_speech_prob': 0.007727035786956549}, {'id': 95, 'seek': 55892, 'start': 572.1999999999999, 'end': 578.12, 'text': ' because it will be going into a lot of details, ok or maybe just I will tell you what the', 'tokens': [51028, 570, 309, 486, 312, 516, 666, 257, 688, 295, 4365, 11, 3133, 420, 1310, 445, 286, 486, 980, 291, 437, 264, 51324], 'temperature': 0.0, 'avg_logprob': -0.1497194533254586, 'compression_ratio': 1.6963562753036436, 'no_speech_prob': 0.007727035786956549}, {'id': 96, 'seek': 55892, 'start': 578.12, 'end': 581.68, 'text': ' problem is and then we will come back and look at it, ok.', 'tokens': [51324, 1154, 307, 293, 550, 321, 486, 808, 646, 293, 574, 412, 309, 11, 3133, 13, 51502], 'temperature': 0.0, 'avg_logprob': -0.1497194533254586, 'compression_ratio': 1.6963562753036436, 'no_speech_prob': 0.007727035786956549}, {'id': 97, 'seek': 55892, 'start': 581.68, 'end': 586.56, 'text': ' So, let us now look at having scheduled these instructions like this in the software pipeline', 'tokens': [51502, 407, 11, 718, 505, 586, 574, 412, 1419, 15678, 613, 9415, 411, 341, 294, 264, 4722, 15517, 51746], 'temperature': 0.0, 'avg_logprob': -0.1497194533254586, 'compression_ratio': 1.6963562753036436, 'no_speech_prob': 0.007727035786956549}, {'id': 98, 'seek': 58656, 'start': 586.64, 'end': 592.28, 'text': ' schedule. Let us see what is really happening with regard to the registers, right. Now,', 'tokens': [50368, 7567, 13, 961, 505, 536, 437, 307, 534, 2737, 365, 3843, 281, 264, 38351, 11, 558, 13, 823, 11, 50650], 'temperature': 0.0, 'avg_logprob': -0.17973722325693262, 'compression_ratio': 1.743801652892562, 'no_speech_prob': 0.03884109482169151}, {'id': 99, 'seek': 58656, 'start': 592.28, 'end': 597.64, 'text': ' think of this as iteration i, i plus 1 and i plus 2, but a software pipeline schedule', 'tokens': [50650, 519, 295, 341, 382, 24784, 741, 11, 741, 1804, 502, 293, 741, 1804, 568, 11, 457, 257, 4722, 15517, 7567, 50918], 'temperature': 0.0, 'avg_logprob': -0.17973722325693262, 'compression_ratio': 1.743801652892562, 'no_speech_prob': 0.03884109482169151}, {'id': 100, 'seek': 58656, 'start': 597.64, 'end': 603.7199999999999, 'text': ' only has one of them, right. For our purpose we have actually written down successive iterations,', 'tokens': [50918, 787, 575, 472, 295, 552, 11, 558, 13, 1171, 527, 4334, 321, 362, 767, 3720, 760, 48043, 36540, 11, 51222], 'temperature': 0.0, 'avg_logprob': -0.17973722325693262, 'compression_ratio': 1.743801652892562, 'no_speech_prob': 0.03884109482169151}, {'id': 101, 'seek': 58656, 'start': 603.7199999999999, 'end': 607.52, 'text': ' but the schedule itself has only one iteration in the code.', 'tokens': [51222, 457, 264, 7567, 2564, 575, 787, 472, 24784, 294, 264, 3089, 13, 51412], 'temperature': 0.0, 'avg_logprob': -0.17973722325693262, 'compression_ratio': 1.743801652892562, 'no_speech_prob': 0.03884109482169151}, {'id': 102, 'seek': 58656, 'start': 607.52, 'end': 613.4799999999999, 'text': ' Now, the load instruction is going to produce a value which is going to be consumed by the', 'tokens': [51412, 823, 11, 264, 3677, 10951, 307, 516, 281, 5258, 257, 2158, 597, 307, 516, 281, 312, 21226, 538, 264, 51710], 'temperature': 0.0, 'avg_logprob': -0.17973722325693262, 'compression_ratio': 1.743801652892562, 'no_speech_prob': 0.03884109482169151}, {'id': 103, 'seek': 61348, 'start': 613.5600000000001, 'end': 619.5600000000001, 'text': ' floating point add instruction, but in our schedule, right if you look at it, right,', 'tokens': [50368, 12607, 935, 909, 10951, 11, 457, 294, 527, 7567, 11, 558, 498, 291, 574, 412, 309, 11, 558, 11, 50668], 'temperature': 0.0, 'avg_logprob': -0.20289221962729653, 'compression_ratio': 1.75, 'no_speech_prob': 0.03440653905272484}, {'id': 104, 'seek': 61348, 'start': 619.5600000000001, 'end': 626.5600000000001, 'text': ' ith iteration of the load, i minus 1th iteration of the add and i minus second iteration of', 'tokens': [50668, 309, 71, 24784, 295, 264, 3677, 11, 741, 3175, 502, 392, 24784, 295, 264, 909, 293, 741, 3175, 1150, 24784, 295, 51018], 'temperature': 0.0, 'avg_logprob': -0.20289221962729653, 'compression_ratio': 1.75, 'no_speech_prob': 0.03440653905272484}, {'id': 105, 'seek': 61348, 'start': 627.04, 'end': 634.04, 'text': ' the store are together in a loop, correct. So, when I unroll this 3 or 4 times then essentially', 'tokens': [51042, 264, 3531, 366, 1214, 294, 257, 6367, 11, 3006, 13, 407, 11, 562, 286, 517, 3970, 341, 805, 420, 1017, 1413, 550, 4476, 51392], 'temperature': 0.0, 'avg_logprob': -0.20289221962729653, 'compression_ratio': 1.75, 'no_speech_prob': 0.03440653905272484}, {'id': 106, 'seek': 61348, 'start': 634.12, 'end': 640.2, 'text': ' this is what I get. This load corresponds to the ith iteration, this add corresponds', 'tokens': [51396, 341, 307, 437, 286, 483, 13, 639, 3677, 23249, 281, 264, 309, 71, 24784, 11, 341, 909, 23249, 51700], 'temperature': 0.0, 'avg_logprob': -0.20289221962729653, 'compression_ratio': 1.75, 'no_speech_prob': 0.03440653905272484}, {'id': 107, 'seek': 64020, 'start': 640.2, 'end': 647.2, 'text': ' to the ith iteration and this store corresponds to the ith iteration. I have marked them as', 'tokens': [50364, 281, 264, 309, 71, 24784, 293, 341, 3531, 23249, 281, 264, 309, 71, 24784, 13, 286, 362, 12658, 552, 382, 50714], 'temperature': 0.0, 'avg_logprob': -0.17763093647203948, 'compression_ratio': 1.8693467336683418, 'no_speech_prob': 0.004869835451245308}, {'id': 108, 'seek': 64020, 'start': 647.2800000000001, 'end': 654.2800000000001, 'text': ' load 1, add 1 and store 1, right. Similarly, yeah, this corresponds to the i plus 1th iteration,', 'tokens': [50718, 3677, 502, 11, 909, 502, 293, 3531, 502, 11, 558, 13, 13157, 11, 1338, 11, 341, 23249, 281, 264, 741, 1804, 502, 392, 24784, 11, 51068], 'temperature': 0.0, 'avg_logprob': -0.17763093647203948, 'compression_ratio': 1.8693467336683418, 'no_speech_prob': 0.004869835451245308}, {'id': 109, 'seek': 64020, 'start': 655.0, 'end': 659.6400000000001, 'text': ' this corresponds to the i plus 1th iteration. Now, let us look at the register requirements', 'tokens': [51104, 341, 23249, 281, 264, 741, 1804, 502, 392, 24784, 13, 823, 11, 718, 505, 574, 412, 264, 7280, 7728, 51336], 'temperature': 0.0, 'avg_logprob': -0.17763093647203948, 'compression_ratio': 1.8693467336683418, 'no_speech_prob': 0.004869835451245308}, {'id': 110, 'seek': 64020, 'start': 659.6400000000001, 'end': 666.6400000000001, 'text': ' and their live ranges, right. So, load produces a value which is being consumed by the add,', 'tokens': [51336, 293, 641, 1621, 22526, 11, 558, 13, 407, 11, 3677, 14725, 257, 2158, 597, 307, 885, 21226, 538, 264, 909, 11, 51686], 'temperature': 0.0, 'avg_logprob': -0.17763093647203948, 'compression_ratio': 1.8693467336683418, 'no_speech_prob': 0.004869835451245308}, {'id': 111, 'seek': 66664, 'start': 667.64, 'end': 674.64, 'text': ' right. Whereas, add produces a value which is being consumed by the store, right. Now,', 'tokens': [50414, 558, 13, 13813, 11, 909, 14725, 257, 2158, 597, 307, 885, 21226, 538, 264, 3531, 11, 558, 13, 823, 11, 50764], 'temperature': 0.0, 'avg_logprob': -0.1553485914208423, 'compression_ratio': 2.0166666666666666, 'no_speech_prob': 0.0019823231268674135}, {'id': 112, 'seek': 66664, 'start': 677.04, 'end': 684.04, 'text': ' this is for the add instruction. The add instruction produces a value which is being used by the', 'tokens': [50884, 341, 307, 337, 264, 909, 10951, 13, 440, 909, 10951, 14725, 257, 2158, 597, 307, 885, 1143, 538, 264, 51234], 'temperature': 0.0, 'avg_logprob': -0.1553485914208423, 'compression_ratio': 2.0166666666666666, 'no_speech_prob': 0.0019823231268674135}, {'id': 113, 'seek': 66664, 'start': 685.0, 'end': 690.62, 'text': ' store instruction as the index, right, pointer. Therefore, its live range starts from here', 'tokens': [51282, 3531, 10951, 382, 264, 8186, 11, 558, 11, 23918, 13, 7504, 11, 1080, 1621, 3613, 3719, 490, 510, 51563], 'temperature': 0.0, 'avg_logprob': -0.1553485914208423, 'compression_ratio': 2.0166666666666666, 'no_speech_prob': 0.0019823231268674135}, {'id': 114, 'seek': 66664, 'start': 690.62, 'end': 696.04, 'text': ' and goes all the way up to here. Now, this is for the subtract instruction. The subtract', 'tokens': [51563, 293, 1709, 439, 264, 636, 493, 281, 510, 13, 823, 11, 341, 307, 337, 264, 16390, 10951, 13, 440, 16390, 51834], 'temperature': 0.0, 'avg_logprob': -0.1553485914208423, 'compression_ratio': 2.0166666666666666, 'no_speech_prob': 0.0019823231268674135}, {'id': 115, 'seek': 69604, 'start': 696.04, 'end': 703.04, 'text': ' instruction produces a value, right, which is going to be used by the branch instruction,', 'tokens': [50364, 10951, 14725, 257, 2158, 11, 558, 11, 597, 307, 516, 281, 312, 1143, 538, 264, 9819, 10951, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.24821358192257764, 'compression_ratio': 1.6243654822335025, 'no_speech_prob': 0.0014443534892052412}, {'id': 116, 'seek': 69604, 'start': 703.04, 'end': 706.92, 'text': ' ok, the same thing being repeated in the next one.', 'tokens': [50714, 3133, 11, 264, 912, 551, 885, 10477, 294, 264, 958, 472, 13, 50908], 'temperature': 0.0, 'avg_logprob': -0.24821358192257764, 'compression_ratio': 1.6243654822335025, 'no_speech_prob': 0.0014443534892052412}, {'id': 117, 'seek': 69604, 'start': 706.92, 'end': 713.92, 'text': ' Now, what are we seeing, right? Let us look at specifically the register used by add 1,', 'tokens': [50908, 823, 11, 437, 366, 321, 2577, 11, 558, 30, 961, 505, 574, 412, 4682, 264, 7280, 1143, 538, 909, 502, 11, 51258], 'temperature': 0.0, 'avg_logprob': -0.24821358192257764, 'compression_ratio': 1.6243654822335025, 'no_speech_prob': 0.0014443534892052412}, {'id': 118, 'seek': 69604, 'start': 714.4, 'end': 721.4, 'text': ' right. The register, let us say if f naught is the destination register for add 1, correct.', 'tokens': [51282, 558, 13, 440, 7280, 11, 718, 505, 584, 498, 283, 13138, 307, 264, 12236, 7280, 337, 909, 502, 11, 3006, 13, 51632], 'temperature': 0.0, 'avg_logprob': -0.24821358192257764, 'compression_ratio': 1.6243654822335025, 'no_speech_prob': 0.0014443534892052412}, {'id': 119, 'seek': 72140, 'start': 721.4, 'end': 728.4, 'text': ' Now, when is that being used? It is being used after three cycles in here, but before', 'tokens': [50364, 823, 11, 562, 307, 300, 885, 1143, 30, 467, 307, 885, 1143, 934, 1045, 17796, 294, 510, 11, 457, 949, 50714], 'temperature': 0.0, 'avg_logprob': -0.19276624826284555, 'compression_ratio': 1.6815286624203822, 'no_speech_prob': 0.0032291999086737633}, {'id': 120, 'seek': 72140, 'start': 731.24, 'end': 738.24, 'text': ' that I have one more add instruction which is trying to rewrite into this. In fact, this', 'tokens': [50856, 300, 286, 362, 472, 544, 909, 10951, 597, 307, 1382, 281, 28132, 666, 341, 13, 682, 1186, 11, 341, 51206], 'temperature': 0.0, 'avg_logprob': -0.19276624826284555, 'compression_ratio': 1.6815286624203822, 'no_speech_prob': 0.0032291999086737633}, {'id': 121, 'seek': 72140, 'start': 739.6, 'end': 744.56, 'text': ' f naught register and this f naught register or this live range and this live range, they', 'tokens': [51274, 283, 13138, 7280, 293, 341, 283, 13138, 7280, 420, 341, 1621, 3613, 293, 341, 1621, 3613, 11, 436, 51522], 'temperature': 0.0, 'avg_logprob': -0.19276624826284555, 'compression_ratio': 1.6815286624203822, 'no_speech_prob': 0.0032291999086737633}, {'id': 122, 'seek': 74456, 'start': 744.5999999999999, 'end': 750.3599999999999, 'text': ' are conflicting, but we have the same register being used for that, right.', 'tokens': [50366, 366, 43784, 11, 457, 321, 362, 264, 912, 7280, 885, 1143, 337, 300, 11, 558, 13, 50654], 'temperature': 0.0, 'avg_logprob': -0.13732395780847428, 'compression_ratio': 1.6699507389162562, 'no_speech_prob': 0.0024918352719396353}, {'id': 123, 'seek': 74456, 'start': 750.3599999999999, 'end': 757.3599999999999, 'text': ' So, my add instruction here, right, what are the register values for this? May be f naught', 'tokens': [50654, 407, 11, 452, 909, 10951, 510, 11, 558, 11, 437, 366, 264, 7280, 4190, 337, 341, 30, 1891, 312, 283, 13138, 51004], 'temperature': 0.0, 'avg_logprob': -0.13732395780847428, 'compression_ratio': 1.6699507389162562, 'no_speech_prob': 0.0024918352719396353}, {'id': 124, 'seek': 74456, 'start': 758.4, 'end': 765.4, 'text': ' f 2 f 4, correct. Remember that in the code there is only one version of the code, one', 'tokens': [51056, 283, 568, 283, 1017, 11, 3006, 13, 5459, 300, 294, 264, 3089, 456, 307, 787, 472, 3037, 295, 264, 3089, 11, 472, 51406], 'temperature': 0.0, 'avg_logprob': -0.13732395780847428, 'compression_ratio': 1.6699507389162562, 'no_speech_prob': 0.0024918352719396353}, {'id': 125, 'seek': 74456, 'start': 767.04, 'end': 773.2399999999999, 'text': ' iteration of the code. So, it uses the value f naught f 2 f 4. So, when I come back in', 'tokens': [51488, 24784, 295, 264, 3089, 13, 407, 11, 309, 4960, 264, 2158, 283, 13138, 283, 568, 283, 1017, 13, 407, 11, 562, 286, 808, 646, 294, 51798], 'temperature': 0.0, 'avg_logprob': -0.13732395780847428, 'compression_ratio': 1.6699507389162562, 'no_speech_prob': 0.0024918352719396353}, {'id': 126, 'seek': 77324, 'start': 773.24, 'end': 779.64, 'text': ' the next iteration, I am trying to redefine that value, but this redefinition is happening', 'tokens': [50364, 264, 958, 24784, 11, 286, 669, 1382, 281, 38818, 533, 300, 2158, 11, 457, 341, 14328, 5194, 849, 307, 2737, 50684], 'temperature': 0.0, 'avg_logprob': -0.17759711243385493, 'compression_ratio': 1.7676767676767677, 'no_speech_prob': 0.004953745752573013}, {'id': 127, 'seek': 77324, 'start': 779.64, 'end': 786.64, 'text': ' before its use has happened. That means that before the store takes the value, I would', 'tokens': [50684, 949, 1080, 764, 575, 2011, 13, 663, 1355, 300, 949, 264, 3531, 2516, 264, 2158, 11, 286, 576, 51034], 'temperature': 0.0, 'avg_logprob': -0.17759711243385493, 'compression_ratio': 1.7676767676767677, 'no_speech_prob': 0.004953745752573013}, {'id': 128, 'seek': 77324, 'start': 787.44, 'end': 792.44, 'text': ' have overwritten it. In some sense, it is like a war dependency, right. This is the', 'tokens': [51074, 362, 670, 26859, 309, 13, 682, 512, 2020, 11, 309, 307, 411, 257, 1516, 33621, 11, 558, 13, 639, 307, 264, 51324], 'temperature': 0.0, 'avg_logprob': -0.17759711243385493, 'compression_ratio': 1.7676767676767677, 'no_speech_prob': 0.004953745752573013}, {'id': 129, 'seek': 77324, 'start': 792.44, 'end': 799.12, 'text': ' read that should have happened and this write should only happen after that, but we have', 'tokens': [51324, 1401, 300, 820, 362, 2011, 293, 341, 2464, 820, 787, 1051, 934, 300, 11, 457, 321, 362, 51658], 'temperature': 0.0, 'avg_logprob': -0.17759711243385493, 'compression_ratio': 1.7676767676767677, 'no_speech_prob': 0.004953745752573013}, {'id': 130, 'seek': 79912, 'start': 799.12, 'end': 804.96, 'text': ' scheduled it so that now it is going to happen before. In other words, a single register', 'tokens': [50364, 15678, 309, 370, 300, 586, 309, 307, 516, 281, 1051, 949, 13, 682, 661, 2283, 11, 257, 2167, 7280, 50656], 'temperature': 0.0, 'avg_logprob': -0.17665373560893965, 'compression_ratio': 1.5970873786407767, 'no_speech_prob': 0.007488994859158993}, {'id': 131, 'seek': 79912, 'start': 804.96, 'end': 811.96, 'text': ' is not enough for add. You need to know how two registers because it has two live ranges,', 'tokens': [50656, 307, 406, 1547, 337, 909, 13, 509, 643, 281, 458, 577, 732, 38351, 570, 309, 575, 732, 1621, 22526, 11, 51006], 'temperature': 0.0, 'avg_logprob': -0.17665373560893965, 'compression_ratio': 1.5970873786407767, 'no_speech_prob': 0.007488994859158993}, {'id': 132, 'seek': 79912, 'start': 813.0, 'end': 820.0, 'text': ' this and this and they are overlapping, correct. So, you need more than one register for f', 'tokens': [51058, 341, 293, 341, 293, 436, 366, 33535, 11, 3006, 13, 407, 11, 291, 643, 544, 813, 472, 7280, 337, 283, 51408], 'temperature': 0.0, 'avg_logprob': -0.17665373560893965, 'compression_ratio': 1.5970873786407767, 'no_speech_prob': 0.007488994859158993}, {'id': 133, 'seek': 79912, 'start': 821.04, 'end': 825.2, 'text': ' naught itself. Similarly, if you look at the green one, you', 'tokens': [51460, 13138, 2564, 13, 13157, 11, 498, 291, 574, 412, 264, 3092, 472, 11, 291, 51668], 'temperature': 0.0, 'avg_logprob': -0.17665373560893965, 'compression_ratio': 1.5970873786407767, 'no_speech_prob': 0.007488994859158993}, {'id': 134, 'seek': 82520, 'start': 825.2, 'end': 831.12, 'text': ' have three, right. There will be one more green here, right. So, there will be three', 'tokens': [50364, 362, 1045, 11, 558, 13, 821, 486, 312, 472, 544, 3092, 510, 11, 558, 13, 407, 11, 456, 486, 312, 1045, 50660], 'temperature': 0.0, 'avg_logprob': -0.164248652841853, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.005833262577652931}, {'id': 135, 'seek': 82520, 'start': 831.12, 'end': 837.6, 'text': ' that will be overlapping with each other, correct. So, this problem is essentially the', 'tokens': [50660, 300, 486, 312, 33535, 365, 1184, 661, 11, 3006, 13, 407, 11, 341, 1154, 307, 4476, 264, 50984], 'temperature': 0.0, 'avg_logprob': -0.164248652841853, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.005833262577652931}, {'id': 136, 'seek': 82520, 'start': 837.6, 'end': 844.6, 'text': ' register allocation problem in software pipelining, okay. Now, if you are looking at the rolled', 'tokens': [50984, 7280, 27599, 1154, 294, 4722, 8489, 338, 1760, 11, 1392, 13, 823, 11, 498, 291, 366, 1237, 412, 264, 14306, 51334], 'temperature': 0.0, 'avg_logprob': -0.164248652841853, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.005833262577652931}, {'id': 137, 'seek': 82520, 'start': 844.8000000000001, 'end': 849.12, 'text': ' version, the compact version that is what is going to really be in the loop, this is', 'tokens': [51344, 3037, 11, 264, 14679, 3037, 300, 307, 437, 307, 516, 281, 534, 312, 294, 264, 6367, 11, 341, 307, 51560], 'temperature': 0.0, 'avg_logprob': -0.164248652841853, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.005833262577652931}, {'id': 138, 'seek': 84912, 'start': 849.12, 'end': 855.28, 'text': ' what it is. As you can see that the floating point operation is going to use a register', 'tokens': [50364, 437, 309, 307, 13, 1018, 291, 393, 536, 300, 264, 12607, 935, 6916, 307, 516, 281, 764, 257, 7280, 50672], 'temperature': 0.0, 'avg_logprob': -0.12998729593613567, 'compression_ratio': 2.1201923076923075, 'no_speech_prob': 0.005363540258258581}, {'id': 139, 'seek': 84912, 'start': 855.28, 'end': 860.68, 'text': ' which is going to overlap with itself. The subtract is going to use a register which', 'tokens': [50672, 597, 307, 516, 281, 19959, 365, 2564, 13, 440, 16390, 307, 516, 281, 764, 257, 7280, 597, 50942], 'temperature': 0.0, 'avg_logprob': -0.12998729593613567, 'compression_ratio': 2.1201923076923075, 'no_speech_prob': 0.005363540258258581}, {'id': 140, 'seek': 84912, 'start': 860.68, 'end': 866.44, 'text': ' is going to overlap with itself. This means that this has to be allocated two registers', 'tokens': [50942, 307, 516, 281, 19959, 365, 2564, 13, 639, 1355, 300, 341, 575, 281, 312, 29772, 732, 38351, 51230], 'temperature': 0.0, 'avg_logprob': -0.12998729593613567, 'compression_ratio': 2.1201923076923075, 'no_speech_prob': 0.005363540258258581}, {'id': 141, 'seek': 84912, 'start': 866.44, 'end': 873.44, 'text': ' and this has to be allocated three registers, right. So, again there are hardware support', 'tokens': [51230, 293, 341, 575, 281, 312, 29772, 1045, 38351, 11, 558, 13, 407, 11, 797, 456, 366, 8837, 1406, 51580], 'temperature': 0.0, 'avg_logprob': -0.12998729593613567, 'compression_ratio': 2.1201923076923075, 'no_speech_prob': 0.005363540258258581}, {'id': 142, 'seek': 84912, 'start': 873.48, 'end': 878.46, 'text': ' to do some of these things and in the absence of a software hardware support, you can also', 'tokens': [51582, 281, 360, 512, 295, 613, 721, 293, 294, 264, 17145, 295, 257, 4722, 8837, 1406, 11, 291, 393, 611, 51831], 'temperature': 0.0, 'avg_logprob': -0.12998729593613567, 'compression_ratio': 2.1201923076923075, 'no_speech_prob': 0.005363540258258581}, {'id': 143, 'seek': 87846, 'start': 878.62, 'end': 885.14, 'text': ' do it in software by unrolling the loop and doing necessary renaming of variables, okay.', 'tokens': [50372, 360, 309, 294, 4722, 538, 517, 18688, 264, 6367, 293, 884, 4818, 8124, 5184, 295, 9102, 11, 1392, 13, 50698], 'temperature': 0.0, 'avg_logprob': -0.1628568172454834, 'compression_ratio': 1.6902985074626866, 'no_speech_prob': 0.0012120892060920596}, {'id': 144, 'seek': 87846, 'start': 885.14, 'end': 890.82, 'text': ' So, I think with that I will stop our discussion on register requirement for modular scheduling', 'tokens': [50698, 407, 11, 286, 519, 365, 300, 286, 486, 1590, 527, 5017, 322, 7280, 11695, 337, 31111, 29055, 50982], 'temperature': 0.0, 'avg_logprob': -0.1628568172454834, 'compression_ratio': 1.6902985074626866, 'no_speech_prob': 0.0012120892060920596}, {'id': 145, 'seek': 87846, 'start': 890.82, 'end': 895.14, 'text': ' or software pipelining because otherwise it gets too complicated. But if you have any', 'tokens': [50982, 420, 4722, 8489, 338, 1760, 570, 5911, 309, 2170, 886, 6179, 13, 583, 498, 291, 362, 604, 51198], 'temperature': 0.0, 'avg_logprob': -0.1628568172454834, 'compression_ratio': 1.6902985074626866, 'no_speech_prob': 0.0012120892060920596}, {'id': 146, 'seek': 87846, 'start': 895.14, 'end': 901.0600000000001, 'text': ' quick questions, maybe we can take it at this point in time. Any questions on software pipelining', 'tokens': [51198, 1702, 1651, 11, 1310, 321, 393, 747, 309, 412, 341, 935, 294, 565, 13, 2639, 1651, 322, 4722, 8489, 338, 1760, 51494], 'temperature': 0.0, 'avg_logprob': -0.1628568172454834, 'compression_ratio': 1.6902985074626866, 'no_speech_prob': 0.0012120892060920596}, {'id': 147, 'seek': 87846, 'start': 901.0600000000001, 'end': 905.38, 'text': ' or otherwise we are done with this, okay. This actually shows you the details of how', 'tokens': [51494, 420, 5911, 321, 366, 1096, 365, 341, 11, 1392, 13, 639, 767, 3110, 291, 264, 4365, 295, 577, 51710], 'temperature': 0.0, 'avg_logprob': -0.1628568172454834, 'compression_ratio': 1.6902985074626866, 'no_speech_prob': 0.0012120892060920596}, {'id': 148, 'seek': 90538, 'start': 905.46, 'end': 909.14, 'text': ' to do the renaming and things like that. I will give you the slides. You can go through', 'tokens': [50368, 281, 360, 264, 8124, 5184, 293, 721, 411, 300, 13, 286, 486, 976, 291, 264, 9788, 13, 509, 393, 352, 807, 50552], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 149, 'seek': 90538, 'start': 909.14, 'end': 913.26, 'text': ' them, right. You do not want to go. This is again a taxonomy of all software pipeline', 'tokens': [50552, 552, 11, 558, 13, 509, 360, 406, 528, 281, 352, 13, 639, 307, 797, 257, 3366, 23423, 295, 439, 4722, 15517, 50758], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 150, 'seek': 90538, 'start': 913.26, 'end': 914.26, 'text': ' schedule.', 'tokens': [50758, 7567, 13, 50808], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 151, 'seek': 90538, 'start': 914.26, 'end': 915.26, 'text': ' .', 'tokens': [50808, 2411, 50858], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 152, 'seek': 90538, 'start': 915.26, 'end': 916.26, 'text': ' More registers?', 'tokens': [50858, 5048, 38351, 30, 50908], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 153, 'seek': 90538, 'start': 916.26, 'end': 917.26, 'text': ' More registers.', 'tokens': [50908, 5048, 38351, 13, 50958], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 154, 'seek': 90538, 'start': 917.26, 'end': 918.26, 'text': ' Okay.', 'tokens': [50958, 1033, 13, 51008], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 155, 'seek': 90538, 'start': 918.26, 'end': 919.26, 'text': ' Then?', 'tokens': [51008, 1396, 30, 51058], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 156, 'seek': 90538, 'start': 919.26, 'end': 931.58, 'text': ' Again you are thinking in terms of adding the', 'tokens': [51058, 3764, 291, 366, 1953, 294, 2115, 295, 5127, 264, 51674], 'temperature': 0.0, 'avg_logprob': -0.42902737572079613, 'compression_ratio': 1.4864864864864864, 'no_speech_prob': 0.19727152585983276}, {'id': 157, 'seek': 93158, 'start': 932.58, 'end': 941.0600000000001, 'text': ' spill instructions and stores, spill loads and stores, but those spill loads and stores', 'tokens': [50414, 22044, 9415, 293, 9512, 11, 22044, 12668, 293, 9512, 11, 457, 729, 22044, 12668, 293, 9512, 50838], 'temperature': 0.0, 'avg_logprob': -0.4563966419385827, 'compression_ratio': 1.504201680672269, 'no_speech_prob': 0.6832184195518494}, {'id': 158, 'seek': 93158, 'start': 941.0600000000001, 'end': 947.34, 'text': ' also need to be scheduled in this corner.', 'tokens': [50838, 611, 643, 281, 312, 15678, 294, 341, 4538, 13, 51152], 'temperature': 0.0, 'avg_logprob': -0.4563966419385827, 'compression_ratio': 1.504201680672269, 'no_speech_prob': 0.6832184195518494}, {'id': 159, 'seek': 93158, 'start': 947.34, 'end': 948.34, 'text': ' .', 'tokens': [51152, 2411, 51202], 'temperature': 0.0, 'avg_logprob': -0.4563966419385827, 'compression_ratio': 1.504201680672269, 'no_speech_prob': 0.6832184195518494}, {'id': 160, 'seek': 93158, 'start': 948.34, 'end': 959.34, 'text': ' Can all of them registers are dependent? Sorry.', 'tokens': [51202, 1664, 439, 295, 552, 38351, 366, 12334, 30, 4919, 13, 51752], 'temperature': 0.0, 'avg_logprob': -0.4563966419385827, 'compression_ratio': 1.504201680672269, 'no_speech_prob': 0.6832184195518494}, {'id': 161, 'seek': 95934, 'start': 959.34, 'end': 960.34, 'text': ' .', 'tokens': [50364, 2411, 50414], 'temperature': 0.0, 'avg_logprob': -0.28125645564152646, 'compression_ratio': 1.1770833333333333, 'no_speech_prob': 0.03615250438451767}, {'id': 162, 'seek': 95934, 'start': 960.34, 'end': 961.34, 'text': ' Okay.', 'tokens': [50414, 1033, 13, 50464], 'temperature': 0.0, 'avg_logprob': -0.28125645564152646, 'compression_ratio': 1.1770833333333333, 'no_speech_prob': 0.03615250438451767}, {'id': 163, 'seek': 95934, 'start': 961.34, 'end': 962.34, 'text': ' .', 'tokens': [50464, 2411, 50514], 'temperature': 0.0, 'avg_logprob': -0.28125645564152646, 'compression_ratio': 1.1770833333333333, 'no_speech_prob': 0.03615250438451767}, {'id': 164, 'seek': 95934, 'start': 962.34, 'end': 963.34, 'text': ' Okay.', 'tokens': [50514, 1033, 13, 50564], 'temperature': 0.0, 'avg_logprob': -0.28125645564152646, 'compression_ratio': 1.1770833333333333, 'no_speech_prob': 0.03615250438451767}, {'id': 165, 'seek': 95934, 'start': 963.34, 'end': 964.34, 'text': ' .', 'tokens': [50564, 2411, 50614], 'temperature': 0.0, 'avg_logprob': -0.28125645564152646, 'compression_ratio': 1.1770833333333333, 'no_speech_prob': 0.03615250438451767}, {'id': 166, 'seek': 95934, 'start': 964.34, 'end': 982.82, 'text': ' So, essentially from whatever you are saying what I understand is that see there is a situation', 'tokens': [50614, 407, 11, 4476, 490, 2035, 291, 366, 1566, 437, 286, 1223, 307, 300, 536, 456, 307, 257, 2590, 51538], 'temperature': 0.0, 'avg_logprob': -0.28125645564152646, 'compression_ratio': 1.1770833333333333, 'no_speech_prob': 0.03615250438451767}, {'id': 167, 'seek': 98282, 'start': 983.82, 'end': 984.82, 'text': ' .', 'tokens': [50414, 2411, 50464], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 168, 'seek': 98282, 'start': 984.82, 'end': 985.82, 'text': ' .', 'tokens': [50464, 2411, 50514], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 169, 'seek': 98282, 'start': 985.82, 'end': 986.82, 'text': ' .', 'tokens': [50514, 2411, 50564], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 170, 'seek': 98282, 'start': 986.82, 'end': 987.82, 'text': ' .', 'tokens': [50564, 2411, 50614], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 171, 'seek': 98282, 'start': 987.82, 'end': 988.82, 'text': ' .', 'tokens': [50614, 2411, 50664], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 172, 'seek': 98282, 'start': 988.82, 'end': 989.82, 'text': ' .', 'tokens': [50664, 2411, 50714], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 173, 'seek': 98282, 'start': 989.82, 'end': 990.82, 'text': ' .', 'tokens': [50714, 2411, 50764], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 174, 'seek': 98282, 'start': 990.82, 'end': 991.82, 'text': ' .', 'tokens': [50764, 2411, 50814], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 175, 'seek': 98282, 'start': 991.82, 'end': 992.82, 'text': ' .', 'tokens': [50814, 2411, 50864], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 176, 'seek': 98282, 'start': 992.82, 'end': 993.82, 'text': ' .', 'tokens': [50864, 2411, 50914], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 177, 'seek': 98282, 'start': 993.82, 'end': 994.82, 'text': ' .', 'tokens': [50914, 2411, 50964], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 178, 'seek': 98282, 'start': 994.82, 'end': 995.82, 'text': ' .', 'tokens': [50964, 2411, 51014], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 179, 'seek': 98282, 'start': 995.82, 'end': 996.82, 'text': ' .', 'tokens': [51014, 2411, 51064], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 180, 'seek': 98282, 'start': 996.82, 'end': 997.82, 'text': ' .', 'tokens': [51064, 2411, 51114], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 181, 'seek': 98282, 'start': 997.82, 'end': 998.82, 'text': ' .', 'tokens': [51114, 2411, 51164], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 182, 'seek': 98282, 'start': 998.82, 'end': 999.82, 'text': ' .', 'tokens': [51164, 2411, 51214], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 183, 'seek': 98282, 'start': 999.82, 'end': 1000.82, 'text': ' .', 'tokens': [51214, 2411, 51264], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 184, 'seek': 98282, 'start': 1000.82, 'end': 1001.82, 'text': ' .', 'tokens': [51264, 2411, 51314], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 185, 'seek': 98282, 'start': 1001.82, 'end': 1002.82, 'text': ' .', 'tokens': [51314, 2411, 51364], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 186, 'seek': 98282, 'start': 1002.82, 'end': 1003.82, 'text': ' .', 'tokens': [51364, 2411, 51414], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 187, 'seek': 98282, 'start': 1003.82, 'end': 1004.82, 'text': ' .', 'tokens': [51414, 2411, 51464], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 188, 'seek': 98282, 'start': 1004.82, 'end': 1005.82, 'text': ' .', 'tokens': [51464, 2411, 51514], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 189, 'seek': 98282, 'start': 1005.82, 'end': 1006.82, 'text': ' .', 'tokens': [51514, 2411, 51564], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 190, 'seek': 98282, 'start': 1006.82, 'end': 1007.82, 'text': ' .', 'tokens': [51564, 2411, 51614], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 191, 'seek': 98282, 'start': 1007.82, 'end': 1008.82, 'text': ' .', 'tokens': [51614, 2411, 51664], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 192, 'seek': 98282, 'start': 1008.82, 'end': 1009.82, 'text': ' .', 'tokens': [51664, 2411, 51714], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 193, 'seek': 98282, 'start': 1009.82, 'end': 1010.82, 'text': ' .', 'tokens': [51714, 2411, 51764], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 194, 'seek': 98282, 'start': 1010.82, 'end': 1011.82, 'text': ' .', 'tokens': [51764, 2411, 51814], 'temperature': 0.0, 'avg_logprob': -0.1504788176957951, 'compression_ratio': 4.230769230769231, 'no_speech_prob': 0.6677379012107849}, {'id': 195, 'seek': 101182, 'start': 1011.82, 'end': 1012.82, 'text': ' .', 'tokens': [50364, 2411, 50414], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 196, 'seek': 101182, 'start': 1012.82, 'end': 1013.82, 'text': ' .', 'tokens': [50414, 2411, 50464], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 197, 'seek': 101182, 'start': 1013.82, 'end': 1014.82, 'text': ' .', 'tokens': [50464, 2411, 50514], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 198, 'seek': 101182, 'start': 1014.82, 'end': 1015.82, 'text': ' .', 'tokens': [50514, 2411, 50564], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 199, 'seek': 101182, 'start': 1015.82, 'end': 1016.82, 'text': ' .', 'tokens': [50564, 2411, 50614], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 200, 'seek': 101182, 'start': 1016.82, 'end': 1017.82, 'text': ' .', 'tokens': [50614, 2411, 50664], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 201, 'seek': 101182, 'start': 1017.82, 'end': 1025.8200000000002, 'text': ' Making it hard for me.', 'tokens': [50664, 14595, 309, 1152, 337, 385, 13, 51064], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 202, 'seek': 101182, 'start': 1025.8200000000002, 'end': 1030.8200000000002, 'text': ' .', 'tokens': [51064, 2411, 51314], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 203, 'seek': 101182, 'start': 1030.8200000000002, 'end': 1031.8200000000002, 'text': ' .', 'tokens': [51314, 2411, 51364], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 204, 'seek': 101182, 'start': 1031.8200000000002, 'end': 1036.22, 'text': ' This is what you got the register classes, is it?', 'tokens': [51364, 639, 307, 437, 291, 658, 264, 7280, 5359, 11, 307, 309, 30, 51584], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 205, 'seek': 101182, 'start': 1036.22, 'end': 1037.22, 'text': ' .', 'tokens': [51584, 2411, 51634], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 206, 'seek': 101182, 'start': 1037.22, 'end': 1038.22, 'text': ' Okay.', 'tokens': [51634, 1033, 13, 51684], 'temperature': 0.8, 'avg_logprob': -0.5100637956099077, 'compression_ratio': 1.1162790697674418, 'no_speech_prob': 0.41842374205589294}, {'id': 207, 'seek': 103822, 'start': 1038.22, 'end': 1056.22, 'text': ' Sorry, let us just try to write it down. S 1 is equal to.', 'tokens': [50364, 4919, 11, 718, 505, 445, 853, 281, 2464, 309, 760, 13, 318, 502, 307, 2681, 281, 13, 51264], 'temperature': 0.0, 'avg_logprob': -0.46231790491052577, 'compression_ratio': 1.118279569892473, 'no_speech_prob': 0.08673056960105896}, {'id': 208, 'seek': 103822, 'start': 1056.22, 'end': 1059.82, 'text': ' S 1 by S 2. Ok and you have only one register.', 'tokens': [51264, 318, 502, 538, 318, 568, 13, 3477, 293, 291, 362, 787, 472, 7280, 13, 51444], 'temperature': 0.0, 'avg_logprob': -0.46231790491052577, 'compression_ratio': 1.118279569892473, 'no_speech_prob': 0.08673056960105896}, {'id': 209, 'seek': 105982, 'start': 1059.82, 'end': 1071.3, 'text': ' I mean if you have to use both of them from register and you have only one register, obviously', 'tokens': [50364, 286, 914, 498, 291, 362, 281, 764, 1293, 295, 552, 490, 7280, 293, 291, 362, 787, 472, 7280, 11, 2745, 50938], 'temperature': 0.0, 'avg_logprob': -0.2756613434338179, 'compression_ratio': 1.6424242424242423, 'no_speech_prob': 0.08073780685663223}, {'id': 210, 'seek': 105982, 'start': 1071.3, 'end': 1078.86, 'text': ' the implementation is impossible. Should not arise. If it arises you cannot generate code,', 'tokens': [50938, 264, 11420, 307, 6243, 13, 6454, 406, 20288, 13, 759, 309, 27388, 291, 2644, 8460, 3089, 11, 51316], 'temperature': 0.0, 'avg_logprob': -0.2756613434338179, 'compression_ratio': 1.6424242424242423, 'no_speech_prob': 0.08073780685663223}, {'id': 211, 'seek': 105982, 'start': 1078.86, 'end': 1085.8999999999999, 'text': ' right. See essentially what you are saying is that you only have op register register', 'tokens': [51316, 558, 13, 3008, 4476, 437, 291, 366, 1566, 307, 300, 291, 787, 362, 999, 7280, 7280, 51668], 'temperature': 0.0, 'avg_logprob': -0.2756613434338179, 'compression_ratio': 1.6424242424242423, 'no_speech_prob': 0.08073780685663223}, {'id': 212, 'seek': 108590, 'start': 1086.1000000000001, 'end': 1092.7800000000002, 'text': ' of a situation, right. And you say that I have only one register, then code generation', 'tokens': [50374, 295, 257, 2590, 11, 558, 13, 400, 291, 584, 300, 286, 362, 787, 472, 7280, 11, 550, 3089, 5125, 50708], 'temperature': 0.0, 'avg_logprob': -0.2574100787823017, 'compression_ratio': 1.5235294117647058, 'no_speech_prob': 0.7068383097648621}, {'id': 213, 'seek': 108590, 'start': 1092.7800000000002, 'end': 1107.3400000000001, 'text': ' itself is not possible, correct. I do not know whether it is a corner case or this is', 'tokens': [50708, 2564, 307, 406, 1944, 11, 3006, 13, 286, 360, 406, 458, 1968, 309, 307, 257, 4538, 1389, 420, 341, 307, 51436], 'temperature': 0.0, 'avg_logprob': -0.2574100787823017, 'compression_ratio': 1.5235294117647058, 'no_speech_prob': 0.7068383097648621}, {'id': 214, 'seek': 108590, 'start': 1107.3400000000001, 'end': 1115.7, 'text': ' an impossible situation, ok. So, see your question is well understood that when I have', 'tokens': [51436, 364, 6243, 2590, 11, 3133, 13, 407, 11, 536, 428, 1168, 307, 731, 7320, 300, 562, 286, 362, 51854], 'temperature': 0.0, 'avg_logprob': -0.2574100787823017, 'compression_ratio': 1.5235294117647058, 'no_speech_prob': 0.7068383097648621}, {'id': 215, 'seek': 111570, 'start': 1115.7, 'end': 1120.1000000000001, 'text': ' multiple live ranges which are overlapping and then I have a situation I do not have', 'tokens': [50364, 3866, 1621, 22526, 597, 366, 33535, 293, 550, 286, 362, 257, 2590, 286, 360, 406, 362, 50584], 'temperature': 0.0, 'avg_logprob': -0.18343466978806716, 'compression_ratio': 1.8583333333333334, 'no_speech_prob': 0.011697271838784218}, {'id': 216, 'seek': 111570, 'start': 1120.1000000000001, 'end': 1126.3400000000001, 'text': ' enough registers. Then one of those live ranges have to be spilt, right. So, maybe this live', 'tokens': [50584, 1547, 38351, 13, 1396, 472, 295, 729, 1621, 22526, 362, 281, 312, 637, 2352, 11, 558, 13, 407, 11, 1310, 341, 1621, 50896], 'temperature': 0.0, 'avg_logprob': -0.18343466978806716, 'compression_ratio': 1.8583333333333334, 'no_speech_prob': 0.011697271838784218}, {'id': 217, 'seek': 111570, 'start': 1126.3400000000001, 'end': 1130.42, 'text': ' range is spilt between this point to this point, so that you will only have exactly', 'tokens': [50896, 3613, 307, 637, 2352, 1296, 341, 935, 281, 341, 935, 11, 370, 300, 291, 486, 787, 362, 2293, 51100], 'temperature': 0.0, 'avg_logprob': -0.18343466978806716, 'compression_ratio': 1.8583333333333334, 'no_speech_prob': 0.011697271838784218}, {'id': 218, 'seek': 111570, 'start': 1130.42, 'end': 1136.06, 'text': ' three live ranges which are overlapping, right. And in any instruction you are going to have', 'tokens': [51100, 1045, 1621, 22526, 597, 366, 33535, 11, 558, 13, 400, 294, 604, 10951, 291, 366, 516, 281, 362, 51382], 'temperature': 0.0, 'avg_logprob': -0.18343466978806716, 'compression_ratio': 1.8583333333333334, 'no_speech_prob': 0.011697271838784218}, {'id': 219, 'seek': 111570, 'start': 1136.06, 'end': 1141.3400000000001, 'text': ' at most two operations. So, before that operation you can always spill all other things and', 'tokens': [51382, 412, 881, 732, 7705, 13, 407, 11, 949, 300, 6916, 291, 393, 1009, 22044, 439, 661, 721, 293, 51646], 'temperature': 0.0, 'avg_logprob': -0.18343466978806716, 'compression_ratio': 1.8583333333333334, 'no_speech_prob': 0.011697271838784218}, {'id': 220, 'seek': 114134, 'start': 1141.34, 'end': 1145.3, 'text': ' you need to have at least that many number of registers to do things.', 'tokens': [50364, 291, 643, 281, 362, 412, 1935, 300, 867, 1230, 295, 38351, 281, 360, 721, 13, 50562], 'temperature': 0.0, 'avg_logprob': -0.495876948038737, 'compression_ratio': 1.6542056074766356, 'no_speech_prob': 0.5789192914962769}, {'id': 221, 'seek': 114134, 'start': 1145.3, 'end': 1152.1, 'text': ' Because it is very in the life you can have tried with the spilt with the number of registers.', 'tokens': [50562, 1436, 309, 307, 588, 294, 264, 993, 291, 393, 362, 3031, 365, 264, 637, 2352, 365, 264, 1230, 295, 38351, 13, 50902], 'temperature': 0.0, 'avg_logprob': -0.495876948038737, 'compression_ratio': 1.6542056074766356, 'no_speech_prob': 0.5789192914962769}, {'id': 222, 'seek': 114134, 'start': 1152.1, 'end': 1159.6599999999999, 'text': ' Ok then what happened? So, it is kind of like number of registers out of the range.', 'tokens': [50902, 3477, 550, 437, 2011, 30, 407, 11, 309, 307, 733, 295, 411, 1230, 295, 38351, 484, 295, 264, 3613, 13, 51280], 'temperature': 0.0, 'avg_logprob': -0.495876948038737, 'compression_ratio': 1.6542056074766356, 'no_speech_prob': 0.5789192914962769}, {'id': 223, 'seek': 114134, 'start': 1159.6599999999999, 'end': 1163.54, 'text': ' Absolutely, right. So, code generation cannot proceed.', 'tokens': [51280, 7021, 11, 558, 13, 407, 11, 3089, 5125, 2644, 8991, 13, 51474], 'temperature': 0.0, 'avg_logprob': -0.495876948038737, 'compression_ratio': 1.6542056074766356, 'no_speech_prob': 0.5789192914962769}, {'id': 224, 'seek': 114134, 'start': 1163.54, 'end': 1166.62, 'text': ' Further. Yeah further. So, the minimum is probably', 'tokens': [51474, 15364, 13, 865, 3052, 13, 407, 11, 264, 7285, 307, 1391, 51628], 'temperature': 0.0, 'avg_logprob': -0.495876948038737, 'compression_ratio': 1.6542056074766356, 'no_speech_prob': 0.5789192914962769}, {'id': 225, 'seek': 116662, 'start': 1166.62, 'end': 1181.26, 'text': ' to and then beyond that it cannot do it, ok. Alright, so any other questions?', 'tokens': [50364, 281, 293, 550, 4399, 300, 309, 2644, 360, 309, 11, 3133, 13, 2798, 11, 370, 604, 661, 1651, 30, 51096], 'temperature': 0.0, 'avg_logprob': -0.42241118170998315, 'compression_ratio': 1.346774193548387, 'no_speech_prob': 0.6888389587402344}, {'id': 226, 'seek': 116662, 'start': 1181.26, 'end': 1189.02, 'text': ' For the register allocation, ok. So, you want to have what are called rotating registers,', 'tokens': [51096, 1171, 264, 7280, 27599, 11, 3133, 13, 407, 11, 291, 528, 281, 362, 437, 366, 1219, 19627, 38351, 11, 51484], 'temperature': 0.0, 'avg_logprob': -0.42241118170998315, 'compression_ratio': 1.346774193548387, 'no_speech_prob': 0.6888389587402344}, {'id': 227, 'seek': 118902, 'start': 1190.02, 'end': 1197.94, 'text': ' So, little bit complicated this is similar to what they have as register windows in spark', 'tokens': [50414, 407, 11, 707, 857, 6179, 341, 307, 2531, 281, 437, 436, 362, 382, 7280, 9309, 294, 9908, 50810], 'temperature': 0.0, 'avg_logprob': -0.17831050327845982, 'compression_ratio': 1.6756756756756757, 'no_speech_prob': 0.06706175208091736}, {'id': 228, 'seek': 118902, 'start': 1197.94, 'end': 1201.78, 'text': ' architecture. So, I have to go into a lot of details that is why I want to skip this', 'tokens': [50810, 9482, 13, 407, 11, 286, 362, 281, 352, 666, 257, 688, 295, 4365, 300, 307, 983, 286, 528, 281, 10023, 341, 51002], 'temperature': 0.0, 'avg_logprob': -0.17831050327845982, 'compression_ratio': 1.6756756756756757, 'no_speech_prob': 0.06706175208091736}, {'id': 229, 'seek': 118902, 'start': 1201.78, 'end': 1207.06, 'text': ' thing. Offline we can talk about it during lunch or something, right. So, again I have', 'tokens': [51002, 551, 13, 6318, 1889, 321, 393, 751, 466, 309, 1830, 6349, 420, 746, 11, 558, 13, 407, 11, 797, 286, 362, 51266], 'temperature': 0.0, 'avg_logprob': -0.17831050327845982, 'compression_ratio': 1.6756756756756757, 'no_speech_prob': 0.06706175208091736}, {'id': 230, 'seek': 118902, 'start': 1207.06, 'end': 1211.66, 'text': ' the details in the slide and maybe it will definitely have the keyword and if you do', 'tokens': [51266, 264, 4365, 294, 264, 4137, 293, 1310, 309, 486, 2138, 362, 264, 20428, 293, 498, 291, 360, 51496], 'temperature': 0.0, 'avg_logprob': -0.17831050327845982, 'compression_ratio': 1.6756756756756757, 'no_speech_prob': 0.06706175208091736}, {'id': 231, 'seek': 118902, 'start': 1211.66, 'end': 1215.82, 'text': ' Google search you can get all the details that you want. Otherwise feel free to contact', 'tokens': [51496, 3329, 3164, 291, 393, 483, 439, 264, 4365, 300, 291, 528, 13, 10328, 841, 1737, 281, 3385, 51704], 'temperature': 0.0, 'avg_logprob': -0.17831050327845982, 'compression_ratio': 1.6756756756756757, 'no_speech_prob': 0.06706175208091736}, {'id': 232, 'seek': 121582, 'start': 1215.82, 'end': 1226.22, 'text': ' me, right, ok. Alright, ok. Now, we talked about code generation, we', 'tokens': [50364, 385, 11, 558, 11, 3133, 13, 2798, 11, 3133, 13, 823, 11, 321, 2825, 466, 3089, 5125, 11, 321, 50884], 'temperature': 0.0, 'avg_logprob': -0.24230229227166428, 'compression_ratio': 1.743718592964824, 'no_speech_prob': 0.1741730123758316}, {'id': 233, 'seek': 121582, 'start': 1226.22, 'end': 1231.06, 'text': ' talked about instruction scheduling, we talked about software pipelining, we talked about', 'tokens': [50884, 2825, 466, 10951, 29055, 11, 321, 2825, 466, 4722, 8489, 338, 1760, 11, 321, 2825, 466, 51126], 'temperature': 0.0, 'avg_logprob': -0.24230229227166428, 'compression_ratio': 1.743718592964824, 'no_speech_prob': 0.1741730123758316}, {'id': 234, 'seek': 121582, 'start': 1231.06, 'end': 1237.02, 'text': ' register allocation. The last component that we wanted to cover is something which is relating', 'tokens': [51126, 7280, 27599, 13, 440, 1036, 6542, 300, 321, 1415, 281, 2060, 307, 746, 597, 307, 23968, 51424], 'temperature': 0.0, 'avg_logprob': -0.24230229227166428, 'compression_ratio': 1.743718592964824, 'no_speech_prob': 0.1741730123758316}, {'id': 235, 'seek': 121582, 'start': 1237.02, 'end': 1243.74, 'text': ' to again certain machine dependent optimizations which pertains to memory hierarchy and which', 'tokens': [51424, 281, 797, 1629, 3479, 12334, 5028, 14455, 597, 13269, 2315, 281, 4675, 22333, 293, 597, 51760], 'temperature': 0.0, 'avg_logprob': -0.24230229227166428, 'compression_ratio': 1.743718592964824, 'no_speech_prob': 0.1741730123758316}, {'id': 236, 'seek': 124374, 'start': 1243.74, 'end': 1250.42, 'text': ' pertains to parallelism, ok. Again I have quite a few slides for the next session. I', 'tokens': [50364, 13269, 2315, 281, 8952, 1434, 11, 3133, 13, 3764, 286, 362, 1596, 257, 1326, 9788, 337, 264, 958, 5481, 13, 286, 50698], 'temperature': 0.0, 'avg_logprob': -0.15521609783172607, 'compression_ratio': 1.6534296028880866, 'no_speech_prob': 0.02492942474782467}, {'id': 237, 'seek': 124374, 'start': 1250.42, 'end': 1255.14, 'text': ' will not do all of them, but I will do a quickly some part of that and then show you what can', 'tokens': [50698, 486, 406, 360, 439, 295, 552, 11, 457, 286, 486, 360, 257, 2661, 512, 644, 295, 300, 293, 550, 855, 291, 437, 393, 50934], 'temperature': 0.0, 'avg_logprob': -0.15521609783172607, 'compression_ratio': 1.6534296028880866, 'no_speech_prob': 0.02492942474782467}, {'id': 238, 'seek': 124374, 'start': 1255.14, 'end': 1260.2, 'text': ' be done. Now, let us just try to get through this memory hierarchy little quickly because', 'tokens': [50934, 312, 1096, 13, 823, 11, 718, 505, 445, 853, 281, 483, 807, 341, 4675, 22333, 707, 2661, 570, 51187], 'temperature': 0.0, 'avg_logprob': -0.15521609783172607, 'compression_ratio': 1.6534296028880866, 'no_speech_prob': 0.02492942474782467}, {'id': 239, 'seek': 124374, 'start': 1260.2, 'end': 1264.98, 'text': ' all of you would have done a course in computer organization. So, let me try to get this thing.', 'tokens': [51187, 439, 295, 291, 576, 362, 1096, 257, 1164, 294, 3820, 4475, 13, 407, 11, 718, 385, 853, 281, 483, 341, 551, 13, 51426], 'temperature': 0.0, 'avg_logprob': -0.15521609783172607, 'compression_ratio': 1.6534296028880866, 'no_speech_prob': 0.02492942474782467}, {'id': 240, 'seek': 124374, 'start': 1264.98, 'end': 1271.38, 'text': ' So, whenever we talked about pipeline instruction execution, we assumed that processor can do', 'tokens': [51426, 407, 11, 5699, 321, 2825, 466, 15517, 10951, 15058, 11, 321, 15895, 300, 15321, 393, 360, 51746], 'temperature': 0.0, 'avg_logprob': -0.15521609783172607, 'compression_ratio': 1.6534296028880866, 'no_speech_prob': 0.02492942474782467}, {'id': 241, 'seek': 127138, 'start': 1271.5800000000002, 'end': 1276.8600000000001, 'text': ' instruction fetch in a cycle or can do load or restore in a single cycle and this is because', 'tokens': [50374, 10951, 23673, 294, 257, 6586, 420, 393, 360, 3677, 420, 15227, 294, 257, 2167, 6586, 293, 341, 307, 570, 50638], 'temperature': 0.0, 'avg_logprob': -0.1300074664029208, 'compression_ratio': 1.725868725868726, 'no_speech_prob': 0.17758338153362274}, {'id': 242, 'seek': 127138, 'start': 1276.8600000000001, 'end': 1283.8600000000001, 'text': ' we have always assumed that there are caches in our architecture, right. And this cache', 'tokens': [50638, 321, 362, 1009, 15895, 300, 456, 366, 269, 13272, 294, 527, 9482, 11, 558, 13, 400, 341, 19459, 50988], 'temperature': 0.0, 'avg_logprob': -0.1300074664029208, 'compression_ratio': 1.725868725868726, 'no_speech_prob': 0.17758338153362274}, {'id': 243, 'seek': 127138, 'start': 1283.8600000000001, 'end': 1288.8600000000001, 'text': ' essentially is a part of the memory hierarchy that we talk about and all of you understand', 'tokens': [50988, 4476, 307, 257, 644, 295, 264, 4675, 22333, 300, 321, 751, 466, 293, 439, 295, 291, 1223, 51238], 'temperature': 0.0, 'avg_logprob': -0.1300074664029208, 'compression_ratio': 1.725868725868726, 'no_speech_prob': 0.17758338153362274}, {'id': 244, 'seek': 127138, 'start': 1288.8600000000001, 'end': 1292.7, 'text': ' this memory hierarchy. So, there is no need for me to go. Particularly what we want to', 'tokens': [51238, 341, 4675, 22333, 13, 407, 11, 456, 307, 572, 643, 337, 385, 281, 352, 13, 32281, 437, 321, 528, 281, 51430], 'temperature': 0.0, 'avg_logprob': -0.1300074664029208, 'compression_ratio': 1.725868725868726, 'no_speech_prob': 0.17758338153362274}, {'id': 245, 'seek': 127138, 'start': 1292.7, 'end': 1299.7, 'text': ' talk about is that we have there is multiple levels of caches L1, L2, L3 and beyond that', 'tokens': [51430, 751, 466, 307, 300, 321, 362, 456, 307, 3866, 4358, 295, 269, 13272, 441, 16, 11, 441, 17, 11, 441, 18, 293, 4399, 300, 51780], 'temperature': 0.0, 'avg_logprob': -0.1300074664029208, 'compression_ratio': 1.725868725868726, 'no_speech_prob': 0.17758338153362274}, {'id': 246, 'seek': 129970, 'start': 1299.7, 'end': 1305.9, 'text': ' there is memory, right. If all of you know how caches work, then I can quickly skip', 'tokens': [50364, 456, 307, 4675, 11, 558, 13, 759, 439, 295, 291, 458, 577, 269, 13272, 589, 11, 550, 286, 393, 2661, 10023, 50674], 'temperature': 0.0, 'avg_logprob': -0.12022901014848189, 'compression_ratio': 1.7649402390438247, 'no_speech_prob': 0.005656764842569828}, {'id': 247, 'seek': 129970, 'start': 1305.9, 'end': 1311.9, 'text': ' some of this discussion and then go to the next one. But just to be very brief on this,', 'tokens': [50674, 512, 295, 341, 5017, 293, 550, 352, 281, 264, 958, 472, 13, 583, 445, 281, 312, 588, 5353, 322, 341, 11, 50974], 'temperature': 0.0, 'avg_logprob': -0.12022901014848189, 'compression_ratio': 1.7649402390438247, 'no_speech_prob': 0.005656764842569828}, {'id': 248, 'seek': 129970, 'start': 1311.9, 'end': 1316.26, 'text': ' what we see here is typically we have the processors. The processor gives an address', 'tokens': [50974, 437, 321, 536, 510, 307, 5850, 321, 362, 264, 27751, 13, 440, 15321, 2709, 364, 2985, 51192], 'temperature': 0.0, 'avg_logprob': -0.12022901014848189, 'compression_ratio': 1.7649402390438247, 'no_speech_prob': 0.005656764842569828}, {'id': 249, 'seek': 129970, 'start': 1316.26, 'end': 1322.1000000000001, 'text': ' which is typically looked at in the L1 cache. L1 cache is typically a split cache for instruction', 'tokens': [51192, 597, 307, 5850, 2956, 412, 294, 264, 441, 16, 19459, 13, 441, 16, 19459, 307, 5850, 257, 7472, 19459, 337, 10951, 51484], 'temperature': 0.0, 'avg_logprob': -0.12022901014848189, 'compression_ratio': 1.7649402390438247, 'no_speech_prob': 0.005656764842569828}, {'id': 250, 'seek': 129970, 'start': 1322.1000000000001, 'end': 1327.5, 'text': ' and data. If the data is available, then it is given to the processor and typically that', 'tokens': [51484, 293, 1412, 13, 759, 264, 1412, 307, 2435, 11, 550, 309, 307, 2212, 281, 264, 15321, 293, 5850, 300, 51754], 'temperature': 0.0, 'avg_logprob': -0.12022901014848189, 'compression_ratio': 1.7649402390438247, 'no_speech_prob': 0.005656764842569828}, {'id': 251, 'seek': 132750, 'start': 1327.5, 'end': 1333.62, 'text': ' takes about 1 to 2 cycles. If the thing is not available in L1 cache, then you have to', 'tokens': [50364, 2516, 466, 502, 281, 568, 17796, 13, 759, 264, 551, 307, 406, 2435, 294, 441, 16, 19459, 11, 550, 291, 362, 281, 50670], 'temperature': 0.0, 'avg_logprob': -0.19855820792061943, 'compression_ratio': 1.7307692307692308, 'no_speech_prob': 0.0361691452562809}, {'id': 252, 'seek': 132750, 'start': 1333.62, 'end': 1338.7, 'text': ' go to L2 cache and if you have multiple levels of hierarchy, if it is not in L2, you will', 'tokens': [50670, 352, 281, 441, 17, 19459, 293, 498, 291, 362, 3866, 4358, 295, 22333, 11, 498, 309, 307, 406, 294, 441, 17, 11, 291, 486, 50924], 'temperature': 0.0, 'avg_logprob': -0.19855820792061943, 'compression_ratio': 1.7307692307692308, 'no_speech_prob': 0.0361691452562809}, {'id': 253, 'seek': 132750, 'start': 1338.7, 'end': 1345.7, 'text': ' go to L3 and so on, right. So, again you all know about temporal locality and spatial locality,', 'tokens': [50924, 352, 281, 441, 18, 293, 370, 322, 11, 558, 13, 407, 11, 797, 291, 439, 458, 466, 30881, 1628, 1860, 293, 23598, 1628, 1860, 11, 51274], 'temperature': 0.0, 'avg_logprob': -0.19855820792061943, 'compression_ratio': 1.7307692307692308, 'no_speech_prob': 0.0361691452562809}, {'id': 254, 'seek': 132750, 'start': 1345.7, 'end': 1352.7, 'text': ' right. Do we need to explain that? Temporal locality, spatial locality, no need, right.', 'tokens': [51274, 558, 13, 1144, 321, 643, 281, 2903, 300, 30, 8095, 2816, 304, 1628, 1860, 11, 23598, 1628, 1860, 11, 572, 643, 11, 558, 13, 51624], 'temperature': 0.0, 'avg_logprob': -0.19855820792061943, 'compression_ratio': 1.7307692307692308, 'no_speech_prob': 0.0361691452562809}, {'id': 255, 'seek': 135270, 'start': 1353.7, 'end': 1360.7, 'text': ' Okay. So, let us look at this particular equation which is of interest to us, right. So, whenever', 'tokens': [50414, 1033, 13, 407, 11, 718, 505, 574, 412, 341, 1729, 5367, 597, 307, 295, 1179, 281, 505, 11, 558, 13, 407, 11, 5699, 50764], 'temperature': 0.0, 'avg_logprob': -0.15106642648075405, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.0028258010279387236}, {'id': 256, 'seek': 135270, 'start': 1360.7, 'end': 1367.06, 'text': ' I talk about a memory access, right, I talk about an average memory access time and if', 'tokens': [50764, 286, 751, 466, 257, 4675, 2105, 11, 558, 11, 286, 751, 466, 364, 4274, 4675, 2105, 565, 293, 498, 51082], 'temperature': 0.0, 'avg_logprob': -0.15106642648075405, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.0028258010279387236}, {'id': 257, 'seek': 135270, 'start': 1367.06, 'end': 1372.7, 'text': ' I have one or more levels of caches, then my average memory access time is essentially', 'tokens': [51082, 286, 362, 472, 420, 544, 4358, 295, 269, 13272, 11, 550, 452, 4274, 4675, 2105, 565, 307, 4476, 51364], 'temperature': 0.0, 'avg_logprob': -0.15106642648075405, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.0028258010279387236}, {'id': 258, 'seek': 135270, 'start': 1372.7, 'end': 1379.7, 'text': ' determined by the hit time of the first level cache, if the data is available in the first', 'tokens': [51364, 9540, 538, 264, 2045, 565, 295, 264, 700, 1496, 19459, 11, 498, 264, 1412, 307, 2435, 294, 264, 700, 51714], 'temperature': 0.0, 'avg_logprob': -0.15106642648075405, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.0028258010279387236}, {'id': 259, 'seek': 137970, 'start': 1379.7, 'end': 1384.78, 'text': ' level cache and if it is not, then I have to fetch it from the subsequent level. So,', 'tokens': [50364, 1496, 19459, 293, 498, 309, 307, 406, 11, 550, 286, 362, 281, 23673, 309, 490, 264, 19962, 1496, 13, 407, 11, 50618], 'temperature': 0.0, 'avg_logprob': -0.15040162232545046, 'compression_ratio': 1.9646017699115044, 'no_speech_prob': 0.0074838874861598015}, {'id': 260, 'seek': 137970, 'start': 1384.78, 'end': 1391.78, 'text': ' there is a miss penalty, the data is not available, there is a miss penalty and there is a miss', 'tokens': [50618, 456, 307, 257, 1713, 16263, 11, 264, 1412, 307, 406, 2435, 11, 456, 307, 257, 1713, 16263, 293, 456, 307, 257, 1713, 50968], 'temperature': 0.0, 'avg_logprob': -0.15040162232545046, 'compression_ratio': 1.9646017699115044, 'no_speech_prob': 0.0074838874861598015}, {'id': 261, 'seek': 137970, 'start': 1391.82, 'end': 1398.82, 'text': ' rate. So, how often I miss and every time I miss, I have to have a miss penalty. Then', 'tokens': [50970, 3314, 13, 407, 11, 577, 2049, 286, 1713, 293, 633, 565, 286, 1713, 11, 286, 362, 281, 362, 257, 1713, 16263, 13, 1396, 51320], 'temperature': 0.0, 'avg_logprob': -0.15040162232545046, 'compression_ratio': 1.9646017699115044, 'no_speech_prob': 0.0074838874861598015}, {'id': 262, 'seek': 137970, 'start': 1398.94, 'end': 1404.5, 'text': ' this miss penalty itself will depend on whether I have the next level of cache or not and', 'tokens': [51326, 341, 1713, 16263, 2564, 486, 5672, 322, 1968, 286, 362, 264, 958, 1496, 295, 19459, 420, 406, 293, 51604], 'temperature': 0.0, 'avg_logprob': -0.15040162232545046, 'compression_ratio': 1.9646017699115044, 'no_speech_prob': 0.0074838874861598015}, {'id': 263, 'seek': 137970, 'start': 1404.5, 'end': 1409.14, 'text': ' again that equation would be something very similar to this equation, whatever that can', 'tokens': [51604, 797, 300, 5367, 576, 312, 746, 588, 2531, 281, 341, 5367, 11, 2035, 300, 393, 51836], 'temperature': 0.0, 'avg_logprob': -0.15040162232545046, 'compression_ratio': 1.9646017699115044, 'no_speech_prob': 0.0074838874861598015}, {'id': 264, 'seek': 140914, 'start': 1409.14, 'end': 1414.7, 'text': ' be fetched from L 2, it is a hit time of L 2 plus miss rate at L 2 multiplied by miss', 'tokens': [50364, 312, 23673, 292, 490, 441, 568, 11, 309, 307, 257, 2045, 565, 295, 441, 568, 1804, 1713, 3314, 412, 441, 568, 17207, 538, 1713, 50642], 'temperature': 0.0, 'avg_logprob': -0.12172249952952068, 'compression_ratio': 1.6238532110091743, 'no_speech_prob': 0.0048281108029186726}, {'id': 265, 'seek': 140914, 'start': 1414.7, 'end': 1420.38, 'text': ' penalty of L 2. So, it keeps going like this, right. Our idea with the caches is that you', 'tokens': [50642, 16263, 295, 441, 568, 13, 407, 11, 309, 5965, 516, 411, 341, 11, 558, 13, 2621, 1558, 365, 264, 269, 13272, 307, 300, 291, 50926], 'temperature': 0.0, 'avg_logprob': -0.12172249952952068, 'compression_ratio': 1.6238532110091743, 'no_speech_prob': 0.0048281108029186726}, {'id': 266, 'seek': 140914, 'start': 1420.38, 'end': 1427.38, 'text': ' want to essentially make sure that the average memory access time is reduced. So, for this,', 'tokens': [50926, 528, 281, 4476, 652, 988, 300, 264, 4274, 4675, 2105, 565, 307, 9212, 13, 407, 11, 337, 341, 11, 51276], 'temperature': 0.0, 'avg_logprob': -0.12172249952952068, 'compression_ratio': 1.6238532110091743, 'no_speech_prob': 0.0048281108029186726}, {'id': 267, 'seek': 140914, 'start': 1429.74, 'end': 1436.74, 'text': ' the important parameters are hit rate, miss penalty and miss rate, okay. If you are an', 'tokens': [51394, 264, 1021, 9834, 366, 2045, 3314, 11, 1713, 16263, 293, 1713, 3314, 11, 1392, 13, 759, 291, 366, 364, 51744], 'temperature': 0.0, 'avg_logprob': -0.12172249952952068, 'compression_ratio': 1.6238532110091743, 'no_speech_prob': 0.0048281108029186726}, {'id': 268, 'seek': 143674, 'start': 1437.6200000000001, 'end': 1442.18, 'text': ' architecture student, then you will worry about all three of them and you try to see', 'tokens': [50408, 9482, 3107, 11, 550, 291, 486, 3292, 466, 439, 1045, 295, 552, 293, 291, 853, 281, 536, 50636], 'temperature': 0.0, 'avg_logprob': -0.11754986156116833, 'compression_ratio': 1.8032128514056225, 'no_speech_prob': 0.006150052882730961}, {'id': 269, 'seek': 143674, 'start': 1442.18, 'end': 1447.94, 'text': ' how you can minimize them. But for the compiler course, what we need to worry about is that', 'tokens': [50636, 577, 291, 393, 17522, 552, 13, 583, 337, 264, 31958, 1164, 11, 437, 321, 643, 281, 3292, 466, 307, 300, 50924], 'temperature': 0.0, 'avg_logprob': -0.11754986156116833, 'compression_ratio': 1.8032128514056225, 'no_speech_prob': 0.006150052882730961}, {'id': 270, 'seek': 143674, 'start': 1447.94, 'end': 1453.42, 'text': ' since we do not have hardware in our control, I cannot change the hit time or the miss penalty,', 'tokens': [50924, 1670, 321, 360, 406, 362, 8837, 294, 527, 1969, 11, 286, 2644, 1319, 264, 2045, 565, 420, 264, 1713, 16263, 11, 51198], 'temperature': 0.0, 'avg_logprob': -0.11754986156116833, 'compression_ratio': 1.8032128514056225, 'no_speech_prob': 0.006150052882730961}, {'id': 271, 'seek': 143674, 'start': 1453.42, 'end': 1460.0, 'text': ' right. I can only influence the miss rate. So, let us see how the compiler can influence', 'tokens': [51198, 558, 13, 286, 393, 787, 6503, 264, 1713, 3314, 13, 407, 11, 718, 505, 536, 577, 264, 31958, 393, 6503, 51527], 'temperature': 0.0, 'avg_logprob': -0.11754986156116833, 'compression_ratio': 1.8032128514056225, 'no_speech_prob': 0.006150052882730961}, {'id': 272, 'seek': 143674, 'start': 1460.0, 'end': 1465.14, 'text': ' the miss rate. For that purpose, we will try to understand how the caches work and what', 'tokens': [51527, 264, 1713, 3314, 13, 1171, 300, 4334, 11, 321, 486, 853, 281, 1223, 577, 264, 269, 13272, 589, 293, 437, 51784], 'temperature': 0.0, 'avg_logprob': -0.11754986156116833, 'compression_ratio': 1.8032128514056225, 'no_speech_prob': 0.006150052882730961}, {'id': 273, 'seek': 146514, 'start': 1465.14, 'end': 1470.5400000000002, 'text': ' can be done. Again, just very quickly hit is when you find the data in the cache. For', 'tokens': [50364, 393, 312, 1096, 13, 3764, 11, 445, 588, 2661, 2045, 307, 562, 291, 915, 264, 1412, 294, 264, 19459, 13, 1171, 50634], 'temperature': 0.0, 'avg_logprob': -0.1517776157545007, 'compression_ratio': 2.060747663551402, 'no_speech_prob': 0.006609905511140823}, {'id': 274, 'seek': 146514, 'start': 1470.5400000000002, 'end': 1475.3400000000001, 'text': ' our purpose of discussion, we will limit ourselves to one level of cache and then talk about', 'tokens': [50634, 527, 4334, 295, 5017, 11, 321, 486, 4948, 4175, 281, 472, 1496, 295, 19459, 293, 550, 751, 466, 50874], 'temperature': 0.0, 'avg_logprob': -0.1517776157545007, 'compression_ratio': 2.060747663551402, 'no_speech_prob': 0.006609905511140823}, {'id': 275, 'seek': 146514, 'start': 1475.3400000000001, 'end': 1480.26, 'text': ' it, right. Hit is when you find the data in the cache, miss is when you do not find the', 'tokens': [50874, 309, 11, 558, 13, 9217, 307, 562, 291, 915, 264, 1412, 294, 264, 19459, 11, 1713, 307, 562, 291, 360, 406, 915, 264, 51120], 'temperature': 0.0, 'avg_logprob': -0.1517776157545007, 'compression_ratio': 2.060747663551402, 'no_speech_prob': 0.006609905511140823}, {'id': 276, 'seek': 146514, 'start': 1480.26, 'end': 1486.98, 'text': ' data in the cache. Hit ratio is the number of hits divided by the number of accesses.', 'tokens': [51120, 1412, 294, 264, 19459, 13, 9217, 8509, 307, 264, 1230, 295, 8664, 6666, 538, 264, 1230, 295, 2105, 279, 13, 51456], 'temperature': 0.0, 'avg_logprob': -0.1517776157545007, 'compression_ratio': 2.060747663551402, 'no_speech_prob': 0.006609905511140823}, {'id': 277, 'seek': 146514, 'start': 1486.98, 'end': 1492.66, 'text': ' Miss ratio is the number of miss divided by the number of accesses. Hit time, of course,', 'tokens': [51456, 5275, 8509, 307, 264, 1230, 295, 1713, 6666, 538, 264, 1230, 295, 2105, 279, 13, 9217, 565, 11, 295, 1164, 11, 51740], 'temperature': 0.0, 'avg_logprob': -0.1517776157545007, 'compression_ratio': 2.060747663551402, 'no_speech_prob': 0.006609905511140823}, {'id': 278, 'seek': 149266, 'start': 1492.66, 'end': 1497.7, 'text': ' we do not, I mean it is the time to access from L1 cache. Miss penalty is the time you', 'tokens': [50364, 321, 360, 406, 11, 286, 914, 309, 307, 264, 565, 281, 2105, 490, 441, 16, 19459, 13, 5275, 16263, 307, 264, 565, 291, 50616], 'temperature': 0.0, 'avg_logprob': -0.1715073408903899, 'compression_ratio': 1.9608695652173913, 'no_speech_prob': 0.009811557829380035}, {'id': 279, 'seek': 149266, 'start': 1497.7, 'end': 1504.7, 'text': ' take to get it from the, from outside of the cache, okay. Now, we also know about different', 'tokens': [50616, 747, 281, 483, 309, 490, 264, 11, 490, 2380, 295, 264, 19459, 11, 1392, 13, 823, 11, 321, 611, 458, 466, 819, 50966], 'temperature': 0.0, 'avg_logprob': -0.1715073408903899, 'compression_ratio': 1.9608695652173913, 'no_speech_prob': 0.009811557829380035}, {'id': 280, 'seek': 149266, 'start': 1504.7, 'end': 1508.78, 'text': ' cache organizations, do not we? What are the three different cache organizations that you', 'tokens': [50966, 19459, 6150, 11, 360, 406, 321, 30, 708, 366, 264, 1045, 819, 19459, 6150, 300, 291, 51170], 'temperature': 0.0, 'avg_logprob': -0.1715073408903899, 'compression_ratio': 1.9608695652173913, 'no_speech_prob': 0.009811557829380035}, {'id': 281, 'seek': 149266, 'start': 1508.78, 'end': 1517.78, 'text': ' are familiar with? Direct mapping, associative, set associative. So, these are the three different', 'tokens': [51170, 366, 4963, 365, 30, 18308, 18350, 11, 4180, 1166, 11, 992, 4180, 1166, 13, 407, 11, 613, 366, 264, 1045, 819, 51620], 'temperature': 0.0, 'avg_logprob': -0.1715073408903899, 'compression_ratio': 1.9608695652173913, 'no_speech_prob': 0.009811557829380035}, {'id': 282, 'seek': 149266, 'start': 1517.78, 'end': 1522.02, 'text': ' cache organizations that you are familiar with. So, they are essentially determined', 'tokens': [51620, 19459, 6150, 300, 291, 366, 4963, 365, 13, 407, 11, 436, 366, 4476, 9540, 51832], 'temperature': 0.0, 'avg_logprob': -0.1715073408903899, 'compression_ratio': 1.9608695652173913, 'no_speech_prob': 0.009811557829380035}, {'id': 283, 'seek': 152202, 'start': 1522.02, 'end': 1527.02, 'text': ' by these three, four questions. Where is a block placed and that is depending on whether', 'tokens': [50364, 538, 613, 1045, 11, 1451, 1651, 13, 2305, 307, 257, 3461, 7074, 293, 300, 307, 5413, 322, 1968, 50614], 'temperature': 0.0, 'avg_logprob': -0.17471669734209433, 'compression_ratio': 1.7135922330097086, 'no_speech_prob': 0.020654359832406044}, {'id': 284, 'seek': 152202, 'start': 1527.02, 'end': 1532.62, 'text': ' it is direct mapped, set associative or fully associative, where it is being placed and', 'tokens': [50614, 309, 307, 2047, 33318, 11, 992, 4180, 1166, 420, 4498, 4180, 1166, 11, 689, 309, 307, 885, 7074, 293, 50894], 'temperature': 0.0, 'avg_logprob': -0.17471669734209433, 'compression_ratio': 1.7135922330097086, 'no_speech_prob': 0.020654359832406044}, {'id': 285, 'seek': 152202, 'start': 1532.62, 'end': 1538.94, 'text': ' then once you know what is the organization, you know how to find the tag and valid, see', 'tokens': [50894, 550, 1564, 291, 458, 437, 307, 264, 4475, 11, 291, 458, 577, 281, 915, 264, 6162, 293, 7363, 11, 536, 51210], 'temperature': 0.0, 'avg_logprob': -0.17471669734209433, 'compression_ratio': 1.7135922330097086, 'no_speech_prob': 0.020654359832406044}, {'id': 286, 'seek': 152202, 'start': 1538.94, 'end': 1545.78, 'text': ' the tag and the set index bits and the offset bits. And for our discussion, we will not', 'tokens': [51210, 264, 6162, 293, 264, 992, 8186, 9239, 293, 264, 18687, 9239, 13, 400, 337, 527, 5017, 11, 321, 486, 406, 51552], 'temperature': 0.0, 'avg_logprob': -0.17471669734209433, 'compression_ratio': 1.7135922330097086, 'no_speech_prob': 0.020654359832406044}, {'id': 287, 'seek': 154578, 'start': 1546.54, 'end': 1551.54, 'text': ' too much worry about the replacement policy or what happens in the right, okay.', 'tokens': [50402, 886, 709, 3292, 466, 264, 14419, 3897, 420, 437, 2314, 294, 264, 558, 11, 1392, 13, 50652], 'temperature': 0.0, 'avg_logprob': -0.22064447402954102, 'compression_ratio': 1.74, 'no_speech_prob': 0.27573809027671814}, {'id': 288, 'seek': 154578, 'start': 1551.54, 'end': 1557.3, 'text': ' So, first let us quickly talk about direct mapped cache. In the case of a direct mapped', 'tokens': [50652, 407, 11, 700, 718, 505, 2661, 751, 466, 2047, 33318, 19459, 13, 682, 264, 1389, 295, 257, 2047, 33318, 50940], 'temperature': 0.0, 'avg_logprob': -0.22064447402954102, 'compression_ratio': 1.74, 'no_speech_prob': 0.27573809027671814}, {'id': 289, 'seek': 154578, 'start': 1557.3, 'end': 1564.3, 'text': ' cache, each memory block is being mapped to a unique place in the cache, right. And that', 'tokens': [50940, 19459, 11, 1184, 4675, 3461, 307, 885, 33318, 281, 257, 3845, 1081, 294, 264, 19459, 11, 558, 13, 400, 300, 51290], 'temperature': 0.0, 'avg_logprob': -0.22064447402954102, 'compression_ratio': 1.74, 'no_speech_prob': 0.27573809027671814}, {'id': 290, 'seek': 154578, 'start': 1564.98, 'end': 1569.8999999999999, 'text': ' unique place is typically identified by a hash function and this hash function is typically', 'tokens': [51324, 3845, 1081, 307, 5850, 9234, 538, 257, 22019, 2445, 293, 341, 22019, 2445, 307, 5850, 51570], 'temperature': 0.0, 'avg_logprob': -0.22064447402954102, 'compression_ratio': 1.74, 'no_speech_prob': 0.27573809027671814}, {'id': 291, 'seek': 156990, 'start': 1569.9, 'end': 1575.26, 'text': ' a mod function that we use. So, if I have for example, let us say 16 blocks in the', 'tokens': [50364, 257, 1072, 2445, 300, 321, 764, 13, 407, 11, 498, 286, 362, 337, 1365, 11, 718, 505, 584, 3165, 8474, 294, 264, 50632], 'temperature': 0.0, 'avg_logprob': -0.15110401312510172, 'compression_ratio': 1.702970297029703, 'no_speech_prob': 0.009527713060379028}, {'id': 292, 'seek': 156990, 'start': 1575.26, 'end': 1581.46, 'text': ' memory and 8 blocks in the cache, then of course, block 0 and block 8 will be mapped', 'tokens': [50632, 4675, 293, 1649, 8474, 294, 264, 19459, 11, 550, 295, 1164, 11, 3461, 1958, 293, 3461, 1649, 486, 312, 33318, 50942], 'temperature': 0.0, 'avg_logprob': -0.15110401312510172, 'compression_ratio': 1.702970297029703, 'no_speech_prob': 0.009527713060379028}, {'id': 293, 'seek': 156990, 'start': 1581.46, 'end': 1588.46, 'text': ' to cache block 0. Block 1 and block 9 will be mapped to cache block 1 and so on, correct.', 'tokens': [50942, 281, 19459, 3461, 1958, 13, 17500, 502, 293, 3461, 1722, 486, 312, 33318, 281, 19459, 3461, 502, 293, 370, 322, 11, 3006, 13, 51292], 'temperature': 0.0, 'avg_logprob': -0.15110401312510172, 'compression_ratio': 1.702970297029703, 'no_speech_prob': 0.009527713060379028}, {'id': 294, 'seek': 156990, 'start': 1589.02, 'end': 1596.02, 'text': ' So, that is really what happens. So, this again you must be familiar with. Let me just', 'tokens': [51320, 407, 11, 300, 307, 534, 437, 2314, 13, 407, 11, 341, 797, 291, 1633, 312, 4963, 365, 13, 961, 385, 445, 51670], 'temperature': 0.0, 'avg_logprob': -0.15110401312510172, 'compression_ratio': 1.702970297029703, 'no_speech_prob': 0.009527713060379028}, {'id': 295, 'seek': 159602, 'start': 1596.42, 'end': 1602.62, 'text': ' get all of these things. So, in a direct mapped cache, if I assume that each block consists', 'tokens': [50384, 483, 439, 295, 613, 721, 13, 407, 11, 294, 257, 2047, 33318, 19459, 11, 498, 286, 6552, 300, 1184, 3461, 14689, 50694], 'temperature': 0.0, 'avg_logprob': -0.15540477964613172, 'compression_ratio': 1.52, 'no_speech_prob': 0.0018024611053988338}, {'id': 296, 'seek': 159602, 'start': 1602.62, 'end': 1609.62, 'text': ' of 32 bits, 32 bytes, then my offset is 5 bits. And if again I have done this for a', 'tokens': [50694, 295, 8858, 9239, 11, 8858, 36088, 11, 550, 452, 18687, 307, 1025, 9239, 13, 400, 498, 797, 286, 362, 1096, 341, 337, 257, 51044], 'temperature': 0.0, 'avg_logprob': -0.15540477964613172, 'compression_ratio': 1.52, 'no_speech_prob': 0.0018024611053988338}, {'id': 297, 'seek': 159602, 'start': 1611.42, 'end': 1618.42, 'text': ' specific case assuming that I have a cache block of size 16 kilobytes with 32 byte blocks,', 'tokens': [51134, 2685, 1389, 11926, 300, 286, 362, 257, 19459, 3461, 295, 2744, 3165, 5128, 996, 43673, 365, 8858, 40846, 8474, 11, 51484], 'temperature': 0.0, 'avg_logprob': -0.15540477964613172, 'compression_ratio': 1.52, 'no_speech_prob': 0.0018024611053988338}, {'id': 298, 'seek': 161842, 'start': 1619.22, 'end': 1626.22, 'text': ' then I have 512 blocks. So, the index will be 9 bits. The remaining are tag bits. All', 'tokens': [50404, 550, 286, 362, 1025, 4762, 8474, 13, 407, 11, 264, 8186, 486, 312, 1722, 9239, 13, 440, 8877, 366, 6162, 9239, 13, 1057, 50754], 'temperature': 0.0, 'avg_logprob': -0.21390597025553384, 'compression_ratio': 1.5844748858447488, 'no_speech_prob': 0.0011116262758150697}, {'id': 299, 'seek': 161842, 'start': 1626.66, 'end': 1631.14, 'text': ' of you are familiar with this, right. You no need to go through this in any more detail,', 'tokens': [50776, 295, 291, 366, 4963, 365, 341, 11, 558, 13, 509, 572, 643, 281, 352, 807, 341, 294, 604, 544, 2607, 11, 51000], 'temperature': 0.0, 'avg_logprob': -0.21390597025553384, 'compression_ratio': 1.5844748858447488, 'no_speech_prob': 0.0011116262758150697}, {'id': 300, 'seek': 161842, 'start': 1631.14, 'end': 1638.14, 'text': ' correct. Okay, good. So, then what we do is that you essentially take the address, use', 'tokens': [51000, 3006, 13, 1033, 11, 665, 13, 407, 11, 550, 437, 321, 360, 307, 300, 291, 4476, 747, 264, 2985, 11, 764, 51350], 'temperature': 0.0, 'avg_logprob': -0.21390597025553384, 'compression_ratio': 1.5844748858447488, 'no_speech_prob': 0.0011116262758150697}, {'id': 301, 'seek': 161842, 'start': 1638.42, 'end': 1644.66, 'text': ' the index bits, index into the cache, right and then do a tag match. If the tag match', 'tokens': [51364, 264, 8186, 9239, 11, 8186, 666, 264, 19459, 11, 558, 293, 550, 360, 257, 6162, 2995, 13, 759, 264, 6162, 2995, 51676], 'temperature': 0.0, 'avg_logprob': -0.21390597025553384, 'compression_ratio': 1.5844748858447488, 'no_speech_prob': 0.0011116262758150697}, {'id': 302, 'seek': 164466, 'start': 1644.66, 'end': 1651.66, 'text': ' is true, then you have found the data. If not, you have a miss, correct. So, here is', 'tokens': [50364, 307, 2074, 11, 550, 291, 362, 1352, 264, 1412, 13, 759, 406, 11, 291, 362, 257, 1713, 11, 3006, 13, 407, 11, 510, 307, 50714], 'temperature': 0.0, 'avg_logprob': -0.12139859330763511, 'compression_ratio': 1.7445887445887447, 'no_speech_prob': 0.002338134916499257}, {'id': 303, 'seek': 164466, 'start': 1652.02, 'end': 1657.26, 'text': ' what you have shown at the hit, miss is not shown, right. This is what happens in a direct', 'tokens': [50732, 437, 291, 362, 4898, 412, 264, 2045, 11, 1713, 307, 406, 4898, 11, 558, 13, 639, 307, 437, 2314, 294, 257, 2047, 50994], 'temperature': 0.0, 'avg_logprob': -0.12139859330763511, 'compression_ratio': 1.7445887445887447, 'no_speech_prob': 0.002338134916499257}, {'id': 304, 'seek': 164466, 'start': 1657.26, 'end': 1663.0600000000002, 'text': ' mapped cache. Now, in a set associative cache, okay, each', 'tokens': [50994, 33318, 19459, 13, 823, 11, 294, 257, 992, 4180, 1166, 19459, 11, 1392, 11, 1184, 51284], 'temperature': 0.0, 'avg_logprob': -0.12139859330763511, 'compression_ratio': 1.7445887445887447, 'no_speech_prob': 0.002338134916499257}, {'id': 305, 'seek': 164466, 'start': 1663.0600000000002, 'end': 1668.3000000000002, 'text': ' block has multiple places to which it can go to, right. And the number of places it', 'tokens': [51284, 3461, 575, 3866, 3190, 281, 597, 309, 393, 352, 281, 11, 558, 13, 400, 264, 1230, 295, 3190, 309, 51546], 'temperature': 0.0, 'avg_logprob': -0.12139859330763511, 'compression_ratio': 1.7445887445887447, 'no_speech_prob': 0.002338134916499257}, {'id': 306, 'seek': 164466, 'start': 1668.3000000000002, 'end': 1674.1000000000001, 'text': ' can go to is essentially the associativity. That means that the cache is divided into', 'tokens': [51546, 393, 352, 281, 307, 4476, 264, 4180, 30142, 13, 663, 1355, 300, 264, 19459, 307, 6666, 666, 51836], 'temperature': 0.0, 'avg_logprob': -0.12139859330763511, 'compression_ratio': 1.7445887445887447, 'no_speech_prob': 0.002338134916499257}, {'id': 307, 'seek': 167410, 'start': 1674.1, 'end': 1679.82, 'text': ' a number of blocks and then it is also those blocks are also grouped in terms of number', 'tokens': [50364, 257, 1230, 295, 8474, 293, 550, 309, 307, 611, 729, 8474, 366, 611, 41877, 294, 2115, 295, 1230, 50650], 'temperature': 0.0, 'avg_logprob': -0.18036449366602406, 'compression_ratio': 1.748, 'no_speech_prob': 0.003407404525205493}, {'id': 308, 'seek': 167410, 'start': 1679.82, 'end': 1686.82, 'text': ' of sets. Each set has let us say 2 or 4 or 8 blocks associated with that. If it is a', 'tokens': [50650, 295, 6352, 13, 6947, 992, 575, 718, 505, 584, 568, 420, 1017, 420, 1649, 8474, 6615, 365, 300, 13, 759, 309, 307, 257, 51000], 'temperature': 0.0, 'avg_logprob': -0.18036449366602406, 'compression_ratio': 1.748, 'no_speech_prob': 0.003407404525205493}, {'id': 309, 'seek': 167410, 'start': 1686.82, 'end': 1692.26, 'text': ' two way, four way or a eight way set associative, then every memory block is uniquely mapped', 'tokens': [51000, 732, 636, 11, 1451, 636, 420, 257, 3180, 636, 992, 4180, 1166, 11, 550, 633, 4675, 3461, 307, 31474, 33318, 51272], 'temperature': 0.0, 'avg_logprob': -0.18036449366602406, 'compression_ratio': 1.748, 'no_speech_prob': 0.003407404525205493}, {'id': 310, 'seek': 167410, 'start': 1692.26, 'end': 1698.2199999999998, 'text': ' to one set, but within that set it can go to any one of those blocks. That is really', 'tokens': [51272, 281, 472, 992, 11, 457, 1951, 300, 992, 309, 393, 352, 281, 604, 472, 295, 729, 8474, 13, 663, 307, 534, 51570], 'temperature': 0.0, 'avg_logprob': -0.18036449366602406, 'compression_ratio': 1.748, 'no_speech_prob': 0.003407404525205493}, {'id': 311, 'seek': 167410, 'start': 1698.2199999999998, 'end': 1703.36, 'text': ' the idea. So, again let us see what it is. Here the same 8 blocks are now divided into', 'tokens': [51570, 264, 1558, 13, 407, 11, 797, 718, 505, 536, 437, 309, 307, 13, 1692, 264, 912, 1649, 8474, 366, 586, 6666, 666, 51827], 'temperature': 0.0, 'avg_logprob': -0.18036449366602406, 'compression_ratio': 1.748, 'no_speech_prob': 0.003407404525205493}, {'id': 312, 'seek': 170336, 'start': 1703.36, 'end': 1710.36, 'text': ' four sets and every memory block is uniquely mapped to one of these sets, but then within', 'tokens': [50364, 1451, 6352, 293, 633, 4675, 3461, 307, 31474, 33318, 281, 472, 295, 613, 6352, 11, 457, 550, 1951, 50714], 'temperature': 0.0, 'avg_logprob': -0.23280906677246094, 'compression_ratio': 1.8439306358381502, 'no_speech_prob': 0.006450095679610968}, {'id': 313, 'seek': 170336, 'start': 1710.52, 'end': 1714.8, 'text': ' the set it can be either one of those blocks, right.', 'tokens': [50722, 264, 992, 309, 393, 312, 2139, 472, 295, 729, 8474, 11, 558, 13, 50936], 'temperature': 0.0, 'avg_logprob': -0.23280906677246094, 'compression_ratio': 1.8439306358381502, 'no_speech_prob': 0.006450095679610968}, {'id': 314, 'seek': 170336, 'start': 1714.8, 'end': 1721.8, 'text': ' So, this is what happens, right. Block 0, block 4, block 8, etcetera are mapped to set', 'tokens': [50936, 407, 11, 341, 307, 437, 2314, 11, 558, 13, 17500, 1958, 11, 3461, 1017, 11, 3461, 1649, 11, 22066, 366, 33318, 281, 992, 51286], 'temperature': 0.0, 'avg_logprob': -0.23280906677246094, 'compression_ratio': 1.8439306358381502, 'no_speech_prob': 0.006450095679610968}, {'id': 315, 'seek': 170336, 'start': 1722.0, 'end': 1729.0, 'text': ' 0, right. Similarly, block 3, block 7, block 11, etcetera are mapped to set 3, right. So,', 'tokens': [51296, 1958, 11, 558, 13, 13157, 11, 3461, 805, 11, 3461, 1614, 11, 3461, 2975, 11, 22066, 366, 33318, 281, 992, 805, 11, 558, 13, 407, 11, 51646], 'temperature': 0.0, 'avg_logprob': -0.23280906677246094, 'compression_ratio': 1.8439306358381502, 'no_speech_prob': 0.006450095679610968}, {'id': 316, 'seek': 172900, 'start': 1729.0, 'end': 1734.92, 'text': ' in this set associative cache it is possible to have for example block 3 and block 11 together', 'tokens': [50364, 294, 341, 992, 4180, 1166, 19459, 309, 307, 1944, 281, 362, 337, 1365, 3461, 805, 293, 3461, 2975, 1214, 50660], 'temperature': 0.0, 'avg_logprob': -0.23770800880763843, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.0022796839475631714}, {'id': 317, 'seek': 172900, 'start': 1734.92, 'end': 1741.2, 'text': ' in set 3. Whereas in the case of a direct mapped class 3 and 11 cannot be together in', 'tokens': [50660, 294, 992, 805, 13, 13813, 294, 264, 1389, 295, 257, 2047, 33318, 1508, 805, 293, 2975, 2644, 312, 1214, 294, 50974], 'temperature': 0.0, 'avg_logprob': -0.23770800880763843, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.0022796839475631714}, {'id': 318, 'seek': 172900, 'start': 1741.2, 'end': 1748.2, 'text': ' the cache, okay. Alright. So, this is similar thing. If you have a set associative cache', 'tokens': [50974, 264, 19459, 11, 1392, 13, 2798, 13, 407, 11, 341, 307, 2531, 551, 13, 759, 291, 362, 257, 992, 4180, 1166, 19459, 51324], 'temperature': 0.0, 'avg_logprob': -0.23770800880763843, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.0022796839475631714}, {'id': 319, 'seek': 172900, 'start': 1749.6, 'end': 1756.6, 'text': ' rate of size again 16 kilobytes, then what you do is that you take the number of cache', 'tokens': [51394, 3314, 295, 2744, 797, 3165, 5128, 996, 43673, 11, 550, 437, 291, 360, 307, 300, 291, 747, 264, 1230, 295, 19459, 51744], 'temperature': 0.0, 'avg_logprob': -0.23770800880763843, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.0022796839475631714}, {'id': 320, 'seek': 175660, 'start': 1757.3999999999999, 'end': 1762.7199999999998, 'text': ' blocks which is 512, you divide it by 4 if it is a 4-way set associative, then you say', 'tokens': [50404, 8474, 597, 307, 1025, 4762, 11, 291, 9845, 309, 538, 1017, 498, 309, 307, 257, 1017, 12, 676, 992, 4180, 1166, 11, 550, 291, 584, 50670], 'temperature': 0.0, 'avg_logprob': -0.2287636478390314, 'compression_ratio': 1.8165938864628821, 'no_speech_prob': 0.009616649709641933}, {'id': 321, 'seek': 175660, 'start': 1762.7199999999998, 'end': 1767.1999999999998, 'text': ' how 128 sets. That means that you need to have 7 bits as index.', 'tokens': [50670, 577, 29810, 6352, 13, 663, 1355, 300, 291, 643, 281, 362, 1614, 9239, 382, 8186, 13, 50894], 'temperature': 0.0, 'avg_logprob': -0.2287636478390314, 'compression_ratio': 1.8165938864628821, 'no_speech_prob': 0.009616649709641933}, {'id': 322, 'seek': 175660, 'start': 1767.1999999999998, 'end': 1771.9199999999998, 'text': ' Now, how do you find the blocks in the cache? For a 2-way set associative cache the diagram', 'tokens': [50894, 823, 11, 577, 360, 291, 915, 264, 8474, 294, 264, 19459, 30, 1171, 257, 568, 12, 676, 992, 4180, 1166, 19459, 264, 10686, 51130], 'temperature': 0.0, 'avg_logprob': -0.2287636478390314, 'compression_ratio': 1.8165938864628821, 'no_speech_prob': 0.009616649709641933}, {'id': 323, 'seek': 175660, 'start': 1771.9199999999998, 'end': 1778.04, 'text': ' shows you use the index bits, you index into the cache. There will be two locations that', 'tokens': [51130, 3110, 291, 764, 264, 8186, 9239, 11, 291, 8186, 666, 264, 19459, 13, 821, 486, 312, 732, 9253, 300, 51436], 'temperature': 0.0, 'avg_logprob': -0.2287636478390314, 'compression_ratio': 1.8165938864628821, 'no_speech_prob': 0.009616649709641933}, {'id': 324, 'seek': 175660, 'start': 1778.04, 'end': 1782.48, 'text': ' you have because corresponding to the set for a 2-way set associative cache you have', 'tokens': [51436, 291, 362, 570, 11760, 281, 264, 992, 337, 257, 568, 12, 676, 992, 4180, 1166, 19459, 291, 362, 51658], 'temperature': 0.0, 'avg_logprob': -0.2287636478390314, 'compression_ratio': 1.8165938864628821, 'no_speech_prob': 0.009616649709641933}, {'id': 325, 'seek': 178248, 'start': 1782.48, 'end': 1787.72, 'text': ' two locations you search both these tags, right. One of them is a hit, then you have', 'tokens': [50364, 732, 9253, 291, 3164, 1293, 613, 18632, 11, 558, 13, 1485, 295, 552, 307, 257, 2045, 11, 550, 291, 362, 50626], 'temperature': 0.0, 'avg_logprob': -0.18212730326551071, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.015322915278375149}, {'id': 326, 'seek': 178248, 'start': 1787.72, 'end': 1794.24, 'text': ' a hit. If both of them are misses then it is a miss, okay. So, that is how you access', 'tokens': [50626, 257, 2045, 13, 759, 1293, 295, 552, 366, 29394, 550, 309, 307, 257, 1713, 11, 1392, 13, 407, 11, 300, 307, 577, 291, 2105, 50952], 'temperature': 0.0, 'avg_logprob': -0.18212730326551071, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.015322915278375149}, {'id': 327, 'seek': 178248, 'start': 1794.24, 'end': 1800.88, 'text': ' the data in a set associative cache, okay. Now, let us try to understand how the caches', 'tokens': [50952, 264, 1412, 294, 257, 992, 4180, 1166, 19459, 11, 1392, 13, 823, 11, 718, 505, 853, 281, 1223, 577, 264, 269, 13272, 51284], 'temperature': 0.0, 'avg_logprob': -0.18212730326551071, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.015322915278375149}, {'id': 328, 'seek': 178248, 'start': 1800.88, 'end': 1807.88, 'text': " work from a programmer's perspective, right. We will use a direct mapped cache which is", 'tokens': [51284, 589, 490, 257, 32116, 311, 4585, 11, 558, 13, 492, 486, 764, 257, 2047, 33318, 19459, 597, 307, 51634], 'temperature': 0.0, 'avg_logprob': -0.18212730326551071, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.015322915278375149}, {'id': 329, 'seek': 180788, 'start': 1807.96, 'end': 1812.64, 'text': ' 16 kilobytes with 32 byte cache block size, okay.', 'tokens': [50368, 3165, 5128, 996, 43673, 365, 8858, 40846, 19459, 3461, 2744, 11, 1392, 13, 50602], 'temperature': 0.0, 'avg_logprob': -0.22790403251188346, 'compression_ratio': 1.5918367346938775, 'no_speech_prob': 0.019798962399363518}, {'id': 330, 'seek': 180788, 'start': 1812.64, 'end': 1818.72, 'text': ' Do you all know, I think this is going to the example, okay. Now, before we go into', 'tokens': [50602, 1144, 291, 439, 458, 11, 286, 519, 341, 307, 516, 281, 264, 1365, 11, 1392, 13, 823, 11, 949, 321, 352, 666, 50906], 'temperature': 0.0, 'avg_logprob': -0.22790403251188346, 'compression_ratio': 1.5918367346938775, 'no_speech_prob': 0.019798962399363518}, {'id': 331, 'seek': 180788, 'start': 1818.72, 'end': 1824.3200000000002, 'text': ' that do you all know the three different types of cache misses? So, the cache misses are', 'tokens': [50906, 300, 360, 291, 439, 458, 264, 1045, 819, 3467, 295, 19459, 29394, 30, 407, 11, 264, 19459, 29394, 366, 51186], 'temperature': 0.0, 'avg_logprob': -0.22790403251188346, 'compression_ratio': 1.5918367346938775, 'no_speech_prob': 0.019798962399363518}, {'id': 332, 'seek': 180788, 'start': 1824.3200000000002, 'end': 1831.3200000000002, 'text': ' classified into three types, right. One called the cold misses, right, cold or compulsory', 'tokens': [51186, 20627, 666, 1045, 3467, 11, 558, 13, 1485, 1219, 264, 3554, 29394, 11, 558, 11, 3554, 420, 42773, 827, 51536], 'temperature': 0.0, 'avg_logprob': -0.22790403251188346, 'compression_ratio': 1.5918367346938775, 'no_speech_prob': 0.019798962399363518}, {'id': 333, 'seek': 183132, 'start': 1831.32, 'end': 1838.32, 'text': ' misses. Another one called conflict misses and the third one called capacity misses.', 'tokens': [50364, 29394, 13, 3996, 472, 1219, 6596, 29394, 293, 264, 2636, 472, 1219, 6042, 29394, 13, 50714], 'temperature': 0.0, 'avg_logprob': -0.22930558025836945, 'compression_ratio': 1.4913294797687862, 'no_speech_prob': 0.017529712989926338}, {'id': 334, 'seek': 183132, 'start': 1846.12, 'end': 1853.12, 'text': ' Have you come across these things? No? Okay. Do we need them? Let us find out, okay. Let', 'tokens': [51104, 3560, 291, 808, 2108, 613, 721, 30, 883, 30, 1033, 13, 1144, 321, 643, 552, 30, 961, 505, 915, 484, 11, 1392, 13, 961, 51454], 'temperature': 0.0, 'avg_logprob': -0.22930558025836945, 'compression_ratio': 1.4913294797687862, 'no_speech_prob': 0.017529712989926338}, {'id': 335, 'seek': 183132, 'start': 1855.52, 'end': 1860.32, 'text': ' me very briefly tell you what these three different types of misses are, right. When', 'tokens': [51574, 385, 588, 10515, 980, 291, 437, 613, 1045, 819, 3467, 295, 29394, 366, 11, 558, 13, 1133, 51814], 'temperature': 0.0, 'avg_logprob': -0.22930558025836945, 'compression_ratio': 1.4913294797687862, 'no_speech_prob': 0.017529712989926338}, {'id': 336, 'seek': 186032, 'start': 1860.32, 'end': 1866.12, 'text': ' you try to bring the block for the first time into the cache that miss has to anyway', 'tokens': [50364, 291, 853, 281, 1565, 264, 3461, 337, 264, 700, 565, 666, 264, 19459, 300, 1713, 575, 281, 4033, 50654], 'temperature': 0.0, 'avg_logprob': -0.14466281965667127, 'compression_ratio': 1.9906542056074767, 'no_speech_prob': 0.0036922069266438484}, {'id': 337, 'seek': 186032, 'start': 1866.12, 'end': 1870.52, 'text': ' happen, right, because there is no way by which the cache by default will have that', 'tokens': [50654, 1051, 11, 558, 11, 570, 456, 307, 572, 636, 538, 597, 264, 19459, 538, 7576, 486, 362, 300, 50874], 'temperature': 0.0, 'avg_logprob': -0.14466281965667127, 'compression_ratio': 1.9906542056074767, 'no_speech_prob': 0.0036922069266438484}, {'id': 338, 'seek': 186032, 'start': 1870.52, 'end': 1877.52, 'text': ' block. So, the first miss that happens is what we call as the cold miss, right. Then', 'tokens': [50874, 3461, 13, 407, 11, 264, 700, 1713, 300, 2314, 307, 437, 321, 818, 382, 264, 3554, 1713, 11, 558, 13, 1396, 51224], 'temperature': 0.0, 'avg_logprob': -0.14466281965667127, 'compression_ratio': 1.9906542056074767, 'no_speech_prob': 0.0036922069266438484}, {'id': 339, 'seek': 186032, 'start': 1878.72, 'end': 1884.6, 'text': ' the misses that happen because your cache cannot have all the capacity to hold all the', 'tokens': [51284, 264, 29394, 300, 1051, 570, 428, 19459, 2644, 362, 439, 264, 6042, 281, 1797, 439, 264, 51578], 'temperature': 0.0, 'avg_logprob': -0.14466281965667127, 'compression_ratio': 1.9906542056074767, 'no_speech_prob': 0.0036922069266438484}, {'id': 340, 'seek': 186032, 'start': 1884.6, 'end': 1889.28, 'text': ' addresses, cache does not have the capacity to hold all the addresses. Those types of', 'tokens': [51578, 16862, 11, 19459, 775, 406, 362, 264, 6042, 281, 1797, 439, 264, 16862, 13, 3950, 3467, 295, 51812], 'temperature': 0.0, 'avg_logprob': -0.14466281965667127, 'compression_ratio': 1.9906542056074767, 'no_speech_prob': 0.0036922069266438484}, {'id': 341, 'seek': 188928, 'start': 1889.28, 'end': 1896.28, 'text': ' misses are called the capacity misses, right and remaining misses are what are called conflict', 'tokens': [50364, 29394, 366, 1219, 264, 6042, 29394, 11, 558, 293, 8877, 29394, 366, 437, 366, 1219, 6596, 50714], 'temperature': 0.0, 'avg_logprob': -0.22956427608627872, 'compression_ratio': 1.6515151515151516, 'no_speech_prob': 0.004657006822526455}, {'id': 342, 'seek': 188928, 'start': 1896.8, 'end': 1901.36, 'text': ' misses, okay. So, in other way of explaining is that with', 'tokens': [50740, 29394, 11, 1392, 13, 407, 11, 294, 661, 636, 295, 13468, 307, 300, 365, 50968], 'temperature': 0.0, 'avg_logprob': -0.22956427608627872, 'compression_ratio': 1.6515151515151516, 'no_speech_prob': 0.004657006822526455}, {'id': 343, 'seek': 188928, 'start': 1901.36, 'end': 1908.36, 'text': ' regard to the capacity misses supposing let us say you have a 32 kilobyte cache, right', 'tokens': [50968, 3843, 281, 264, 6042, 29394, 1003, 6110, 718, 505, 584, 291, 362, 257, 8858, 5128, 13944, 975, 19459, 11, 558, 51318], 'temperature': 0.0, 'avg_logprob': -0.22956427608627872, 'compression_ratio': 1.6515151515151516, 'no_speech_prob': 0.004657006822526455}, {'id': 344, 'seek': 188928, 'start': 1908.36, 'end': 1915.36, 'text': ' with block size as 32, right. Then this will have 1k blocks in this, correct. Now, that', 'tokens': [51318, 365, 3461, 2744, 382, 8858, 11, 558, 13, 1396, 341, 486, 362, 502, 74, 8474, 294, 341, 11, 3006, 13, 823, 11, 300, 51668], 'temperature': 0.0, 'avg_logprob': -0.22956427608627872, 'compression_ratio': 1.6515151515151516, 'no_speech_prob': 0.004657006822526455}, {'id': 345, 'seek': 191536, 'start': 1915.36, 'end': 1922.36, 'text': ' 1k blocks can hold only at most 1k of locations, right. If you access, if you are going to', 'tokens': [50364, 502, 74, 8474, 393, 1797, 787, 412, 881, 502, 74, 295, 9253, 11, 558, 13, 759, 291, 2105, 11, 498, 291, 366, 516, 281, 50714], 'temperature': 0.0, 'avg_logprob': -0.1718486279857402, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.010368493385612965}, {'id': 346, 'seek': 191536, 'start': 1924.12, 'end': 1931.12, 'text': ' access data which is beyond 1k blocks, then irrespective of what you do, it is going to', 'tokens': [50802, 2105, 1412, 597, 307, 4399, 502, 74, 8474, 11, 550, 3418, 19575, 488, 295, 437, 291, 360, 11, 309, 307, 516, 281, 51152], 'temperature': 0.0, 'avg_logprob': -0.1718486279857402, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.010368493385612965}, {'id': 347, 'seek': 191536, 'start': 1931.82, 'end': 1938.56, 'text': ' give a miss up to 1k only what is what you can hold and beyond that, right, anything', 'tokens': [51187, 976, 257, 1713, 493, 281, 502, 74, 787, 437, 307, 437, 291, 393, 1797, 293, 4399, 300, 11, 558, 11, 1340, 51524], 'temperature': 0.0, 'avg_logprob': -0.1718486279857402, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.010368493385612965}, {'id': 348, 'seek': 191536, 'start': 1938.56, 'end': 1942.56, 'text': ' that you try to access even though you may want it to be in the cache, it is not going', 'tokens': [51524, 300, 291, 853, 281, 2105, 754, 1673, 291, 815, 528, 309, 281, 312, 294, 264, 19459, 11, 309, 307, 406, 516, 51724], 'temperature': 0.0, 'avg_logprob': -0.1718486279857402, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.010368493385612965}, {'id': 349, 'seek': 194256, 'start': 1942.56, 'end': 1944.8799999999999, 'text': ' to be there. For example, I will actually give you some', 'tokens': [50364, 281, 312, 456, 13, 1171, 1365, 11, 286, 486, 767, 976, 291, 512, 50480], 'temperature': 0.0, 'avg_logprob': -0.18267593383789063, 'compression_ratio': 1.6816326530612244, 'no_speech_prob': 0.005128189921379089}, {'id': 350, 'seek': 194256, 'start': 1944.8799999999999, 'end': 1949.8799999999999, 'text': ' examples of this in the next slide where you will actually try to understand that, right.', 'tokens': [50480, 5110, 295, 341, 294, 264, 958, 4137, 689, 291, 486, 767, 853, 281, 1223, 300, 11, 558, 13, 50730], 'temperature': 0.0, 'avg_logprob': -0.18267593383789063, 'compression_ratio': 1.6816326530612244, 'no_speech_prob': 0.005128189921379089}, {'id': 351, 'seek': 194256, 'start': 1949.8799999999999, 'end': 1955.8799999999999, 'text': ' So, because of my limited capacity any miss that happens is essentially a capacity miss.', 'tokens': [50730, 407, 11, 570, 295, 452, 5567, 6042, 604, 1713, 300, 2314, 307, 4476, 257, 6042, 1713, 13, 51030], 'temperature': 0.0, 'avg_logprob': -0.18267593383789063, 'compression_ratio': 1.6816326530612244, 'no_speech_prob': 0.005128189921379089}, {'id': 352, 'seek': 194256, 'start': 1955.8799999999999, 'end': 1960.8799999999999, 'text': ' A conflict miss on the other hand happens in the following way. See, you remember you', 'tokens': [51030, 316, 6596, 1713, 322, 264, 661, 1011, 2314, 294, 264, 3480, 636, 13, 3008, 11, 291, 1604, 291, 51280], 'temperature': 0.0, 'avg_logprob': -0.18267593383789063, 'compression_ratio': 1.6816326530612244, 'no_speech_prob': 0.005128189921379089}, {'id': 353, 'seek': 194256, 'start': 1960.8799999999999, 'end': 1967.8799999999999, 'text': ' saw the example of block 3 and block 11 getting mapped to the same set, right, set 3 in our', 'tokens': [51280, 1866, 264, 1365, 295, 3461, 805, 293, 3461, 2975, 1242, 33318, 281, 264, 912, 992, 11, 558, 11, 992, 805, 294, 527, 51630], 'temperature': 0.0, 'avg_logprob': -0.18267593383789063, 'compression_ratio': 1.6816326530612244, 'no_speech_prob': 0.005128189921379089}, {'id': 354, 'seek': 196788, 'start': 1968.88, 'end': 1975.88, 'text': ' set associative cache, correct. What if I also want to access block 7? That will also', 'tokens': [50414, 992, 4180, 1166, 19459, 11, 3006, 13, 708, 498, 286, 611, 528, 281, 2105, 3461, 1614, 30, 663, 486, 611, 50764], 'temperature': 0.0, 'avg_logprob': -0.1689537518644986, 'compression_ratio': 1.467741935483871, 'no_speech_prob': 0.006557865999639034}, {'id': 355, 'seek': 196788, 'start': 1977.72, 'end': 1984.72, 'text': ' get mapped to the same set, correct. Now, if I have a program which tries to alternatively', 'tokens': [50856, 483, 33318, 281, 264, 912, 992, 11, 3006, 13, 823, 11, 498, 286, 362, 257, 1461, 597, 9898, 281, 8535, 356, 51206], 'temperature': 0.0, 'avg_logprob': -0.1689537518644986, 'compression_ratio': 1.467741935483871, 'no_speech_prob': 0.006557865999639034}, {'id': 356, 'seek': 196788, 'start': 1984.72, 'end': 1991.72, 'text': ' access 3, 7 and 11 repeatedly, then what happens? One of them is going to evict the other, right', 'tokens': [51206, 2105, 805, 11, 1614, 293, 2975, 18227, 11, 550, 437, 2314, 30, 1485, 295, 552, 307, 516, 281, 1073, 985, 264, 661, 11, 558, 51556], 'temperature': 0.0, 'avg_logprob': -0.1689537518644986, 'compression_ratio': 1.467741935483871, 'no_speech_prob': 0.006557865999639034}, {'id': 357, 'seek': 199172, 'start': 1991.92, 'end': 1998.2, 'text': ' and you are going to have a miss. That kind of a miss is what is called a conflict miss.', 'tokens': [50374, 293, 291, 366, 516, 281, 362, 257, 1713, 13, 663, 733, 295, 257, 1713, 307, 437, 307, 1219, 257, 6596, 1713, 13, 50688], 'temperature': 0.0, 'avg_logprob': -0.19314619700113933, 'compression_ratio': 1.8541666666666667, 'no_speech_prob': 0.009357823058962822}, {'id': 358, 'seek': 199172, 'start': 1998.2, 'end': 2004.2, 'text': ' See, I have 1024 blocks. If you have allowed each one of these blocks to go somewhere in', 'tokens': [50688, 3008, 11, 286, 362, 1266, 7911, 8474, 13, 759, 291, 362, 4350, 1184, 472, 295, 613, 8474, 281, 352, 4079, 294, 50988], 'temperature': 0.0, 'avg_logprob': -0.19314619700113933, 'compression_ratio': 1.8541666666666667, 'no_speech_prob': 0.009357823058962822}, {'id': 359, 'seek': 199172, 'start': 2004.2, 'end': 2010.52, 'text': ' the cache, I could have had all three of them together, correct. If I had a fully associative', 'tokens': [50988, 264, 19459, 11, 286, 727, 362, 632, 439, 1045, 295, 552, 1214, 11, 3006, 13, 759, 286, 632, 257, 4498, 4180, 1166, 51304], 'temperature': 0.0, 'avg_logprob': -0.19314619700113933, 'compression_ratio': 1.8541666666666667, 'no_speech_prob': 0.009357823058962822}, {'id': 360, 'seek': 199172, 'start': 2010.52, 'end': 2016.52, 'text': ' cache of 1024 blocks, these three accesses would not have caused a miss whereas, because', 'tokens': [51304, 19459, 295, 1266, 7911, 8474, 11, 613, 1045, 2105, 279, 576, 406, 362, 7008, 257, 1713, 9735, 11, 570, 51604], 'temperature': 0.0, 'avg_logprob': -0.19314619700113933, 'compression_ratio': 1.8541666666666667, 'no_speech_prob': 0.009357823058962822}, {'id': 361, 'seek': 199172, 'start': 2016.52, 'end': 2021.2, 'text': ' I have a two-way set associative cache, I have a miss. Do not worry even if I have a', 'tokens': [51604, 286, 362, 257, 732, 12, 676, 992, 4180, 1166, 19459, 11, 286, 362, 257, 1713, 13, 1144, 406, 3292, 754, 498, 286, 362, 257, 51838], 'temperature': 0.0, 'avg_logprob': -0.19314619700113933, 'compression_ratio': 1.8541666666666667, 'no_speech_prob': 0.009357823058962822}, {'id': 362, 'seek': 202120, 'start': 2021.2, 'end': 2028.2, 'text': ' four-way set associative cache, I could have had all three of them together, right. So,', 'tokens': [50364, 1451, 12, 676, 992, 4180, 1166, 19459, 11, 286, 727, 362, 632, 439, 1045, 295, 552, 1214, 11, 558, 13, 407, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.15453778780423677, 'compression_ratio': 1.5913043478260869, 'no_speech_prob': 0.0009676362969912589}, {'id': 363, 'seek': 202120, 'start': 2028.2, 'end': 2034.72, 'text': ' the misses which happen because my associativity is limited are called conflict misses, right.', 'tokens': [50714, 264, 29394, 597, 1051, 570, 452, 4180, 30142, 307, 5567, 366, 1219, 6596, 29394, 11, 558, 13, 51040], 'temperature': 0.0, 'avg_logprob': -0.15453778780423677, 'compression_ratio': 1.5913043478260869, 'no_speech_prob': 0.0009676362969912589}, {'id': 364, 'seek': 202120, 'start': 2034.72, 'end': 2040.48, 'text': ' So, these are the three different types of misses. We will not too much worry about classifying', 'tokens': [51040, 407, 11, 613, 366, 264, 1045, 819, 3467, 295, 29394, 13, 492, 486, 406, 886, 709, 3292, 466, 1508, 5489, 51328], 'temperature': 0.0, 'avg_logprob': -0.15453778780423677, 'compression_ratio': 1.5913043478260869, 'no_speech_prob': 0.0009676362969912589}, {'id': 365, 'seek': 202120, 'start': 2040.48, 'end': 2046.88, 'text': ' them, but somewhere I might mention, okay. Now, let us move forward. Let us take a real', 'tokens': [51328, 552, 11, 457, 4079, 286, 1062, 2152, 11, 1392, 13, 823, 11, 718, 505, 1286, 2128, 13, 961, 505, 747, 257, 957, 51648], 'temperature': 0.0, 'avg_logprob': -0.15453778780423677, 'compression_ratio': 1.5913043478260869, 'no_speech_prob': 0.0009676362969912589}, {'id': 366, 'seek': 204688, 'start': 2046.88, 'end': 2053.6800000000003, 'text': ' example and then see what happens. Supposing, let us say I want to access an array of 2k', 'tokens': [50364, 1365, 293, 550, 536, 437, 2314, 13, 9391, 6110, 11, 718, 505, 584, 286, 528, 281, 2105, 364, 10225, 295, 568, 74, 50704], 'temperature': 0.0, 'avg_logprob': -0.19929202805217514, 'compression_ratio': 1.7297297297297298, 'no_speech_prob': 0.026916000992059708}, {'id': 367, 'seek': 204688, 'start': 2053.6800000000003, 'end': 2060.12, 'text': ' elements and this is an array of double. Each element is 8 bytes long, okay. And for the', 'tokens': [50704, 4959, 293, 341, 307, 364, 10225, 295, 3834, 13, 6947, 4478, 307, 1649, 36088, 938, 11, 1392, 13, 400, 337, 264, 51026], 'temperature': 0.0, 'avg_logprob': -0.19929202805217514, 'compression_ratio': 1.7297297297297298, 'no_speech_prob': 0.026916000992059708}, {'id': 368, 'seek': 204688, 'start': 2060.12, 'end': 2065.2400000000002, 'text': ' purpose of this example, we will only assume that the array is in my data cache. No other', 'tokens': [51026, 4334, 295, 341, 1365, 11, 321, 486, 787, 6552, 300, 264, 10225, 307, 294, 452, 1412, 19459, 13, 883, 661, 51282], 'temperature': 0.0, 'avg_logprob': -0.19929202805217514, 'compression_ratio': 1.7297297297297298, 'no_speech_prob': 0.026916000992059708}, {'id': 369, 'seek': 204688, 'start': 2065.2400000000002, 'end': 2071.0, 'text': ' variable is in my data cache, right, right. And this is the code that is going to be executed.', 'tokens': [51282, 7006, 307, 294, 452, 1412, 19459, 11, 558, 11, 558, 13, 400, 341, 307, 264, 3089, 300, 307, 516, 281, 312, 17577, 13, 51570], 'temperature': 0.0, 'avg_logprob': -0.19929202805217514, 'compression_ratio': 1.7297297297297298, 'no_speech_prob': 0.026916000992059708}, {'id': 370, 'seek': 204688, 'start': 2071.0, 'end': 2076.6, 'text': ' Again, I do not really see the reason for understanding the code, but let us see what', 'tokens': [51570, 3764, 11, 286, 360, 406, 534, 536, 264, 1778, 337, 3701, 264, 3089, 11, 457, 718, 505, 536, 437, 51850], 'temperature': 0.0, 'avg_logprob': -0.19929202805217514, 'compression_ratio': 1.7297297297297298, 'no_speech_prob': 0.026916000992059708}, {'id': 371, 'seek': 207660, 'start': 2076.6, 'end': 2083.12, 'text': ' happens here. So, as I mentioned earlier, we are only going to say that the array A', 'tokens': [50364, 2314, 510, 13, 407, 11, 382, 286, 2835, 3071, 11, 321, 366, 787, 516, 281, 584, 300, 264, 10225, 316, 50690], 'temperature': 0.0, 'avg_logprob': -0.14556387359020756, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.005946485325694084}, {'id': 372, 'seek': 207660, 'start': 2083.12, 'end': 2090.0, 'text': ' and its elements are what is going to be stored in our cache, right. And so, the way in which', 'tokens': [50690, 293, 1080, 4959, 366, 437, 307, 516, 281, 312, 12187, 294, 527, 19459, 11, 558, 13, 400, 370, 11, 264, 636, 294, 597, 51034], 'temperature': 0.0, 'avg_logprob': -0.14556387359020756, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.005946485325694084}, {'id': 373, 'seek': 207660, 'start': 2090.0, 'end': 2096.16, 'text': ' the elements are going to be accessed in the loop is that you will first load array A 0,', 'tokens': [51034, 264, 4959, 366, 516, 281, 312, 34211, 294, 264, 6367, 307, 300, 291, 486, 700, 3677, 10225, 316, 1958, 11, 51342], 'temperature': 0.0, 'avg_logprob': -0.14556387359020756, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.005946485325694084}, {'id': 374, 'seek': 207660, 'start': 2096.16, 'end': 2102.88, 'text': ' then A 1, A 2, A 3, A 4 and so on. Now, can you tell me that when I do write this program', 'tokens': [51342, 550, 316, 502, 11, 316, 568, 11, 316, 805, 11, 316, 1017, 293, 370, 322, 13, 823, 11, 393, 291, 980, 385, 300, 562, 286, 360, 2464, 341, 1461, 51678], 'temperature': 0.0, 'avg_logprob': -0.14556387359020756, 'compression_ratio': 1.655813953488372, 'no_speech_prob': 0.005946485325694084}, {'id': 375, 'seek': 210288, 'start': 2103.2000000000003, 'end': 2109.28, 'text': ' and then when I run it on a machine which has 16 kilobytes of cache, right and assuming', 'tokens': [50380, 293, 550, 562, 286, 1190, 309, 322, 257, 3479, 597, 575, 3165, 5128, 996, 43673, 295, 19459, 11, 558, 293, 11926, 50684], 'temperature': 0.0, 'avg_logprob': -0.20008646923562753, 'compression_ratio': 1.5601851851851851, 'no_speech_prob': 0.338077187538147}, {'id': 376, 'seek': 210288, 'start': 2109.28, 'end': 2115.92, 'text': ' that only array A is going to be in my cache, how many hits and how many misses will I have,', 'tokens': [50684, 300, 787, 10225, 316, 307, 516, 281, 312, 294, 452, 19459, 11, 577, 867, 8664, 293, 577, 867, 29394, 486, 286, 362, 11, 51016], 'temperature': 0.0, 'avg_logprob': -0.20008646923562753, 'compression_ratio': 1.5601851851851851, 'no_speech_prob': 0.338077187538147}, {'id': 377, 'seek': 210288, 'start': 2115.92, 'end': 2121.88, 'text': ' right. That should be analyzable, okay. At least approximately we should be able to get', 'tokens': [51016, 558, 13, 663, 820, 312, 6459, 89, 712, 11, 1392, 13, 1711, 1935, 10447, 321, 820, 312, 1075, 281, 483, 51314], 'temperature': 0.0, 'avg_logprob': -0.20008646923562753, 'compression_ratio': 1.5601851851851851, 'no_speech_prob': 0.338077187538147}, {'id': 378, 'seek': 210288, 'start': 2121.88, 'end': 2128.48, 'text': ' a picture of this, right. So, I will make it things simpler for you.', 'tokens': [51314, 257, 3036, 295, 341, 11, 558, 13, 407, 11, 286, 486, 652, 309, 721, 18587, 337, 291, 13, 51644], 'temperature': 0.0, 'avg_logprob': -0.20008646923562753, 'compression_ratio': 1.5601851851851851, 'no_speech_prob': 0.338077187538147}, {'id': 379, 'seek': 212848, 'start': 2128.48, 'end': 2135.08, 'text': ' I will also tell you if I know what is the base address of this, right, then I can divide', 'tokens': [50364, 286, 486, 611, 980, 291, 498, 286, 458, 437, 307, 264, 3096, 2985, 295, 341, 11, 558, 11, 550, 286, 393, 9845, 50694], 'temperature': 0.0, 'avg_logprob': -0.19136464290129832, 'compression_ratio': 1.7341772151898733, 'no_speech_prob': 0.07658789306879044}, {'id': 380, 'seek': 212848, 'start': 2135.08, 'end': 2143.64, 'text': ' this in terms of I think these ones and zeros have kind of gone here, right. So, okay. So,', 'tokens': [50694, 341, 294, 2115, 295, 286, 519, 613, 2306, 293, 35193, 362, 733, 295, 2780, 510, 11, 558, 13, 407, 11, 1392, 13, 407, 11, 51122], 'temperature': 0.0, 'avg_logprob': -0.19136464290129832, 'compression_ratio': 1.7341772151898733, 'no_speech_prob': 0.07658789306879044}, {'id': 381, 'seek': 212848, 'start': 2143.64, 'end': 2153.36, 'text': ' this is my offset bits. These are my set index bits, okay. These are my set index bits, okay.', 'tokens': [51122, 341, 307, 452, 18687, 9239, 13, 1981, 366, 452, 992, 8186, 9239, 11, 1392, 13, 1981, 366, 452, 992, 8186, 9239, 11, 1392, 13, 51608], 'temperature': 0.0, 'avg_logprob': -0.19136464290129832, 'compression_ratio': 1.7341772151898733, 'no_speech_prob': 0.07658789306879044}, {'id': 382, 'seek': 215336, 'start': 2153.84, 'end': 2160.2000000000003, 'text': ' So, let us first look at, okay. Now, as I mentioned earlier, let us assume that my', 'tokens': [50388, 407, 11, 718, 505, 700, 574, 412, 11, 1392, 13, 823, 11, 382, 286, 2835, 3071, 11, 718, 505, 6552, 300, 452, 50706], 'temperature': 0.0, 'avg_logprob': -0.13445826065845978, 'compression_ratio': 1.5497076023391814, 'no_speech_prob': 0.0067824325524270535}, {'id': 383, 'seek': 215336, 'start': 2160.2000000000003, 'end': 2167.8, 'text': ' cache block size is 32 bytes, right. That means that these 5 bits are going to be my index bits,', 'tokens': [50706, 19459, 3461, 2744, 307, 8858, 36088, 11, 558, 13, 663, 1355, 300, 613, 1025, 9239, 366, 516, 281, 312, 452, 8186, 9239, 11, 51086], 'temperature': 0.0, 'avg_logprob': -0.13445826065845978, 'compression_ratio': 1.5497076023391814, 'no_speech_prob': 0.0067824325524270535}, {'id': 384, 'seek': 215336, 'start': 2167.8, 'end': 2176.8, 'text': ' right and let us say how many bits, okay. So, I have 9 bits as my set index bits. So,', 'tokens': [51086, 558, 293, 718, 505, 584, 577, 867, 9239, 11, 1392, 13, 407, 11, 286, 362, 1722, 9239, 382, 452, 992, 8186, 9239, 13, 407, 11, 51536], 'temperature': 0.0, 'avg_logprob': -0.13445826065845978, 'compression_ratio': 1.5497076023391814, 'no_speech_prob': 0.0067824325524270535}, {'id': 385, 'seek': 217680, 'start': 2176.8, 'end': 2183.48, 'text': ' that means that this has 512 sets, right and if it is a 16 kilobyte cache, then it is basically', 'tokens': [50364, 300, 1355, 300, 341, 575, 1025, 4762, 6352, 11, 558, 293, 498, 309, 307, 257, 3165, 5128, 13944, 975, 19459, 11, 550, 309, 307, 1936, 50698], 'temperature': 0.0, 'avg_logprob': -0.12973341884383235, 'compression_ratio': 1.6363636363636365, 'no_speech_prob': 0.0033532711677253246}, {'id': 386, 'seek': 217680, 'start': 2183.48, 'end': 2188.96, 'text': ' a direct mapped cache. So, we are talking about a direct mapped cache of 16 kilobytes, right.', 'tokens': [50698, 257, 2047, 33318, 19459, 13, 407, 11, 321, 366, 1417, 466, 257, 2047, 33318, 19459, 295, 3165, 5128, 996, 43673, 11, 558, 13, 50972], 'temperature': 0.0, 'avg_logprob': -0.12973341884383235, 'compression_ratio': 1.6363636363636365, 'no_speech_prob': 0.0033532711677253246}, {'id': 387, 'seek': 217680, 'start': 2188.96, 'end': 2201.7200000000003, 'text': ' So, these are the 9 bits. If the address is this, then the first block A0, right, will be in cache', 'tokens': [50972, 407, 11, 613, 366, 264, 1722, 9239, 13, 759, 264, 2985, 307, 341, 11, 550, 264, 700, 3461, 316, 15, 11, 558, 11, 486, 312, 294, 19459, 51610], 'temperature': 0.0, 'avg_logprob': -0.12973341884383235, 'compression_ratio': 1.6363636363636365, 'no_speech_prob': 0.0033532711677253246}, {'id': 388, 'seek': 220172, 'start': 2201.72, 'end': 2210.48, 'text': ' block 256. That is really what it says. If you look at this value 100000, right, that is essentially', 'tokens': [50364, 3461, 38882, 13, 663, 307, 534, 437, 309, 1619, 13, 759, 291, 574, 412, 341, 2158, 2319, 1360, 11, 558, 11, 300, 307, 4476, 50802], 'temperature': 0.0, 'avg_logprob': -0.14319235239273462, 'compression_ratio': 1.574468085106383, 'no_speech_prob': 0.04524380341172218}, {'id': 389, 'seek': 220172, 'start': 2210.48, 'end': 2221.08, 'text': ' cache block 256, okay. Now, in each element, sorry, each block of the cache contains 32 bytes. How', 'tokens': [50802, 19459, 3461, 38882, 11, 1392, 13, 823, 11, 294, 1184, 4478, 11, 2597, 11, 1184, 3461, 295, 264, 19459, 8306, 8858, 36088, 13, 1012, 51332], 'temperature': 0.0, 'avg_logprob': -0.14319235239273462, 'compression_ratio': 1.574468085106383, 'no_speech_prob': 0.04524380341172218}, {'id': 390, 'seek': 220172, 'start': 2221.08, 'end': 2229.2, 'text': ' many elements are these? Each element is 8 bytes long, right. That means 4 elements will be in 1', 'tokens': [51332, 867, 4959, 366, 613, 30, 6947, 4478, 307, 1649, 36088, 938, 11, 558, 13, 663, 1355, 1017, 4959, 486, 312, 294, 502, 51738], 'temperature': 0.0, 'avg_logprob': -0.14319235239273462, 'compression_ratio': 1.574468085106383, 'no_speech_prob': 0.04524380341172218}, {'id': 391, 'seek': 222920, 'start': 2229.2, 'end': 2238.7999999999997, 'text': ' cache block. So, let us look at this diagram, right. If A0 is in cache block 256, then obviously', 'tokens': [50364, 19459, 3461, 13, 407, 11, 718, 505, 574, 412, 341, 10686, 11, 558, 13, 759, 316, 15, 307, 294, 19459, 3461, 38882, 11, 550, 2745, 50844], 'temperature': 0.0, 'avg_logprob': -0.10360177618558289, 'compression_ratio': 1.4598540145985401, 'no_speech_prob': 0.3361184597015381}, {'id': 392, 'seek': 222920, 'start': 2238.7999999999997, 'end': 2246.04, 'text': ' A1 will also be there, A2 will also be there, A3 will also be there. What about A4? That will be mapped', 'tokens': [50844, 316, 16, 486, 611, 312, 456, 11, 316, 17, 486, 611, 312, 456, 11, 316, 18, 486, 611, 312, 456, 13, 708, 466, 316, 19, 30, 663, 486, 312, 33318, 51206], 'temperature': 0.0, 'avg_logprob': -0.10360177618558289, 'compression_ratio': 1.4598540145985401, 'no_speech_prob': 0.3361184597015381}, {'id': 393, 'seek': 224604, 'start': 2246.04, 'end': 2257.04, 'text': ' to cache block 257, right. A8 will be 258 and so on, okay, right. Now, suddenly in between I have,', 'tokens': [50364, 281, 19459, 3461, 3552, 22, 11, 558, 13, 316, 23, 486, 312, 3552, 23, 293, 370, 322, 11, 1392, 11, 558, 13, 823, 11, 5800, 294, 1296, 286, 362, 11, 50914], 'temperature': 0.0, 'avg_logprob': -0.10565741856892903, 'compression_ratio': 1.5737704918032787, 'no_speech_prob': 0.07134665548801422}, {'id': 394, 'seek': 224604, 'start': 2257.04, 'end': 2267.24, 'text': ' okay. So, remember this has 512 blocks, right. Now, when I access A0, since I am accessing it', 'tokens': [50914, 1392, 13, 407, 11, 1604, 341, 575, 1025, 4762, 8474, 11, 558, 13, 823, 11, 562, 286, 2105, 316, 15, 11, 1670, 286, 669, 26440, 309, 51424], 'temperature': 0.0, 'avg_logprob': -0.10565741856892903, 'compression_ratio': 1.5737704918032787, 'no_speech_prob': 0.07134665548801422}, {'id': 395, 'seek': 224604, 'start': 2267.24, 'end': 2273.64, 'text': ' for the first time, right, the data is not going to be available. So, it is going to be a miss.', 'tokens': [51424, 337, 264, 700, 565, 11, 558, 11, 264, 1412, 307, 406, 516, 281, 312, 2435, 13, 407, 11, 309, 307, 516, 281, 312, 257, 1713, 13, 51744], 'temperature': 0.0, 'avg_logprob': -0.10565741856892903, 'compression_ratio': 1.5737704918032787, 'no_speech_prob': 0.07134665548801422}, {'id': 396, 'seek': 227364, 'start': 2273.64, 'end': 2282.7999999999997, 'text': ' Whereas, when I access A1, A2 and A3 subsequently, right, because A0 was brought in, this entire block', 'tokens': [50364, 13813, 11, 562, 286, 2105, 316, 16, 11, 316, 17, 293, 316, 18, 26514, 11, 558, 11, 570, 316, 15, 390, 3038, 294, 11, 341, 2302, 3461, 50822], 'temperature': 0.0, 'avg_logprob': -0.08418645404634022, 'compression_ratio': 1.7454545454545454, 'no_speech_prob': 0.03336300700902939}, {'id': 397, 'seek': 227364, 'start': 2282.7999999999997, 'end': 2289.7999999999997, 'text': ' was brought in, all of them are going to be hits. Similarly, when I access A4, it is being brought', 'tokens': [50822, 390, 3038, 294, 11, 439, 295, 552, 366, 516, 281, 312, 8664, 13, 13157, 11, 562, 286, 2105, 316, 19, 11, 309, 307, 885, 3038, 51172], 'temperature': 0.0, 'avg_logprob': -0.08418645404634022, 'compression_ratio': 1.7454545454545454, 'no_speech_prob': 0.03336300700902939}, {'id': 398, 'seek': 227364, 'start': 2289.7999999999997, 'end': 2295.92, 'text': ' in for the first time. Therefore, it is a miss and all subsequent accesses will be hits. So,', 'tokens': [51172, 294, 337, 264, 700, 565, 13, 7504, 11, 309, 307, 257, 1713, 293, 439, 19962, 2105, 279, 486, 312, 8664, 13, 407, 11, 51478], 'temperature': 0.0, 'avg_logprob': -0.08418645404634022, 'compression_ratio': 1.7454545454545454, 'no_speech_prob': 0.03336300700902939}, {'id': 399, 'seek': 227364, 'start': 2295.92, 'end': 2301.96, 'text': ' you can see that the first miss that happens is what we call as the cold miss or the cold', 'tokens': [51478, 291, 393, 536, 300, 264, 700, 1713, 300, 2314, 307, 437, 321, 818, 382, 264, 3554, 1713, 420, 264, 3554, 51780], 'temperature': 0.0, 'avg_logprob': -0.08418645404634022, 'compression_ratio': 1.7454545454545454, 'no_speech_prob': 0.03336300700902939}, {'id': 400, 'seek': 230196, 'start': 2301.96, 'end': 2310.32, 'text': ' compulsory miss, right. All other things are hit, right. Now, if I start from 256 and if there are', 'tokens': [50364, 42773, 827, 1713, 11, 558, 13, 1057, 661, 721, 366, 2045, 11, 558, 13, 823, 11, 498, 286, 722, 490, 38882, 293, 498, 456, 366, 50782], 'temperature': 0.0, 'avg_logprob': -0.13417049971493808, 'compression_ratio': 1.46, 'no_speech_prob': 0.03087262436747551}, {'id': 401, 'seek': 230196, 'start': 2310.32, 'end': 2321.2, 'text': ' 512 blocks, I should have gone up to 511, correct. But then I end up with 255. Why? After 511,', 'tokens': [50782, 1025, 4762, 8474, 11, 286, 820, 362, 2780, 493, 281, 1025, 5348, 11, 3006, 13, 583, 550, 286, 917, 493, 365, 3552, 20, 13, 1545, 30, 2381, 1025, 5348, 11, 51326], 'temperature': 0.0, 'avg_logprob': -0.13417049971493808, 'compression_ratio': 1.46, 'no_speech_prob': 0.03087262436747551}, {'id': 402, 'seek': 230196, 'start': 2321.2, 'end': 2328.48, 'text': ' where would the next block be? 0, correct. See, remember this is a cache, this is an array of size', 'tokens': [51326, 689, 576, 264, 958, 3461, 312, 30, 1958, 11, 3006, 13, 3008, 11, 1604, 341, 307, 257, 19459, 11, 341, 307, 364, 10225, 295, 2744, 51690], 'temperature': 0.0, 'avg_logprob': -0.13417049971493808, 'compression_ratio': 1.46, 'no_speech_prob': 0.03087262436747551}, {'id': 403, 'seek': 232848, 'start': 2328.48, 'end': 2337.76, 'text': ' 2K elements, right, 2K elements each of 8 bytes, correct. So, 1K elements would be how many bytes?', 'tokens': [50364, 568, 42, 4959, 11, 558, 11, 568, 42, 4959, 1184, 295, 1649, 36088, 11, 3006, 13, 407, 11, 502, 42, 4959, 576, 312, 577, 867, 36088, 30, 50828], 'temperature': 0.0, 'avg_logprob': -0.13021113363544592, 'compression_ratio': 1.6353591160220995, 'no_speech_prob': 0.2992269694805145}, {'id': 404, 'seek': 232848, 'start': 2337.76, 'end': 2346.4, 'text': ' 8K bytes, right. So, 8K bytes is starting from 256 all the way up to 512 and the next 8K elements', 'tokens': [50828, 1649, 42, 36088, 11, 558, 13, 407, 11, 1649, 42, 36088, 307, 2891, 490, 38882, 439, 264, 636, 493, 281, 1025, 4762, 293, 264, 958, 1649, 42, 4959, 51260], 'temperature': 0.0, 'avg_logprob': -0.13021113363544592, 'compression_ratio': 1.6353591160220995, 'no_speech_prob': 0.2992269694805145}, {'id': 405, 'seek': 232848, 'start': 2346.4, 'end': 2354.92, 'text': ' will be from 0 to 255. So, that is really what is happening here, ok. So, somewhere in between when', 'tokens': [51260, 486, 312, 490, 1958, 281, 3552, 20, 13, 407, 11, 300, 307, 534, 437, 307, 2737, 510, 11, 3133, 13, 407, 11, 4079, 294, 1296, 562, 51686], 'temperature': 0.0, 'avg_logprob': -0.13021113363544592, 'compression_ratio': 1.6353591160220995, 'no_speech_prob': 0.2992269694805145}, {'id': 406, 'seek': 235492, 'start': 2354.92, 'end': 2364.2400000000002, 'text': ' you talk about A of 1025 that will be or A of 1024 that will be in cache block 0, A of 1028 will', 'tokens': [50364, 291, 751, 466, 316, 295, 1266, 6074, 300, 486, 312, 420, 316, 295, 1266, 7911, 300, 486, 312, 294, 19459, 3461, 1958, 11, 316, 295, 1266, 11205, 486, 50830], 'temperature': 0.0, 'avg_logprob': -0.09854048147968862, 'compression_ratio': 1.7337278106508875, 'no_speech_prob': 0.07318267971277237}, {'id': 407, 'seek': 235492, 'start': 2364.2400000000002, 'end': 2371.16, 'text': ' be in cache block 1 and so on and A of 244 is in cache block 255, ok. In this particular case,', 'tokens': [50830, 312, 294, 19459, 3461, 502, 293, 370, 322, 293, 316, 295, 4022, 19, 307, 294, 19459, 3461, 3552, 20, 11, 3133, 13, 682, 341, 1729, 1389, 11, 51176], 'temperature': 0.0, 'avg_logprob': -0.09854048147968862, 'compression_ratio': 1.7337278106508875, 'no_speech_prob': 0.07318267971277237}, {'id': 408, 'seek': 235492, 'start': 2371.16, 'end': 2379.08, 'text': ' the array size is same as your cache block size, correct. So, if you want to access the entire array,', 'tokens': [51176, 264, 10225, 2744, 307, 912, 382, 428, 19459, 3461, 2744, 11, 3006, 13, 407, 11, 498, 291, 528, 281, 2105, 264, 2302, 10225, 11, 51572], 'temperature': 0.0, 'avg_logprob': -0.09854048147968862, 'compression_ratio': 1.7337278106508875, 'no_speech_prob': 0.07318267971277237}, {'id': 409, 'seek': 237908, 'start': 2379.24, 'end': 2385.44, 'text': ' you can actually fit it in your cache and as you access all the elements, the entire array is being', 'tokens': [50372, 291, 393, 767, 3318, 309, 294, 428, 19459, 293, 382, 291, 2105, 439, 264, 4959, 11, 264, 2302, 10225, 307, 885, 50682], 'temperature': 0.0, 'avg_logprob': -0.13755270957946777, 'compression_ratio': 1.6751054852320675, 'no_speech_prob': 0.05651212856173515}, {'id': 410, 'seek': 237908, 'start': 2385.44, 'end': 2391.72, 'text': ' brought into your cache, ok. So, in this particular case, what is going to happen? Your first access', 'tokens': [50682, 3038, 666, 428, 19459, 11, 3133, 13, 407, 11, 294, 341, 1729, 1389, 11, 437, 307, 516, 281, 1051, 30, 2260, 700, 2105, 50996], 'temperature': 0.0, 'avg_logprob': -0.13755270957946777, 'compression_ratio': 1.6751054852320675, 'no_speech_prob': 0.05651212856173515}, {'id': 411, 'seek': 237908, 'start': 2391.72, 'end': 2399.52, 'text': ' is a miss and subsequent accesses would be shits. So, for every four accesses, you have one miss.', 'tokens': [50996, 307, 257, 1713, 293, 19962, 2105, 279, 576, 312, 402, 1208, 13, 407, 11, 337, 633, 1451, 2105, 279, 11, 291, 362, 472, 1713, 13, 51386], 'temperature': 0.0, 'avg_logprob': -0.13755270957946777, 'compression_ratio': 1.6751054852320675, 'no_speech_prob': 0.05651212856173515}, {'id': 412, 'seek': 237908, 'start': 2399.52, 'end': 2406.3199999999997, 'text': ' Now, supposing let us say you try to access this array repeatedly 10 times, then what would happen', 'tokens': [51386, 823, 11, 1003, 6110, 718, 505, 584, 291, 853, 281, 2105, 341, 10225, 18227, 1266, 1413, 11, 550, 437, 576, 1051, 51726], 'temperature': 0.0, 'avg_logprob': -0.13755270957946777, 'compression_ratio': 1.6751054852320675, 'no_speech_prob': 0.05651212856173515}, {'id': 413, 'seek': 240632, 'start': 2406.32, 'end': 2414.2000000000003, 'text': ' the subsequent accesses? All will be hits because after the first access, this value is going to', 'tokens': [50364, 264, 19962, 2105, 279, 30, 1057, 486, 312, 8664, 570, 934, 264, 700, 2105, 11, 341, 2158, 307, 516, 281, 50758], 'temperature': 0.0, 'avg_logprob': -0.1287020444869995, 'compression_ratio': 1.471794871794872, 'no_speech_prob': 0.053597792983055115}, {'id': 414, 'seek': 240632, 'start': 2414.2000000000003, 'end': 2420.32, 'text': ' be there, this cold miss will disappear and all the data elements are available, right. So,', 'tokens': [50758, 312, 456, 11, 341, 3554, 1713, 486, 11596, 293, 439, 264, 1412, 4959, 366, 2435, 11, 558, 13, 407, 11, 51064], 'temperature': 0.0, 'avg_logprob': -0.1287020444869995, 'compression_ratio': 1.471794871794872, 'no_speech_prob': 0.053597792983055115}, {'id': 415, 'seek': 240632, 'start': 2420.32, 'end': 2430.84, 'text': ' if you try to do this access 10 times, then you have exactly 2048 divided by 4 which is 512 misses', 'tokens': [51064, 498, 291, 853, 281, 360, 341, 2105, 1266, 1413, 11, 550, 291, 362, 2293, 945, 13318, 6666, 538, 1017, 597, 307, 1025, 4762, 29394, 51590], 'temperature': 0.0, 'avg_logprob': -0.1287020444869995, 'compression_ratio': 1.471794871794872, 'no_speech_prob': 0.053597792983055115}, {'id': 416, 'seek': 243084, 'start': 2430.84, 'end': 2440.92, 'text': ' and then 2048 divided by multiplied by 10 that many accesses. So, 512 divided by 2480, 20,480,', 'tokens': [50364, 293, 550, 945, 13318, 6666, 538, 17207, 538, 1266, 300, 867, 2105, 279, 13, 407, 11, 1025, 4762, 6666, 538, 4022, 4702, 11, 945, 11, 19, 4702, 11, 50868], 'temperature': 0.0, 'avg_logprob': -0.2195893221123274, 'compression_ratio': 1.5235602094240839, 'no_speech_prob': 0.1564447581768036}, {'id': 417, 'seek': 243084, 'start': 2440.92, 'end': 2449.1200000000003, 'text': ' that is your miss ratio so to say, correct, ok. Good, again this is going into all of these details.', 'tokens': [50868, 300, 307, 428, 1713, 8509, 370, 281, 584, 11, 3006, 11, 3133, 13, 2205, 11, 797, 341, 307, 516, 666, 439, 295, 613, 4365, 13, 51278], 'temperature': 0.0, 'avg_logprob': -0.2195893221123274, 'compression_ratio': 1.5235602094240839, 'no_speech_prob': 0.1564447581768036}, {'id': 418, 'seek': 243084, 'start': 2449.1200000000003, 'end': 2454.76, 'text': ' So, you can just look at it say that for every four accesses, there is one miss. So, that means', 'tokens': [51278, 407, 11, 291, 393, 445, 574, 412, 309, 584, 300, 337, 633, 1451, 2105, 279, 11, 456, 307, 472, 1713, 13, 407, 11, 300, 1355, 51560], 'temperature': 0.0, 'avg_logprob': -0.2195893221123274, 'compression_ratio': 1.5235602094240839, 'no_speech_prob': 0.1564447581768036}, {'id': 419, 'seek': 245476, 'start': 2455.0, 'end': 2463.32, 'text': ' there is a 25 percent miss and 75 percent hit, ok. And essentially whatever that we are getting is', 'tokens': [50376, 456, 307, 257, 3552, 3043, 1713, 293, 9562, 3043, 2045, 11, 3133, 13, 400, 4476, 2035, 300, 321, 366, 1242, 307, 50792], 'temperature': 0.0, 'avg_logprob': -0.21061730702718098, 'compression_ratio': 1.5212765957446808, 'no_speech_prob': 0.13972795009613037}, {'id': 420, 'seek': 245476, 'start': 2463.32, 'end': 2468.84, 'text': ' because of spatial locality, data is available. If you iterate it 10 times, then you also get', 'tokens': [50792, 570, 295, 23598, 1628, 1860, 11, 1412, 307, 2435, 13, 759, 291, 44497, 309, 1266, 1413, 11, 550, 291, 611, 483, 51068], 'temperature': 0.0, 'avg_logprob': -0.21061730702718098, 'compression_ratio': 1.5212765957446808, 'no_speech_prob': 0.13972795009613037}, {'id': 421, 'seek': 245476, 'start': 2468.84, 'end': 2477.28, 'text': ' benefit because of temporal locality, ok. Now, instead of 10, 2048, if let us say if you have', 'tokens': [51068, 5121, 570, 295, 30881, 1628, 1860, 11, 3133, 13, 823, 11, 2602, 295, 1266, 11, 945, 13318, 11, 498, 718, 505, 584, 498, 291, 362, 51490], 'temperature': 0.0, 'avg_logprob': -0.21061730702718098, 'compression_ratio': 1.5212765957446808, 'no_speech_prob': 0.13972795009613037}, {'id': 422, 'seek': 247728, 'start': 2477.28, 'end': 2487.0800000000004, 'text': ' 4096 elements, then what happens, right. Then also if you go through this array once, ok. So,', 'tokens': [50364, 3356, 22962, 4959, 11, 550, 437, 2314, 11, 558, 13, 1396, 611, 498, 291, 352, 807, 341, 10225, 1564, 11, 3133, 13, 407, 11, 50854], 'temperature': 0.0, 'avg_logprob': -0.19303603111943113, 'compression_ratio': 1.64, 'no_speech_prob': 0.1117984876036644}, {'id': 423, 'seek': 247728, 'start': 2487.0800000000004, 'end': 2496.5600000000004, 'text': ' that just yeah. So, this is example one with this much, ok. Now, the first time that you go through,', 'tokens': [50854, 300, 445, 1338, 13, 407, 11, 341, 307, 1365, 472, 365, 341, 709, 11, 3133, 13, 823, 11, 264, 700, 565, 300, 291, 352, 807, 11, 51328], 'temperature': 0.0, 'avg_logprob': -0.19303603111943113, 'compression_ratio': 1.64, 'no_speech_prob': 0.1117984876036644}, {'id': 424, 'seek': 247728, 'start': 2496.5600000000004, 'end': 2502.32, 'text': ' you have all compulsory misses, but if you go through it 10 times, then what happens is that', 'tokens': [51328, 291, 362, 439, 42773, 827, 29394, 11, 457, 498, 291, 352, 807, 309, 1266, 1413, 11, 550, 437, 2314, 307, 300, 51616], 'temperature': 0.0, 'avg_logprob': -0.19303603111943113, 'compression_ratio': 1.64, 'no_speech_prob': 0.1117984876036644}, {'id': 425, 'seek': 250232, 'start': 2502.56, 'end': 2508.04, 'text': ' you remember that you can only hold 2048 elements in your cache because it is a 16 kilobyte cache.', 'tokens': [50376, 291, 1604, 300, 291, 393, 787, 1797, 945, 13318, 4959, 294, 428, 19459, 570, 309, 307, 257, 3165, 5128, 13944, 975, 19459, 13, 50650], 'temperature': 0.0, 'avg_logprob': -0.1487873077392578, 'compression_ratio': 1.7969924812030076, 'no_speech_prob': 0.15609727799892426}, {'id': 426, 'seek': 250232, 'start': 2508.04, 'end': 2514.56, 'text': ' If you have 4K elements in your cache, then after you go to the 2049th element, it will actually', 'tokens': [50650, 759, 291, 362, 1017, 42, 4959, 294, 428, 19459, 11, 550, 934, 291, 352, 281, 264, 945, 14938, 392, 4478, 11, 309, 486, 767, 50976], 'temperature': 0.0, 'avg_logprob': -0.1487873077392578, 'compression_ratio': 1.7969924812030076, 'no_speech_prob': 0.15609727799892426}, {'id': 427, 'seek': 250232, 'start': 2514.56, 'end': 2520.4, 'text': ' rewrite the existing elements. Then if you try to iterate, then the second time when you come,', 'tokens': [50976, 28132, 264, 6741, 4959, 13, 1396, 498, 291, 853, 281, 44497, 11, 550, 264, 1150, 565, 562, 291, 808, 11, 51268], 'temperature': 0.0, 'avg_logprob': -0.1487873077392578, 'compression_ratio': 1.7969924812030076, 'no_speech_prob': 0.15609727799892426}, {'id': 428, 'seek': 250232, 'start': 2520.4, 'end': 2526.04, 'text': ' you again you are not going to see your elements in the cache. So, those misses that happen are', 'tokens': [51268, 291, 797, 291, 366, 406, 516, 281, 536, 428, 4959, 294, 264, 19459, 13, 407, 11, 729, 29394, 300, 1051, 366, 51550], 'temperature': 0.0, 'avg_logprob': -0.1487873077392578, 'compression_ratio': 1.7969924812030076, 'no_speech_prob': 0.15609727799892426}, {'id': 429, 'seek': 250232, 'start': 2526.04, 'end': 2531.28, 'text': ' what are going to be called as capacity misses, ok. That is really what this is explaining.', 'tokens': [51550, 437, 366, 516, 281, 312, 1219, 382, 6042, 29394, 11, 3133, 13, 663, 307, 534, 437, 341, 307, 13468, 13, 51812], 'temperature': 0.0, 'avg_logprob': -0.1487873077392578, 'compression_ratio': 1.7969924812030076, 'no_speech_prob': 0.15609727799892426}, {'id': 430, 'seek': 253128, 'start': 2531.28, 'end': 2539.5600000000004, 'text': ' Let us look at another example where you have two arrays, each one of them is 2048, right. So,', 'tokens': [50364, 961, 505, 574, 412, 1071, 1365, 689, 291, 362, 732, 41011, 11, 1184, 472, 295, 552, 307, 945, 13318, 11, 558, 13, 407, 11, 50778], 'temperature': 0.0, 'avg_logprob': -0.12308182166172908, 'compression_ratio': 1.6515837104072397, 'no_speech_prob': 0.007837207056581974}, {'id': 431, 'seek': 253128, 'start': 2539.5600000000004, 'end': 2544.2400000000002, 'text': ' in this particular case, the order in which you are going to do the accesses is that you', 'tokens': [50778, 294, 341, 1729, 1389, 11, 264, 1668, 294, 597, 291, 366, 516, 281, 360, 264, 2105, 279, 307, 300, 291, 51012], 'temperature': 0.0, 'avg_logprob': -0.12308182166172908, 'compression_ratio': 1.6515837104072397, 'no_speech_prob': 0.007837207056581974}, {'id': 432, 'seek': 253128, 'start': 2544.2400000000002, 'end': 2552.32, 'text': ' are going to access A of 0 followed by B of 0, A of 1 followed by B of 1 and so on, right.', 'tokens': [51012, 366, 516, 281, 2105, 316, 295, 1958, 6263, 538, 363, 295, 1958, 11, 316, 295, 502, 6263, 538, 363, 295, 502, 293, 370, 322, 11, 558, 13, 51416], 'temperature': 0.0, 'avg_logprob': -0.12308182166172908, 'compression_ratio': 1.6515837104072397, 'no_speech_prob': 0.007837207056581974}, {'id': 433, 'seek': 253128, 'start': 2552.32, 'end': 2558.88, 'text': ' Now, I will skip the details of, ok. I will actually do this part, but then skip the other', 'tokens': [51416, 823, 11, 286, 486, 10023, 264, 4365, 295, 11, 3133, 13, 286, 486, 767, 360, 341, 644, 11, 457, 550, 10023, 264, 661, 51744], 'temperature': 0.0, 'avg_logprob': -0.12308182166172908, 'compression_ratio': 1.6515837104072397, 'no_speech_prob': 0.007837207056581974}, {'id': 434, 'seek': 255888, 'start': 2558.88, 'end': 2564.7200000000003, 'text': ' details. Supposing let us say array A is in this location and array B is in this location,', 'tokens': [50364, 4365, 13, 9391, 6110, 718, 505, 584, 10225, 316, 307, 294, 341, 4914, 293, 10225, 363, 307, 294, 341, 4914, 11, 50656], 'temperature': 0.0, 'avg_logprob': -0.15147081235559975, 'compression_ratio': 1.6022727272727273, 'no_speech_prob': 0.029762452468276024}, {'id': 435, 'seek': 255888, 'start': 2564.7200000000003, 'end': 2575.0, 'text': ' right, exactly offset by 2K into 8, ok. Now, you can see that the first address is this and the', 'tokens': [50656, 558, 11, 2293, 18687, 538, 568, 42, 666, 1649, 11, 3133, 13, 823, 11, 291, 393, 536, 300, 264, 700, 2985, 307, 341, 293, 264, 51170], 'temperature': 0.0, 'avg_logprob': -0.15147081235559975, 'compression_ratio': 1.6022727272727273, 'no_speech_prob': 0.029762452468276024}, {'id': 436, 'seek': 255888, 'start': 2575.0, 'end': 2586.4, 'text': ' second address is that, right. Now, what do you see? That both A and B or A of 0 and B of 0 are', 'tokens': [51170, 1150, 2985, 307, 300, 11, 558, 13, 823, 11, 437, 360, 291, 536, 30, 663, 1293, 316, 293, 363, 420, 316, 295, 1958, 293, 363, 295, 1958, 366, 51740], 'temperature': 0.0, 'avg_logprob': -0.15147081235559975, 'compression_ratio': 1.6022727272727273, 'no_speech_prob': 0.029762452468276024}, {'id': 437, 'seek': 258640, 'start': 2586.4, 'end': 2593.48, 'text': ' mapped to the same cache block, right. When both A of 0 and B of 0 are mapped to the same', 'tokens': [50364, 33318, 281, 264, 912, 19459, 3461, 11, 558, 13, 1133, 1293, 316, 295, 1958, 293, 363, 295, 1958, 366, 33318, 281, 264, 912, 50718], 'temperature': 0.0, 'avg_logprob': -0.1083319346110026, 'compression_ratio': 1.95, 'no_speech_prob': 0.034172508865594864}, {'id': 438, 'seek': 258640, 'start': 2593.48, 'end': 2597.96, 'text': ' cache block, let us see now what happens when I try to do the sequence of accesses.', 'tokens': [50718, 19459, 3461, 11, 718, 505, 536, 586, 437, 2314, 562, 286, 853, 281, 360, 264, 8310, 295, 2105, 279, 13, 50942], 'temperature': 0.0, 'avg_logprob': -0.1083319346110026, 'compression_ratio': 1.95, 'no_speech_prob': 0.034172508865594864}, {'id': 439, 'seek': 258640, 'start': 2597.96, 'end': 2603.88, 'text': ' When I try to do the sequence of accesses, A of 0 will give me first a miss, cold miss,', 'tokens': [50942, 1133, 286, 853, 281, 360, 264, 8310, 295, 2105, 279, 11, 316, 295, 1958, 486, 976, 385, 700, 257, 1713, 11, 3554, 1713, 11, 51238], 'temperature': 0.0, 'avg_logprob': -0.1083319346110026, 'compression_ratio': 1.95, 'no_speech_prob': 0.034172508865594864}, {'id': 440, 'seek': 258640, 'start': 2603.88, 'end': 2612.48, 'text': ' that is ok. B of 0 will give me a cold miss, that is also ok. Then what about A of 1? So,', 'tokens': [51238, 300, 307, 3133, 13, 363, 295, 1958, 486, 976, 385, 257, 3554, 1713, 11, 300, 307, 611, 3133, 13, 1396, 437, 466, 316, 295, 502, 30, 407, 11, 51668], 'temperature': 0.0, 'avg_logprob': -0.1083319346110026, 'compression_ratio': 1.95, 'no_speech_prob': 0.034172508865594864}, {'id': 441, 'seek': 261248, 'start': 2613.44, 'end': 2622.0, 'text': ' this is 256. Both A of 0 and B of 0 are mapped to the same cache block, 256, correct. Now,', 'tokens': [50412, 341, 307, 38882, 13, 6767, 316, 295, 1958, 293, 363, 295, 1958, 366, 33318, 281, 264, 912, 19459, 3461, 11, 38882, 11, 3006, 13, 823, 11, 50840], 'temperature': 0.0, 'avg_logprob': -0.1458856008386099, 'compression_ratio': 1.6149425287356323, 'no_speech_prob': 0.036362841725349426}, {'id': 442, 'seek': 261248, 'start': 2622.0, 'end': 2630.76, 'text': ' we have accessed A of 0 which was a miss. So, A 0, A 1, A 2, A 3 were brought to cache block 0,', 'tokens': [50840, 321, 362, 34211, 316, 295, 1958, 597, 390, 257, 1713, 13, 407, 11, 316, 1958, 11, 316, 502, 11, 316, 568, 11, 316, 805, 645, 3038, 281, 19459, 3461, 1958, 11, 51278], 'temperature': 0.0, 'avg_logprob': -0.1458856008386099, 'compression_ratio': 1.6149425287356323, 'no_speech_prob': 0.036362841725349426}, {'id': 443, 'seek': 261248, 'start': 2630.76, 'end': 2640.84, 'text': ' correct. After that we access B of 0. That means that B 0, B 1, B 2, B 3 were brought into the', 'tokens': [51278, 3006, 13, 2381, 300, 321, 2105, 363, 295, 1958, 13, 663, 1355, 300, 363, 1958, 11, 363, 502, 11, 363, 568, 11, 363, 805, 645, 3038, 666, 264, 51782], 'temperature': 0.0, 'avg_logprob': -0.1458856008386099, 'compression_ratio': 1.6149425287356323, 'no_speech_prob': 0.036362841725349426}, {'id': 444, 'seek': 264084, 'start': 2640.84, 'end': 2647.92, 'text': ' cache block. But where in the cache block? Same cache block 0, which means your A was replaced,', 'tokens': [50364, 19459, 3461, 13, 583, 689, 294, 264, 19459, 3461, 30, 10635, 19459, 3461, 1958, 11, 597, 1355, 428, 316, 390, 10772, 11, 50718], 'temperature': 0.0, 'avg_logprob': -0.14778020222981772, 'compression_ratio': 1.5828877005347595, 'no_speech_prob': 0.13483506441116333}, {'id': 445, 'seek': 264084, 'start': 2647.92, 'end': 2656.8, 'text': ' right. Then when you try to access again A of 1, that data will not be there. You will have a miss.', 'tokens': [50718, 558, 13, 1396, 562, 291, 853, 281, 2105, 797, 316, 295, 502, 11, 300, 1412, 486, 406, 312, 456, 13, 509, 486, 362, 257, 1713, 13, 51162], 'temperature': 0.0, 'avg_logprob': -0.14778020222981772, 'compression_ratio': 1.5828877005347595, 'no_speech_prob': 0.13483506441116333}, {'id': 446, 'seek': 264084, 'start': 2656.8, 'end': 2664.1600000000003, 'text': ' This miss is a conflict, right, because this data was replaced because of something else was mapping', 'tokens': [51162, 639, 1713, 307, 257, 6596, 11, 558, 11, 570, 341, 1412, 390, 10772, 570, 295, 746, 1646, 390, 18350, 51530], 'temperature': 0.0, 'avg_logprob': -0.14778020222981772, 'compression_ratio': 1.5828877005347595, 'no_speech_prob': 0.13483506441116333}, {'id': 447, 'seek': 266416, 'start': 2664.16, 'end': 2671.52, 'text': ' to the same cache location, right. So, if you look at this accesses, then you can see that after', 'tokens': [50364, 281, 264, 912, 19459, 4914, 11, 558, 13, 407, 11, 498, 291, 574, 412, 341, 2105, 279, 11, 550, 291, 393, 536, 300, 934, 50732], 'temperature': 0.0, 'avg_logprob': -0.14623163101520945, 'compression_ratio': 1.7839506172839505, 'no_speech_prob': 0.13118061423301697}, {'id': 448, 'seek': 266416, 'start': 2671.52, 'end': 2678.92, 'text': ' the first two misses of A of 0 and B of 0, A of 1, B of 1, A of 2, B of 2, blah, blah, blah, blah,', 'tokens': [50732, 264, 700, 732, 29394, 295, 316, 295, 1958, 293, 363, 295, 1958, 11, 316, 295, 502, 11, 363, 295, 502, 11, 316, 295, 568, 11, 363, 295, 568, 11, 12288, 11, 12288, 11, 12288, 11, 12288, 11, 51102], 'temperature': 0.0, 'avg_logprob': -0.14623163101520945, 'compression_ratio': 1.7839506172839505, 'no_speech_prob': 0.13118061423301697}, {'id': 449, 'seek': 266416, 'start': 2678.92, 'end': 2688.52, 'text': ' blah, blah, everything is a miss, right. So, in this case having the cache is no good, right.', 'tokens': [51102, 12288, 11, 12288, 11, 1203, 307, 257, 1713, 11, 558, 13, 407, 11, 294, 341, 1389, 1419, 264, 19459, 307, 572, 665, 11, 558, 13, 51582], 'temperature': 0.0, 'avg_logprob': -0.14623163101520945, 'compression_ratio': 1.7839506172839505, 'no_speech_prob': 0.13118061423301697}, {'id': 450, 'seek': 268852, 'start': 2688.52, 'end': 2699.84, 'text': ' You have a hit ratio of 0. What can you do to improve this situation? Separate cache for A and B.', 'tokens': [50364, 509, 362, 257, 2045, 8509, 295, 1958, 13, 708, 393, 291, 360, 281, 3470, 341, 2590, 30, 43480, 473, 19459, 337, 316, 293, 363, 13, 50930], 'temperature': 0.0, 'avg_logprob': -0.214289837413364, 'compression_ratio': 1.5243243243243243, 'no_speech_prob': 0.15877361595630646}, {'id': 451, 'seek': 268852, 'start': 2699.84, 'end': 2708.44, 'text': ' Who said that? Okay. Yeah, unfortunately we cannot change the processor, right or we cannot', 'tokens': [50930, 2102, 848, 300, 30, 1033, 13, 865, 11, 7015, 321, 2644, 1319, 264, 15321, 11, 558, 420, 321, 2644, 51360], 'temperature': 0.0, 'avg_logprob': -0.214289837413364, 'compression_ratio': 1.5243243243243243, 'no_speech_prob': 0.15877361595630646}, {'id': 452, 'seek': 268852, 'start': 2708.44, 'end': 2717.88, 'text': ' change what is inside the processor. This is a very, very simple problem. Let us assume that', 'tokens': [51360, 1319, 437, 307, 1854, 264, 15321, 13, 639, 307, 257, 588, 11, 588, 2199, 1154, 13, 961, 505, 6552, 300, 51832], 'temperature': 0.0, 'avg_logprob': -0.214289837413364, 'compression_ratio': 1.5243243243243243, 'no_speech_prob': 0.15877361595630646}, {'id': 453, 'seek': 271788, 'start': 2717.88, 'end': 2723.52, 'text': ' we are going to do this loop only once and I at least want to get that 75 percent, right,', 'tokens': [50364, 321, 366, 516, 281, 360, 341, 6367, 787, 1564, 293, 286, 412, 1935, 528, 281, 483, 300, 9562, 3043, 11, 558, 11, 50646], 'temperature': 0.0, 'avg_logprob': -0.12782011946586713, 'compression_ratio': 1.5519125683060109, 'no_speech_prob': 0.002485280390828848}, {'id': 454, 'seek': 271788, 'start': 2723.52, 'end': 2734.7200000000003, 'text': ' which is for every four accesses, one miss kind of a thing. Is that something that we can do other', 'tokens': [50646, 597, 307, 337, 633, 1451, 2105, 279, 11, 472, 1713, 733, 295, 257, 551, 13, 1119, 300, 746, 300, 321, 393, 360, 661, 51206], 'temperature': 0.0, 'avg_logprob': -0.12782011946586713, 'compression_ratio': 1.5519125683060109, 'no_speech_prob': 0.002485280390828848}, {'id': 455, 'seek': 271788, 'start': 2734.7200000000003, 'end': 2743.4, 'text': ' than changing the processor or the cache? Let us say that we are not hardware engineers, right.', 'tokens': [51206, 813, 4473, 264, 15321, 420, 264, 19459, 30, 961, 505, 584, 300, 321, 366, 406, 8837, 11955, 11, 558, 13, 51640], 'temperature': 0.0, 'avg_logprob': -0.12782011946586713, 'compression_ratio': 1.5519125683060109, 'no_speech_prob': 0.002485280390828848}, {'id': 456, 'seek': 274340, 'start': 2743.4, 'end': 2748.88, 'text': ' We are all elsewhere. We have given a processor and we want to improve the situation because,', 'tokens': [50364, 492, 366, 439, 14517, 13, 492, 362, 2212, 257, 15321, 293, 321, 528, 281, 3470, 264, 2590, 570, 11, 50638], 'temperature': 0.0, 'avg_logprob': -0.2561037129369275, 'compression_ratio': 1.3977900552486189, 'no_speech_prob': 0.2128235101699829}, {'id': 457, 'seek': 274340, 'start': 2748.88, 'end': 2756.52, 'text': ' again remember we are talking about this from the compiler perspective. Why were the misses', 'tokens': [50638, 797, 1604, 321, 366, 1417, 466, 341, 490, 264, 31958, 4585, 13, 1545, 645, 264, 29394, 51020], 'temperature': 0.0, 'avg_logprob': -0.2561037129369275, 'compression_ratio': 1.3977900552486189, 'no_speech_prob': 0.2128235101699829}, {'id': 458, 'seek': 274340, 'start': 2756.52, 'end': 2767.0, 'text': ' happening? Sorry? Change sequence of, okay. How will you change it?', 'tokens': [51020, 2737, 30, 4919, 30, 15060, 8310, 295, 11, 1392, 13, 1012, 486, 291, 1319, 309, 30, 51544], 'temperature': 0.0, 'avg_logprob': -0.2561037129369275, 'compression_ratio': 1.3977900552486189, 'no_speech_prob': 0.2128235101699829}, {'id': 459, 'seek': 277340, 'start': 2773.8, 'end': 2782.64, 'text': ' Okay. Okay, that is one possible way of doing it. Very clever because you have done instruction', 'tokens': [50384, 1033, 13, 1033, 11, 300, 307, 472, 1944, 636, 295, 884, 309, 13, 4372, 13494, 570, 291, 362, 1096, 10951, 50826], 'temperature': 0.0, 'avg_logprob': -0.2267196923494339, 'compression_ratio': 1.418848167539267, 'no_speech_prob': 0.023238683119416237}, {'id': 460, 'seek': 277340, 'start': 2782.64, 'end': 2789.28, 'text': ' scheduling. You can do that. But something else, more from a cache optimization point.', 'tokens': [50826, 29055, 13, 509, 393, 360, 300, 13, 583, 746, 1646, 11, 544, 490, 257, 19459, 19618, 935, 13, 51158], 'temperature': 0.0, 'avg_logprob': -0.2267196923494339, 'compression_ratio': 1.418848167539267, 'no_speech_prob': 0.023238683119416237}, {'id': 461, 'seek': 277340, 'start': 2789.28, 'end': 2799.0, 'text': ' Yes, definitely a clever answer. Why were the misses happening? Because of the conflict,', 'tokens': [51158, 1079, 11, 2138, 257, 13494, 1867, 13, 1545, 645, 264, 29394, 2737, 30, 1436, 295, 264, 6596, 11, 51644], 'temperature': 0.0, 'avg_logprob': -0.2267196923494339, 'compression_ratio': 1.418848167539267, 'no_speech_prob': 0.023238683119416237}, {'id': 462, 'seek': 279900, 'start': 2799.76, 'end': 2812.56, 'text': ' yeah, go ahead. You are trying to say something. If I do something so that A of 0 and B of 0 go', 'tokens': [50402, 1338, 11, 352, 2286, 13, 509, 366, 1382, 281, 584, 746, 13, 759, 286, 360, 746, 370, 300, 316, 295, 1958, 293, 363, 295, 1958, 352, 51042], 'temperature': 0.0, 'avg_logprob': -0.22805021323409735, 'compression_ratio': 1.3285714285714285, 'no_speech_prob': 0.016855206340551376}, {'id': 463, 'seek': 279900, 'start': 2812.56, 'end': 2821.12, 'text': ' to different cache locations and there is no problem at all, right. Instead of having 2048', 'tokens': [51042, 281, 819, 19459, 9253, 293, 456, 307, 572, 1154, 412, 439, 11, 558, 13, 7156, 295, 1419, 945, 13318, 51470], 'temperature': 0.0, 'avg_logprob': -0.22805021323409735, 'compression_ratio': 1.3285714285714285, 'no_speech_prob': 0.016855206340551376}, {'id': 464, 'seek': 282112, 'start': 2821.12, 'end': 2828.96, 'text': ' elements, if I had 2052 elements, correct, they will be offset at least by one block.', 'tokens': [50364, 4959, 11, 498, 286, 632, 945, 17602, 4959, 11, 3006, 11, 436, 486, 312, 18687, 412, 1935, 538, 472, 3461, 13, 50756], 'temperature': 0.0, 'avg_logprob': -0.1206766354140415, 'compression_ratio': 1.603448275862069, 'no_speech_prob': 0.2636745870113373}, {'id': 465, 'seek': 282112, 'start': 2828.96, 'end': 2836.2799999999997, 'text': ' That is actually all that I need. Very simple, right. Instead of buying a new processor or a', 'tokens': [50756, 663, 307, 767, 439, 300, 286, 643, 13, 4372, 2199, 11, 558, 13, 7156, 295, 6382, 257, 777, 15321, 420, 257, 51122], 'temperature': 0.0, 'avg_logprob': -0.1206766354140415, 'compression_ratio': 1.603448275862069, 'no_speech_prob': 0.2636745870113373}, {'id': 466, 'seek': 282112, 'start': 2836.2799999999997, 'end': 2844.08, 'text': ' new computer, you just use four extra bytes or four extra elements, problem is solved, correct.', 'tokens': [51122, 777, 3820, 11, 291, 445, 764, 1451, 2857, 36088, 420, 1451, 2857, 4959, 11, 1154, 307, 13041, 11, 3006, 13, 51512], 'temperature': 0.0, 'avg_logprob': -0.1206766354140415, 'compression_ratio': 1.603448275862069, 'no_speech_prob': 0.2636745870113373}, {'id': 467, 'seek': 282112, 'start': 2844.08, 'end': 2850.64, 'text': ' All that we wanted is that we do not want these two things to be getting mapped to the same cache', 'tokens': [51512, 1057, 300, 321, 1415, 307, 300, 321, 360, 406, 528, 613, 732, 721, 281, 312, 1242, 33318, 281, 264, 912, 19459, 51840], 'temperature': 0.0, 'avg_logprob': -0.1206766354140415, 'compression_ratio': 1.603448275862069, 'no_speech_prob': 0.2636745870113373}, {'id': 468, 'seek': 285064, 'start': 2850.64, 'end': 2856.2799999999997, 'text': ' location. So, this solution is often called padding. You just pad this element so that,', 'tokens': [50364, 4914, 13, 407, 11, 341, 3827, 307, 2049, 1219, 39562, 13, 509, 445, 6887, 341, 4478, 370, 300, 11, 50646], 'temperature': 0.0, 'avg_logprob': -0.13381031209772284, 'compression_ratio': 1.6954887218045114, 'no_speech_prob': 0.006928668823093176}, {'id': 469, 'seek': 285064, 'start': 2856.2799999999997, 'end': 2861.96, 'text': ' you know, two of them do not necessarily map to the same thing. Compiler by default will do', 'tokens': [50646, 291, 458, 11, 732, 295, 552, 360, 406, 4725, 4471, 281, 264, 912, 551, 13, 6620, 5441, 538, 7576, 486, 360, 50930], 'temperature': 0.0, 'avg_logprob': -0.13381031209772284, 'compression_ratio': 1.6954887218045114, 'no_speech_prob': 0.006928668823093176}, {'id': 470, 'seek': 285064, 'start': 2861.96, 'end': 2866.48, 'text': ' that today. If you want, you can check in your compiler whether it is happening or not happening,', 'tokens': [50930, 300, 965, 13, 759, 291, 528, 11, 291, 393, 1520, 294, 428, 31958, 1968, 309, 307, 2737, 420, 406, 2737, 11, 51156], 'temperature': 0.0, 'avg_logprob': -0.13381031209772284, 'compression_ratio': 1.6954887218045114, 'no_speech_prob': 0.006928668823093176}, {'id': 471, 'seek': 285064, 'start': 2866.48, 'end': 2873.24, 'text': ' right. That means you run a program with 2048 elements and then run another program with,', 'tokens': [51156, 558, 13, 663, 1355, 291, 1190, 257, 1461, 365, 945, 13318, 4959, 293, 550, 1190, 1071, 1461, 365, 11, 51494], 'temperature': 0.0, 'avg_logprob': -0.13381031209772284, 'compression_ratio': 1.6954887218045114, 'no_speech_prob': 0.006928668823093176}, {'id': 472, 'seek': 285064, 'start': 2873.24, 'end': 2878.56, 'text': ' let us say, more number of elements, 2052 or whatever elements and then see whether', 'tokens': [51494, 718, 505, 584, 11, 544, 1230, 295, 4959, 11, 945, 17602, 420, 2035, 4959, 293, 550, 536, 1968, 51760], 'temperature': 0.0, 'avg_logprob': -0.13381031209772284, 'compression_ratio': 1.6954887218045114, 'no_speech_prob': 0.006928668823093176}, {'id': 473, 'seek': 287856, 'start': 2878.56, 'end': 2885.4, 'text': ' their execution time significantly differ. They may not. So, all that we need to do is that the', 'tokens': [50364, 641, 15058, 565, 10591, 743, 13, 814, 815, 406, 13, 407, 11, 439, 300, 321, 643, 281, 360, 307, 300, 264, 50706], 'temperature': 0.0, 'avg_logprob': -0.16284189832971452, 'compression_ratio': 1.7954545454545454, 'no_speech_prob': 0.06984663754701614}, {'id': 474, 'seek': 287856, 'start': 2885.4, 'end': 2891.52, 'text': ' compiler should assign addresses such that they do not map to the same location. And if it does,', 'tokens': [50706, 31958, 820, 6269, 16862, 1270, 300, 436, 360, 406, 4471, 281, 264, 912, 4914, 13, 400, 498, 309, 775, 11, 51012], 'temperature': 0.0, 'avg_logprob': -0.16284189832971452, 'compression_ratio': 1.7954545454545454, 'no_speech_prob': 0.06984663754701614}, {'id': 475, 'seek': 287856, 'start': 2891.52, 'end': 2898.2, 'text': ' all that you need to do is to pad the first array with four extra elements. The moment you pad the', 'tokens': [51012, 439, 300, 291, 643, 281, 360, 307, 281, 6887, 264, 700, 10225, 365, 1451, 2857, 4959, 13, 440, 1623, 291, 6887, 264, 51346], 'temperature': 0.0, 'avg_logprob': -0.16284189832971452, 'compression_ratio': 1.7954545454545454, 'no_speech_prob': 0.06984663754701614}, {'id': 476, 'seek': 287856, 'start': 2898.2, 'end': 2902.12, 'text': ' first array with four extra elements, yeah, I will just take the question after I finish this sentence.', 'tokens': [51346, 700, 10225, 365, 1451, 2857, 4959, 11, 1338, 11, 286, 486, 445, 747, 264, 1168, 934, 286, 2413, 341, 8174, 13, 51542], 'temperature': 0.0, 'avg_logprob': -0.16284189832971452, 'compression_ratio': 1.7954545454545454, 'no_speech_prob': 0.06984663754701614}, {'id': 477, 'seek': 290212, 'start': 2902.12, 'end': 2908.08, 'text': ' So, the moment you pad the first array with four extra elements, right, the second array', 'tokens': [50364, 407, 11, 264, 1623, 291, 6887, 264, 700, 10225, 365, 1451, 2857, 4959, 11, 558, 11, 264, 1150, 10225, 50662], 'temperature': 0.0, 'avg_logprob': -0.1560438952399689, 'compression_ratio': 1.6865079365079365, 'no_speech_prob': 0.1516074389219284}, {'id': 478, 'seek': 290212, 'start': 2908.08, 'end': 2915.44, 'text': ' getting shifted at least by one cache block and therefore, both a0 and b0 will be in different', 'tokens': [50662, 1242, 18892, 412, 1935, 538, 472, 19459, 3461, 293, 4412, 11, 1293, 257, 15, 293, 272, 15, 486, 312, 294, 819, 51030], 'temperature': 0.0, 'avg_logprob': -0.1560438952399689, 'compression_ratio': 1.6865079365079365, 'no_speech_prob': 0.1516074389219284}, {'id': 479, 'seek': 290212, 'start': 2915.44, 'end': 2921.44, 'text': ' locations and therefore, all of these accesses will result in the one miss followed by three', 'tokens': [51030, 9253, 293, 4412, 11, 439, 295, 613, 2105, 279, 486, 1874, 294, 264, 472, 1713, 6263, 538, 1045, 51330], 'temperature': 0.0, 'avg_logprob': -0.1560438952399689, 'compression_ratio': 1.6865079365079365, 'no_speech_prob': 0.1516074389219284}, {'id': 480, 'seek': 290212, 'start': 2921.44, 'end': 2926.2799999999997, 'text': ' hits. That pattern will continue. That is again only for this example. I am sure that you are', 'tokens': [51330, 8664, 13, 663, 5102, 486, 2354, 13, 663, 307, 797, 787, 337, 341, 1365, 13, 286, 669, 988, 300, 291, 366, 51572], 'temperature': 0.0, 'avg_logprob': -0.1560438952399689, 'compression_ratio': 1.6865079365079365, 'no_speech_prob': 0.1516074389219284}, {'id': 481, 'seek': 290212, 'start': 2926.2799999999997, 'end': 2928.2799999999997, 'text': ' going to have an example which is different. Go ahead.', 'tokens': [51572, 516, 281, 362, 364, 1365, 597, 307, 819, 13, 1037, 2286, 13, 51672], 'temperature': 0.0, 'avg_logprob': -0.1560438952399689, 'compression_ratio': 1.6865079365079365, 'no_speech_prob': 0.1516074389219284}, {'id': 482, 'seek': 292828, 'start': 2928.28, 'end': 2948.52, 'text': ' Right. Right. So, that is entirely a different problem, not a cache problem per se. Even there,', 'tokens': [50364, 1779, 13, 1779, 13, 407, 11, 300, 307, 7696, 257, 819, 1154, 11, 406, 257, 19459, 1154, 680, 369, 13, 2754, 456, 11, 51376], 'temperature': 0.0, 'avg_logprob': -0.20744327704111734, 'compression_ratio': 1.3897058823529411, 'no_speech_prob': 0.03829142823815346}, {'id': 483, 'seek': 292828, 'start': 2948.52, 'end': 2953.2000000000003, 'text': ' if you have these two arrays which are getting mapped to the same location, you will have the', 'tokens': [51376, 498, 291, 362, 613, 732, 41011, 597, 366, 1242, 33318, 281, 264, 912, 4914, 11, 291, 486, 362, 264, 51610], 'temperature': 0.0, 'avg_logprob': -0.20744327704111734, 'compression_ratio': 1.3897058823529411, 'no_speech_prob': 0.03829142823815346}, {'id': 484, 'seek': 295320, 'start': 2953.2, 'end': 2960.16, 'text': ' cache misses, okay. And again, if you have the cache misses, you bring those b, right,', 'tokens': [50364, 19459, 29394, 11, 1392, 13, 400, 797, 11, 498, 291, 362, 264, 19459, 29394, 11, 291, 1565, 729, 272, 11, 558, 11, 50712], 'temperature': 0.0, 'avg_logprob': -0.16213241867397143, 'compression_ratio': 1.8214285714285714, 'no_speech_prob': 0.269279420375824}, {'id': 485, 'seek': 295320, 'start': 2960.16, 'end': 2965.12, 'text': ' and then you load it. You load it, but you load it with a cost, right. We will talk about', 'tokens': [50712, 293, 550, 291, 3677, 309, 13, 509, 3677, 309, 11, 457, 291, 3677, 309, 365, 257, 2063, 11, 558, 13, 492, 486, 751, 466, 50960], 'temperature': 0.0, 'avg_logprob': -0.16213241867397143, 'compression_ratio': 1.8214285714285714, 'no_speech_prob': 0.269279420375824}, {'id': 486, 'seek': 295320, 'start': 2965.12, 'end': 2972.3199999999997, 'text': ' these vector processors right after this, right after this, okay. Again, this is a separate', 'tokens': [50960, 613, 8062, 27751, 558, 934, 341, 11, 558, 934, 341, 11, 1392, 13, 3764, 11, 341, 307, 257, 4994, 51320], 'temperature': 0.0, 'avg_logprob': -0.16213241867397143, 'compression_ratio': 1.8214285714285714, 'no_speech_prob': 0.269279420375824}, {'id': 487, 'seek': 295320, 'start': 2972.3199999999997, 'end': 2976.3199999999997, 'text': ' optimization that you have to do. That is a separate optimization. These are orthogonal,', 'tokens': [51320, 19618, 300, 291, 362, 281, 360, 13, 663, 307, 257, 4994, 19618, 13, 1981, 366, 41488, 11, 51520], 'temperature': 0.0, 'avg_logprob': -0.16213241867397143, 'compression_ratio': 1.8214285714285714, 'no_speech_prob': 0.269279420375824}, {'id': 488, 'seek': 297632, 'start': 2976.32, 'end': 2984.1600000000003, 'text': ' correct. So, is this solution fine? The simple padding, okay, either add four elements to a or', 'tokens': [50364, 3006, 13, 407, 11, 307, 341, 3827, 2489, 30, 440, 2199, 39562, 11, 1392, 11, 2139, 909, 1451, 4959, 281, 257, 420, 50756], 'temperature': 0.0, 'avg_logprob': -0.17952811363900062, 'compression_ratio': 1.5892116182572613, 'no_speech_prob': 0.13563980162143707}, {'id': 489, 'seek': 297632, 'start': 2984.1600000000003, 'end': 2991.56, 'text': ' you have a small array of 16 bytes, whatever it is, sorry, 32 bytes so that the one gets shifted.', 'tokens': [50756, 291, 362, 257, 1359, 10225, 295, 3165, 36088, 11, 2035, 309, 307, 11, 2597, 11, 8858, 36088, 370, 300, 264, 472, 2170, 18892, 13, 51126], 'temperature': 0.0, 'avg_logprob': -0.17952811363900062, 'compression_ratio': 1.5892116182572613, 'no_speech_prob': 0.13563980162143707}, {'id': 490, 'seek': 297632, 'start': 2991.56, 'end': 2997.1200000000003, 'text': ' Anything which is more than 32 is all that you need to do, okay. So, essentially, you have to', 'tokens': [51126, 11998, 597, 307, 544, 813, 8858, 307, 439, 300, 291, 643, 281, 360, 11, 1392, 13, 407, 11, 4476, 11, 291, 362, 281, 51404], 'temperature': 0.0, 'avg_logprob': -0.17952811363900062, 'compression_ratio': 1.5892116182572613, 'no_speech_prob': 0.13563980162143707}, {'id': 491, 'seek': 297632, 'start': 2997.1200000000003, 'end': 3002.0800000000004, 'text': ' make sure that the base address of b is such that it is not that. You may not directly see these', 'tokens': [51404, 652, 988, 300, 264, 3096, 2985, 295, 272, 307, 1270, 300, 309, 307, 406, 300, 13, 509, 815, 406, 3838, 536, 613, 51652], 'temperature': 0.0, 'avg_logprob': -0.17952811363900062, 'compression_ratio': 1.5892116182572613, 'no_speech_prob': 0.13563980162143707}, {'id': 492, 'seek': 300208, 'start': 3002.08, 'end': 3009.24, 'text': ' addresses, but you can actually do this padding to make it change, okay. Now, the moment you do', 'tokens': [50364, 16862, 11, 457, 291, 393, 767, 360, 341, 39562, 281, 652, 309, 1319, 11, 1392, 13, 823, 11, 264, 1623, 291, 360, 50722], 'temperature': 0.0, 'avg_logprob': -0.07843721866607666, 'compression_ratio': 1.7627906976744185, 'no_speech_prob': 0.11272650957107544}, {'id': 493, 'seek': 300208, 'start': 3009.24, 'end': 3015.24, 'text': ' this, this is what you are going to get, okay. You are going to get back your 75 percent heat', 'tokens': [50722, 341, 11, 341, 307, 437, 291, 366, 516, 281, 483, 11, 1392, 13, 509, 366, 516, 281, 483, 646, 428, 9562, 3043, 3738, 51022], 'temperature': 0.0, 'avg_logprob': -0.07843721866607666, 'compression_ratio': 1.7627906976744185, 'no_speech_prob': 0.11272650957107544}, {'id': 494, 'seek': 300208, 'start': 3015.24, 'end': 3020.48, 'text': ' ratio. You could have also done another thing, right. If you are going to have this kind of a', 'tokens': [51022, 8509, 13, 509, 727, 362, 611, 1096, 1071, 551, 11, 558, 13, 759, 291, 366, 516, 281, 362, 341, 733, 295, 257, 51284], 'temperature': 0.0, 'avg_logprob': -0.07843721866607666, 'compression_ratio': 1.7627906976744185, 'no_speech_prob': 0.11272650957107544}, {'id': 495, 'seek': 300208, 'start': 3020.48, 'end': 3027.7999999999997, 'text': ' thing where you have a and b, instead of having them as two arrays, you can have it as an array', 'tokens': [51284, 551, 689, 291, 362, 257, 293, 272, 11, 2602, 295, 1419, 552, 382, 732, 41011, 11, 291, 393, 362, 309, 382, 364, 10225, 51650], 'temperature': 0.0, 'avg_logprob': -0.07843721866607666, 'compression_ratio': 1.7627906976744185, 'no_speech_prob': 0.11272650957107544}, {'id': 496, 'seek': 302780, 'start': 3027.8, 'end': 3034.4, 'text': ' of structures, right, where the structure has two elements a, b, right. So, this is what is called', 'tokens': [50364, 295, 9227, 11, 558, 11, 689, 264, 3877, 575, 732, 4959, 257, 11, 272, 11, 558, 13, 407, 11, 341, 307, 437, 307, 1219, 50694], 'temperature': 0.0, 'avg_logprob': -0.08720775360756731, 'compression_ratio': 2.0388888888888888, 'no_speech_prob': 0.07824312895536423}, {'id': 497, 'seek': 302780, 'start': 3034.4, 'end': 3041.32, 'text': ' structure of arrays versus array of structures, right. So, this is an array of structure idea.', 'tokens': [50694, 3877, 295, 41011, 5717, 10225, 295, 9227, 11, 558, 13, 407, 11, 341, 307, 364, 10225, 295, 3877, 1558, 13, 51040], 'temperature': 0.0, 'avg_logprob': -0.08720775360756731, 'compression_ratio': 2.0388888888888888, 'no_speech_prob': 0.07824312895536423}, {'id': 498, 'seek': 302780, 'start': 3041.32, 'end': 3047.5600000000004, 'text': ' So, when you do this, what happens is that each element of the structure has a and b,', 'tokens': [51040, 407, 11, 562, 291, 360, 341, 11, 437, 2314, 307, 300, 1184, 4478, 295, 264, 3877, 575, 257, 293, 272, 11, 51352], 'temperature': 0.0, 'avg_logprob': -0.08720775360756731, 'compression_ratio': 2.0388888888888888, 'no_speech_prob': 0.07824312895536423}, {'id': 499, 'seek': 302780, 'start': 3047.5600000000004, 'end': 3055.32, 'text': ' right, and they will be adjacent elements. So, one cache line will have two structures,', 'tokens': [51352, 558, 11, 293, 436, 486, 312, 24441, 4959, 13, 407, 11, 472, 19459, 1622, 486, 362, 732, 9227, 11, 51740], 'temperature': 0.0, 'avg_logprob': -0.08720775360756731, 'compression_ratio': 2.0388888888888888, 'no_speech_prob': 0.07824312895536423}, {'id': 500, 'seek': 305532, 'start': 3055.32, 'end': 3062.2000000000003, 'text': ' four elements, which is two structures, right. Structure 0, a. Structure 0, b. Structure 1,', 'tokens': [50364, 1451, 4959, 11, 597, 307, 732, 9227, 11, 558, 13, 745, 2885, 1958, 11, 257, 13, 745, 2885, 1958, 11, 272, 13, 745, 2885, 502, 11, 50708], 'temperature': 0.0, 'avg_logprob': -0.1142255260098365, 'compression_ratio': 2.0086580086580086, 'no_speech_prob': 0.036423616111278534}, {'id': 501, 'seek': 305532, 'start': 3062.2000000000003, 'end': 3068.6000000000004, 'text': ' a. Structure 1, b. Next cache line will have structure 2 and structure 3. The next cache', 'tokens': [50708, 257, 13, 745, 2885, 502, 11, 272, 13, 3087, 19459, 1622, 486, 362, 3877, 568, 293, 3877, 805, 13, 440, 958, 19459, 51028], 'temperature': 0.0, 'avg_logprob': -0.1142255260098365, 'compression_ratio': 2.0086580086580086, 'no_speech_prob': 0.036423616111278534}, {'id': 502, 'seek': 305532, 'start': 3068.6000000000004, 'end': 3074.44, 'text': ' line will have structure 4 and so on and so forth, right. When you reorder your data structure,', 'tokens': [51028, 1622, 486, 362, 3877, 1017, 293, 370, 322, 293, 370, 5220, 11, 558, 13, 1133, 291, 319, 4687, 428, 1412, 3877, 11, 51320], 'temperature': 0.0, 'avg_logprob': -0.1142255260098365, 'compression_ratio': 2.0086580086580086, 'no_speech_prob': 0.036423616111278534}, {'id': 503, 'seek': 305532, 'start': 3074.44, 'end': 3079.6000000000004, 'text': ' that also helps. So, if you are going to use two arrays which are kind of going to be used', 'tokens': [51320, 300, 611, 3665, 13, 407, 11, 498, 291, 366, 516, 281, 764, 732, 41011, 597, 366, 733, 295, 516, 281, 312, 1143, 51578], 'temperature': 0.0, 'avg_logprob': -0.1142255260098365, 'compression_ratio': 2.0086580086580086, 'no_speech_prob': 0.036423616111278534}, {'id': 504, 'seek': 305532, 'start': 3079.6000000000004, 'end': 3085.28, 'text': ' together and if they have sizes which are kind of likely to conflict, then you may want to think', 'tokens': [51578, 1214, 293, 498, 436, 362, 11602, 597, 366, 733, 295, 3700, 281, 6596, 11, 550, 291, 815, 528, 281, 519, 51862], 'temperature': 0.0, 'avg_logprob': -0.1142255260098365, 'compression_ratio': 2.0086580086580086, 'no_speech_prob': 0.036423616111278534}, {'id': 505, 'seek': 308528, 'start': 3085.28, 'end': 3091.28, 'text': ' in terms of array of structures rather than structure of arrays, right. That is another way', 'tokens': [50364, 294, 2115, 295, 10225, 295, 9227, 2831, 813, 3877, 295, 41011, 11, 558, 13, 663, 307, 1071, 636, 50664], 'temperature': 0.0, 'avg_logprob': -0.12860469615205805, 'compression_ratio': 1.75, 'no_speech_prob': 0.0013302802108228207}, {'id': 506, 'seek': 308528, 'start': 3091.28, 'end': 3096.2000000000003, 'text': ' by which the same problem can be handled, okay. Let us talk about the third important thing which', 'tokens': [50664, 538, 597, 264, 912, 1154, 393, 312, 18033, 11, 1392, 13, 961, 505, 751, 466, 264, 2636, 1021, 551, 597, 50910], 'temperature': 0.0, 'avg_logprob': -0.12860469615205805, 'compression_ratio': 1.75, 'no_speech_prob': 0.0013302802108228207}, {'id': 507, 'seek': 308528, 'start': 3096.2000000000003, 'end': 3101.52, 'text': ' is about dealing with more than one dimension of the array, multiple dimensions of the array,', 'tokens': [50910, 307, 466, 6260, 365, 544, 813, 472, 10139, 295, 264, 10225, 11, 3866, 12819, 295, 264, 10225, 11, 51176], 'temperature': 0.0, 'avg_logprob': -0.12860469615205805, 'compression_ratio': 1.75, 'no_speech_prob': 0.0013302802108228207}, {'id': 508, 'seek': 308528, 'start': 3101.52, 'end': 3110.0, 'text': ' right. Let us now look at this code. I have a nested loop, right, for j, for i and then I have', 'tokens': [51176, 558, 13, 961, 505, 586, 574, 412, 341, 3089, 13, 286, 362, 257, 15646, 292, 6367, 11, 558, 11, 337, 361, 11, 337, 741, 293, 550, 286, 362, 51600], 'temperature': 0.0, 'avg_logprob': -0.12860469615205805, 'compression_ratio': 1.75, 'no_speech_prob': 0.0013302802108228207}, {'id': 509, 'seek': 311000, 'start': 3110.0, 'end': 3116.88, 'text': ' some accesses, right. Now, let us look at the reference sequence. You are basically accessing', 'tokens': [50364, 512, 2105, 279, 11, 558, 13, 823, 11, 718, 505, 574, 412, 264, 6408, 8310, 13, 509, 366, 1936, 26440, 50708], 'temperature': 0.0, 'avg_logprob': -0.1225471185601276, 'compression_ratio': 1.7393939393939395, 'no_speech_prob': 0.060441531240940094}, {'id': 510, 'seek': 311000, 'start': 3116.88, 'end': 3125.48, 'text': ' a 0 0, a 0, right. Yeah, you are accessing a and b alternatively. So, a 0 0, b 0 0 and then you', 'tokens': [50708, 257, 1958, 1958, 11, 257, 1958, 11, 558, 13, 865, 11, 291, 366, 26440, 257, 293, 272, 8535, 356, 13, 407, 11, 257, 1958, 1958, 11, 272, 1958, 1958, 293, 550, 291, 51138], 'temperature': 0.0, 'avg_logprob': -0.1225471185601276, 'compression_ratio': 1.7393939393939395, 'no_speech_prob': 0.060441531240940094}, {'id': 511, 'seek': 311000, 'start': 3125.48, 'end': 3136.08, 'text': ' are storing b 0 0, then a 1 0, b 1 0, b 1 0 and so on, correct. Now, assuming that, let us assume', 'tokens': [51138, 366, 26085, 272, 1958, 1958, 11, 550, 257, 502, 1958, 11, 272, 502, 1958, 11, 272, 502, 1958, 293, 370, 322, 11, 3006, 13, 823, 11, 11926, 300, 11, 718, 505, 6552, 51668], 'temperature': 0.0, 'avg_logprob': -0.1225471185601276, 'compression_ratio': 1.7393939393939395, 'no_speech_prob': 0.060441531240940094}, {'id': 512, 'seek': 313608, 'start': 3136.08, 'end': 3142.64, 'text': ' that a and b are not conflicting to the same location. Would you get locality here? Would', 'tokens': [50364, 300, 257, 293, 272, 366, 406, 43784, 281, 264, 912, 4914, 13, 6068, 291, 483, 1628, 1860, 510, 30, 6068, 50692], 'temperature': 0.0, 'avg_logprob': -0.16411764481488397, 'compression_ratio': 1.7570093457943925, 'no_speech_prob': 0.05239563435316086}, {'id': 513, 'seek': 313608, 'start': 3142.64, 'end': 3148.48, 'text': ' you get the spatial locality that you are seeing earlier? That is an yes or a no? No,', 'tokens': [50692, 291, 483, 264, 23598, 1628, 1860, 300, 291, 366, 2577, 3071, 30, 663, 307, 364, 2086, 420, 257, 572, 30, 883, 11, 50984], 'temperature': 0.0, 'avg_logprob': -0.16411764481488397, 'compression_ratio': 1.7570093457943925, 'no_speech_prob': 0.05239563435316086}, {'id': 514, 'seek': 313608, 'start': 3148.48, 'end': 3153.44, 'text': ' because sometimes, you know, some regions yes is this and some regions no is this. So, I do not know.', 'tokens': [50984, 570, 2171, 11, 291, 458, 11, 512, 10682, 2086, 307, 341, 293, 512, 10682, 572, 307, 341, 13, 407, 11, 286, 360, 406, 458, 13, 51232], 'temperature': 0.0, 'avg_logprob': -0.16411764481488397, 'compression_ratio': 1.7570093457943925, 'no_speech_prob': 0.05239563435316086}, {'id': 515, 'seek': 313608, 'start': 3153.44, 'end': 3161.6, 'text': ' So, would you get spatial locality? Assuming that, let us assume that a of 0 0 maps to cache block', 'tokens': [51232, 407, 11, 576, 291, 483, 23598, 1628, 1860, 30, 6281, 24919, 300, 11, 718, 505, 6552, 300, 257, 295, 1958, 1958, 11317, 281, 19459, 3461, 51640], 'temperature': 0.0, 'avg_logprob': -0.16411764481488397, 'compression_ratio': 1.7570093457943925, 'no_speech_prob': 0.05239563435316086}, {'id': 516, 'seek': 316160, 'start': 3161.6, 'end': 3168.08, 'text': ' 0 and b of 0 0 maps to cache block 256. So, let us say we have put them far apart, right.', 'tokens': [50364, 1958, 293, 272, 295, 1958, 1958, 11317, 281, 19459, 3461, 38882, 13, 407, 11, 718, 505, 584, 321, 362, 829, 552, 1400, 4936, 11, 558, 13, 50688], 'temperature': 0.0, 'avg_logprob': -0.13837792499955878, 'compression_ratio': 1.4512820512820512, 'no_speech_prob': 0.08489780873060226}, {'id': 517, 'seek': 316160, 'start': 3168.08, 'end': 3176.72, 'text': ' Let us worry about that. Why would they not give me a spatial locality? a of 0 0 and then a of 1 0,', 'tokens': [50688, 961, 505, 3292, 466, 300, 13, 1545, 576, 436, 406, 976, 385, 257, 23598, 1628, 1860, 30, 257, 295, 1958, 1958, 293, 550, 257, 295, 502, 1958, 11, 51120], 'temperature': 0.0, 'avg_logprob': -0.13837792499955878, 'compression_ratio': 1.4512820512820512, 'no_speech_prob': 0.08489780873060226}, {'id': 518, 'seek': 316160, 'start': 3176.72, 'end': 3187.96, 'text': ' right. So, this depends on what is the order in which the elements are stored. Are we talking', 'tokens': [51120, 558, 13, 407, 11, 341, 5946, 322, 437, 307, 264, 1668, 294, 597, 264, 4959, 366, 12187, 13, 2014, 321, 1417, 51682], 'temperature': 0.0, 'avg_logprob': -0.13837792499955878, 'compression_ratio': 1.4512820512820512, 'no_speech_prob': 0.08489780873060226}, {'id': 519, 'seek': 318796, 'start': 3187.96, 'end': 3194.0, 'text': ' about a row major order or a column major order? If it is a C program, it is a row major order.', 'tokens': [50364, 466, 257, 5386, 2563, 1668, 420, 257, 7738, 2563, 1668, 30, 759, 309, 307, 257, 383, 1461, 11, 309, 307, 257, 5386, 2563, 1668, 13, 50666], 'temperature': 0.0, 'avg_logprob': -0.1107723505600639, 'compression_ratio': 1.7028571428571428, 'no_speech_prob': 0.03481409326195717}, {'id': 520, 'seek': 318796, 'start': 3194.0, 'end': 3202.48, 'text': ' In a row major order, spatial locality is going to be seen from a of 0 0, a of 0 1, a of 0 2 and so on.', 'tokens': [50666, 682, 257, 5386, 2563, 1668, 11, 23598, 1628, 1860, 307, 516, 281, 312, 1612, 490, 257, 295, 1958, 1958, 11, 257, 295, 1958, 502, 11, 257, 295, 1958, 568, 293, 370, 322, 13, 51090], 'temperature': 0.0, 'avg_logprob': -0.1107723505600639, 'compression_ratio': 1.7028571428571428, 'no_speech_prob': 0.03481409326195717}, {'id': 521, 'seek': 318796, 'start': 3202.48, 'end': 3211.0, 'text': ' So, if you access the elements like this, you are going to access a 0 and then a 1 0, which is far', 'tokens': [51090, 407, 11, 498, 291, 2105, 264, 4959, 411, 341, 11, 291, 366, 516, 281, 2105, 257, 1958, 293, 550, 257, 502, 1958, 11, 597, 307, 1400, 51516], 'temperature': 0.0, 'avg_logprob': -0.1107723505600639, 'compression_ratio': 1.7028571428571428, 'no_speech_prob': 0.03481409326195717}, {'id': 522, 'seek': 321100, 'start': 3211.4, 'end': 3218.32, 'text': ' away from that and then a 2 0, which is far away from that, okay. I do not exploit spatial locality', 'tokens': [50384, 1314, 490, 300, 293, 550, 257, 568, 1958, 11, 597, 307, 1400, 1314, 490, 300, 11, 1392, 13, 286, 360, 406, 25924, 23598, 1628, 1860, 50730], 'temperature': 0.0, 'avg_logprob': -0.12376880645751953, 'compression_ratio': 1.61864406779661, 'no_speech_prob': 0.08184704184532166}, {'id': 523, 'seek': 321100, 'start': 3218.32, 'end': 3224.28, 'text': ' in that way, but then after I come back, I am going to eventually access a 0 1. Will I at least', 'tokens': [50730, 294, 300, 636, 11, 457, 550, 934, 286, 808, 646, 11, 286, 669, 516, 281, 4728, 2105, 257, 1958, 502, 13, 3099, 286, 412, 1935, 51028], 'temperature': 0.0, 'avg_logprob': -0.12376880645751953, 'compression_ratio': 1.61864406779661, 'no_speech_prob': 0.08184704184532166}, {'id': 524, 'seek': 321100, 'start': 3224.28, 'end': 3230.32, 'text': ' get the locality then? No, because by that time I would have replaced this with something else,', 'tokens': [51028, 483, 264, 1628, 1860, 550, 30, 883, 11, 570, 538, 300, 565, 286, 576, 362, 10772, 341, 365, 746, 1646, 11, 51330], 'temperature': 0.0, 'avg_logprob': -0.12376880645751953, 'compression_ratio': 1.61864406779661, 'no_speech_prob': 0.08184704184532166}, {'id': 525, 'seek': 321100, 'start': 3230.32, 'end': 3236.64, 'text': ' correct. So, that is really what is going to happen. So, let us look at these things here.', 'tokens': [51330, 3006, 13, 407, 11, 300, 307, 534, 437, 307, 516, 281, 1051, 13, 407, 11, 718, 505, 574, 412, 613, 721, 510, 13, 51646], 'temperature': 0.0, 'avg_logprob': -0.12376880645751953, 'compression_ratio': 1.61864406779661, 'no_speech_prob': 0.08184704184532166}, {'id': 526, 'seek': 323664, 'start': 3236.64, 'end': 3243.56, 'text': ' So, we talked about this row major ordering, which all of you know, right, as opposed to the', 'tokens': [50364, 407, 11, 321, 2825, 466, 341, 5386, 2563, 21739, 11, 597, 439, 295, 291, 458, 11, 558, 11, 382, 8851, 281, 264, 50710], 'temperature': 0.0, 'avg_logprob': -0.12814223164259786, 'compression_ratio': 1.9292929292929293, 'no_speech_prob': 0.1011575311422348}, {'id': 527, 'seek': 323664, 'start': 3243.56, 'end': 3250.16, 'text': ' column major order. So, this is row major order, right, a 0 0, a 0 1, a 0 2 are successive elements,', 'tokens': [50710, 7738, 2563, 1668, 13, 407, 11, 341, 307, 5386, 2563, 1668, 11, 558, 11, 257, 1958, 1958, 11, 257, 1958, 502, 11, 257, 1958, 568, 366, 48043, 4959, 11, 51040], 'temperature': 0.0, 'avg_logprob': -0.12814223164259786, 'compression_ratio': 1.9292929292929293, 'no_speech_prob': 0.1011575311422348}, {'id': 528, 'seek': 323664, 'start': 3250.16, 'end': 3256.44, 'text': ' whereas in column major ordering, these will be the successive elements. So, if your storage is', 'tokens': [51040, 9735, 294, 7738, 2563, 21739, 11, 613, 486, 312, 264, 48043, 4959, 13, 407, 11, 498, 428, 6725, 307, 51354], 'temperature': 0.0, 'avg_logprob': -0.12814223164259786, 'compression_ratio': 1.9292929292929293, 'no_speech_prob': 0.1011575311422348}, {'id': 529, 'seek': 323664, 'start': 3256.44, 'end': 3262.92, 'text': ' in row major order, then you must necessarily do row major ordering to get spatial locality,', 'tokens': [51354, 294, 5386, 2563, 1668, 11, 550, 291, 1633, 4725, 360, 5386, 2563, 21739, 281, 483, 23598, 1628, 1860, 11, 51678], 'temperature': 0.0, 'avg_logprob': -0.12814223164259786, 'compression_ratio': 1.9292929292929293, 'no_speech_prob': 0.1011575311422348}, {'id': 530, 'seek': 326292, 'start': 3262.92, 'end': 3268.16, 'text': ' right. The array is small, then it is okay. Even then you may get the spatial locality,', 'tokens': [50364, 558, 13, 440, 10225, 307, 1359, 11, 550, 309, 307, 1392, 13, 2754, 550, 291, 815, 483, 264, 23598, 1628, 1860, 11, 50626], 'temperature': 0.0, 'avg_logprob': -0.16685319380326705, 'compression_ratio': 1.6651982378854626, 'no_speech_prob': 0.008001868613064289}, {'id': 531, 'seek': 326292, 'start': 3268.16, 'end': 3273.7200000000003, 'text': ' because the entire array stays in your cache. But let us assume that it is a 2k by 2k array,', 'tokens': [50626, 570, 264, 2302, 10225, 10834, 294, 428, 19459, 13, 583, 718, 505, 6552, 300, 309, 307, 257, 568, 74, 538, 568, 74, 10225, 11, 50904], 'temperature': 0.0, 'avg_logprob': -0.16685319380326705, 'compression_ratio': 1.6651982378854626, 'no_speech_prob': 0.008001868613064289}, {'id': 532, 'seek': 326292, 'start': 3273.7200000000003, 'end': 3280.84, 'text': ' that is like 4m, way, way bigger than any L1 cache or L2 cache, right. So, something is going to', 'tokens': [50904, 300, 307, 411, 1017, 76, 11, 636, 11, 636, 3801, 813, 604, 441, 16, 19459, 420, 441, 17, 19459, 11, 558, 13, 407, 11, 746, 307, 516, 281, 51260], 'temperature': 0.0, 'avg_logprob': -0.16685319380326705, 'compression_ratio': 1.6651982378854626, 'no_speech_prob': 0.008001868613064289}, {'id': 533, 'seek': 326292, 'start': 3280.84, 'end': 3285.7200000000003, 'text': ' replace. By the time you come back and want to look at it, it is not going to be there in the cache,', 'tokens': [51260, 7406, 13, 3146, 264, 565, 291, 808, 646, 293, 528, 281, 574, 412, 309, 11, 309, 307, 406, 516, 281, 312, 456, 294, 264, 19459, 11, 51504], 'temperature': 0.0, 'avg_logprob': -0.16685319380326705, 'compression_ratio': 1.6651982378854626, 'no_speech_prob': 0.008001868613064289}, {'id': 534, 'seek': 328572, 'start': 3285.72, 'end': 3293.2, 'text': ' right. So, that is really what is happening here. I have assumed it to be 1024 cross 1024,', 'tokens': [50364, 558, 13, 407, 11, 300, 307, 534, 437, 307, 2737, 510, 13, 286, 362, 15895, 309, 281, 312, 1266, 7911, 3278, 1266, 7911, 11, 50738], 'temperature': 0.0, 'avg_logprob': -0.1399237552535868, 'compression_ratio': 1.6888888888888889, 'no_speech_prob': 0.03039582446217537}, {'id': 535, 'seek': 328572, 'start': 3293.2, 'end': 3300.9599999999996, 'text': ' that is like 8 megabytes, right. 8 megabytes is far too bigger than your L1 or L2 caches, right.', 'tokens': [50738, 300, 307, 411, 1649, 10816, 24538, 11, 558, 13, 1649, 10816, 24538, 307, 1400, 886, 3801, 813, 428, 441, 16, 420, 441, 17, 269, 13272, 11, 558, 13, 51126], 'temperature': 0.0, 'avg_logprob': -0.1399237552535868, 'compression_ratio': 1.6888888888888889, 'no_speech_prob': 0.03039582446217537}, {'id': 536, 'seek': 328572, 'start': 3300.9599999999996, 'end': 3308.04, 'text': ' So, you and then you have two such arrays, that means 16 megabytes. Definitely it cannot hold in', 'tokens': [51126, 407, 11, 291, 293, 550, 291, 362, 732, 1270, 41011, 11, 300, 1355, 3165, 10816, 24538, 13, 12151, 309, 2644, 1797, 294, 51480], 'temperature': 0.0, 'avg_logprob': -0.1399237552535868, 'compression_ratio': 1.6888888888888889, 'no_speech_prob': 0.03039582446217537}, {'id': 537, 'seek': 328572, 'start': 3308.04, 'end': 3312.52, 'text': ' your cache. So, you are going to have capacity misses. So, by the time you come back and access', 'tokens': [51480, 428, 19459, 13, 407, 11, 291, 366, 516, 281, 362, 6042, 29394, 13, 407, 11, 538, 264, 565, 291, 808, 646, 293, 2105, 51704], 'temperature': 0.0, 'avg_logprob': -0.1399237552535868, 'compression_ratio': 1.6888888888888889, 'no_speech_prob': 0.03039582446217537}, {'id': 538, 'seek': 331252, 'start': 3312.52, 'end': 3318.04, 'text': ' A01, because of capacity misses, those lines would have been thrown. You can actually work out the', 'tokens': [50364, 316, 10607, 11, 570, 295, 6042, 29394, 11, 729, 3876, 576, 362, 668, 11732, 13, 509, 393, 767, 589, 484, 264, 50640], 'temperature': 0.0, 'avg_logprob': -0.15508637338314415, 'compression_ratio': 1.7244444444444444, 'no_speech_prob': 0.3173229396343231}, {'id': 539, 'seek': 331252, 'start': 3318.04, 'end': 3326.96, 'text': ' details and find out, right, okay. So, in this particular case, because you do a load of B00', 'tokens': [50640, 4365, 293, 915, 484, 11, 558, 11, 1392, 13, 407, 11, 294, 341, 1729, 1389, 11, 570, 291, 360, 257, 3677, 295, 363, 628, 51086], 'temperature': 0.0, 'avg_logprob': -0.15508637338314415, 'compression_ratio': 1.7244444444444444, 'no_speech_prob': 0.3173229396343231}, {'id': 540, 'seek': 331252, 'start': 3326.96, 'end': 3332.48, 'text': ' and then a store, one of them is going to be a hit, the other one, sorry, one of them is going to', 'tokens': [51086, 293, 550, 257, 3531, 11, 472, 295, 552, 307, 516, 281, 312, 257, 2045, 11, 264, 661, 472, 11, 2597, 11, 472, 295, 552, 307, 516, 281, 51362], 'temperature': 0.0, 'avg_logprob': -0.15508637338314415, 'compression_ratio': 1.7244444444444444, 'no_speech_prob': 0.3173229396343231}, {'id': 541, 'seek': 331252, 'start': 3332.48, 'end': 3338.4, 'text': ' be a miss, the other one which you access immediately would be a hit. So, of these three accesses,', 'tokens': [51362, 312, 257, 1713, 11, 264, 661, 472, 597, 291, 2105, 4258, 576, 312, 257, 2045, 13, 407, 11, 295, 613, 1045, 2105, 279, 11, 51658], 'temperature': 0.0, 'avg_logprob': -0.15508637338314415, 'compression_ratio': 1.7244444444444444, 'no_speech_prob': 0.3173229396343231}, {'id': 542, 'seek': 333840, 'start': 3338.6, 'end': 3344.52, 'text': ' there will be two misses and one hit. That is why you are getting 33 percent. If the store has not', 'tokens': [50374, 456, 486, 312, 732, 29394, 293, 472, 2045, 13, 663, 307, 983, 291, 366, 1242, 11816, 3043, 13, 759, 264, 3531, 575, 406, 50670], 'temperature': 0.0, 'avg_logprob': -0.12488267391542845, 'compression_ratio': 1.5421052631578946, 'no_speech_prob': 0.0602884441614151}, {'id': 543, 'seek': 333840, 'start': 3344.52, 'end': 3355.04, 'text': ' been there, you would have got 100 percent misses, okay. So, you remember the earlier program was', 'tokens': [50670, 668, 456, 11, 291, 576, 362, 658, 2319, 3043, 29394, 11, 1392, 13, 407, 11, 291, 1604, 264, 3071, 1461, 390, 51196], 'temperature': 0.0, 'avg_logprob': -0.12488267391542845, 'compression_ratio': 1.5421052631578946, 'no_speech_prob': 0.0602884441614151}, {'id': 544, 'seek': 333840, 'start': 3355.04, 'end': 3364.76, 'text': ' something like this, right. For j is equal to 0 to 1024 and then i is equal to 0 to 1024 and you', 'tokens': [51196, 746, 411, 341, 11, 558, 13, 1171, 361, 307, 2681, 281, 1958, 281, 1266, 7911, 293, 550, 741, 307, 2681, 281, 1958, 281, 1266, 7911, 293, 291, 51682], 'temperature': 0.0, 'avg_logprob': -0.12488267391542845, 'compression_ratio': 1.5421052631578946, 'no_speech_prob': 0.0602884441614151}, {'id': 545, 'seek': 336476, 'start': 3364.76, 'end': 3371.1200000000003, 'text': ' are accessing A of ij. That is what was the problem. If I have switched these two loops,', 'tokens': [50364, 366, 26440, 316, 295, 741, 73, 13, 663, 307, 437, 390, 264, 1154, 13, 759, 286, 362, 16858, 613, 732, 16121, 11, 50682], 'temperature': 0.0, 'avg_logprob': -0.11716322782563, 'compression_ratio': 1.4845360824742269, 'no_speech_prob': 0.008263736963272095}, {'id': 546, 'seek': 336476, 'start': 3371.1200000000003, 'end': 3379.92, 'text': ' then what would have happened? My accesses would have been to A00, A01, A02 and so on. And in that', 'tokens': [50682, 550, 437, 576, 362, 2011, 30, 1222, 2105, 279, 576, 362, 668, 281, 316, 628, 11, 316, 10607, 11, 316, 12756, 293, 370, 322, 13, 400, 294, 300, 51122], 'temperature': 0.0, 'avg_logprob': -0.11716322782563, 'compression_ratio': 1.4845360824742269, 'no_speech_prob': 0.008263736963272095}, {'id': 547, 'seek': 336476, 'start': 3379.92, 'end': 3387.92, 'text': ' case, I would have had my 75 percent or more kind of a hit ratio. So, again it is the responsibility', 'tokens': [51122, 1389, 11, 286, 576, 362, 632, 452, 9562, 3043, 420, 544, 733, 295, 257, 2045, 8509, 13, 407, 11, 797, 309, 307, 264, 6357, 51522], 'temperature': 0.0, 'avg_logprob': -0.11716322782563, 'compression_ratio': 1.4845360824742269, 'no_speech_prob': 0.008263736963272095}, {'id': 548, 'seek': 338792, 'start': 3387.92, 'end': 3395.12, 'text': ' of the compiler to understand what is the right storage order. And if the loop is not in the', 'tokens': [50364, 295, 264, 31958, 281, 1223, 437, 307, 264, 558, 6725, 1668, 13, 400, 498, 264, 6367, 307, 406, 294, 264, 50724], 'temperature': 0.0, 'avg_logprob': -0.16957265680486505, 'compression_ratio': 1.837696335078534, 'no_speech_prob': 0.30170318484306335}, {'id': 549, 'seek': 338792, 'start': 3395.12, 'end': 3401.4, 'text': ' storage order, is it possible to interchange the loop so that you can do the benefits of,', 'tokens': [50724, 6725, 1668, 11, 307, 309, 1944, 281, 30358, 264, 6367, 370, 300, 291, 393, 360, 264, 5311, 295, 11, 51038], 'temperature': 0.0, 'avg_logprob': -0.16957265680486505, 'compression_ratio': 1.837696335078534, 'no_speech_prob': 0.30170318484306335}, {'id': 550, 'seek': 338792, 'start': 3401.4, 'end': 3407.32, 'text': ' you can get the benefits of spatial locality. It may not always be possible to do the interchange.', 'tokens': [51038, 291, 393, 483, 264, 5311, 295, 23598, 1628, 1860, 13, 467, 815, 406, 1009, 312, 1944, 281, 360, 264, 30358, 13, 51334], 'temperature': 0.0, 'avg_logprob': -0.16957265680486505, 'compression_ratio': 1.837696335078534, 'no_speech_prob': 0.30170318484306335}, {'id': 551, 'seek': 338792, 'start': 3407.32, 'end': 3413.7200000000003, 'text': ' May be unrolling. May be unrolling. Will unrolling help in this case?', 'tokens': [51334, 1891, 312, 517, 18688, 13, 1891, 312, 517, 18688, 13, 3099, 517, 18688, 854, 294, 341, 1389, 30, 51654], 'temperature': 0.0, 'avg_logprob': -0.16957265680486505, 'compression_ratio': 1.837696335078534, 'no_speech_prob': 0.30170318484306335}, {'id': 552, 'seek': 341372, 'start': 3413.72, 'end': 3421.6, 'text': ' Yes. Unrolling will not help. Unrolling still essentially takes the same order.', 'tokens': [50364, 1079, 13, 1156, 18688, 486, 406, 854, 13, 1156, 18688, 920, 4476, 2516, 264, 912, 1668, 13, 50758], 'temperature': 0.0, 'avg_logprob': -0.18680744171142577, 'compression_ratio': 1.6097560975609757, 'no_speech_prob': 0.025092337280511856}, {'id': 553, 'seek': 341372, 'start': 3421.6, 'end': 3429.2799999999997, 'text': ' Unless you unroll it in a different way, okay, which essentially boils down to doing the', 'tokens': [50758, 16581, 291, 517, 3970, 309, 294, 257, 819, 636, 11, 1392, 11, 597, 4476, 35049, 760, 281, 884, 264, 51142], 'temperature': 0.0, 'avg_logprob': -0.18680744171142577, 'compression_ratio': 1.6097560975609757, 'no_speech_prob': 0.025092337280511856}, {'id': 554, 'seek': 341372, 'start': 3429.2799999999997, 'end': 3434.4399999999996, 'text': ' interchange, correct. If you want to get spatial locality here, you have to do the interchange,', 'tokens': [51142, 30358, 11, 3006, 13, 759, 291, 528, 281, 483, 23598, 1628, 1860, 510, 11, 291, 362, 281, 360, 264, 30358, 11, 51400], 'temperature': 0.0, 'avg_logprob': -0.18680744171142577, 'compression_ratio': 1.6097560975609757, 'no_speech_prob': 0.025092337280511856}, {'id': 555, 'seek': 343444, 'start': 3434.44, 'end': 3444.04, 'text': ' right. Are you all with me? Okay. So, let us keep this. Finish this. So, if I interchange the loops', 'tokens': [50364, 558, 13, 2014, 291, 439, 365, 385, 30, 1033, 13, 407, 11, 718, 505, 1066, 341, 13, 31583, 341, 13, 407, 11, 498, 286, 30358, 264, 16121, 50844], 'temperature': 0.0, 'avg_logprob': -0.15724272015451016, 'compression_ratio': 1.5364583333333333, 'no_speech_prob': 0.028379542753100395}, {'id': 556, 'seek': 343444, 'start': 3444.04, 'end': 3451.16, 'text': ' and then write it in this order, A of i is equal to 0 to 1024 and j is equal to 0 to 1024, then my', 'tokens': [50844, 293, 550, 2464, 309, 294, 341, 1668, 11, 316, 295, 741, 307, 2681, 281, 1958, 281, 1266, 7911, 293, 361, 307, 2681, 281, 1958, 281, 1266, 7911, 11, 550, 452, 51200], 'temperature': 0.0, 'avg_logprob': -0.15724272015451016, 'compression_ratio': 1.5364583333333333, 'no_speech_prob': 0.028379542753100395}, {'id': 557, 'seek': 343444, 'start': 3451.16, 'end': 3456.84, 'text': ' access order is same as my storage order. And therefore, I am going to get the spatial locality,', 'tokens': [51200, 2105, 1668, 307, 912, 382, 452, 6725, 1668, 13, 400, 4412, 11, 286, 669, 516, 281, 483, 264, 23598, 1628, 1860, 11, 51484], 'temperature': 0.0, 'avg_logprob': -0.15724272015451016, 'compression_ratio': 1.5364583333333333, 'no_speech_prob': 0.028379542753100395}, {'id': 558, 'seek': 345684, 'start': 3456.84, 'end': 3466.28, 'text': ' okay. Now, okay. Let us just move on to data parallelism. Yeah.', 'tokens': [50364, 1392, 13, 823, 11, 1392, 13, 961, 505, 445, 1286, 322, 281, 1412, 8952, 1434, 13, 865, 13, 50836], 'temperature': 0.0, 'avg_logprob': -0.32432402263988147, 'compression_ratio': 0.9402985074626866, 'no_speech_prob': 0.7838936448097229}, {'id': 559, 'seek': 346628, 'start': 3466.28, 'end': 3476.0800000000004, 'text': ' This is 2D array.', 'tokens': [50364, 639, 307, 568, 35, 10225, 13, 50854], 'temperature': 0.0, 'avg_logprob': -0.33165693283081055, 'compression_ratio': 1.1294117647058823, 'no_speech_prob': 0.28435850143432617}, {'id': 560, 'seek': 346628, 'start': 3476.0800000000004, 'end': 3493.5600000000004, 'text': ' Not coherence wise, coherence is not the point at all. Leave that aside, yeah.', 'tokens': [50854, 1726, 26528, 655, 10829, 11, 26528, 655, 307, 406, 264, 935, 412, 439, 13, 9825, 300, 7359, 11, 1338, 13, 51728], 'temperature': 0.0, 'avg_logprob': -0.33165693283081055, 'compression_ratio': 1.1294117647058823, 'no_speech_prob': 0.28435850143432617}, {'id': 561, 'seek': 349356, 'start': 3493.56, 'end': 3506.08, 'text': ' Why? Why? In any case, it is actually stored as a one-dimensional thing in memory, correct, right.', 'tokens': [50364, 1545, 30, 1545, 30, 682, 604, 1389, 11, 309, 307, 767, 12187, 382, 257, 472, 12, 18759, 551, 294, 4675, 11, 3006, 11, 558, 13, 50990], 'temperature': 0.0, 'avg_logprob': -0.25290253162384035, 'compression_ratio': 1.1981132075471699, 'no_speech_prob': 0.4548887610435486}, {'id': 562, 'seek': 349356, 'start': 3506.08, 'end': 3516.52, 'text': ' Is it how it is going to do?', 'tokens': [50990, 1119, 309, 577, 309, 307, 516, 281, 360, 30, 51512], 'temperature': 0.0, 'avg_logprob': -0.25290253162384035, 'compression_ratio': 1.1981132075471699, 'no_speech_prob': 0.4548887610435486}, {'id': 563, 'seek': 351652, 'start': 3516.52, 'end': 3527.16, 'text': ' If you have declared this as a two-dimensional array and if you give A of i j, it will actually', 'tokens': [50364, 759, 291, 362, 15489, 341, 382, 257, 732, 12, 18759, 10225, 293, 498, 291, 976, 316, 295, 741, 361, 11, 309, 486, 767, 50896], 'temperature': 0.0, 'avg_logprob': -0.13338381178835604, 'compression_ratio': 1.6331877729257642, 'no_speech_prob': 0.1798190325498581}, {'id': 564, 'seek': 351652, 'start': 3527.16, 'end': 3533.52, 'text': ' compute i times the number of elements in that multiplied by this plus j times the number of', 'tokens': [50896, 14722, 741, 1413, 264, 1230, 295, 4959, 294, 300, 17207, 538, 341, 1804, 361, 1413, 264, 1230, 295, 51214], 'temperature': 0.0, 'avg_logprob': -0.13338381178835604, 'compression_ratio': 1.6331877729257642, 'no_speech_prob': 0.1798190325498581}, {'id': 565, 'seek': 351652, 'start': 3533.52, 'end': 3540.28, 'text': ' this. Get that as an expression and then index it outside of the A of something. That is how', 'tokens': [51214, 341, 13, 3240, 300, 382, 364, 6114, 293, 550, 8186, 309, 2380, 295, 264, 316, 295, 746, 13, 663, 307, 577, 51552], 'temperature': 0.0, 'avg_logprob': -0.13338381178835604, 'compression_ratio': 1.6331877729257642, 'no_speech_prob': 0.1798190325498581}, {'id': 566, 'seek': 351652, 'start': 3540.28, 'end': 3545.7599999999998, 'text': ' it is supposed to generate code for that, right. It is not like I am going to find out where', 'tokens': [51552, 309, 307, 3442, 281, 8460, 3089, 337, 300, 11, 558, 13, 467, 307, 406, 411, 286, 669, 516, 281, 915, 484, 689, 51826], 'temperature': 0.0, 'avg_logprob': -0.13338381178835604, 'compression_ratio': 1.6331877729257642, 'no_speech_prob': 0.1798190325498581}, {'id': 567, 'seek': 354576, 'start': 3545.76, 'end': 3552.6400000000003, 'text': ' A of i 0 would be or what is the address of A of i 0 and then to that I am going to add something.', 'tokens': [50364, 316, 295, 741, 1958, 576, 312, 420, 437, 307, 264, 2985, 295, 316, 295, 741, 1958, 293, 550, 281, 300, 286, 669, 516, 281, 909, 746, 13, 50708], 'temperature': 0.0, 'avg_logprob': -0.17457821393253828, 'compression_ratio': 1.7534883720930232, 'no_speech_prob': 0.04253355786204338}, {'id': 568, 'seek': 354576, 'start': 3552.6400000000003, 'end': 3557.76, 'text': ' Whichever way you do, I think it is only the index address calculation, right.', 'tokens': [50708, 3013, 1054, 636, 291, 360, 11, 286, 519, 309, 307, 787, 264, 8186, 2985, 17108, 11, 558, 13, 50964], 'temperature': 0.0, 'avg_logprob': -0.17457821393253828, 'compression_ratio': 1.7534883720930232, 'no_speech_prob': 0.04253355786204338}, {'id': 569, 'seek': 354576, 'start': 3557.76, 'end': 3563.5600000000004, 'text': ' Dynamic memory allocation.', 'tokens': [50964, 45440, 4675, 27599, 13, 51254], 'temperature': 0.0, 'avg_logprob': -0.17457821393253828, 'compression_ratio': 1.7534883720930232, 'no_speech_prob': 0.04253355786204338}, {'id': 570, 'seek': 354576, 'start': 3563.5600000000004, 'end': 3567.6400000000003, 'text': ' Dynamic memory allocation. So, if you are declaring it as a two-dimensional', 'tokens': [51254, 45440, 4675, 27599, 13, 407, 11, 498, 291, 366, 40374, 309, 382, 257, 732, 12, 18759, 51458], 'temperature': 0.0, 'avg_logprob': -0.17457821393253828, 'compression_ratio': 1.7534883720930232, 'no_speech_prob': 0.04253355786204338}, {'id': 571, 'seek': 354576, 'start': 3567.6400000000003, 'end': 3575.2400000000002, 'text': ' array and then allocating all the space upfront, it is the same, right. If you are doing dynamic', 'tokens': [51458, 10225, 293, 550, 12660, 990, 439, 264, 1901, 30264, 11, 309, 307, 264, 912, 11, 558, 13, 759, 291, 366, 884, 8546, 51838], 'temperature': 0.0, 'avg_logprob': -0.17457821393253828, 'compression_ratio': 1.7534883720930232, 'no_speech_prob': 0.04253355786204338}, {'id': 572, 'seek': 357524, 'start': 3575.24, 'end': 3579.3599999999997, 'text': ' allocation, then the problem is different, right. You are essentially allocating an array', 'tokens': [50364, 27599, 11, 550, 264, 1154, 307, 819, 11, 558, 13, 509, 366, 4476, 12660, 990, 364, 10225, 50570], 'temperature': 0.0, 'avg_logprob': -0.25374770614336123, 'compression_ratio': 1.9241071428571428, 'no_speech_prob': 0.05742412805557251}, {'id': 573, 'seek': 357524, 'start': 3579.3599999999997, 'end': 3584.08, 'text': ' of one dimension and for each one of them you are allocating an another array, obviously.', 'tokens': [50570, 295, 472, 10139, 293, 337, 1184, 472, 295, 552, 291, 366, 12660, 990, 364, 1071, 10225, 11, 2745, 13, 50806], 'temperature': 0.0, 'avg_logprob': -0.25374770614336123, 'compression_ratio': 1.9241071428571428, 'no_speech_prob': 0.05742412805557251}, {'id': 574, 'seek': 357524, 'start': 3584.08, 'end': 3590.6, 'text': ' So, in that case, using the one-dimensional array as a two-dimensional array.', 'tokens': [50806, 407, 11, 294, 300, 1389, 11, 1228, 264, 472, 12, 18759, 10225, 382, 257, 732, 12, 18759, 10225, 13, 51132], 'temperature': 0.0, 'avg_logprob': -0.25374770614336123, 'compression_ratio': 1.9241071428571428, 'no_speech_prob': 0.05742412805557251}, {'id': 575, 'seek': 357524, 'start': 3590.6, 'end': 3594.2, 'text': ' Yeah, you are essentially saying that I do not do dynamic allocation or even if I do', 'tokens': [51132, 865, 11, 291, 366, 4476, 1566, 300, 286, 360, 406, 360, 8546, 27599, 420, 754, 498, 286, 360, 51312], 'temperature': 0.0, 'avg_logprob': -0.25374770614336123, 'compression_ratio': 1.9241071428571428, 'no_speech_prob': 0.05742412805557251}, {'id': 576, 'seek': 357524, 'start': 3594.2, 'end': 3600.68, 'text': ' dynamic allocation, I do all of them together in one shot, right. See, again think of it', 'tokens': [51312, 8546, 27599, 11, 286, 360, 439, 295, 552, 1214, 294, 472, 3347, 11, 558, 13, 3008, 11, 797, 519, 295, 309, 51636], 'temperature': 0.0, 'avg_logprob': -0.25374770614336123, 'compression_ratio': 1.9241071428571428, 'no_speech_prob': 0.05742412805557251}, {'id': 577, 'seek': 360068, 'start': 3600.68, 'end': 3606.52, 'text': ' in the following way. If I have an array which is 1024 cross 1024, why would I want', 'tokens': [50364, 294, 264, 3480, 636, 13, 759, 286, 362, 364, 10225, 597, 307, 1266, 7911, 3278, 1266, 7911, 11, 983, 576, 286, 528, 50656], 'temperature': 0.0, 'avg_logprob': -0.19498944523358586, 'compression_ratio': 1.737991266375546, 'no_speech_prob': 0.13057976961135864}, {'id': 578, 'seek': 360068, 'start': 3606.52, 'end': 3613.7999999999997, 'text': ' to do dynamic allocation, right? You would not, right. There are, you know, programs', 'tokens': [50656, 281, 360, 8546, 27599, 11, 558, 30, 509, 576, 406, 11, 558, 13, 821, 366, 11, 291, 458, 11, 4268, 51020], 'temperature': 0.0, 'avg_logprob': -0.19498944523358586, 'compression_ratio': 1.737991266375546, 'no_speech_prob': 0.13057976961135864}, {'id': 579, 'seek': 360068, 'start': 3613.7999999999997, 'end': 3618.04, 'text': ' and there are variables where you want to declare certain things as, I mean declare', 'tokens': [51020, 293, 456, 366, 9102, 689, 291, 528, 281, 19710, 1629, 721, 382, 11, 286, 914, 19710, 51232], 'temperature': 0.0, 'avg_logprob': -0.19498944523358586, 'compression_ratio': 1.737991266375546, 'no_speech_prob': 0.13057976961135864}, {'id': 580, 'seek': 360068, 'start': 3618.04, 'end': 3621.9199999999996, 'text': ' something statically and there are certain places where you definitely have to go for', 'tokens': [51232, 746, 2219, 984, 293, 456, 366, 1629, 3190, 689, 291, 2138, 362, 281, 352, 337, 51426], 'temperature': 0.0, 'avg_logprob': -0.19498944523358586, 'compression_ratio': 1.737991266375546, 'no_speech_prob': 0.13057976961135864}, {'id': 581, 'seek': 360068, 'start': 3621.9199999999996, 'end': 3624.96, 'text': ' a dynamic thing. When you do a dynamic thing, I am assuming', 'tokens': [51426, 257, 8546, 551, 13, 1133, 291, 360, 257, 8546, 551, 11, 286, 669, 11926, 51578], 'temperature': 0.0, 'avg_logprob': -0.19498944523358586, 'compression_ratio': 1.737991266375546, 'no_speech_prob': 0.13057976961135864}, {'id': 582, 'seek': 362496, 'start': 3625.96, 'end': 3632.28, 'text': ' do a 1024 cross 1024. It is 1024 and then for each one of them will have different,', 'tokens': [50414, 360, 257, 1266, 7911, 3278, 1266, 7911, 13, 467, 307, 1266, 7911, 293, 550, 337, 1184, 472, 295, 552, 486, 362, 819, 11, 50730], 'temperature': 0.0, 'avg_logprob': -0.3734139152195143, 'compression_ratio': 1.6163793103448276, 'no_speech_prob': 0.3072783648967743}, {'id': 583, 'seek': 362496, 'start': 3632.28, 'end': 3637.52, 'text': ' for example, when I talk about an adjacency list representation, right. There are the', 'tokens': [50730, 337, 1365, 11, 562, 286, 751, 466, 364, 22940, 3020, 1329, 10290, 11, 558, 13, 821, 366, 264, 50992], 'temperature': 0.0, 'avg_logprob': -0.3734139152195143, 'compression_ratio': 1.6163793103448276, 'no_speech_prob': 0.3072783648967743}, {'id': 584, 'seek': 362496, 'start': 3637.52, 'end': 3640.52, 'text': ' cases where you actually do dynamic memory allocation.', 'tokens': [50992, 3331, 689, 291, 767, 360, 8546, 4675, 27599, 13, 51142], 'temperature': 0.0, 'avg_logprob': -0.3734139152195143, 'compression_ratio': 1.6163793103448276, 'no_speech_prob': 0.3072783648967743}, {'id': 585, 'seek': 362496, 'start': 3640.52, 'end': 3649.52, 'text': ' Why is it that for dynamic allocation to the array, it is so much different than on statically', 'tokens': [51142, 1545, 307, 309, 300, 337, 8546, 27599, 281, 264, 10225, 11, 309, 307, 370, 709, 819, 813, 322, 2219, 984, 51592], 'temperature': 0.0, 'avg_logprob': -0.3734139152195143, 'compression_ratio': 1.6163793103448276, 'no_speech_prob': 0.3072783648967743}, {'id': 586, 'seek': 362496, 'start': 3649.52, 'end': 3652.6, 'text': ' allocated? Okay. Because this different elements of the', 'tokens': [51592, 29772, 30, 1033, 13, 1436, 341, 819, 4959, 295, 264, 51746], 'temperature': 0.0, 'avg_logprob': -0.3734139152195143, 'compression_ratio': 1.6163793103448276, 'no_speech_prob': 0.3072783648967743}, {'id': 587, 'seek': 365260, 'start': 3652.6, 'end': 3659.6, 'text': ' rows are going to be allocated, I mean, it is going to be allocated by the malloc separately,', 'tokens': [50364, 13241, 366, 516, 281, 312, 29772, 11, 286, 914, 11, 309, 307, 516, 281, 312, 29772, 538, 264, 16026, 905, 14759, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.23218259706601993, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.09897289425134659}, {'id': 588, 'seek': 365260, 'start': 3659.6, 'end': 3666.44, 'text': ' right. And there are certain analysis that you can do with a statically allocated array.', 'tokens': [50714, 558, 13, 400, 456, 366, 1629, 5215, 300, 291, 393, 360, 365, 257, 2219, 984, 29772, 10225, 13, 51056], 'temperature': 0.0, 'avg_logprob': -0.23218259706601993, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.09897289425134659}, {'id': 589, 'seek': 365260, 'start': 3666.44, 'end': 3672.68, 'text': ' In a dynamically allocated array, you cannot even do many of those analysis, right. So,', 'tokens': [51056, 682, 257, 43492, 29772, 10225, 11, 291, 2644, 754, 360, 867, 295, 729, 5215, 11, 558, 13, 407, 11, 51368], 'temperature': 0.0, 'avg_logprob': -0.23218259706601993, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.09897289425134659}, {'id': 590, 'seek': 365260, 'start': 3672.68, 'end': 3681.16, 'text': ' I would not say why or which one would perform better. It is kind of hard to predict, okay.', 'tokens': [51368, 286, 576, 406, 584, 983, 420, 597, 472, 576, 2042, 1101, 13, 467, 307, 733, 295, 1152, 281, 6069, 11, 1392, 13, 51792], 'temperature': 0.0, 'avg_logprob': -0.23218259706601993, 'compression_ratio': 1.7572815533980584, 'no_speech_prob': 0.09897289425134659}, {'id': 591, 'seek': 368116, 'start': 3681.16, 'end': 3685.2, 'text': ' By saying that I will declare it as a one dimensional array, you are saying that I am', 'tokens': [50364, 3146, 1566, 300, 286, 486, 19710, 309, 382, 257, 472, 18795, 10225, 11, 291, 366, 1566, 300, 286, 669, 50566], 'temperature': 0.0, 'avg_logprob': -0.24535242163616677, 'compression_ratio': 1.7692307692307692, 'no_speech_prob': 0.04219738394021988}, {'id': 592, 'seek': 368116, 'start': 3685.2, 'end': 3689.44, 'text': ' going to allocate all of them together in which case it pretty much becomes same as', 'tokens': [50566, 516, 281, 35713, 439, 295, 552, 1214, 294, 597, 1389, 309, 1238, 709, 3643, 912, 382, 50778], 'temperature': 0.0, 'avg_logprob': -0.24535242163616677, 'compression_ratio': 1.7692307692307692, 'no_speech_prob': 0.04219738394021988}, {'id': 593, 'seek': 368116, 'start': 3689.44, 'end': 3695.08, 'text': ' static allocation except that it is done dynamically at runtime. It is a contiguous piece of that', 'tokens': [50778, 13437, 27599, 3993, 300, 309, 307, 1096, 43492, 412, 34474, 13, 467, 307, 257, 660, 30525, 2522, 295, 300, 51060], 'temperature': 0.0, 'avg_logprob': -0.24535242163616677, 'compression_ratio': 1.7692307692307692, 'no_speech_prob': 0.04219738394021988}, {'id': 594, 'seek': 368116, 'start': 3695.08, 'end': 3699.3599999999997, 'text': ' many elements whereas this also was a contiguous piece. This was in data segment whereas that', 'tokens': [51060, 867, 4959, 9735, 341, 611, 390, 257, 660, 30525, 2522, 13, 639, 390, 294, 1412, 9469, 9735, 300, 51274], 'temperature': 0.0, 'avg_logprob': -0.24535242163616677, 'compression_ratio': 1.7692307692307692, 'no_speech_prob': 0.04219738394021988}, {'id': 595, 'seek': 368116, 'start': 3699.3599999999997, 'end': 3704.24, 'text': ' will be in heap segment. Other than that, there is no real difference, okay. There may', 'tokens': [51274, 486, 312, 294, 33591, 9469, 13, 5358, 813, 300, 11, 456, 307, 572, 957, 2649, 11, 1392, 13, 821, 815, 51518], 'temperature': 0.0, 'avg_logprob': -0.24535242163616677, 'compression_ratio': 1.7692307692307692, 'no_speech_prob': 0.04219738394021988}, {'id': 596, 'seek': 368116, 'start': 3704.24, 'end': 3710.7999999999997, 'text': ' not be, okay. Any other questions?', 'tokens': [51518, 406, 312, 11, 1392, 13, 2639, 661, 1651, 30, 51846], 'temperature': 0.0, 'avg_logprob': -0.24535242163616677, 'compression_ratio': 1.7692307692307692, 'no_speech_prob': 0.04219738394021988}, {'id': 597, 'seek': 371080, 'start': 3710.8, 'end': 3717.52, 'text': ' All I wanted to point out here is that do not, I mean, when you have these programs,', 'tokens': [50364, 1057, 286, 1415, 281, 935, 484, 510, 307, 300, 360, 406, 11, 286, 914, 11, 562, 291, 362, 613, 4268, 11, 50700], 'temperature': 0.0, 'avg_logprob': -0.14906281940007615, 'compression_ratio': 2.008510638297872, 'no_speech_prob': 0.1549554020166397}, {'id': 598, 'seek': 371080, 'start': 3717.52, 'end': 3722.4, 'text': ' you should be able to find out which of these accesses are likely to give you more hits', 'tokens': [50700, 291, 820, 312, 1075, 281, 915, 484, 597, 295, 613, 2105, 279, 366, 3700, 281, 976, 291, 544, 8664, 50944], 'temperature': 0.0, 'avg_logprob': -0.14906281940007615, 'compression_ratio': 2.008510638297872, 'no_speech_prob': 0.1549554020166397}, {'id': 599, 'seek': 371080, 'start': 3722.4, 'end': 3726.0800000000004, 'text': ' and which of these accesses are likely to give less hits. That we should be able to', 'tokens': [50944, 293, 597, 295, 613, 2105, 279, 366, 3700, 281, 976, 1570, 8664, 13, 663, 321, 820, 312, 1075, 281, 51128], 'temperature': 0.0, 'avg_logprob': -0.14906281940007615, 'compression_ratio': 2.008510638297872, 'no_speech_prob': 0.1549554020166397}, {'id': 600, 'seek': 371080, 'start': 3726.0800000000004, 'end': 3730.48, 'text': ' figure out and we cannot say that we would not be able to figure this out because after', 'tokens': [51128, 2573, 484, 293, 321, 2644, 584, 300, 321, 576, 406, 312, 1075, 281, 2573, 341, 484, 570, 934, 51348], 'temperature': 0.0, 'avg_logprob': -0.14906281940007615, 'compression_ratio': 2.008510638297872, 'no_speech_prob': 0.1549554020166397}, {'id': 601, 'seek': 371080, 'start': 3730.48, 'end': 3735.0800000000004, 'text': ' all we understand caches, we understand how program works and we should be able to figure', 'tokens': [51348, 439, 321, 1223, 269, 13272, 11, 321, 1223, 577, 1461, 1985, 293, 321, 820, 312, 1075, 281, 2573, 51578], 'temperature': 0.0, 'avg_logprob': -0.14906281940007615, 'compression_ratio': 2.008510638297872, 'no_speech_prob': 0.1549554020166397}, {'id': 602, 'seek': 371080, 'start': 3735.0800000000004, 'end': 3739.2400000000002, 'text': ' this out, right. Any other questions?', 'tokens': [51578, 341, 484, 11, 558, 13, 2639, 661, 1651, 30, 51786], 'temperature': 0.0, 'avg_logprob': -0.14906281940007615, 'compression_ratio': 2.008510638297872, 'no_speech_prob': 0.1549554020166397}, {'id': 603, 'seek': 373924, 'start': 3739.68, 'end': 3743.9599999999996, 'text': ' So what happens in a matrix multiplication? That is the eventual question we want to get', 'tokens': [50386, 407, 437, 2314, 294, 257, 8141, 27290, 30, 663, 307, 264, 33160, 1168, 321, 528, 281, 483, 50600], 'temperature': 0.0, 'avg_logprob': -0.15865669787769587, 'compression_ratio': 1.5868263473053892, 'no_speech_prob': 0.04668065160512924}, {'id': 604, 'seek': 373924, 'start': 3743.9599999999996, 'end': 3749.64, 'text': ' into, right. All of you remember the matrix multiplication program, right. The program', 'tokens': [50600, 666, 11, 558, 13, 1057, 295, 291, 1604, 264, 8141, 27290, 1461, 11, 558, 13, 440, 1461, 50884], 'temperature': 0.0, 'avg_logprob': -0.15865669787769587, 'compression_ratio': 1.5868263473053892, 'no_speech_prob': 0.04668065160512924}, {'id': 605, 'seek': 373924, 'start': 3749.64, 'end': 3761.8399999999997, 'text': ' says A of ij is equal to A of ij plus B of ik multiplied by C of kj. So, B array is going', 'tokens': [50884, 1619, 316, 295, 741, 73, 307, 2681, 281, 316, 295, 741, 73, 1804, 363, 295, 4320, 17207, 538, 383, 295, 350, 73, 13, 407, 11, 363, 10225, 307, 516, 51494], 'temperature': 0.0, 'avg_logprob': -0.15865669787769587, 'compression_ratio': 1.5868263473053892, 'no_speech_prob': 0.04668065160512924}, {'id': 606, 'seek': 376184, 'start': 3761.84, 'end': 3770.48, 'text': ' to be accessed row wise. C array is going to be accessed column wise, right. So, in', 'tokens': [50364, 281, 312, 34211, 5386, 10829, 13, 383, 10225, 307, 516, 281, 312, 34211, 7738, 10829, 11, 558, 13, 407, 11, 294, 50796], 'temperature': 0.0, 'avg_logprob': -0.22861559250775507, 'compression_ratio': 1.6827956989247312, 'no_speech_prob': 0.06664611399173737}, {'id': 607, 'seek': 376184, 'start': 3770.48, 'end': 3777.28, 'text': ' one of them you will get benefits of spatial locality. In the other, you will not. And', 'tokens': [50796, 472, 295, 552, 291, 486, 483, 5311, 295, 23598, 1628, 1860, 13, 682, 264, 661, 11, 291, 486, 406, 13, 400, 51136], 'temperature': 0.0, 'avg_logprob': -0.22861559250775507, 'compression_ratio': 1.6827956989247312, 'no_speech_prob': 0.06664611399173737}, {'id': 608, 'seek': 376184, 'start': 3777.28, 'end': 3783.0, 'text': ' if these arrays are too big, in neither of them you will get temporal locality, correct.', 'tokens': [51136, 498, 613, 41011, 366, 886, 955, 11, 294, 9662, 295, 552, 291, 486, 483, 30881, 1628, 1860, 11, 3006, 13, 51422], 'temperature': 0.0, 'avg_logprob': -0.22861559250775507, 'compression_ratio': 1.6827956989247312, 'no_speech_prob': 0.06664611399173737}, {'id': 609, 'seek': 376184, 'start': 3783.0, 'end': 3787.6000000000004, 'text': ' So, is that something that we can do to improve that?', 'tokens': [51422, 407, 11, 307, 300, 746, 300, 321, 393, 360, 281, 3470, 300, 30, 51652], 'temperature': 0.0, 'avg_logprob': -0.22861559250775507, 'compression_ratio': 1.6827956989247312, 'no_speech_prob': 0.06664611399173737}, {'id': 610, 'seek': 378760, 'start': 3788.36, 'end': 3797.7999999999997, 'text': ' Yeah, but then when you do the transport you are anyway incurring the cost, right. True,', 'tokens': [50402, 865, 11, 457, 550, 562, 291, 360, 264, 5495, 291, 366, 4033, 35774, 2937, 264, 2063, 11, 558, 13, 13587, 11, 50874], 'temperature': 0.0, 'avg_logprob': -0.19985502031114366, 'compression_ratio': 2.0344827586206895, 'no_speech_prob': 0.0873955711722374}, {'id': 611, 'seek': 378760, 'start': 3797.7999999999997, 'end': 3802.52, 'text': ' I mean if you transport then you can use that, but then when you do the transport you are', 'tokens': [50874, 286, 914, 498, 291, 5495, 550, 291, 393, 764, 300, 11, 457, 550, 562, 291, 360, 264, 5495, 291, 366, 51110], 'temperature': 0.0, 'avg_logprob': -0.19985502031114366, 'compression_ratio': 2.0344827586206895, 'no_speech_prob': 0.0873955711722374}, {'id': 612, 'seek': 378760, 'start': 3802.52, 'end': 3809.36, 'text': ' going to access C in the column wise way or you are going to write it into the transpose', 'tokens': [51110, 516, 281, 2105, 383, 294, 264, 7738, 10829, 636, 420, 291, 366, 516, 281, 2464, 309, 666, 264, 25167, 51452], 'temperature': 0.0, 'avg_logprob': -0.19985502031114366, 'compression_ratio': 2.0344827586206895, 'no_speech_prob': 0.0873955711722374}, {'id': 613, 'seek': 378760, 'start': 3809.36, 'end': 3814.8399999999997, 'text': ' array in the column wise way. You are going to get hit somewhere. You can postpone the', 'tokens': [51452, 10225, 294, 264, 7738, 10829, 636, 13, 509, 366, 516, 281, 483, 2045, 4079, 13, 509, 393, 28973, 546, 264, 51726], 'temperature': 0.0, 'avg_logprob': -0.19985502031114366, 'compression_ratio': 2.0344827586206895, 'no_speech_prob': 0.0873955711722374}, {'id': 614, 'seek': 381484, 'start': 3814.84, 'end': 3821.28, 'text': ' problem, but you cannot solve the problem, is not it? But there is an advantage. If you', 'tokens': [50364, 1154, 11, 457, 291, 2644, 5039, 264, 1154, 11, 307, 406, 309, 30, 583, 456, 307, 364, 5002, 13, 759, 291, 50686], 'temperature': 0.0, 'avg_logprob': -0.21632182490718257, 'compression_ratio': 1.6833976833976834, 'no_speech_prob': 0.05447584390640259}, {'id': 615, 'seek': 381484, 'start': 3821.28, 'end': 3825.08, 'text': ' are going to repeatedly use that you will get the benefit of that, true.', 'tokens': [50686, 366, 516, 281, 18227, 764, 300, 291, 486, 483, 264, 5121, 295, 300, 11, 2074, 13, 50876], 'temperature': 0.0, 'avg_logprob': -0.21632182490718257, 'compression_ratio': 1.6833976833976834, 'no_speech_prob': 0.05447584390640259}, {'id': 616, 'seek': 381484, 'start': 3825.08, 'end': 3831.48, 'text': ' Okay, so we are going to talk about that little later, right, if time permits. Now everything', 'tokens': [50876, 1033, 11, 370, 321, 366, 516, 281, 751, 466, 300, 707, 1780, 11, 558, 11, 498, 565, 30990, 13, 823, 1203, 51196], 'temperature': 0.0, 'avg_logprob': -0.21632182490718257, 'compression_ratio': 1.6833976833976834, 'no_speech_prob': 0.05447584390640259}, {'id': 617, 'seek': 381484, 'start': 3831.48, 'end': 3836.28, 'text': ' is if time permits because we have only one more session. So, let us see what happens.', 'tokens': [51196, 307, 498, 565, 30990, 570, 321, 362, 787, 472, 544, 5481, 13, 407, 11, 718, 505, 536, 437, 2314, 13, 51436], 'temperature': 0.0, 'avg_logprob': -0.21632182490718257, 'compression_ratio': 1.6833976833976834, 'no_speech_prob': 0.05447584390640259}, {'id': 618, 'seek': 381484, 'start': 3836.28, 'end': 3844.6400000000003, 'text': ' Okay, let me quickly talk about this parallelization and SIMD machines or SIMD operations. So,', 'tokens': [51436, 1033, 11, 718, 385, 2661, 751, 466, 341, 8952, 2144, 293, 24738, 35, 8379, 420, 24738, 35, 7705, 13, 407, 11, 51854], 'temperature': 0.0, 'avg_logprob': -0.21632182490718257, 'compression_ratio': 1.6833976833976834, 'no_speech_prob': 0.05447584390640259}, {'id': 619, 'seek': 384464, 'start': 3844.64, 'end': 3849.48, 'text': ' one class of parallel machines are called SIMD machines which stands for single instruction', 'tokens': [50364, 472, 1508, 295, 8952, 8379, 366, 1219, 24738, 35, 8379, 597, 7382, 337, 2167, 10951, 50606], 'temperature': 0.0, 'avg_logprob': -0.16098602781904506, 'compression_ratio': 1.9778761061946903, 'no_speech_prob': 0.008278626948595047}, {'id': 620, 'seek': 384464, 'start': 3849.48, 'end': 3854.7999999999997, 'text': ' multiple data and in these machines essentially you execute a single operation or a single', 'tokens': [50606, 3866, 1412, 293, 294, 613, 8379, 4476, 291, 14483, 257, 2167, 6916, 420, 257, 2167, 50872], 'temperature': 0.0, 'avg_logprob': -0.16098602781904506, 'compression_ratio': 1.9778761061946903, 'no_speech_prob': 0.008278626948595047}, {'id': 621, 'seek': 384464, 'start': 3854.7999999999997, 'end': 3860.3599999999997, 'text': ' instruction, but that single instruction operates on multiple data elements. That is why it', 'tokens': [50872, 10951, 11, 457, 300, 2167, 10951, 22577, 322, 3866, 1412, 4959, 13, 663, 307, 983, 309, 51150], 'temperature': 0.0, 'avg_logprob': -0.16098602781904506, 'compression_ratio': 1.9778761061946903, 'no_speech_prob': 0.008278626948595047}, {'id': 622, 'seek': 384464, 'start': 3860.3599999999997, 'end': 3864.72, 'text': ' is called single instruction multiple data elements. Typically when you have a vector', 'tokens': [51150, 307, 1219, 2167, 10951, 3866, 1412, 4959, 13, 23129, 562, 291, 362, 257, 8062, 51368], 'temperature': 0.0, 'avg_logprob': -0.16098602781904506, 'compression_ratio': 1.9778761061946903, 'no_speech_prob': 0.008278626948595047}, {'id': 623, 'seek': 384464, 'start': 3864.72, 'end': 3870.98, 'text': ' and you are trying to do A of i plus B of i across all elements of i then that is like', 'tokens': [51368, 293, 291, 366, 1382, 281, 360, 316, 295, 741, 1804, 363, 295, 741, 2108, 439, 4959, 295, 741, 550, 300, 307, 411, 51681], 'temperature': 0.0, 'avg_logprob': -0.16098602781904506, 'compression_ratio': 1.9778761061946903, 'no_speech_prob': 0.008278626948595047}, {'id': 624, 'seek': 387098, 'start': 3871.02, 'end': 3875.14, 'text': ' a vector operation or that is like a SIMD operation, right.', 'tokens': [50366, 257, 8062, 6916, 420, 300, 307, 411, 257, 24738, 35, 6916, 11, 558, 13, 50572], 'temperature': 0.0, 'avg_logprob': -0.19730287439682903, 'compression_ratio': 1.8131868131868132, 'no_speech_prob': 0.06081131845712662}, {'id': 625, 'seek': 387098, 'start': 3875.14, 'end': 3880.66, 'text': ' Today you can see SIMD machines in many forms. Earlier days there used to be vector processors', 'tokens': [50572, 2692, 291, 393, 536, 24738, 35, 8379, 294, 867, 6422, 13, 24552, 1708, 456, 1143, 281, 312, 8062, 27751, 50848], 'temperature': 0.0, 'avg_logprob': -0.19730287439682903, 'compression_ratio': 1.8131868131868132, 'no_speech_prob': 0.06081131845712662}, {'id': 626, 'seek': 387098, 'start': 3880.66, 'end': 3886.62, 'text': ' which used to exploit SIMD. There also used to be array processors which used to exploit', 'tokens': [50848, 597, 1143, 281, 25924, 24738, 35, 13, 821, 611, 1143, 281, 312, 10225, 27751, 597, 1143, 281, 25924, 51146], 'temperature': 0.0, 'avg_logprob': -0.19730287439682903, 'compression_ratio': 1.8131868131868132, 'no_speech_prob': 0.06081131845712662}, {'id': 627, 'seek': 387098, 'start': 3886.62, 'end': 3894.82, 'text': " SIMD, but these were like the 60s and the 70s and the 80s, but today's processors have", 'tokens': [51146, 24738, 35, 11, 457, 613, 645, 411, 264, 4060, 82, 293, 264, 5285, 82, 293, 264, 4688, 82, 11, 457, 965, 311, 27751, 362, 51556], 'temperature': 0.0, 'avg_logprob': -0.19730287439682903, 'compression_ratio': 1.8131868131868132, 'no_speech_prob': 0.06081131845712662}, {'id': 628, 'seek': 389482, 'start': 3894.9, 'end': 3900.6600000000003, 'text': ' instructions like the MMX instructions or the AVX instructions. These are what we call', 'tokens': [50368, 9415, 411, 264, 34191, 55, 9415, 420, 264, 30198, 55, 9415, 13, 1981, 366, 437, 321, 818, 50656], 'temperature': 0.0, 'avg_logprob': -0.18374298431061126, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.02184884622693062}, {'id': 629, 'seek': 389482, 'start': 3900.6600000000003, 'end': 3907.6600000000003, 'text': ' as the wide word instruction, right. So, for example I have a 512 bit register and I have', 'tokens': [50656, 382, 264, 4874, 1349, 10951, 11, 558, 13, 407, 11, 337, 1365, 286, 362, 257, 1025, 4762, 857, 7280, 293, 286, 362, 51006], 'temperature': 0.0, 'avg_logprob': -0.18374298431061126, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.02184884622693062}, {'id': 630, 'seek': 389482, 'start': 3908.1400000000003, 'end': 3915.1400000000003, 'text': ' a functional unit which can actually do operations on 512 bits. That means that I can take 1632', 'tokens': [51030, 257, 11745, 4985, 597, 393, 767, 360, 7705, 322, 1025, 4762, 9239, 13, 663, 1355, 300, 286, 393, 747, 3165, 11440, 51380], 'temperature': 0.0, 'avg_logprob': -0.18374298431061126, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.02184884622693062}, {'id': 631, 'seek': 389482, 'start': 3915.1400000000003, 'end': 3922.1400000000003, 'text': ' bits and perform operations on all of these 16 operands. That is really what it is, right.', 'tokens': [51380, 9239, 293, 2042, 7705, 322, 439, 295, 613, 3165, 2208, 2967, 13, 663, 307, 534, 437, 309, 307, 11, 558, 13, 51730], 'temperature': 0.0, 'avg_logprob': -0.18374298431061126, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.02184884622693062}, {'id': 632, 'seek': 392214, 'start': 3922.3799999999997, 'end': 3929.3799999999997, 'text': ' So this is also a form of SIMD machine, right. So it could be 512 bits or 256 bits or 64', 'tokens': [50376, 407, 341, 307, 611, 257, 1254, 295, 24738, 35, 3479, 11, 558, 13, 407, 309, 727, 312, 1025, 4762, 9239, 420, 38882, 9239, 420, 12145, 50726], 'temperature': 0.0, 'avg_logprob': -0.1771375846862793, 'compression_ratio': 1.6161137440758293, 'no_speech_prob': 0.008134420961141586}, {'id': 633, 'seek': 392214, 'start': 3930.94, 'end': 3937.94, 'text': ' bits and depending on that it is called either MMX or SSE or AVX and so on. Again AVX 256', 'tokens': [50804, 9239, 293, 5413, 322, 300, 309, 307, 1219, 2139, 34191, 55, 420, 318, 5879, 420, 30198, 55, 293, 370, 322, 13, 3764, 30198, 55, 38882, 51154], 'temperature': 0.0, 'avg_logprob': -0.1771375846862793, 'compression_ratio': 1.6161137440758293, 'no_speech_prob': 0.008134420961141586}, {'id': 634, 'seek': 392214, 'start': 3937.94, 'end': 3944.3799999999997, 'text': ' is there, AVX 512 is there and so on. So there is also one other class of machines which', 'tokens': [51154, 307, 456, 11, 30198, 55, 1025, 4762, 307, 456, 293, 370, 322, 13, 407, 456, 307, 611, 472, 661, 1508, 295, 8379, 597, 51476], 'temperature': 0.0, 'avg_logprob': -0.1771375846862793, 'compression_ratio': 1.6161137440758293, 'no_speech_prob': 0.008134420961141586}, {'id': 635, 'seek': 392214, 'start': 3944.3799999999997, 'end': 3951.3799999999997, 'text': ' could potentially fit into this SIMD machines. What is that, right? GPUs.', 'tokens': [51476, 727, 7263, 3318, 666, 341, 24738, 35, 8379, 13, 708, 307, 300, 11, 558, 30, 18407, 82, 13, 51826], 'temperature': 0.0, 'avg_logprob': -0.1771375846862793, 'compression_ratio': 1.6161137440758293, 'no_speech_prob': 0.008134420961141586}, {'id': 636, 'seek': 395214, 'start': 3952.14, 'end': 3959.14, 'text': ' Right, because they have what are called SIMD cores in them and those SIMD cores try to', 'tokens': [50364, 1779, 11, 570, 436, 362, 437, 366, 1219, 24738, 35, 24826, 294, 552, 293, 729, 24738, 35, 24826, 853, 281, 50714], 'temperature': 0.0, 'avg_logprob': -0.19701780591692244, 'compression_ratio': 1.7598039215686274, 'no_speech_prob': 0.005815063137561083}, {'id': 637, 'seek': 395214, 'start': 3959.74, 'end': 3966.3799999999997, 'text': ' execute instructions in parallel, same instructions on multiple data, right. It is actually I', 'tokens': [50744, 14483, 9415, 294, 8952, 11, 912, 9415, 322, 3866, 1412, 11, 558, 13, 467, 307, 767, 286, 51076], 'temperature': 0.0, 'avg_logprob': -0.19701780591692244, 'compression_ratio': 1.7598039215686274, 'no_speech_prob': 0.005815063137561083}, {'id': 638, 'seek': 395214, 'start': 3966.3799999999997, 'end': 3971.74, 'text': ' mean people classify this as SIMD, single instructions multiple threads, but it actually', 'tokens': [51076, 914, 561, 33872, 341, 382, 24738, 35, 11, 2167, 9415, 3866, 19314, 11, 457, 309, 767, 51344], 'temperature': 0.0, 'avg_logprob': -0.19701780591692244, 'compression_ratio': 1.7598039215686274, 'no_speech_prob': 0.005815063137561083}, {'id': 639, 'seek': 395214, 'start': 3971.74, 'end': 3977.94, 'text': ' operates on multiple data values, right. That is also a SIMD machine, right. If you have', 'tokens': [51344, 22577, 322, 3866, 1412, 4190, 11, 558, 13, 663, 307, 611, 257, 24738, 35, 3479, 11, 558, 13, 759, 291, 362, 51654], 'temperature': 0.0, 'avg_logprob': -0.19701780591692244, 'compression_ratio': 1.7598039215686274, 'no_speech_prob': 0.005815063137561083}, {'id': 640, 'seek': 397794, 'start': 3977.94, 'end': 3982.66, 'text': ' not heard about graphics processing unit, go to NVIDIA, right, for a visit and they', 'tokens': [50364, 406, 2198, 466, 11837, 9007, 4985, 11, 352, 281, 426, 3958, 6914, 11, 558, 11, 337, 257, 3441, 293, 436, 50600], 'temperature': 0.0, 'avg_logprob': -0.16641759872436523, 'compression_ratio': 1.5158730158730158, 'no_speech_prob': 0.005827995482832193}, {'id': 641, 'seek': 397794, 'start': 3982.66, 'end': 3984.86, 'text': ' will tell you what it is.', 'tokens': [50600, 486, 980, 291, 437, 309, 307, 13, 50710], 'temperature': 0.0, 'avg_logprob': -0.16641759872436523, 'compression_ratio': 1.5158730158730158, 'no_speech_prob': 0.005827995482832193}, {'id': 642, 'seek': 397794, 'start': 3984.86, 'end': 3991.86, 'text': ' Okay, so let us focus on this SSE and AVX instructions, okay. This shows in the timeline', 'tokens': [50710, 1033, 11, 370, 718, 505, 1879, 322, 341, 318, 5879, 293, 30198, 55, 9415, 11, 1392, 13, 639, 3110, 294, 264, 12933, 51060], 'temperature': 0.0, 'avg_logprob': -0.16641759872436523, 'compression_ratio': 1.5158730158730158, 'no_speech_prob': 0.005827995482832193}, {'id': 643, 'seek': 397794, 'start': 3994.54, 'end': 4000.62, 'text': ' how these things have evolved, right. I think way back in the 97 we had this MMX instructions', 'tokens': [51194, 577, 613, 721, 362, 14178, 11, 558, 13, 286, 519, 636, 646, 294, 264, 23399, 321, 632, 341, 34191, 55, 9415, 51498], 'temperature': 0.0, 'avg_logprob': -0.16641759872436523, 'compression_ratio': 1.5158730158730158, 'no_speech_prob': 0.005827995482832193}, {'id': 644, 'seek': 397794, 'start': 4000.62, 'end': 4006.98, 'text': ' which used to operate on 64 or 128 bits. Now today we talk about similar operations which', 'tokens': [51498, 597, 1143, 281, 9651, 322, 12145, 420, 29810, 9239, 13, 823, 965, 321, 751, 466, 2531, 7705, 597, 51816], 'temperature': 0.0, 'avg_logprob': -0.16641759872436523, 'compression_ratio': 1.5158730158730158, 'no_speech_prob': 0.005827995482832193}, {'id': 645, 'seek': 400698, 'start': 4006.98, 'end': 4013.42, 'text': ' are happening on 512 bits. So let us see what this is. I have the example in the next slide.', 'tokens': [50364, 366, 2737, 322, 1025, 4762, 9239, 13, 407, 718, 505, 536, 437, 341, 307, 13, 286, 362, 264, 1365, 294, 264, 958, 4137, 13, 50686], 'temperature': 0.0, 'avg_logprob': -0.18580974416529877, 'compression_ratio': 1.7067307692307692, 'no_speech_prob': 0.006303051020950079}, {'id': 646, 'seek': 400698, 'start': 4013.42, 'end': 4020.42, 'text': ' So this is really what happens, okay. Let us assume I have a register which is 128 bits', 'tokens': [50686, 407, 341, 307, 534, 437, 2314, 11, 1392, 13, 961, 505, 6552, 286, 362, 257, 7280, 597, 307, 29810, 9239, 51036], 'temperature': 0.0, 'avg_logprob': -0.18580974416529877, 'compression_ratio': 1.7067307692307692, 'no_speech_prob': 0.006303051020950079}, {'id': 647, 'seek': 400698, 'start': 4021.46, 'end': 4027.98, 'text': ' long, correct. So I have a set of registers which are 128 bits long and let us say, okay,', 'tokens': [51088, 938, 11, 3006, 13, 407, 286, 362, 257, 992, 295, 38351, 597, 366, 29810, 9239, 938, 293, 718, 505, 584, 11, 1392, 11, 51414], 'temperature': 0.0, 'avg_logprob': -0.18580974416529877, 'compression_ratio': 1.7067307692307692, 'no_speech_prob': 0.006303051020950079}, {'id': 648, 'seek': 400698, 'start': 4027.98, 'end': 4033.4, 'text': ' my operations have kind of shifted, okay. And I have four functional units which can', 'tokens': [51414, 452, 7705, 362, 733, 295, 18892, 11, 1392, 13, 400, 286, 362, 1451, 11745, 6815, 597, 393, 51685], 'temperature': 0.0, 'avg_logprob': -0.18580974416529877, 'compression_ratio': 1.7067307692307692, 'no_speech_prob': 0.006303051020950079}, {'id': 649, 'seek': 403340, 'start': 4033.48, 'end': 4038.88, 'text': ' perform operations. And what I can do is that I can take some parts of X naught and the', 'tokens': [50368, 2042, 7705, 13, 400, 437, 286, 393, 360, 307, 300, 286, 393, 747, 512, 3166, 295, 1783, 13138, 293, 264, 50638], 'temperature': 0.0, 'avg_logprob': -0.16065157613446635, 'compression_ratio': 1.650943396226415, 'no_speech_prob': 0.009196649305522442}, {'id': 650, 'seek': 403340, 'start': 4038.88, 'end': 4044.88, 'text': ' corresponding part of Y naught and I can perform the operation to produce Z naught. Similarly,', 'tokens': [50638, 11760, 644, 295, 398, 13138, 293, 286, 393, 2042, 264, 6916, 281, 5258, 1176, 13138, 13, 13157, 11, 50938], 'temperature': 0.0, 'avg_logprob': -0.16065157613446635, 'compression_ratio': 1.650943396226415, 'no_speech_prob': 0.009196649305522442}, {'id': 651, 'seek': 403340, 'start': 4044.88, 'end': 4051.28, 'text': ' X 1, Y 1, Z 1, X 2, Y 2, Z 2 and so on. This is essentially what happens and this operation', 'tokens': [50938, 1783, 502, 11, 398, 502, 11, 1176, 502, 11, 1783, 568, 11, 398, 568, 11, 1176, 568, 293, 370, 322, 13, 639, 307, 4476, 437, 2314, 293, 341, 6916, 51258], 'temperature': 0.0, 'avg_logprob': -0.16065157613446635, 'compression_ratio': 1.650943396226415, 'no_speech_prob': 0.009196649305522442}, {'id': 652, 'seek': 403340, 'start': 4051.28, 'end': 4057.8, 'text': ' can be add, subtract, multiply or logical operations whatever it is, right.', 'tokens': [51258, 393, 312, 909, 11, 16390, 11, 12972, 420, 14978, 7705, 2035, 309, 307, 11, 558, 13, 51584], 'temperature': 0.0, 'avg_logprob': -0.16065157613446635, 'compression_ratio': 1.650943396226415, 'no_speech_prob': 0.009196649305522442}, {'id': 653, 'seek': 405780, 'start': 4057.8, 'end': 4063.52, 'text': ' So by giving one instruction I am performing operations instead of performing it on 32', 'tokens': [50364, 407, 538, 2902, 472, 10951, 286, 669, 10205, 7705, 2602, 295, 10205, 309, 322, 8858, 50650], 'temperature': 0.0, 'avg_logprob': -0.16816104650497438, 'compression_ratio': 1.6422018348623852, 'no_speech_prob': 0.00714089022949338}, {'id': 654, 'seek': 405780, 'start': 4063.52, 'end': 4069.5600000000004, 'text': ' bits, I am performing it on 128 bits. Therefore that single operation essentially results', 'tokens': [50650, 9239, 11, 286, 669, 10205, 309, 322, 29810, 9239, 13, 7504, 300, 2167, 6916, 4476, 3542, 50952], 'temperature': 0.0, 'avg_logprob': -0.16816104650497438, 'compression_ratio': 1.6422018348623852, 'no_speech_prob': 0.00714089022949338}, {'id': 655, 'seek': 405780, 'start': 4069.5600000000004, 'end': 4075.5600000000004, 'text': ' in four parallel operations at the same time. This is essentially what we call as SIMD execution', 'tokens': [50952, 294, 1451, 8952, 7705, 412, 264, 912, 565, 13, 639, 307, 4476, 437, 321, 818, 382, 24738, 35, 15058, 51252], 'temperature': 0.0, 'avg_logprob': -0.16816104650497438, 'compression_ratio': 1.6422018348623852, 'no_speech_prob': 0.00714089022949338}, {'id': 656, 'seek': 405780, 'start': 4075.5600000000004, 'end': 4081.92, 'text': ' or SSC or AVX or whatever you want to call it, okay. Modern processors including the', 'tokens': [51252, 420, 12238, 34, 420, 30198, 55, 420, 2035, 291, 528, 281, 818, 309, 11, 1392, 13, 19814, 27751, 3009, 264, 51570], 'temperature': 0.0, 'avg_logprob': -0.16816104650497438, 'compression_ratio': 1.6422018348623852, 'no_speech_prob': 0.00714089022949338}, {'id': 657, 'seek': 408192, 'start': 4081.96, 'end': 4088.96, 'text': ' processors that you have in your laptop and desktop today support some form of AVX instruction.', 'tokens': [50366, 27751, 300, 291, 362, 294, 428, 10732, 293, 14502, 965, 1406, 512, 1254, 295, 30198, 55, 10951, 13, 50716], 'temperature': 0.0, 'avg_logprob': -0.16673554314507377, 'compression_ratio': 1.7294117647058824, 'no_speech_prob': 0.01239842176437378}, {'id': 658, 'seek': 408192, 'start': 4089.08, 'end': 4093.32, 'text': ' So today afternoon in the lab session you will try to find out whether your compiler', 'tokens': [50722, 407, 965, 6499, 294, 264, 2715, 5481, 291, 486, 853, 281, 915, 484, 1968, 428, 31958, 50934], 'temperature': 0.0, 'avg_logprob': -0.16673554314507377, 'compression_ratio': 1.7294117647058824, 'no_speech_prob': 0.01239842176437378}, {'id': 659, 'seek': 408192, 'start': 4093.32, 'end': 4099.04, 'text': ' can generate code so that it can make use of those processors capability, right. That', 'tokens': [50934, 393, 8460, 3089, 370, 300, 309, 393, 652, 764, 295, 729, 27751, 13759, 11, 558, 13, 663, 51220], 'temperature': 0.0, 'avg_logprob': -0.16673554314507377, 'compression_ratio': 1.7294117647058824, 'no_speech_prob': 0.01239842176437378}, {'id': 660, 'seek': 408192, 'start': 4099.04, 'end': 4103.4400000000005, 'text': ' is something that you will see. Again the reason that we are trying to study is that', 'tokens': [51220, 307, 746, 300, 291, 486, 536, 13, 3764, 264, 1778, 300, 321, 366, 1382, 281, 2979, 307, 300, 51440], 'temperature': 0.0, 'avg_logprob': -0.16673554314507377, 'compression_ratio': 1.7294117647058824, 'no_speech_prob': 0.01239842176437378}, {'id': 661, 'seek': 408192, 'start': 4103.4400000000005, 'end': 4108.4400000000005, 'text': ' what should I do as a compiler writer in order for me to generate code for these parallel', 'tokens': [51440, 437, 820, 286, 360, 382, 257, 31958, 9936, 294, 1668, 337, 385, 281, 8460, 3089, 337, 613, 8952, 51690], 'temperature': 0.0, 'avg_logprob': -0.16673554314507377, 'compression_ratio': 1.7294117647058824, 'no_speech_prob': 0.01239842176437378}, {'id': 662, 'seek': 410844, 'start': 4108.44, 'end': 4112.679999999999, 'text': ' machines, right. That is really what we are trying to look at. But first thing is that', 'tokens': [50364, 8379, 11, 558, 13, 663, 307, 534, 437, 321, 366, 1382, 281, 574, 412, 13, 583, 700, 551, 307, 300, 50576], 'temperature': 0.0, 'avg_logprob': -0.1657124137878418, 'compression_ratio': 1.7306122448979593, 'no_speech_prob': 0.00852845050394535}, {'id': 663, 'seek': 410844, 'start': 4112.679999999999, 'end': 4116.799999999999, 'text': ' we need to understand what these things are, right, okay.', 'tokens': [50576, 321, 643, 281, 1223, 437, 613, 721, 366, 11, 558, 11, 1392, 13, 50782], 'temperature': 0.0, 'avg_logprob': -0.1657124137878418, 'compression_ratio': 1.7306122448979593, 'no_speech_prob': 0.00852845050394535}, {'id': 664, 'seek': 410844, 'start': 4116.799999999999, 'end': 4122.719999999999, 'text': ' So for example Intel, okay Intel of more recent kind let us say if you are looking at Skylake', 'tokens': [50782, 407, 337, 1365, 19762, 11, 1392, 19762, 295, 544, 5162, 733, 718, 505, 584, 498, 291, 366, 1237, 412, 9879, 75, 619, 51078], 'temperature': 0.0, 'avg_logprob': -0.1657124137878418, 'compression_ratio': 1.7306122448979593, 'no_speech_prob': 0.00852845050394535}, {'id': 665, 'seek': 410844, 'start': 4122.719999999999, 'end': 4129.719999999999, 'text': ' kind of a processor would have a 512 bit register which means that on that you can do 16 single', 'tokens': [51078, 733, 295, 257, 15321, 576, 362, 257, 1025, 4762, 857, 7280, 597, 1355, 300, 322, 300, 291, 393, 360, 3165, 2167, 51428], 'temperature': 0.0, 'avg_logprob': -0.1657124137878418, 'compression_ratio': 1.7306122448979593, 'no_speech_prob': 0.00852845050394535}, {'id': 666, 'seek': 410844, 'start': 4131.16, 'end': 4138.16, 'text': ' precision floating point operations or 8 double precision floating point operations or 32', 'tokens': [51500, 18356, 12607, 935, 7705, 420, 1649, 3834, 18356, 12607, 935, 7705, 420, 8858, 51850], 'temperature': 0.0, 'avg_logprob': -0.1657124137878418, 'compression_ratio': 1.7306122448979593, 'no_speech_prob': 0.00852845050394535}, {'id': 667, 'seek': 413844, 'start': 4138.44, 'end': 4143.599999999999, 'text': ' 16 bit operations and so on and so forth, right. Where are those 16 bits and 8 bits', 'tokens': [50364, 3165, 857, 7705, 293, 370, 322, 293, 370, 5220, 11, 558, 13, 2305, 366, 729, 3165, 9239, 293, 1649, 9239, 50622], 'temperature': 0.0, 'avg_logprob': -0.2686192989349365, 'compression_ratio': 1.5441176470588236, 'no_speech_prob': 0.0008935173973441124}, {'id': 668, 'seek': 413844, 'start': 4143.599999999999, 'end': 4149.4, 'text': ' are relevant? All of you should know the keyword, buzzword.', 'tokens': [50622, 366, 7340, 30, 1057, 295, 291, 820, 458, 264, 20428, 11, 13036, 7462, 13, 50912], 'temperature': 0.0, 'avg_logprob': -0.2686192989349365, 'compression_ratio': 1.5441176470588236, 'no_speech_prob': 0.0008935173973441124}, {'id': 669, 'seek': 413844, 'start': 4149.4, 'end': 4154.44, 'text': ' Machine learning, deep learning, right. They all work with low precision things so that', 'tokens': [50912, 22155, 2539, 11, 2452, 2539, 11, 558, 13, 814, 439, 589, 365, 2295, 18356, 721, 370, 300, 51164], 'temperature': 0.0, 'avg_logprob': -0.2686192989349365, 'compression_ratio': 1.5441176470588236, 'no_speech_prob': 0.0008935173973441124}, {'id': 670, 'seek': 413844, 'start': 4154.44, 'end': 4161.44, 'text': ' you can actually do using these 512 bits, right. What 64 parallel operations, 8 bit', 'tokens': [51164, 291, 393, 767, 360, 1228, 613, 1025, 4762, 9239, 11, 558, 13, 708, 12145, 8952, 7705, 11, 1649, 857, 51514], 'temperature': 0.0, 'avg_logprob': -0.2686192989349365, 'compression_ratio': 1.5441176470588236, 'no_speech_prob': 0.0008935173973441124}, {'id': 671, 'seek': 416144, 'start': 4162.24, 'end': 4169.24, 'text': ' operations, correct. So all of that is possible. It also has 256 and 128 bit registers and these', 'tokens': [50404, 7705, 11, 3006, 13, 407, 439, 295, 300, 307, 1944, 13, 467, 611, 575, 38882, 293, 29810, 857, 38351, 293, 613, 50754], 'temperature': 0.0, 'avg_logprob': -0.13462794004981196, 'compression_ratio': 1.5573770491803278, 'no_speech_prob': 0.0019886638037860394}, {'id': 672, 'seek': 416144, 'start': 4171.599999999999, 'end': 4178.599999999999, 'text': ' are called by different names, okay. So there you go, right. If you have a 256 bit register', 'tokens': [50872, 366, 1219, 538, 819, 5288, 11, 1392, 13, 407, 456, 291, 352, 11, 558, 13, 759, 291, 362, 257, 38882, 857, 7280, 51222], 'temperature': 0.0, 'avg_logprob': -0.13462794004981196, 'compression_ratio': 1.5573770491803278, 'no_speech_prob': 0.0019886638037860394}, {'id': 673, 'seek': 416144, 'start': 4179.919999999999, 'end': 4186.48, 'text': ' on that you can do 8 single precision floating point operations or 4 double precision operations', 'tokens': [51288, 322, 300, 291, 393, 360, 1649, 2167, 18356, 12607, 935, 7705, 420, 1017, 3834, 18356, 7705, 51616], 'temperature': 0.0, 'avg_logprob': -0.13462794004981196, 'compression_ratio': 1.5573770491803278, 'no_speech_prob': 0.0019886638037860394}, {'id': 674, 'seek': 418648, 'start': 4186.48, 'end': 4193.48, 'text': ' or 32 8 bit operation, right. These are typically used in machine learning kind of applications,', 'tokens': [50364, 420, 8858, 1649, 857, 6916, 11, 558, 13, 1981, 366, 5850, 1143, 294, 3479, 2539, 733, 295, 5821, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.2184341521490188, 'compression_ratio': 1.5422222222222222, 'no_speech_prob': 0.00416081678122282}, {'id': 675, 'seek': 418648, 'start': 4194.24, 'end': 4201.24, 'text': ' right. So if you have read about GPUs and GPUs capable of having a very high AI flops,', 'tokens': [50752, 558, 13, 407, 498, 291, 362, 1401, 466, 18407, 82, 293, 18407, 82, 8189, 295, 1419, 257, 588, 1090, 7318, 932, 3370, 11, 51102], 'temperature': 0.0, 'avg_logprob': -0.2184341521490188, 'compression_ratio': 1.5422222222222222, 'no_speech_prob': 0.00416081678122282}, {'id': 676, 'seek': 418648, 'start': 4202.32, 'end': 4208.16, 'text': ' AI floating point operation this is really what they are talking about, okay.', 'tokens': [51156, 7318, 12607, 935, 6916, 341, 307, 534, 437, 436, 366, 1417, 466, 11, 1392, 13, 51448], 'temperature': 0.0, 'avg_logprob': -0.2184341521490188, 'compression_ratio': 1.5422222222222222, 'no_speech_prob': 0.00416081678122282}, {'id': 677, 'seek': 418648, 'start': 4208.16, 'end': 4213.82, 'text': ' Now this is all fine. Architecture provides you all these features, right. Programmer', 'tokens': [51448, 823, 341, 307, 439, 2489, 13, 43049, 6417, 291, 439, 613, 4122, 11, 558, 13, 8338, 936, 51731], 'temperature': 0.0, 'avg_logprob': -0.2184341521490188, 'compression_ratio': 1.5422222222222222, 'no_speech_prob': 0.00416081678122282}, {'id': 678, 'seek': 421382, 'start': 4213.82, 'end': 4219.66, 'text': ' do not write code like this. You still have to take the code for i is equal to 1 to 10,', 'tokens': [50364, 360, 406, 2464, 3089, 411, 341, 13, 509, 920, 362, 281, 747, 264, 3089, 337, 741, 307, 2681, 281, 502, 281, 1266, 11, 50656], 'temperature': 0.0, 'avg_logprob': -0.20481526969683053, 'compression_ratio': 1.6330275229357798, 'no_speech_prob': 0.007980084046721458}, {'id': 679, 'seek': 421382, 'start': 4219.66, 'end': 4225.0199999999995, 'text': ' a of i is equal to b of i plus c of i. How do I generate code for that, right. That is', 'tokens': [50656, 257, 295, 741, 307, 2681, 281, 272, 295, 741, 1804, 269, 295, 741, 13, 1012, 360, 286, 8460, 3089, 337, 300, 11, 558, 13, 663, 307, 50924], 'temperature': 0.0, 'avg_logprob': -0.20481526969683053, 'compression_ratio': 1.6330275229357798, 'no_speech_prob': 0.007980084046721458}, {'id': 680, 'seek': 421382, 'start': 4225.0199999999995, 'end': 4232.0199999999995, 'text': ' the problem that we are trying to talk about, okay. So compilers have automatic vectorizations', 'tokens': [50924, 264, 1154, 300, 321, 366, 1382, 281, 751, 466, 11, 1392, 13, 407, 715, 388, 433, 362, 12509, 8062, 14455, 51274], 'temperature': 0.0, 'avg_logprob': -0.20481526969683053, 'compression_ratio': 1.6330275229357798, 'no_speech_prob': 0.007980084046721458}, {'id': 681, 'seek': 421382, 'start': 4233.0599999999995, 'end': 4237.099999999999, 'text': ' which is what we all enjoy like we say okay I do not have to do any work. I just press', 'tokens': [51326, 597, 307, 437, 321, 439, 2103, 411, 321, 584, 1392, 286, 360, 406, 362, 281, 360, 604, 589, 13, 286, 445, 1886, 51528], 'temperature': 0.0, 'avg_logprob': -0.20481526969683053, 'compression_ratio': 1.6330275229357798, 'no_speech_prob': 0.007980084046721458}, {'id': 682, 'seek': 423710, 'start': 4237.14, 'end': 4244.14, 'text': ' the button if it can do it is good. It typically works on simple programs, okay and to certain', 'tokens': [50366, 264, 2960, 498, 309, 393, 360, 309, 307, 665, 13, 467, 5850, 1985, 322, 2199, 4268, 11, 1392, 293, 281, 1629, 50716], 'temperature': 0.0, 'avg_logprob': -0.2117481231689453, 'compression_ratio': 1.5606060606060606, 'no_speech_prob': 0.00918197724968195}, {'id': 683, 'seek': 423710, 'start': 4245.660000000001, 'end': 4251.46, 'text': ' extent it helps you. So you can see where it works and where it does not or you can', 'tokens': [50792, 8396, 309, 3665, 291, 13, 407, 291, 393, 536, 689, 309, 1985, 293, 689, 309, 775, 406, 420, 291, 393, 51082], 'temperature': 0.0, 'avg_logprob': -0.2117481231689453, 'compression_ratio': 1.5606060606060606, 'no_speech_prob': 0.00918197724968195}, {'id': 684, 'seek': 423710, 'start': 4251.46, 'end': 4257.02, 'text': ' do thread. So okay so let me give you the example of automatic vectorization before', 'tokens': [51082, 360, 7207, 13, 407, 1392, 370, 718, 385, 976, 291, 264, 1365, 295, 12509, 8062, 2144, 949, 51360], 'temperature': 0.0, 'avg_logprob': -0.2117481231689453, 'compression_ratio': 1.5606060606060606, 'no_speech_prob': 0.00918197724968195}, {'id': 685, 'seek': 423710, 'start': 4257.02, 'end': 4260.22, 'text': ' I go to different other methods of doing this.', 'tokens': [51360, 286, 352, 281, 819, 661, 7150, 295, 884, 341, 13, 51520], 'temperature': 0.0, 'avg_logprob': -0.2117481231689453, 'compression_ratio': 1.5606060606060606, 'no_speech_prob': 0.00918197724968195}, {'id': 686, 'seek': 426022, 'start': 4260.22, 'end': 4267.22, 'text': ' So again here I have three arrays x, y and z each 256 elements and we are basically trying', 'tokens': [50364, 407, 797, 510, 286, 362, 1045, 41011, 2031, 11, 288, 293, 710, 1184, 38882, 4959, 293, 321, 366, 1936, 1382, 50714], 'temperature': 0.0, 'avg_logprob': -0.24260758817865608, 'compression_ratio': 1.5330396475770924, 'no_speech_prob': 0.03158394992351532}, {'id': 687, 'seek': 426022, 'start': 4267.820000000001, 'end': 4274.06, 'text': ' to perform write some kind of element wise product operations on this, right. y of i', 'tokens': [50744, 281, 2042, 2464, 512, 733, 295, 4478, 10829, 1674, 7705, 322, 341, 11, 558, 13, 288, 295, 741, 51056], 'temperature': 0.0, 'avg_logprob': -0.24260758817865608, 'compression_ratio': 1.5330396475770924, 'no_speech_prob': 0.03158394992351532}, {'id': 688, 'seek': 426022, 'start': 4274.06, 'end': 4280.42, 'text': ' is equal to well I should have said z of i but does not matter, okay. So you look at', 'tokens': [51056, 307, 2681, 281, 731, 286, 820, 362, 848, 710, 295, 741, 457, 775, 406, 1871, 11, 1392, 13, 407, 291, 574, 412, 51374], 'temperature': 0.0, 'avg_logprob': -0.24260758817865608, 'compression_ratio': 1.5330396475770924, 'no_speech_prob': 0.03158394992351532}, {'id': 689, 'seek': 426022, 'start': 4280.42, 'end': 4286.42, 'text': ' the code over here very complicated. I do not even understand what this is, okay. There', 'tokens': [51374, 264, 3089, 670, 510, 588, 6179, 13, 286, 360, 406, 754, 1223, 437, 341, 307, 11, 1392, 13, 821, 51674], 'temperature': 0.0, 'avg_logprob': -0.24260758817865608, 'compression_ratio': 1.5330396475770924, 'no_speech_prob': 0.03158394992351532}, {'id': 690, 'seek': 428642, 'start': 4286.74, 'end': 4293.74, 'text': ' are two move instructions which basically move array y and array z into these two registers,', 'tokens': [50380, 366, 732, 1286, 9415, 597, 1936, 1286, 10225, 288, 293, 10225, 710, 666, 613, 732, 38351, 11, 50730], 'temperature': 0.0, 'avg_logprob': -0.2405337691307068, 'compression_ratio': 1.606060606060606, 'no_speech_prob': 0.013365324586629868}, {'id': 691, 'seek': 428642, 'start': 4294.62, 'end': 4301.62, 'text': ' okay. And these move instructions would move a set of 16 or 32 words together depending', 'tokens': [50774, 1392, 13, 400, 613, 1286, 9415, 576, 1286, 257, 992, 295, 3165, 420, 8858, 2283, 1214, 5413, 51124], 'temperature': 0.0, 'avg_logprob': -0.2405337691307068, 'compression_ratio': 1.606060606060606, 'no_speech_prob': 0.013365324586629868}, {'id': 692, 'seek': 428642, 'start': 4302.58, 'end': 4309.58, 'text': ' on the size, okay. x is actually 512 bits so it will actually move 16, 32 bit values', 'tokens': [51172, 322, 264, 2744, 11, 1392, 13, 2031, 307, 767, 1025, 4762, 9239, 370, 309, 486, 767, 1286, 3165, 11, 8858, 857, 4190, 51522], 'temperature': 0.0, 'avg_logprob': -0.2405337691307068, 'compression_ratio': 1.606060606060606, 'no_speech_prob': 0.013365324586629868}, {'id': 693, 'seek': 430958, 'start': 4309.58, 'end': 4316.58, 'text': ' into that, right. Then you do a multiply. So the v essentially says it is a vector operation.', 'tokens': [50364, 666, 300, 11, 558, 13, 1396, 291, 360, 257, 12972, 13, 407, 264, 371, 4476, 1619, 309, 307, 257, 8062, 6916, 13, 50714], 'temperature': 0.0, 'avg_logprob': -0.1714595158894857, 'compression_ratio': 1.7428571428571429, 'no_speech_prob': 0.0024996374268084764}, {'id': 694, 'seek': 430958, 'start': 4317.58, 'end': 4323.62, 'text': ' So it will actually do a parallel multiply of this xmm on register with xmm to register.', 'tokens': [50764, 407, 309, 486, 767, 360, 257, 8952, 12972, 295, 341, 2031, 2174, 322, 7280, 365, 2031, 2174, 281, 7280, 13, 51066], 'temperature': 0.0, 'avg_logprob': -0.1714595158894857, 'compression_ratio': 1.7428571428571429, 'no_speech_prob': 0.0024996374268084764}, {'id': 695, 'seek': 430958, 'start': 4323.62, 'end': 4330.38, 'text': ' So you will see something like this happening, right, okay. First you move the operand from', 'tokens': [51066, 407, 291, 486, 536, 746, 411, 341, 2737, 11, 558, 11, 1392, 13, 2386, 291, 1286, 264, 2208, 474, 490, 51404], 'temperature': 0.0, 'avg_logprob': -0.1714595158894857, 'compression_ratio': 1.7428571428571429, 'no_speech_prob': 0.0024996374268084764}, {'id': 696, 'seek': 430958, 'start': 4330.38, 'end': 4337.38, 'text': ' the memory into these registers and then you perform this parallel multiplication, correct.', 'tokens': [51404, 264, 4675, 666, 613, 38351, 293, 550, 291, 2042, 341, 8952, 27290, 11, 3006, 13, 51754], 'temperature': 0.0, 'avg_logprob': -0.1714595158894857, 'compression_ratio': 1.7428571428571429, 'no_speech_prob': 0.0024996374268084764}, {'id': 697, 'seek': 433738, 'start': 4337.38, 'end': 4342.34, 'text': ' And then you store these values back into the other array, right. That is again the', 'tokens': [50364, 400, 550, 291, 3531, 613, 4190, 646, 666, 264, 661, 10225, 11, 558, 13, 663, 307, 797, 264, 50612], 'temperature': 0.0, 'avg_logprob': -0.14556158420651458, 'compression_ratio': 1.726829268292683, 'no_speech_prob': 0.0007393776904791594}, {'id': 698, 'seek': 433738, 'start': 4342.34, 'end': 4347.9800000000005, 'text': ' move operation. So as I mentioned this should have been z not y, okay. So you are essentially', 'tokens': [50612, 1286, 6916, 13, 407, 382, 286, 2835, 341, 820, 362, 668, 710, 406, 288, 11, 1392, 13, 407, 291, 366, 4476, 50894], 'temperature': 0.0, 'avg_logprob': -0.14556158420651458, 'compression_ratio': 1.726829268292683, 'no_speech_prob': 0.0007393776904791594}, {'id': 699, 'seek': 433738, 'start': 4347.9800000000005, 'end': 4354.9800000000005, 'text': ' moving this xmm 0 back into the z array. So these four operations, each one of these four', 'tokens': [50894, 2684, 341, 2031, 2174, 1958, 646, 666, 264, 710, 10225, 13, 407, 613, 1451, 7705, 11, 1184, 472, 295, 613, 1451, 51244], 'temperature': 0.0, 'avg_logprob': -0.14556158420651458, 'compression_ratio': 1.726829268292683, 'no_speech_prob': 0.0007393776904791594}, {'id': 700, 'seek': 433738, 'start': 4356.22, 'end': 4363.22, 'text': ' operations essentially perform equivalent of 16, 32 bit operation, right. And they all', 'tokens': [51306, 7705, 4476, 2042, 10344, 295, 3165, 11, 8858, 857, 6916, 11, 558, 13, 400, 436, 439, 51656], 'temperature': 0.0, 'avg_logprob': -0.14556158420651458, 'compression_ratio': 1.726829268292683, 'no_speech_prob': 0.0007393776904791594}, {'id': 701, 'seek': 436322, 'start': 4363.860000000001, 'end': 4368.7, 'text': ' can be performed in the same amount of time whether you perform one operation or 16 operation.', 'tokens': [50396, 393, 312, 10332, 294, 264, 912, 2372, 295, 565, 1968, 291, 2042, 472, 6916, 420, 3165, 6916, 13, 50638], 'temperature': 0.0, 'avg_logprob': -0.18067111221014284, 'compression_ratio': 1.7035573122529644, 'no_speech_prob': 0.0009897049749270082}, {'id': 702, 'seek': 436322, 'start': 4368.7, 'end': 4374.76, 'text': ' The time taken is same because they are all going to be done in parallel, right, okay.', 'tokens': [50638, 440, 565, 2726, 307, 912, 570, 436, 366, 439, 516, 281, 312, 1096, 294, 8952, 11, 558, 11, 1392, 13, 50941], 'temperature': 0.0, 'avg_logprob': -0.18067111221014284, 'compression_ratio': 1.7035573122529644, 'no_speech_prob': 0.0009897049749270082}, {'id': 703, 'seek': 436322, 'start': 4374.76, 'end': 4379.18, 'text': ' So this is how the code is going to look like. So afternoon when you compile your code for', 'tokens': [50941, 407, 341, 307, 577, 264, 3089, 307, 516, 281, 574, 411, 13, 407, 6499, 562, 291, 31413, 428, 3089, 337, 51162], 'temperature': 0.0, 'avg_logprob': -0.18067111221014284, 'compression_ratio': 1.7035573122529644, 'no_speech_prob': 0.0009897049749270082}, {'id': 704, 'seek': 436322, 'start': 4379.18, 'end': 4385.42, 'text': ' vectorization do expect to see some really messy code like this, okay.', 'tokens': [51162, 8062, 2144, 360, 2066, 281, 536, 512, 534, 16191, 3089, 411, 341, 11, 1392, 13, 51474], 'temperature': 0.0, 'avg_logprob': -0.18067111221014284, 'compression_ratio': 1.7035573122529644, 'no_speech_prob': 0.0009897049749270082}, {'id': 705, 'seek': 436322, 'start': 4385.42, 'end': 4392.42, 'text': ' Now you asked a question about vectorization and cache. Is that question still there or', 'tokens': [51474, 823, 291, 2351, 257, 1168, 466, 8062, 2144, 293, 19459, 13, 1119, 300, 1168, 920, 456, 420, 51824], 'temperature': 0.0, 'avg_logprob': -0.18067111221014284, 'compression_ratio': 1.7035573122529644, 'no_speech_prob': 0.0009897049749270082}, {'id': 706, 'seek': 439242, 'start': 4392.42, 'end': 4398.62, 'text': ' not? It is gone, correct. So why do not I ask you the question? Supposing let us say', 'tokens': [50364, 406, 30, 467, 307, 2780, 11, 3006, 13, 407, 983, 360, 406, 286, 1029, 291, 264, 1168, 30, 9391, 6110, 718, 505, 584, 50674], 'temperature': 0.0, 'avg_logprob': -0.2692539469401042, 'compression_ratio': 1.4153005464480874, 'no_speech_prob': 0.007287012878805399}, {'id': 707, 'seek': 439242, 'start': 4398.62, 'end': 4405.62, 'text': ' I have a two dimensional array xij, right and I want to multiply x of i0 with y of i0', 'tokens': [50674, 286, 362, 257, 732, 18795, 10225, 2031, 1718, 11, 558, 293, 286, 528, 281, 12972, 2031, 295, 741, 15, 365, 288, 295, 741, 15, 51024], 'temperature': 0.0, 'avg_logprob': -0.2692539469401042, 'compression_ratio': 1.4153005464480874, 'no_speech_prob': 0.007287012878805399}, {'id': 708, 'seek': 439242, 'start': 4411.9800000000005, 'end': 4418.9800000000005, 'text': ' for different values of i. Then what happens? Assume row major ordering, right. Again we', 'tokens': [51342, 337, 819, 4190, 295, 741, 13, 1396, 437, 2314, 30, 6281, 2540, 5386, 2563, 21739, 11, 558, 13, 3764, 321, 51692], 'temperature': 0.0, 'avg_logprob': -0.2692539469401042, 'compression_ratio': 1.4153005464480874, 'no_speech_prob': 0.007287012878805399}, {'id': 709, 'seek': 441898, 'start': 4419.98, 'end': 4426.98, 'text': ' are doing the same thing. If it had been like x of, I mean if I am doing x of i0, i1, i2,', 'tokens': [50414, 366, 884, 264, 912, 551, 13, 759, 309, 632, 668, 411, 2031, 295, 11, 286, 914, 498, 286, 669, 884, 2031, 295, 741, 15, 11, 741, 16, 11, 741, 17, 11, 50764], 'temperature': 0.0, 'avg_logprob': -0.19947963290744358, 'compression_ratio': 1.640552995391705, 'no_speech_prob': 0.009016991592943668}, {'id': 710, 'seek': 441898, 'start': 4428.219999999999, 'end': 4434.179999999999, 'text': ' i3 with y of i0, i1, i2, i3 you could have easily brought them, correct. Spatial locality', 'tokens': [50826, 741, 18, 365, 288, 295, 741, 15, 11, 741, 16, 11, 741, 17, 11, 741, 18, 291, 727, 362, 3612, 3038, 552, 11, 3006, 13, 1738, 267, 831, 1628, 1860, 51124], 'temperature': 0.0, 'avg_logprob': -0.19947963290744358, 'compression_ratio': 1.640552995391705, 'no_speech_prob': 0.009016991592943668}, {'id': 711, 'seek': 441898, 'start': 4434.179999999999, 'end': 4439.179999999999, 'text': ' would have been there, you would have brought it to these 512 bit registers and you could', 'tokens': [51124, 576, 362, 668, 456, 11, 291, 576, 362, 3038, 309, 281, 613, 1025, 4762, 857, 38351, 293, 291, 727, 51374], 'temperature': 0.0, 'avg_logprob': -0.19947963290744358, 'compression_ratio': 1.640552995391705, 'no_speech_prob': 0.009016991592943668}, {'id': 712, 'seek': 441898, 'start': 4439.179999999999, 'end': 4444.179999999999, 'text': ' have performed the operation, everything is fine. That case was no problem. But let us', 'tokens': [51374, 362, 10332, 264, 6916, 11, 1203, 307, 2489, 13, 663, 1389, 390, 572, 1154, 13, 583, 718, 505, 51624], 'temperature': 0.0, 'avg_logprob': -0.19947963290744358, 'compression_ratio': 1.640552995391705, 'no_speech_prob': 0.009016991592943668}, {'id': 713, 'seek': 444418, 'start': 4444.18, 'end': 4451.18, 'text': ' say I want to multiply x00, x10, x20, x40 with y10, y20, y30 and y40. Now these move', 'tokens': [50364, 584, 286, 528, 281, 12972, 2031, 628, 11, 2031, 3279, 11, 2031, 2009, 11, 2031, 5254, 365, 288, 3279, 11, 288, 2009, 11, 288, 3446, 293, 288, 5254, 13, 823, 613, 1286, 50714], 'temperature': 0.0, 'avg_logprob': -0.1245313312696374, 'compression_ratio': 1.5562130177514792, 'no_speech_prob': 0.019630221650004387}, {'id': 714, 'seek': 444418, 'start': 4456.54, 'end': 4463.22, 'text': ' operations which are actually able to move things together, right is going to struggle', 'tokens': [50982, 7705, 597, 366, 767, 1075, 281, 1286, 721, 1214, 11, 558, 307, 516, 281, 7799, 51316], 'temperature': 0.0, 'avg_logprob': -0.1245313312696374, 'compression_ratio': 1.5562130177514792, 'no_speech_prob': 0.019630221650004387}, {'id': 715, 'seek': 444418, 'start': 4463.22, 'end': 4469.860000000001, 'text': ' because these are in different locations in the memory and therefore in different locations', 'tokens': [51316, 570, 613, 366, 294, 819, 9253, 294, 264, 4675, 293, 4412, 294, 819, 9253, 51648], 'temperature': 0.0, 'avg_logprob': -0.1245313312696374, 'compression_ratio': 1.5562130177514792, 'no_speech_prob': 0.019630221650004387}, {'id': 716, 'seek': 446986, 'start': 4469.86, 'end': 4476.86, 'text': ' in the cache, right. So, if this move takes let us say t cycles,', 'tokens': [50364, 294, 264, 19459, 11, 558, 13, 407, 11, 498, 341, 1286, 2516, 718, 505, 584, 256, 17796, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.1740302928658419, 'compression_ratio': 1.6485148514851484, 'no_speech_prob': 0.00922271516174078}, {'id': 717, 'seek': 446986, 'start': 4477.94, 'end': 4484.94, 'text': ' that move if it is done inefficiently will take n times t, n times t, t times 4 not t', 'tokens': [50768, 300, 1286, 498, 309, 307, 1096, 43495, 356, 486, 747, 297, 1413, 256, 11, 297, 1413, 256, 11, 256, 1413, 1017, 406, 256, 51118], 'temperature': 0.0, 'avg_logprob': -0.1740302928658419, 'compression_ratio': 1.6485148514851484, 'no_speech_prob': 0.00922271516174078}, {'id': 718, 'seek': 446986, 'start': 4485.94, 'end': 4492.82, 'text': ' plus 4, t times 4 or t times 16 amount of time. But then there are some intelligent', 'tokens': [51168, 1804, 1017, 11, 256, 1413, 1017, 420, 256, 1413, 3165, 2372, 295, 565, 13, 583, 550, 456, 366, 512, 13232, 51512], 'temperature': 0.0, 'avg_logprob': -0.1740302928658419, 'compression_ratio': 1.6485148514851484, 'no_speech_prob': 0.00922271516174078}, {'id': 719, 'seek': 446986, 'start': 4492.82, 'end': 4499.46, 'text': ' operations like gather, right which will actually take values from different locations and somehow', 'tokens': [51512, 7705, 411, 5448, 11, 558, 597, 486, 767, 747, 4190, 490, 819, 9253, 293, 6063, 51844], 'temperature': 0.0, 'avg_logprob': -0.1740302928658419, 'compression_ratio': 1.6485148514851484, 'no_speech_prob': 0.00922271516174078}, {'id': 720, 'seek': 449946, 'start': 4499.46, 'end': 4505.82, 'text': ' try to push these things in a way which is faster but definitely not in t, okay. So,', 'tokens': [50364, 853, 281, 2944, 613, 721, 294, 257, 636, 597, 307, 4663, 457, 2138, 406, 294, 256, 11, 1392, 13, 407, 11, 50682], 'temperature': 0.0, 'avg_logprob': -0.2127268488814191, 'compression_ratio': 1.6713615023474178, 'no_speech_prob': 0.001569736865349114}, {'id': 721, 'seek': 449946, 'start': 4505.82, 'end': 4511.02, 'text': ' you use gather operations to move those operations into a vector register. Then of course you', 'tokens': [50682, 291, 764, 5448, 7705, 281, 1286, 729, 7705, 666, 257, 8062, 7280, 13, 1396, 295, 1164, 291, 50942], 'temperature': 0.0, 'avg_logprob': -0.2127268488814191, 'compression_ratio': 1.6713615023474178, 'no_speech_prob': 0.001569736865349114}, {'id': 722, 'seek': 449946, 'start': 4511.02, 'end': 4518.02, 'text': ' can perform these operations we multiply d together and then you put a scatter operation', 'tokens': [50942, 393, 2042, 613, 7705, 321, 12972, 274, 1214, 293, 550, 291, 829, 257, 34951, 6916, 51292], 'temperature': 0.0, 'avg_logprob': -0.2127268488814191, 'compression_ratio': 1.6713615023474178, 'no_speech_prob': 0.001569736865349114}, {'id': 723, 'seek': 449946, 'start': 4518.3, 'end': 4522.94, 'text': ' which will actually put it in different places in the memory, possible to do that, okay.', 'tokens': [51306, 597, 486, 767, 829, 309, 294, 819, 3190, 294, 264, 4675, 11, 1944, 281, 360, 300, 11, 1392, 13, 51538], 'temperature': 0.0, 'avg_logprob': -0.2127268488814191, 'compression_ratio': 1.6713615023474178, 'no_speech_prob': 0.001569736865349114}, {'id': 724, 'seek': 452294, 'start': 4522.94, 'end': 4529.94, 'text': ' There is a cost additional cost but it is better than doing it as a scalar, right possible,', 'tokens': [50364, 821, 307, 257, 2063, 4497, 2063, 457, 309, 307, 1101, 813, 884, 309, 382, 257, 39684, 11, 558, 1944, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.18998822477674976, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.029611729085445404}, {'id': 725, 'seek': 452294, 'start': 4530.86, 'end': 4537.0199999999995, 'text': ' okay. So, there are lots of things that are happening and what we now need to do is that', 'tokens': [50760, 1392, 13, 407, 11, 456, 366, 3195, 295, 721, 300, 366, 2737, 293, 437, 321, 586, 643, 281, 360, 307, 300, 51068], 'temperature': 0.0, 'avg_logprob': -0.18998822477674976, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.029611729085445404}, {'id': 726, 'seek': 452294, 'start': 4537.0199999999995, 'end': 4542.98, 'text': ' since architecture is doing all these things as compiler writer we should be able to generate', 'tokens': [51068, 1670, 9482, 307, 884, 439, 613, 721, 382, 31958, 9936, 321, 820, 312, 1075, 281, 8460, 51366], 'temperature': 0.0, 'avg_logprob': -0.18998822477674976, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.029611729085445404}, {'id': 727, 'seek': 452294, 'start': 4542.98, 'end': 4546.66, 'text': ' code appropriately. For example, if my architecture supports scatter', 'tokens': [51366, 3089, 23505, 13, 1171, 1365, 11, 498, 452, 9482, 9346, 34951, 51550], 'temperature': 0.0, 'avg_logprob': -0.18998822477674976, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.029611729085445404}, {'id': 728, 'seek': 452294, 'start': 4546.66, 'end': 4551.139999999999, 'text': ' gather and I have a program which is like this I should rather use the scatter gather', 'tokens': [51550, 5448, 293, 286, 362, 257, 1461, 597, 307, 411, 341, 286, 820, 2831, 764, 264, 34951, 5448, 51774], 'temperature': 0.0, 'avg_logprob': -0.18998822477674976, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.029611729085445404}, {'id': 729, 'seek': 455114, 'start': 4551.14, 'end': 4558.14, 'text': ' instructions to do that efficiently, right. Again more challenges for the compiler writer,', 'tokens': [50364, 9415, 281, 360, 300, 19621, 11, 558, 13, 3764, 544, 4759, 337, 264, 31958, 9936, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.21947860717773438, 'compression_ratio': 1.543103448275862, 'no_speech_prob': 0.008852814324200153}, {'id': 730, 'seek': 455114, 'start': 4559.740000000001, 'end': 4565.62, 'text': ' okay. So, how do we exploit vectorization from our processors? Either you could use', 'tokens': [50794, 1392, 13, 407, 11, 577, 360, 321, 25924, 8062, 2144, 490, 527, 27751, 30, 13746, 291, 727, 764, 51088], 'temperature': 0.0, 'avg_logprob': -0.21947860717773438, 'compression_ratio': 1.543103448275862, 'no_speech_prob': 0.008852814324200153}, {'id': 731, 'seek': 455114, 'start': 4565.62, 'end': 4571.46, 'text': ' automatic vectorization so GCC or something will have, right the appropriate flag which', 'tokens': [51088, 12509, 8062, 2144, 370, 460, 11717, 420, 746, 486, 362, 11, 558, 264, 6854, 7166, 597, 51380], 'temperature': 0.0, 'avg_logprob': -0.21947860717773438, 'compression_ratio': 1.543103448275862, 'no_speech_prob': 0.008852814324200153}, {'id': 732, 'seek': 455114, 'start': 4571.46, 'end': 4578.46, 'text': ' helps you to do this, okay. But it may work for some simple cases like this but not necessarily', 'tokens': [51380, 3665, 291, 281, 360, 341, 11, 1392, 13, 583, 309, 815, 589, 337, 512, 2199, 3331, 411, 341, 457, 406, 4725, 51730], 'temperature': 0.0, 'avg_logprob': -0.21947860717773438, 'compression_ratio': 1.543103448275862, 'no_speech_prob': 0.008852814324200153}, {'id': 733, 'seek': 457846, 'start': 4579.46, 'end': 4586.46, 'text': ' for all possible cases, right. You can also do one thing you can also indicate which arrays', 'tokens': [50414, 337, 439, 1944, 3331, 11, 558, 13, 509, 393, 611, 360, 472, 551, 291, 393, 611, 13330, 597, 41011, 50764], 'temperature': 0.0, 'avg_logprob': -0.22535647948582968, 'compression_ratio': 1.6857142857142857, 'no_speech_prob': 0.005929978098720312}, {'id': 734, 'seek': 457846, 'start': 4586.9, 'end': 4592.06, 'text': ' or vectors where you are likely to perform vector operations and declare them as vector', 'tokens': [50786, 420, 18875, 689, 291, 366, 3700, 281, 2042, 8062, 7705, 293, 19710, 552, 382, 8062, 51044], 'temperature': 0.0, 'avg_logprob': -0.22535647948582968, 'compression_ratio': 1.6857142857142857, 'no_speech_prob': 0.005929978098720312}, {'id': 735, 'seek': 457846, 'start': 4592.06, 'end': 4598.06, 'text': ' arrays, vector data types and the compiler will take that hint and then try to vectorize', 'tokens': [51044, 41011, 11, 8062, 1412, 3467, 293, 264, 31958, 486, 747, 300, 12075, 293, 550, 853, 281, 8062, 1125, 51344], 'temperature': 0.0, 'avg_logprob': -0.22535647948582968, 'compression_ratio': 1.6857142857142857, 'no_speech_prob': 0.005929978098720312}, {'id': 736, 'seek': 457846, 'start': 4598.06, 'end': 4602.06, 'text': ' it. That is another approach. Again I am not going to go into all the details of how to', 'tokens': [51344, 309, 13, 663, 307, 1071, 3109, 13, 3764, 286, 669, 406, 516, 281, 352, 666, 439, 264, 4365, 295, 577, 281, 51544], 'temperature': 0.0, 'avg_logprob': -0.22535647948582968, 'compression_ratio': 1.6857142857142857, 'no_speech_prob': 0.005929978098720312}, {'id': 737, 'seek': 457846, 'start': 4602.06, 'end': 4606.78, 'text': ' do that etcetera because that is really not the purpose.', 'tokens': [51544, 360, 300, 22066, 570, 300, 307, 534, 406, 264, 4334, 13, 51780], 'temperature': 0.0, 'avg_logprob': -0.22535647948582968, 'compression_ratio': 1.6857142857142857, 'no_speech_prob': 0.005929978098720312}, {'id': 738, 'seek': 460678, 'start': 4606.78, 'end': 4612.46, 'text': ' You can also write vector intrinsic functions which actually does all of these things, okay.', 'tokens': [50364, 509, 393, 611, 2464, 8062, 35698, 6828, 597, 767, 775, 439, 295, 613, 721, 11, 1392, 13, 50648], 'temperature': 0.0, 'avg_logprob': -0.1551432836623419, 'compression_ratio': 1.811965811965812, 'no_speech_prob': 0.018848078325390816}, {'id': 739, 'seek': 460678, 'start': 4612.46, 'end': 4617.78, 'text': ' Here I write the bad code in this form and then I give this to the compiler. The compiler', 'tokens': [50648, 1692, 286, 2464, 264, 1578, 3089, 294, 341, 1254, 293, 550, 286, 976, 341, 281, 264, 31958, 13, 440, 31958, 50914], 'temperature': 0.0, 'avg_logprob': -0.1551432836623419, 'compression_ratio': 1.811965811965812, 'no_speech_prob': 0.018848078325390816}, {'id': 740, 'seek': 460678, 'start': 4617.78, 'end': 4624.42, 'text': ' uses this to generate vector code. So, you can do one of these three things, okay. But', 'tokens': [50914, 4960, 341, 281, 8460, 8062, 3089, 13, 407, 11, 291, 393, 360, 472, 295, 613, 1045, 721, 11, 1392, 13, 583, 51246], 'temperature': 0.0, 'avg_logprob': -0.1551432836623419, 'compression_ratio': 1.811965811965812, 'no_speech_prob': 0.018848078325390816}, {'id': 741, 'seek': 460678, 'start': 4624.42, 'end': 4629.62, 'text': ' now we will ask the following question. How do I know that this array this loop can be', 'tokens': [51246, 586, 321, 486, 1029, 264, 3480, 1168, 13, 1012, 360, 286, 458, 300, 341, 10225, 341, 6367, 393, 312, 51506], 'temperature': 0.0, 'avg_logprob': -0.1551432836623419, 'compression_ratio': 1.811965811965812, 'no_speech_prob': 0.018848078325390816}, {'id': 742, 'seek': 460678, 'start': 4629.62, 'end': 4636.62, 'text': ' vectorized, right? How do we know that this loop can be vectorized?', 'tokens': [51506, 8062, 1602, 11, 558, 30, 1012, 360, 321, 458, 300, 341, 6367, 393, 312, 8062, 1602, 30, 51856], 'temperature': 0.0, 'avg_logprob': -0.1551432836623419, 'compression_ratio': 1.811965811965812, 'no_speech_prob': 0.018848078325390816}, {'id': 743, 'seek': 463678, 'start': 4636.78, 'end': 4643.78, 'text': ' We have to do certain analysis to figure out that this can be vectorized, right? And', 'tokens': [50364, 492, 362, 281, 360, 1629, 5215, 281, 2573, 484, 300, 341, 393, 312, 8062, 1602, 11, 558, 30, 400, 50714], 'temperature': 0.0, 'avg_logprob': -0.13730004559392514, 'compression_ratio': 1.7673267326732673, 'no_speech_prob': 0.0010088376002386212}, {'id': 744, 'seek': 463678, 'start': 4644.34, 'end': 4649.82, 'text': ' that is when you can actually generate code like this. In fact if GCC or LLVM is generating', 'tokens': [50742, 300, 307, 562, 291, 393, 767, 8460, 3089, 411, 341, 13, 682, 1186, 498, 460, 11717, 420, 441, 43, 53, 44, 307, 17746, 51016], 'temperature': 0.0, 'avg_logprob': -0.13730004559392514, 'compression_ratio': 1.7673267326732673, 'no_speech_prob': 0.0010088376002386212}, {'id': 745, 'seek': 463678, 'start': 4649.82, 'end': 4656.099999999999, 'text': ' code like this they must be doing that analysis because all I wrote was this. Then it figured', 'tokens': [51016, 3089, 411, 341, 436, 1633, 312, 884, 300, 5215, 570, 439, 286, 4114, 390, 341, 13, 1396, 309, 8932, 51330], 'temperature': 0.0, 'avg_logprob': -0.13730004559392514, 'compression_ratio': 1.7673267326732673, 'no_speech_prob': 0.0010088376002386212}, {'id': 746, 'seek': 463678, 'start': 4656.099999999999, 'end': 4661.9, 'text': ' out that this can be vectorized and I have to generate code like this, right. So, that', 'tokens': [51330, 484, 300, 341, 393, 312, 8062, 1602, 293, 286, 362, 281, 8460, 3089, 411, 341, 11, 558, 13, 407, 11, 300, 51620], 'temperature': 0.0, 'avg_logprob': -0.13730004559392514, 'compression_ratio': 1.7673267326732673, 'no_speech_prob': 0.0010088376002386212}, {'id': 747, 'seek': 466190, 'start': 4661.9, 'end': 4667.62, 'text': ' compiler was smart enough to do that by doing certain analysis. What are those analysis,', 'tokens': [50364, 31958, 390, 4069, 1547, 281, 360, 300, 538, 884, 1629, 5215, 13, 708, 366, 729, 5215, 11, 50650], 'temperature': 0.0, 'avg_logprob': -0.20095979083668103, 'compression_ratio': 1.6775700934579438, 'no_speech_prob': 0.018075916916131973}, {'id': 748, 'seek': 466190, 'start': 4667.62, 'end': 4674.62, 'text': ' right? Again we talked about cache locality and other things and said that okay because', 'tokens': [50650, 558, 30, 3764, 321, 2825, 466, 19459, 1628, 1860, 293, 661, 721, 293, 848, 300, 1392, 570, 51000], 'temperature': 0.0, 'avg_logprob': -0.20095979083668103, 'compression_ratio': 1.6775700934579438, 'no_speech_prob': 0.018075916916131973}, {'id': 749, 'seek': 466190, 'start': 4674.98, 'end': 4681.139999999999, 'text': ' you wrote the loop as for j for i it was giving those locality. You have to interchange the', 'tokens': [51018, 291, 4114, 264, 6367, 382, 337, 361, 337, 741, 309, 390, 2902, 729, 1628, 1860, 13, 509, 362, 281, 30358, 264, 51326], 'temperature': 0.0, 'avg_logprob': -0.20095979083668103, 'compression_ratio': 1.6775700934579438, 'no_speech_prob': 0.018075916916131973}, {'id': 750, 'seek': 466190, 'start': 4681.139999999999, 'end': 4687.58, 'text': ' loops. How do we figure that out, right? And how do we analyze that and how do we say when', 'tokens': [51326, 16121, 13, 1012, 360, 321, 2573, 300, 484, 11, 558, 30, 400, 577, 360, 321, 12477, 300, 293, 577, 360, 321, 584, 562, 51648], 'temperature': 0.0, 'avg_logprob': -0.20095979083668103, 'compression_ratio': 1.6775700934579438, 'no_speech_prob': 0.018075916916131973}, {'id': 751, 'seek': 468758, 'start': 4687.58, 'end': 4692.5, 'text': ' we can actually interchange loops? Can we interchange in all occasions? No, you may', 'tokens': [50364, 321, 393, 767, 30358, 16121, 30, 1664, 321, 30358, 294, 439, 20641, 30, 883, 11, 291, 815, 50610], 'temperature': 0.0, 'avg_logprob': -0.18204514682292938, 'compression_ratio': 1.7157894736842105, 'no_speech_prob': 0.014655942097306252}, {'id': 752, 'seek': 468758, 'start': 4692.5, 'end': 4697.78, 'text': ' violate some dependency. So, how do we do those analysis, right? We will try to see', 'tokens': [50610, 37478, 512, 33621, 13, 407, 11, 577, 360, 321, 360, 729, 5215, 11, 558, 30, 492, 486, 853, 281, 536, 50874], 'temperature': 0.0, 'avg_logprob': -0.18204514682292938, 'compression_ratio': 1.7157894736842105, 'no_speech_prob': 0.014655942097306252}, {'id': 753, 'seek': 468758, 'start': 4697.78, 'end': 4702.98, 'text': ' some of these things very briefly, right, in the afternoon class, okay. That I am going', 'tokens': [50874, 512, 295, 613, 721, 588, 10515, 11, 558, 11, 294, 264, 6499, 1508, 11, 1392, 13, 663, 286, 669, 516, 51134], 'temperature': 0.0, 'avg_logprob': -0.18204514682292938, 'compression_ratio': 1.7157894736842105, 'no_speech_prob': 0.014655942097306252}, {'id': 754, 'seek': 468758, 'start': 4702.98, 'end': 4707.18, 'text': ' to do it slightly at a high level. So, I will not go into all the details, but at least', 'tokens': [51134, 281, 360, 309, 4748, 412, 257, 1090, 1496, 13, 407, 11, 286, 486, 406, 352, 666, 439, 264, 4365, 11, 457, 412, 1935, 51344], 'temperature': 0.0, 'avg_logprob': -0.18204514682292938, 'compression_ratio': 1.7157894736842105, 'no_speech_prob': 0.014655942097306252}, {'id': 755, 'seek': 468758, 'start': 4707.18, 'end': 4710.82, 'text': ' try to tell you what is in there and what we need to do.', 'tokens': [51344, 853, 281, 980, 291, 437, 307, 294, 456, 293, 437, 321, 643, 281, 360, 13, 51526], 'temperature': 0.0, 'avg_logprob': -0.18204514682292938, 'compression_ratio': 1.7157894736842105, 'no_speech_prob': 0.014655942097306252}, {'id': 756, 'seek': 468758, 'start': 4710.82, 'end': 4715.5, 'text': ' So, I want you to before we conclude this session I want you to take back this following', 'tokens': [51526, 407, 11, 286, 528, 291, 281, 949, 321, 16886, 341, 5481, 286, 528, 291, 281, 747, 646, 341, 3480, 51760], 'temperature': 0.0, 'avg_logprob': -0.18204514682292938, 'compression_ratio': 1.7157894736842105, 'no_speech_prob': 0.014655942097306252}, {'id': 757, 'seek': 471550, 'start': 4715.7, 'end': 4721.46, 'text': ' things. Although in the last two days we talked about a lot of mundane things like code generation,', 'tokens': [50374, 721, 13, 5780, 294, 264, 1036, 732, 1708, 321, 2825, 466, 257, 688, 295, 43497, 721, 411, 3089, 5125, 11, 50662], 'temperature': 0.0, 'avg_logprob': -0.19638063289501048, 'compression_ratio': 1.8221343873517786, 'no_speech_prob': 0.11346790939569473}, {'id': 758, 'seek': 471550, 'start': 4721.46, 'end': 4726.7, 'text': ' register allocation, instruction scheduling, all of this look like some nitty-gritty details,', 'tokens': [50662, 7280, 27599, 11, 10951, 29055, 11, 439, 295, 341, 574, 411, 512, 297, 10016, 12, 861, 10016, 4365, 11, 50924], 'temperature': 0.0, 'avg_logprob': -0.19638063289501048, 'compression_ratio': 1.8221343873517786, 'no_speech_prob': 0.11346790939569473}, {'id': 759, 'seek': 471550, 'start': 4726.7, 'end': 4732.82, 'text': ' right, may be trying to say one cycle here, one cycle there kind of a thing. It is not', 'tokens': [50924, 558, 11, 815, 312, 1382, 281, 584, 472, 6586, 510, 11, 472, 6586, 456, 733, 295, 257, 551, 13, 467, 307, 406, 51230], 'temperature': 0.0, 'avg_logprob': -0.19638063289501048, 'compression_ratio': 1.8221343873517786, 'no_speech_prob': 0.11346790939569473}, {'id': 760, 'seek': 471550, 'start': 4732.82, 'end': 4738.9, 'text': ' about that. It is about the new features which are coming in the processors, the new things', 'tokens': [51230, 466, 300, 13, 467, 307, 466, 264, 777, 4122, 597, 366, 1348, 294, 264, 27751, 11, 264, 777, 721, 51534], 'temperature': 0.0, 'avg_logprob': -0.19638063289501048, 'compression_ratio': 1.8221343873517786, 'no_speech_prob': 0.11346790939569473}, {'id': 761, 'seek': 471550, 'start': 4738.9, 'end': 4744.34, 'text': ' that are coming in the processor and being able to generate code automatically for that.', 'tokens': [51534, 300, 366, 1348, 294, 264, 15321, 293, 885, 1075, 281, 8460, 3089, 6772, 337, 300, 13, 51806], 'temperature': 0.0, 'avg_logprob': -0.19638063289501048, 'compression_ratio': 1.8221343873517786, 'no_speech_prob': 0.11346790939569473}, {'id': 762, 'seek': 474434, 'start': 4744.34, 'end': 4751.34, 'text': ' That is why compiler design is exciting, right. Today you have GPUs. How do I generate code', 'tokens': [50364, 663, 307, 983, 31958, 1715, 307, 4670, 11, 558, 13, 2692, 291, 362, 18407, 82, 13, 1012, 360, 286, 8460, 3089, 50714], 'temperature': 0.0, 'avg_logprob': -0.22385321941572367, 'compression_ratio': 1.617117117117117, 'no_speech_prob': 0.016613367944955826}, {'id': 763, 'seek': 474434, 'start': 4752.5, 'end': 4759.1, 'text': ' for GPUs? Can I take your C program and then automatically generate a CUDA code which will', 'tokens': [50772, 337, 18407, 82, 30, 1664, 286, 747, 428, 383, 1461, 293, 550, 6772, 8460, 257, 29777, 7509, 3089, 597, 486, 51102], 'temperature': 0.0, 'avg_logprob': -0.22385321941572367, 'compression_ratio': 1.617117117117117, 'no_speech_prob': 0.016613367944955826}, {'id': 764, 'seek': 474434, 'start': 4759.1, 'end': 4765.42, 'text': ' do certain things, right? Or if I have a CUDA code can I analyze it and make it better for', 'tokens': [51102, 360, 1629, 721, 11, 558, 30, 1610, 498, 286, 362, 257, 29777, 7509, 3089, 393, 286, 12477, 309, 293, 652, 309, 1101, 337, 51418], 'temperature': 0.0, 'avg_logprob': -0.22385321941572367, 'compression_ratio': 1.617117117117117, 'no_speech_prob': 0.016613367944955826}, {'id': 765, 'seek': 474434, 'start': 4765.42, 'end': 4772.42, 'text': ' the GPUs, right? Or if I have a C code can I exploit the AVX capabilities in the CPUs', 'tokens': [51418, 264, 18407, 82, 11, 558, 30, 1610, 498, 286, 362, 257, 383, 3089, 393, 286, 25924, 264, 30198, 55, 10862, 294, 264, 13199, 82, 51768], 'temperature': 0.0, 'avg_logprob': -0.22385321941572367, 'compression_ratio': 1.617117117117117, 'no_speech_prob': 0.016613367944955826}, {'id': 766, 'seek': 477434, 'start': 4774.34, 'end': 4780.54, 'text': ' of the processor? Or if my processor has four cores, eight cores, all your processors has', 'tokens': [50364, 295, 264, 15321, 30, 1610, 498, 452, 15321, 575, 1451, 24826, 11, 3180, 24826, 11, 439, 428, 27751, 575, 50674], 'temperature': 0.0, 'avg_logprob': -0.2098069327218192, 'compression_ratio': 1.8414634146341464, 'no_speech_prob': 0.00410864083096385}, {'id': 767, 'seek': 477434, 'start': 4780.54, 'end': 4787.54, 'text': ' four cores and eight cores. How many of your programs are exploiting that? May be nothing,', 'tokens': [50674, 1451, 24826, 293, 3180, 24826, 13, 1012, 867, 295, 428, 4268, 366, 12382, 1748, 300, 30, 1891, 312, 1825, 11, 51024], 'temperature': 0.0, 'avg_logprob': -0.2098069327218192, 'compression_ratio': 1.8414634146341464, 'no_speech_prob': 0.00410864083096385}, {'id': 768, 'seek': 477434, 'start': 4787.54, 'end': 4792.7, 'text': ' right, because you did not put the proper compiler switch or may be the proper compiler', 'tokens': [51024, 558, 11, 570, 291, 630, 406, 829, 264, 2296, 31958, 3679, 420, 815, 312, 264, 2296, 31958, 51282], 'temperature': 0.0, 'avg_logprob': -0.2098069327218192, 'compression_ratio': 1.8414634146341464, 'no_speech_prob': 0.00410864083096385}, {'id': 769, 'seek': 477434, 'start': 4792.7, 'end': 4797.42, 'text': ' switch is not yet available to automatically parallelize some of them. Can you write one', 'tokens': [51282, 3679, 307, 406, 1939, 2435, 281, 6772, 8952, 1125, 512, 295, 552, 13, 1664, 291, 2464, 472, 51518], 'temperature': 0.0, 'avg_logprob': -0.2098069327218192, 'compression_ratio': 1.8414634146341464, 'no_speech_prob': 0.00410864083096385}, {'id': 770, 'seek': 477434, 'start': 4797.42, 'end': 4804.26, 'text': ' of that, right? So, there are lots of interesting opportunities in compiler design, right, that', 'tokens': [51518, 295, 300, 11, 558, 30, 407, 11, 456, 366, 3195, 295, 1880, 4786, 294, 31958, 1715, 11, 558, 11, 300, 51860], 'temperature': 0.0, 'avg_logprob': -0.2098069327218192, 'compression_ratio': 1.8414634146341464, 'no_speech_prob': 0.00410864083096385}, {'id': 771, 'seek': 480426, 'start': 4804.26, 'end': 4810.26, 'text': ' you can actually do to exploit that. So, do not think of compiler design as oh that lexical', 'tokens': [50364, 291, 393, 767, 360, 281, 25924, 300, 13, 407, 11, 360, 406, 519, 295, 31958, 1715, 382, 1954, 300, 476, 87, 804, 50664], 'temperature': 0.0, 'avg_logprob': -0.21092594501584075, 'compression_ratio': 1.5803571428571428, 'no_speech_prob': 0.0012296950444579124}, {'id': 772, 'seek': 480426, 'start': 4810.26, 'end': 4816.66, 'text': ' analysis parsing blah blah and you know. I mean today nobody really talks about many', 'tokens': [50664, 5215, 21156, 278, 12288, 12288, 293, 291, 458, 13, 286, 914, 965, 5079, 534, 6686, 466, 867, 50984], 'temperature': 0.0, 'avg_logprob': -0.21092594501584075, 'compression_ratio': 1.5803571428571428, 'no_speech_prob': 0.0012296950444579124}, {'id': 773, 'seek': 480426, 'start': 4816.66, 'end': 4821.46, 'text': ' of these things. It is important for us to understand to know how they are done, but', 'tokens': [50984, 295, 613, 721, 13, 467, 307, 1021, 337, 505, 281, 1223, 281, 458, 577, 436, 366, 1096, 11, 457, 51224], 'temperature': 0.0, 'avg_logprob': -0.21092594501584075, 'compression_ratio': 1.5803571428571428, 'no_speech_prob': 0.0012296950444579124}, {'id': 774, 'seek': 480426, 'start': 4821.46, 'end': 4827.58, 'text': ' there are lots and lots of interesting challenges and opportunities in compilers, okay. Many', 'tokens': [51224, 456, 366, 3195, 293, 3195, 295, 1880, 4759, 293, 4786, 294, 715, 388, 433, 11, 1392, 13, 5126, 51530], 'temperature': 0.0, 'avg_logprob': -0.21092594501584075, 'compression_ratio': 1.5803571428571428, 'no_speech_prob': 0.0012296950444579124}, {'id': 775, 'seek': 482758, 'start': 4827.86, 'end': 4834.86, 'text': ' problems that you can work on, right and everyday processors are coming up with more and more', 'tokens': [50378, 2740, 300, 291, 393, 589, 322, 11, 558, 293, 7429, 27751, 366, 1348, 493, 365, 544, 293, 544, 50728], 'temperature': 0.0, 'avg_logprob': -0.22834080663220635, 'compression_ratio': 1.6283185840707965, 'no_speech_prob': 0.028618961572647095}, {'id': 776, 'seek': 482758, 'start': 4835.46, 'end': 4840.54, 'text': ' capability. First of all, I mean let me before I go into that, first of all let me ask you', 'tokens': [50758, 13759, 13, 2386, 295, 439, 11, 286, 914, 718, 385, 949, 286, 352, 666, 300, 11, 700, 295, 439, 718, 385, 1029, 291, 51012], 'temperature': 0.0, 'avg_logprob': -0.22834080663220635, 'compression_ratio': 1.6283185840707965, 'no_speech_prob': 0.028618961572647095}, {'id': 777, 'seek': 482758, 'start': 4840.54, 'end': 4845.9, 'text': ' the following question. Why do we even need compilers? Why cannot we just write programs', 'tokens': [51012, 264, 3480, 1168, 13, 1545, 360, 321, 754, 643, 715, 388, 433, 30, 1545, 2644, 321, 445, 2464, 4268, 51280], 'temperature': 0.0, 'avg_logprob': -0.22834080663220635, 'compression_ratio': 1.6283185840707965, 'no_speech_prob': 0.028618961572647095}, {'id': 778, 'seek': 482758, 'start': 4845.9, 'end': 4852.9, 'text': ' in assembly language? To write large programs is difficult. Even to write an assembly language', 'tokens': [51280, 294, 12103, 2856, 30, 1407, 2464, 2416, 4268, 307, 2252, 13, 2754, 281, 2464, 364, 12103, 2856, 51630], 'temperature': 0.0, 'avg_logprob': -0.22834080663220635, 'compression_ratio': 1.6283185840707965, 'no_speech_prob': 0.028618961572647095}, {'id': 779, 'seek': 485290, 'start': 4852.9, 'end': 4859.9, 'text': ' program, what do you need to know? You need to know about the architecture, machine architecture', 'tokens': [50364, 1461, 11, 437, 360, 291, 643, 281, 458, 30, 509, 643, 281, 458, 466, 264, 9482, 11, 3479, 9482, 50714], 'temperature': 0.0, 'avg_logprob': -0.1736462726149448, 'compression_ratio': 1.7632850241545894, 'no_speech_prob': 0.003726091468706727}, {'id': 780, 'seek': 485290, 'start': 4863.5, 'end': 4868.42, 'text': ' and other things, correct and then the moment you write an assembly program for one machine,', 'tokens': [50894, 293, 661, 721, 11, 3006, 293, 550, 264, 1623, 291, 2464, 364, 12103, 1461, 337, 472, 3479, 11, 51140], 'temperature': 0.0, 'avg_logprob': -0.1736462726149448, 'compression_ratio': 1.7632850241545894, 'no_speech_prob': 0.003726091468706727}, {'id': 781, 'seek': 485290, 'start': 4868.42, 'end': 4873.42, 'text': ' if you want to take it to some other machine, you will have to redo the whole work, right.', 'tokens': [51140, 498, 291, 528, 281, 747, 309, 281, 512, 661, 3479, 11, 291, 486, 362, 281, 29956, 264, 1379, 589, 11, 558, 13, 51390], 'temperature': 0.0, 'avg_logprob': -0.1736462726149448, 'compression_ratio': 1.7632850241545894, 'no_speech_prob': 0.003726091468706727}, {'id': 782, 'seek': 485290, 'start': 4873.42, 'end': 4878.62, 'text': ' So, essentially the reason that we have a compiler is that you want to abstract some', 'tokens': [51390, 407, 11, 4476, 264, 1778, 300, 321, 362, 257, 31958, 307, 300, 291, 528, 281, 12649, 512, 51650], 'temperature': 0.0, 'avg_logprob': -0.1736462726149448, 'compression_ratio': 1.7632850241545894, 'no_speech_prob': 0.003726091468706727}, {'id': 783, 'seek': 487862, 'start': 4878.62, 'end': 4883.62, 'text': ' of those details, correct. So, that the programmer need not have to worry about it. He can still', 'tokens': [50364, 295, 729, 4365, 11, 3006, 13, 407, 11, 300, 264, 32116, 643, 406, 362, 281, 3292, 466, 309, 13, 634, 393, 920, 50614], 'temperature': 0.0, 'avg_logprob': -0.15192685334578804, 'compression_ratio': 1.8346774193548387, 'no_speech_prob': 0.007146749645471573}, {'id': 784, 'seek': 487862, 'start': 4883.62, 'end': 4888.62, 'text': ' think of A as an array, B as an array doing some addition, for loop, blah, blah, blah,', 'tokens': [50614, 519, 295, 316, 382, 364, 10225, 11, 363, 382, 364, 10225, 884, 512, 4500, 11, 337, 6367, 11, 12288, 11, 12288, 11, 12288, 11, 50864], 'temperature': 0.0, 'avg_logprob': -0.15192685334578804, 'compression_ratio': 1.8346774193548387, 'no_speech_prob': 0.007146749645471573}, {'id': 785, 'seek': 487862, 'start': 4888.62, 'end': 4893.86, 'text': ' correct. So, everything else is taken care of by the compiler. Similarly, whenever there', 'tokens': [50864, 3006, 13, 407, 11, 1203, 1646, 307, 2726, 1127, 295, 538, 264, 31958, 13, 13157, 11, 5699, 456, 51126], 'temperature': 0.0, 'avg_logprob': -0.15192685334578804, 'compression_ratio': 1.8346774193548387, 'no_speech_prob': 0.007146749645471573}, {'id': 786, 'seek': 487862, 'start': 4893.86, 'end': 4898.58, 'text': ' is a new feature that is coming in the architecture, do you want the programmer to know about it', 'tokens': [51126, 307, 257, 777, 4111, 300, 307, 1348, 294, 264, 9482, 11, 360, 291, 528, 264, 32116, 281, 458, 466, 309, 51362], 'temperature': 0.0, 'avg_logprob': -0.15192685334578804, 'compression_ratio': 1.8346774193548387, 'no_speech_prob': 0.007146749645471573}, {'id': 787, 'seek': 487862, 'start': 4898.58, 'end': 4903.46, 'text': ' and exploit it? Do you want the programmer to write code like this or do you want the', 'tokens': [51362, 293, 25924, 309, 30, 1144, 291, 528, 264, 32116, 281, 2464, 3089, 411, 341, 420, 360, 291, 528, 264, 51606], 'temperature': 0.0, 'avg_logprob': -0.15192685334578804, 'compression_ratio': 1.8346774193548387, 'no_speech_prob': 0.007146749645471573}, {'id': 788, 'seek': 490346, 'start': 4904.02, 'end': 4909.14, 'text': ' compiler to generate code like this? That is the question, right. So, here there is', 'tokens': [50392, 31958, 281, 8460, 3089, 411, 341, 30, 663, 307, 264, 1168, 11, 558, 13, 407, 11, 510, 456, 307, 50648], 'temperature': 0.0, 'avg_logprob': -0.2136586567140975, 'compression_ratio': 1.792828685258964, 'no_speech_prob': 0.0985439196228981}, {'id': 789, 'seek': 490346, 'start': 4909.14, 'end': 4914.22, 'text': ' with explicit arithmetic instructions or data types, here with this with intrinsics where', 'tokens': [50648, 365, 13691, 42973, 9415, 420, 1412, 3467, 11, 510, 365, 341, 365, 28621, 1167, 689, 50902], 'temperature': 0.0, 'avg_logprob': -0.2136586567140975, 'compression_ratio': 1.792828685258964, 'no_speech_prob': 0.0985439196228981}, {'id': 790, 'seek': 490346, 'start': 4914.22, 'end': 4919.7, 'text': ' he has to generate a lot more code by knowing things. So, what do we want them to see? What', 'tokens': [50902, 415, 575, 281, 8460, 257, 688, 544, 3089, 538, 5276, 721, 13, 407, 11, 437, 360, 321, 528, 552, 281, 536, 30, 708, 51176], 'temperature': 0.0, 'avg_logprob': -0.2136586567140975, 'compression_ratio': 1.792828685258964, 'no_speech_prob': 0.0985439196228981}, {'id': 791, 'seek': 490346, 'start': 4919.7, 'end': 4924.7, 'text': ' as compiler writers can we enable them to do, right? That is really the question, right.', 'tokens': [51176, 382, 31958, 13491, 393, 321, 9528, 552, 281, 360, 11, 558, 30, 663, 307, 534, 264, 1168, 11, 558, 13, 51426], 'temperature': 0.0, 'avg_logprob': -0.2136586567140975, 'compression_ratio': 1.792828685258964, 'no_speech_prob': 0.0985439196228981}, {'id': 792, 'seek': 490346, 'start': 4924.7, 'end': 4930.42, 'text': ' So, again there are lots of interesting problems and challenges that could be solved by writing', 'tokens': [51426, 407, 11, 797, 456, 366, 3195, 295, 1880, 2740, 293, 4759, 300, 727, 312, 13041, 538, 3579, 51712], 'temperature': 0.0, 'avg_logprob': -0.2136586567140975, 'compression_ratio': 1.792828685258964, 'no_speech_prob': 0.0985439196228981}, {'id': 793, 'seek': 493042, 'start': 4930.42, 'end': 4937.42, 'text': ' better compilers. So, keep that in mind when you come back for the afternoon session, that', 'tokens': [50364, 1101, 715, 388, 433, 13, 407, 11, 1066, 300, 294, 1575, 562, 291, 808, 646, 337, 264, 6499, 5481, 11, 300, 50714], 'temperature': 0.0, 'avg_logprob': -0.27122437159220375, 'compression_ratio': 1.1685393258426966, 'no_speech_prob': 0.3355086147785187}, {'id': 794, 'seek': 493042, 'start': 4937.42, 'end': 4938.3, 'text': ' we will stop.', 'tokens': [50714, 321, 486, 1590, 13, 50758], 'temperature': 0.0, 'avg_logprob': -0.27122437159220375, 'compression_ratio': 1.1685393258426966, 'no_speech_prob': 0.3355086147785187}]