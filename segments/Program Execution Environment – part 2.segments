[{'id': 0, 'seek': 0, 'start': 0.0, 'end': 15.0, 'text': ' Correct. So, C99 onwards that means if you are using fairly recent compiler it should', 'tokens': [50364, 12753, 13, 407, 11, 383, 8494, 34230, 300, 1355, 498, 291, 366, 1228, 6457, 5162, 31958, 309, 820, 51114], 'temperature': 0.0, 'avg_logprob': -0.22557266422959624, 'compression_ratio': 1.6134969325153374, 'no_speech_prob': 0.22709237039089203}, {'id': 1, 'seek': 0, 'start': 15.0, 'end': 20.0, 'text': ' be there unless you are using some turbo C kind of thing this would not be there, but', 'tokens': [51114, 312, 456, 5969, 291, 366, 1228, 512, 20902, 383, 733, 295, 551, 341, 576, 406, 312, 456, 11, 457, 51364], 'temperature': 0.0, 'avg_logprob': -0.22557266422959624, 'compression_ratio': 1.6134969325153374, 'no_speech_prob': 0.22709237039089203}, {'id': 2, 'seek': 0, 'start': 20.0, 'end': 28.16, 'text': ' in any recent and decent compiler this should be supported. This concept is actually called', 'tokens': [51364, 294, 604, 5162, 293, 8681, 31958, 341, 820, 312, 8104, 13, 639, 3410, 307, 767, 1219, 51772], 'temperature': 0.0, 'avg_logprob': -0.22557266422959624, 'compression_ratio': 1.6134969325153374, 'no_speech_prob': 0.22709237039089203}, {'id': 3, 'seek': 2816, 'start': 28.16, 'end': 39.16, 'text': ' as variable length array or VLA in short form. Now, the question is when you have VLA in', 'tokens': [50364, 382, 7006, 4641, 10225, 420, 691, 11435, 294, 2099, 1254, 13, 823, 11, 264, 1168, 307, 562, 291, 362, 691, 11435, 294, 50914], 'temperature': 0.0, 'avg_logprob': -0.17730058034261068, 'compression_ratio': 1.3082706766917294, 'no_speech_prob': 0.1090066134929657}, {'id': 4, 'seek': 2816, 'start': 39.16, 'end': 50.84, 'text': ' your program how will the offsets computed because n is dynamic value and it can vary', 'tokens': [50914, 428, 1461, 577, 486, 264, 39457, 1385, 40610, 570, 297, 307, 8546, 2158, 293, 309, 393, 10559, 51498], 'temperature': 0.0, 'avg_logprob': -0.17730058034261068, 'compression_ratio': 1.3082706766917294, 'no_speech_prob': 0.1090066134929657}, {'id': 5, 'seek': 5084, 'start': 50.84, 'end': 58.720000000000006, 'text': ' for every call which you make to that function. So, how will you allocate and access the variables?', 'tokens': [50364, 337, 633, 818, 597, 291, 652, 281, 300, 2445, 13, 407, 11, 577, 486, 291, 35713, 293, 2105, 264, 9102, 30, 50758], 'temperature': 0.0, 'avg_logprob': -0.14875568662370955, 'compression_ratio': 1.5138121546961325, 'no_speech_prob': 0.8296288847923279}, {'id': 6, 'seek': 5084, 'start': 58.720000000000006, 'end': 68.04, 'text': ' So far what we have seen is you have ESP from which you can reference and ESP will keep', 'tokens': [50758, 407, 1400, 437, 321, 362, 1612, 307, 291, 362, 12564, 47, 490, 597, 291, 393, 6408, 293, 12564, 47, 486, 1066, 51224], 'temperature': 0.0, 'avg_logprob': -0.14875568662370955, 'compression_ratio': 1.5138121546961325, 'no_speech_prob': 0.8296288847923279}, {'id': 7, 'seek': 5084, 'start': 68.04, 'end': 76.24000000000001, 'text': ' growing or changing. So, whenever you have VLA you have to change the ESP dynamically.', 'tokens': [51224, 4194, 420, 4473, 13, 407, 11, 5699, 291, 362, 691, 11435, 291, 362, 281, 1319, 264, 12564, 47, 43492, 13, 51634], 'temperature': 0.0, 'avg_logprob': -0.14875568662370955, 'compression_ratio': 1.5138121546961325, 'no_speech_prob': 0.8296288847923279}, {'id': 8, 'seek': 7624, 'start': 76.24, 'end': 101.06, 'text': ' Yes. So, that is one way to implement VLA where you can actually allocate it on heap. So,', 'tokens': [50364, 1079, 13, 407, 11, 300, 307, 472, 636, 281, 4445, 691, 11435, 689, 291, 393, 767, 35713, 309, 322, 33591, 13, 407, 11, 51605], 'temperature': 0.0, 'avg_logprob': -0.22836824699684424, 'compression_ratio': 1.0348837209302326, 'no_speech_prob': 0.07735858857631683}, {'id': 9, 'seek': 10106, 'start': 101.06, 'end': 108.10000000000001, 'text': ' that would solve the problem to some extent, but if you had to allocate it on stack then what will', 'tokens': [50364, 300, 576, 5039, 264, 1154, 281, 512, 8396, 11, 457, 498, 291, 632, 281, 35713, 309, 322, 8630, 550, 437, 486, 50716], 'temperature': 0.0, 'avg_logprob': -0.1366894291896446, 'compression_ratio': 1.8056872037914693, 'no_speech_prob': 0.16845549643039703}, {'id': 10, 'seek': 10106, 'start': 108.10000000000001, 'end': 115.46000000000001, 'text': ' you do? By the way the semantics of VLA is by the time function returns you have to deallocate.', 'tokens': [50716, 291, 360, 30, 3146, 264, 636, 264, 4361, 45298, 295, 691, 11435, 307, 538, 264, 565, 2445, 11247, 291, 362, 281, 368, 336, 42869, 13, 51084], 'temperature': 0.0, 'avg_logprob': -0.1366894291896446, 'compression_ratio': 1.8056872037914693, 'no_speech_prob': 0.16845549643039703}, {'id': 11, 'seek': 10106, 'start': 116.5, 'end': 122.02000000000001, 'text': ' So, what you will have to do is you have to insert a malloc call and free call at end of', 'tokens': [51136, 407, 11, 437, 291, 486, 362, 281, 360, 307, 291, 362, 281, 8969, 257, 16026, 905, 818, 293, 1737, 818, 412, 917, 295, 51412], 'temperature': 0.0, 'avg_logprob': -0.1366894291896446, 'compression_ratio': 1.8056872037914693, 'no_speech_prob': 0.16845549643039703}, {'id': 12, 'seek': 10106, 'start': 122.02000000000001, 'end': 128.74, 'text': ' the function. So, that is how you can implement it on heap, but you have to implement it on stack', 'tokens': [51412, 264, 2445, 13, 407, 11, 300, 307, 577, 291, 393, 4445, 309, 322, 33591, 11, 457, 291, 362, 281, 4445, 309, 322, 8630, 51748], 'temperature': 0.0, 'avg_logprob': -0.1366894291896446, 'compression_ratio': 1.8056872037914693, 'no_speech_prob': 0.16845549643039703}, {'id': 13, 'seek': 12874, 'start': 128.74, 'end': 141.10000000000002, 'text': ' what will you do? What I would suggest is today end of day or whenever you have time try writing', 'tokens': [50364, 437, 486, 291, 360, 30, 708, 286, 576, 3402, 307, 965, 917, 295, 786, 420, 5699, 291, 362, 565, 853, 3579, 50982], 'temperature': 0.0, 'avg_logprob': -0.12850685973665607, 'compression_ratio': 1.591160220994475, 'no_speech_prob': 0.007565604988485575}, {'id': 14, 'seek': 12874, 'start': 141.10000000000002, 'end': 147.26000000000002, 'text': ' such programs and look at the assembly and see what kind of stack layout is generated and you', 'tokens': [50982, 1270, 4268, 293, 574, 412, 264, 12103, 293, 536, 437, 733, 295, 8630, 13333, 307, 10833, 293, 291, 51290], 'temperature': 0.0, 'avg_logprob': -0.12850685973665607, 'compression_ratio': 1.591160220994475, 'no_speech_prob': 0.007565604988485575}, {'id': 15, 'seek': 12874, 'start': 147.26000000000002, 'end': 154.54000000000002, 'text': ' can try this with base pointer preserved and with dash f omit base pointer and see how things are', 'tokens': [51290, 393, 853, 341, 365, 3096, 23918, 22242, 293, 365, 8240, 283, 3406, 270, 3096, 23918, 293, 536, 577, 721, 366, 51654], 'temperature': 0.0, 'avg_logprob': -0.12850685973665607, 'compression_ratio': 1.591160220994475, 'no_speech_prob': 0.007565604988485575}, {'id': 16, 'seek': 15454, 'start': 154.54, 'end': 160.82, 'text': ' changing. But this essentially requires dynamic allocation on the stack as the program is running', 'tokens': [50364, 4473, 13, 583, 341, 4476, 7029, 8546, 27599, 322, 264, 8630, 382, 264, 1461, 307, 2614, 50678], 'temperature': 0.0, 'avg_logprob': -0.14670643695565158, 'compression_ratio': 1.6266094420600858, 'no_speech_prob': 0.26248154044151306}, {'id': 17, 'seek': 15454, 'start': 160.82, 'end': 169.14, 'text': ' you have to keep allocating. Any doubts before we kind of move on? So, so far what we have seen is', 'tokens': [50678, 291, 362, 281, 1066, 12660, 990, 13, 2639, 22618, 949, 321, 733, 295, 1286, 322, 30, 407, 11, 370, 1400, 437, 321, 362, 1612, 307, 51094], 'temperature': 0.0, 'avg_logprob': -0.14670643695565158, 'compression_ratio': 1.6266094420600858, 'no_speech_prob': 0.26248154044151306}, {'id': 18, 'seek': 15454, 'start': 169.14, 'end': 175.38, 'text': ' how to handle local variables and we have seen how to transfer control back and forth between', 'tokens': [51094, 577, 281, 4813, 2654, 9102, 293, 321, 362, 1612, 577, 281, 5003, 1969, 646, 293, 5220, 1296, 51406], 'temperature': 0.0, 'avg_logprob': -0.14670643695565158, 'compression_ratio': 1.6266094420600858, 'no_speech_prob': 0.26248154044151306}, {'id': 19, 'seek': 15454, 'start': 175.38, 'end': 180.22, 'text': ' caller and callee. The other thing which is interesting is how the parameters need to be', 'tokens': [51406, 48324, 293, 818, 1653, 13, 440, 661, 551, 597, 307, 1880, 307, 577, 264, 9834, 643, 281, 312, 51648], 'temperature': 0.0, 'avg_logprob': -0.14670643695565158, 'compression_ratio': 1.6266094420600858, 'no_speech_prob': 0.26248154044151306}, {'id': 20, 'seek': 18022, 'start': 180.22, 'end': 187.18, 'text': ' handled. So, we had parameters which need to be passed from caller to callee. Now just like the', 'tokens': [50364, 18033, 13, 407, 11, 321, 632, 9834, 597, 643, 281, 312, 4678, 490, 48324, 281, 818, 1653, 13, 823, 445, 411, 264, 50712], 'temperature': 0.0, 'avg_logprob': -0.15099012333413828, 'compression_ratio': 1.7972350230414746, 'no_speech_prob': 0.244862362742424}, {'id': 21, 'seek': 18022, 'start': 187.18, 'end': 193.18, 'text': ' problems which we had earlier the callee function needs to know where the parameters are so that it', 'tokens': [50712, 2740, 597, 321, 632, 3071, 264, 818, 1653, 2445, 2203, 281, 458, 689, 264, 9834, 366, 370, 300, 309, 51012], 'temperature': 0.0, 'avg_logprob': -0.15099012333413828, 'compression_ratio': 1.7972350230414746, 'no_speech_prob': 0.244862362742424}, {'id': 22, 'seek': 18022, 'start': 193.18, 'end': 199.94, 'text': ' can access it and caller needs to know where the return at value is so that they can interface', 'tokens': [51012, 393, 2105, 309, 293, 48324, 2203, 281, 458, 689, 264, 2736, 412, 2158, 307, 370, 300, 436, 393, 9226, 51350], 'temperature': 0.0, 'avg_logprob': -0.15099012333413828, 'compression_ratio': 1.7972350230414746, 'no_speech_prob': 0.244862362742424}, {'id': 23, 'seek': 18022, 'start': 199.94, 'end': 208.3, 'text': ' between the two. So, typically how will where will you pass parameters? Let us go with the same set', 'tokens': [51350, 1296, 264, 732, 13, 407, 11, 5850, 577, 486, 689, 486, 291, 1320, 9834, 30, 961, 505, 352, 365, 264, 912, 992, 51768], 'temperature': 0.0, 'avg_logprob': -0.15099012333413828, 'compression_ratio': 1.7972350230414746, 'no_speech_prob': 0.244862362742424}, {'id': 24, 'seek': 20830, 'start': 208.38000000000002, 'end': 214.62, 'text': ' of things which we were trying to answer. Can we store them in hardware registers? We may not have', 'tokens': [50368, 295, 721, 597, 321, 645, 1382, 281, 1867, 13, 1664, 321, 3531, 552, 294, 8837, 38351, 30, 492, 815, 406, 362, 50680], 'temperature': 0.0, 'avg_logprob': -0.16024052013050427, 'compression_ratio': 1.670995670995671, 'no_speech_prob': 0.103608138859272}, {'id': 25, 'seek': 20830, 'start': 214.62, 'end': 221.94, 'text': ' sufficient number of registers and plus we might have an aggregate which is like a struct like a', 'tokens': [50680, 11563, 1230, 295, 38351, 293, 1804, 321, 1062, 362, 364, 26118, 597, 307, 411, 257, 6594, 411, 257, 51046], 'temperature': 0.0, 'avg_logprob': -0.16024052013050427, 'compression_ratio': 1.670995670995671, 'no_speech_prob': 0.103608138859272}, {'id': 26, 'seek': 20830, 'start': 221.94, 'end': 227.82000000000002, 'text': ' struct of 10 elements or struct of 5 elements those again may not fit into the registers.', 'tokens': [51046, 6594, 295, 1266, 4959, 420, 6594, 295, 1025, 4959, 729, 797, 815, 406, 3318, 666, 264, 38351, 13, 51340], 'temperature': 0.0, 'avg_logprob': -0.16024052013050427, 'compression_ratio': 1.670995670995671, 'no_speech_prob': 0.103608138859272}, {'id': 27, 'seek': 20830, 'start': 227.82000000000002, 'end': 237.98000000000002, 'text': ' What about global variables? Correct same problem with recursion so the answer is stack. So, now you', 'tokens': [51340, 708, 466, 4338, 9102, 30, 12753, 912, 1154, 365, 20560, 313, 370, 264, 1867, 307, 8630, 13, 407, 11, 586, 291, 51848], 'temperature': 0.0, 'avg_logprob': -0.16024052013050427, 'compression_ratio': 1.670995670995671, 'no_speech_prob': 0.103608138859272}, {'id': 28, 'seek': 23798, 'start': 237.98, 'end': 245.57999999999998, 'text': ' should know at least how to get to stack. So, this is the stack frame which we have seen so far. So,', 'tokens': [50364, 820, 458, 412, 1935, 577, 281, 483, 281, 8630, 13, 407, 11, 341, 307, 264, 8630, 3920, 597, 321, 362, 1612, 370, 1400, 13, 407, 11, 50744], 'temperature': 0.0, 'avg_logprob': -0.1053027692048446, 'compression_ratio': 2.1839080459770117, 'no_speech_prob': 0.0008293857681564987}, {'id': 29, 'seek': 23798, 'start': 245.57999999999998, 'end': 252.1, 'text': ' we have stack frame of the caller function and stack frame of the callee function and here we', 'tokens': [50744, 321, 362, 8630, 3920, 295, 264, 48324, 2445, 293, 8630, 3920, 295, 264, 818, 1653, 2445, 293, 510, 321, 51070], 'temperature': 0.0, 'avg_logprob': -0.1053027692048446, 'compression_ratio': 2.1839080459770117, 'no_speech_prob': 0.0008293857681564987}, {'id': 30, 'seek': 23798, 'start': 252.1, 'end': 258.14, 'text': ' know we have local variables which are stored. So, where should parameters be stored? Should', 'tokens': [51070, 458, 321, 362, 2654, 9102, 597, 366, 12187, 13, 407, 11, 689, 820, 9834, 312, 12187, 30, 6454, 51372], 'temperature': 0.0, 'avg_logprob': -0.1053027692048446, 'compression_ratio': 2.1839080459770117, 'no_speech_prob': 0.0008293857681564987}, {'id': 31, 'seek': 23798, 'start': 258.14, 'end': 262.74, 'text': ' they be stored in the stack frame of callee function or stack frame of the caller functions?', 'tokens': [51372, 436, 312, 12187, 294, 264, 8630, 3920, 295, 818, 1653, 2445, 420, 8630, 3920, 295, 264, 48324, 6828, 30, 51602], 'temperature': 0.0, 'avg_logprob': -0.1053027692048446, 'compression_ratio': 2.1839080459770117, 'no_speech_prob': 0.0008293857681564987}, {'id': 32, 'seek': 26274, 'start': 262.74, 'end': 276.5, 'text': ' Why callee? But how will a caller function allocate something into callee stack frame?', 'tokens': [50364, 1545, 818, 1653, 30, 583, 577, 486, 257, 48324, 2445, 35713, 746, 666, 818, 1653, 8630, 3920, 30, 51052], 'temperature': 0.0, 'avg_logprob': -0.14361248345210634, 'compression_ratio': 1.532544378698225, 'no_speech_prob': 0.014914735220372677}, {'id': 33, 'seek': 26274, 'start': 276.5, 'end': 282.34000000000003, 'text': ' Because remember to access callee stack frame you must have written address already pushed', 'tokens': [51052, 1436, 1604, 281, 2105, 818, 1653, 8630, 3920, 291, 1633, 362, 3720, 2985, 1217, 9152, 51344], 'temperature': 0.0, 'avg_logprob': -0.14361248345210634, 'compression_ratio': 1.532544378698225, 'no_speech_prob': 0.014914735220372677}, {'id': 34, 'seek': 26274, 'start': 282.34000000000003, 'end': 288.54, 'text': ' on to the stack and that will happen only after call instruction is executed. So,', 'tokens': [51344, 322, 281, 264, 8630, 293, 300, 486, 1051, 787, 934, 818, 10951, 307, 17577, 13, 407, 11, 51654], 'temperature': 0.0, 'avg_logprob': -0.14361248345210634, 'compression_ratio': 1.532544378698225, 'no_speech_prob': 0.014914735220372677}, {'id': 35, 'seek': 28854, 'start': 288.54, 'end': 295.70000000000005, 'text': ' how will you say how will you create a hole in the stack? See to be able to allocate in', 'tokens': [50364, 577, 486, 291, 584, 577, 486, 291, 1884, 257, 5458, 294, 264, 8630, 30, 3008, 281, 312, 1075, 281, 35713, 294, 50722], 'temperature': 0.0, 'avg_logprob': -0.14219716462222012, 'compression_ratio': 1.88, 'no_speech_prob': 0.012426207773387432}, {'id': 36, 'seek': 28854, 'start': 295.70000000000005, 'end': 302.94, 'text': ' the callee stack frame what you need is caller is executing somewhere here you need to create', 'tokens': [50722, 264, 818, 1653, 8630, 3920, 437, 291, 643, 307, 48324, 307, 32368, 4079, 510, 291, 643, 281, 1884, 51084], 'temperature': 0.0, 'avg_logprob': -0.14219716462222012, 'compression_ratio': 1.88, 'no_speech_prob': 0.012426207773387432}, {'id': 37, 'seek': 28854, 'start': 302.94, 'end': 308.78000000000003, 'text': ' a hole for return address for the call instruction then allocate stuff here get back stack pointer', 'tokens': [51084, 257, 5458, 337, 2736, 2985, 337, 264, 818, 10951, 550, 35713, 1507, 510, 483, 646, 8630, 23918, 51376], 'temperature': 0.0, 'avg_logprob': -0.14219716462222012, 'compression_ratio': 1.88, 'no_speech_prob': 0.012426207773387432}, {'id': 38, 'seek': 28854, 'start': 308.78000000000003, 'end': 315.66, 'text': ' here and then so that it is laid out. So, it actually gets allocated in the caller stack frame.', 'tokens': [51376, 510, 293, 550, 370, 300, 309, 307, 9897, 484, 13, 407, 11, 309, 767, 2170, 29772, 294, 264, 48324, 8630, 3920, 13, 51720], 'temperature': 0.0, 'avg_logprob': -0.14219716462222012, 'compression_ratio': 1.88, 'no_speech_prob': 0.012426207773387432}, {'id': 39, 'seek': 31566, 'start': 316.66, 'end': 321.90000000000003, 'text': ' So, these are allocated on the caller stack frames. So, caller function will push things', 'tokens': [50414, 407, 11, 613, 366, 29772, 322, 264, 48324, 8630, 12083, 13, 407, 11, 48324, 2445, 486, 2944, 721, 50676], 'temperature': 0.0, 'avg_logprob': -0.16984121916724032, 'compression_ratio': 1.7515527950310559, 'no_speech_prob': 0.0016482388600707054}, {'id': 40, 'seek': 31566, 'start': 321.90000000000003, 'end': 330.98, 'text': ' on to the stack and then the call instruction will push the return address. So, parameters are just', 'tokens': [50676, 322, 281, 264, 8630, 293, 550, 264, 818, 10951, 486, 2944, 264, 2736, 2985, 13, 407, 11, 9834, 366, 445, 51130], 'temperature': 0.0, 'avg_logprob': -0.16984121916724032, 'compression_ratio': 1.7515527950310559, 'no_speech_prob': 0.0016482388600707054}, {'id': 41, 'seek': 31566, 'start': 330.98, 'end': 341.74, 'text': ' above the stack pointer sorry return address and this essentially forms yet another contract.', 'tokens': [51130, 3673, 264, 8630, 23918, 2597, 2736, 2985, 293, 341, 4476, 6422, 1939, 1071, 4364, 13, 51668], 'temperature': 0.0, 'avg_logprob': -0.16984121916724032, 'compression_ratio': 1.7515527950310559, 'no_speech_prob': 0.0016482388600707054}, {'id': 42, 'seek': 34174, 'start': 341.78000000000003, 'end': 349.14, 'text': ' Now, callee needs to access things from the caller stack frame. Does everyone understand', 'tokens': [50366, 823, 11, 818, 1653, 2203, 281, 2105, 721, 490, 264, 48324, 8630, 3920, 13, 4402, 1518, 1223, 50734], 'temperature': 0.0, 'avg_logprob': -0.1935912874009874, 'compression_ratio': 1.9045226130653266, 'no_speech_prob': 0.0071190642192959785}, {'id': 43, 'seek': 34174, 'start': 349.14, 'end': 355.1, 'text': ' this? We could not allocate it in callee stack frame because caller does not have access to', 'tokens': [50734, 341, 30, 492, 727, 406, 35713, 309, 294, 818, 1653, 8630, 3920, 570, 48324, 775, 406, 362, 2105, 281, 51032], 'temperature': 0.0, 'avg_logprob': -0.1935912874009874, 'compression_ratio': 1.9045226130653266, 'no_speech_prob': 0.0071190642192959785}, {'id': 44, 'seek': 34174, 'start': 355.1, 'end': 361.5, 'text': ' callee stack frame, but callee can access callers stack frame and this kind of gets to a point which', 'tokens': [51032, 818, 1653, 8630, 3920, 11, 457, 818, 1653, 393, 2105, 818, 433, 8630, 3920, 293, 341, 733, 295, 2170, 281, 257, 935, 597, 51352], 'temperature': 0.0, 'avg_logprob': -0.1935912874009874, 'compression_ratio': 1.9045226130653266, 'no_speech_prob': 0.0071190642192959785}, {'id': 45, 'seek': 34174, 'start': 361.5, 'end': 367.1, 'text': ' we were getting earlier and you need to make sure that callee can access callers stack frame. You', 'tokens': [51352, 321, 645, 1242, 3071, 293, 291, 643, 281, 652, 988, 300, 818, 1653, 393, 2105, 818, 433, 8630, 3920, 13, 509, 51632], 'temperature': 0.0, 'avg_logprob': -0.1935912874009874, 'compression_ratio': 1.9045226130653266, 'no_speech_prob': 0.0071190642192959785}, {'id': 46, 'seek': 36710, 'start': 367.1, 'end': 375.5, 'text': ' cannot have a violation there. So, what will happen is so let us say I had this function. So,', 'tokens': [50364, 2644, 362, 257, 22840, 456, 13, 407, 11, 437, 486, 1051, 307, 370, 718, 505, 584, 286, 632, 341, 2445, 13, 407, 11, 50784], 'temperature': 0.0, 'avg_logprob': -0.16615468805486505, 'compression_ratio': 1.5771428571428572, 'no_speech_prob': 0.10959155112504959}, {'id': 47, 'seek': 36710, 'start': 375.5, 'end': 381.3, 'text': ' this has bunch of local variables x y and some those we have already seen those are saved here.', 'tokens': [50784, 341, 575, 3840, 295, 2654, 9102, 2031, 288, 293, 512, 729, 321, 362, 1217, 1612, 729, 366, 6624, 510, 13, 51074], 'temperature': 0.0, 'avg_logprob': -0.16615468805486505, 'compression_ratio': 1.5771428571428572, 'no_speech_prob': 0.10959155112504959}, {'id': 48, 'seek': 36710, 'start': 381.3, 'end': 389.06, 'text': ' So, if EBP is here they are at EBP minus 4 EBP minus 8 EBP minus 12 and then there are', 'tokens': [51074, 407, 11, 498, 50148, 47, 307, 510, 436, 366, 412, 50148, 47, 3175, 1017, 50148, 47, 3175, 1649, 50148, 47, 3175, 2272, 293, 550, 456, 366, 51462], 'temperature': 0.0, 'avg_logprob': -0.16615468805486505, 'compression_ratio': 1.5771428571428572, 'no_speech_prob': 0.10959155112504959}, {'id': 49, 'seek': 38906, 'start': 389.06, 'end': 397.54, 'text': ' parameters m and n. So, those are actually pushed here. Again the same thing applies', 'tokens': [50364, 9834, 275, 293, 297, 13, 407, 11, 729, 366, 767, 9152, 510, 13, 3764, 264, 912, 551, 13165, 50788], 'temperature': 0.0, 'avg_logprob': -0.17252407611255915, 'compression_ratio': 1.5310734463276836, 'no_speech_prob': 0.3071094751358032}, {'id': 50, 'seek': 38906, 'start': 397.54, 'end': 403.94, 'text': ' that if you had a base pointer then they will be at the fixed offset. So, you can access them as', 'tokens': [50788, 300, 498, 291, 632, 257, 3096, 23918, 550, 436, 486, 312, 412, 264, 6806, 18687, 13, 407, 11, 291, 393, 2105, 552, 382, 51108], 'temperature': 0.0, 'avg_logprob': -0.17252407611255915, 'compression_ratio': 1.5310734463276836, 'no_speech_prob': 0.3071094751358032}, {'id': 51, 'seek': 38906, 'start': 403.94, 'end': 411.54, 'text': ' EBP plus 4 is written address EBP plus 8 is this parameter EBP plus 12 is this parameter.', 'tokens': [51108, 50148, 47, 1804, 1017, 307, 3720, 2985, 50148, 47, 1804, 1649, 307, 341, 13075, 50148, 47, 1804, 2272, 307, 341, 13075, 13, 51488], 'temperature': 0.0, 'avg_logprob': -0.17252407611255915, 'compression_ratio': 1.5310734463276836, 'no_speech_prob': 0.3071094751358032}, {'id': 52, 'seek': 41154, 'start': 411.90000000000003, 'end': 420.1, 'text': ' And you can access the parameter with their EBP relative address. Again in this case you can use', 'tokens': [50382, 400, 291, 393, 2105, 264, 13075, 365, 641, 50148, 47, 4972, 2985, 13, 3764, 294, 341, 1389, 291, 393, 764, 50792], 'temperature': 0.0, 'avg_logprob': -0.19858938455581665, 'compression_ratio': 1.5824175824175823, 'no_speech_prob': 0.006095636170357466}, {'id': 53, 'seek': 41154, 'start': 420.1, 'end': 426.18, 'text': ' stack pointer it just adds more complexity within the compiler, but there is nothing wrong with', 'tokens': [50792, 8630, 23918, 309, 445, 10860, 544, 14024, 1951, 264, 31958, 11, 457, 456, 307, 1825, 2085, 365, 51096], 'temperature': 0.0, 'avg_logprob': -0.19858938455581665, 'compression_ratio': 1.5824175824175823, 'no_speech_prob': 0.006095636170357466}, {'id': 54, 'seek': 41154, 'start': 426.18, 'end': 432.70000000000005, 'text': ' being able to use stack pointer. Now the question what should be the order of parameters on the', 'tokens': [51096, 885, 1075, 281, 764, 8630, 23918, 13, 823, 264, 1168, 437, 820, 312, 264, 1668, 295, 9834, 322, 264, 51422], 'temperature': 0.0, 'avg_logprob': -0.19858938455581665, 'compression_ratio': 1.5824175824175823, 'no_speech_prob': 0.006095636170357466}, {'id': 55, 'seek': 43270, 'start': 432.7, 'end': 438.06, 'text': ' stack? Should it be passed left to right or should it be passed right to left?', 'tokens': [50364, 8630, 30, 6454, 309, 312, 4678, 1411, 281, 558, 420, 820, 309, 312, 4678, 558, 281, 1411, 30, 50632], 'temperature': 0.0, 'avg_logprob': -0.26911345395174896, 'compression_ratio': 1.2580645161290323, 'no_speech_prob': 0.691552460193634}, {'id': 56, 'seek': 43806, 'start': 438.06, 'end': 463.02, 'text': ' Correct. So, does that even matter? So, does the order of parameters on the stack matter?', 'tokens': [50364, 12753, 13, 407, 11, 775, 300, 754, 1871, 30, 407, 11, 775, 264, 1668, 295, 9834, 322, 264, 8630, 1871, 30, 51612], 'temperature': 0.0, 'avg_logprob': -0.21780788898468018, 'compression_ratio': 1.1710526315789473, 'no_speech_prob': 0.17709016799926758}, {'id': 57, 'seek': 46806, 'start': 468.54, 'end': 473.58, 'text': ' So, as long as both caller and callee agree that I am passing left to right or right to left and', 'tokens': [50388, 407, 11, 382, 938, 382, 1293, 48324, 293, 818, 1653, 3986, 300, 286, 669, 8437, 1411, 281, 558, 420, 558, 281, 1411, 293, 50640], 'temperature': 0.0, 'avg_logprob': -0.22412948047413545, 'compression_ratio': 1.5224719101123596, 'no_speech_prob': 0.15185555815696716}, {'id': 58, 'seek': 46806, 'start': 473.58, 'end': 479.66, 'text': " both of them access in the consistent way there shouldn't be any problem. Yes.", 'tokens': [50640, 1293, 295, 552, 2105, 294, 264, 8398, 636, 456, 4659, 380, 312, 604, 1154, 13, 1079, 13, 50944], 'temperature': 0.0, 'avg_logprob': -0.22412948047413545, 'compression_ratio': 1.5224719101123596, 'no_speech_prob': 0.15185555815696716}, {'id': 59, 'seek': 46806, 'start': 479.66, 'end': 492.94, 'text': ' Correct. So, in this case if you actually look at it the parameter I mean parameters are passed', 'tokens': [50944, 12753, 13, 407, 11, 294, 341, 1389, 498, 291, 767, 574, 412, 309, 264, 13075, 286, 914, 9834, 366, 4678, 51608], 'temperature': 0.0, 'avg_logprob': -0.22412948047413545, 'compression_ratio': 1.5224719101123596, 'no_speech_prob': 0.15185555815696716}, {'id': 60, 'seek': 49294, 'start': 492.94, 'end': 499.82, 'text': ' in right to left order. So, if you look at n is pushed first then m is pushed. So, in this case', 'tokens': [50364, 294, 558, 281, 1411, 1668, 13, 407, 11, 498, 291, 574, 412, 297, 307, 9152, 700, 550, 275, 307, 9152, 13, 407, 11, 294, 341, 1389, 50708], 'temperature': 0.0, 'avg_logprob': -0.11449448267618816, 'compression_ratio': 1.7464788732394365, 'no_speech_prob': 0.14026795327663422}, {'id': 61, 'seek': 49294, 'start': 499.82, 'end': 505.26, 'text': ' things are actually passed right to left and the reason for that is vararq functions.', 'tokens': [50708, 721, 366, 767, 4678, 558, 281, 1411, 293, 264, 1778, 337, 300, 307, 1374, 289, 80, 6828, 13, 50980], 'temperature': 0.0, 'avg_logprob': -0.11449448267618816, 'compression_ratio': 1.7464788732394365, 'no_speech_prob': 0.14026795327663422}, {'id': 62, 'seek': 49294, 'start': 506.06, 'end': 512.46, 'text': ' Does everyone know what is a vararq function? Printf is an example of vararq function. So,', 'tokens': [51020, 4402, 1518, 458, 437, 307, 257, 1374, 289, 80, 2445, 30, 34439, 69, 307, 364, 1365, 295, 1374, 289, 80, 2445, 13, 407, 11, 51340], 'temperature': 0.0, 'avg_logprob': -0.11449448267618816, 'compression_ratio': 1.7464788732394365, 'no_speech_prob': 0.14026795327663422}, {'id': 63, 'seek': 49294, 'start': 512.46, 'end': 522.06, 'text': ' let us say I had a printf in which I pass a string and I pass x y z w whatever number of parameters', 'tokens': [51340, 718, 505, 584, 286, 632, 257, 4482, 69, 294, 597, 286, 1320, 257, 6798, 293, 286, 1320, 2031, 288, 710, 261, 2035, 1230, 295, 9834, 51820], 'temperature': 0.0, 'avg_logprob': -0.11449448267618816, 'compression_ratio': 1.7464788732394365, 'no_speech_prob': 0.14026795327663422}, {'id': 64, 'seek': 52294, 'start': 523.0200000000001, 'end': 527.9000000000001, 'text': ' now let us imagine what is happening in vararq function. So, let us try to say that I will push', 'tokens': [50368, 586, 718, 505, 3811, 437, 307, 2737, 294, 1374, 289, 80, 2445, 13, 407, 11, 718, 505, 853, 281, 584, 300, 286, 486, 2944, 50612], 'temperature': 0.0, 'avg_logprob': -0.06886602029567812, 'compression_ratio': 1.839080459770115, 'no_speech_prob': 0.00016597262583673}, {'id': 65, 'seek': 52294, 'start': 527.9000000000001, 'end': 532.86, 'text': ' things from left to right that means what will happen is first percent s will be pushed', 'tokens': [50612, 721, 490, 1411, 281, 558, 300, 1355, 437, 486, 1051, 307, 700, 3043, 262, 486, 312, 9152, 50860], 'temperature': 0.0, 'avg_logprob': -0.06886602029567812, 'compression_ratio': 1.839080459770115, 'no_speech_prob': 0.00016597262583673}, {'id': 66, 'seek': 52294, 'start': 533.98, 'end': 539.4200000000001, 'text': ' then x will be pushed then y will be pushed then g will be pushed then w will be pushed', 'tokens': [50916, 550, 2031, 486, 312, 9152, 550, 288, 486, 312, 9152, 550, 290, 486, 312, 9152, 550, 261, 486, 312, 9152, 51188], 'temperature': 0.0, 'avg_logprob': -0.06886602029567812, 'compression_ratio': 1.839080459770115, 'no_speech_prob': 0.00016597262583673}, {'id': 67, 'seek': 52294, 'start': 539.4200000000001, 'end': 547.82, 'text': ' and my stack pointer is here. Now the problem is', 'tokens': [51188, 293, 452, 8630, 23918, 307, 510, 13, 823, 264, 1154, 307, 51608], 'temperature': 0.0, 'avg_logprob': -0.06886602029567812, 'compression_ratio': 1.839080459770115, 'no_speech_prob': 0.00016597262583673}, {'id': 68, 'seek': 54782, 'start': 548.62, 'end': 554.7, 'text': ' printf function the callee function does it know how many parameters were passed?', 'tokens': [50404, 4482, 69, 2445, 264, 818, 1653, 2445, 775, 309, 458, 577, 867, 9834, 645, 4678, 30, 50708], 'temperature': 0.0, 'avg_logprob': -0.15963251450482538, 'compression_ratio': 1.9517241379310344, 'no_speech_prob': 0.0007319142459891737}, {'id': 69, 'seek': 54782, 'start': 556.7800000000001, 'end': 562.46, 'text': ' It does not know how many parameters were passed. The only way it can figure out how many parameters', 'tokens': [50812, 467, 775, 406, 458, 577, 867, 9834, 645, 4678, 13, 440, 787, 636, 309, 393, 2573, 484, 577, 867, 9834, 51096], 'temperature': 0.0, 'avg_logprob': -0.15963251450482538, 'compression_ratio': 1.9517241379310344, 'no_speech_prob': 0.0007319142459891737}, {'id': 70, 'seek': 54782, 'start': 562.46, 'end': 571.5, 'text': ' were passed is by looking at percent s. So, if this was say percent d percent d percent d percent d.', 'tokens': [51096, 645, 4678, 307, 538, 1237, 412, 3043, 262, 13, 407, 11, 498, 341, 390, 584, 3043, 274, 3043, 274, 3043, 274, 3043, 274, 13, 51548], 'temperature': 0.0, 'avg_logprob': -0.15963251450482538, 'compression_ratio': 1.9517241379310344, 'no_speech_prob': 0.0007319142459891737}, {'id': 71, 'seek': 57150, 'start': 571.58, 'end': 579.02, 'text': ' So, it knows that four things were passed to me. But how does it know where this string itself is', 'tokens': [50368, 407, 11, 309, 3255, 300, 1451, 721, 645, 4678, 281, 385, 13, 583, 577, 775, 309, 458, 689, 341, 6798, 2564, 307, 50740], 'temperature': 0.0, 'avg_logprob': -0.13768521944681802, 'compression_ratio': 1.7352941176470589, 'no_speech_prob': 0.01743515022099018}, {'id': 72, 'seek': 57150, 'start': 579.02, 'end': 587.26, 'text': ' stored? The string itself will be stored at some location in the caller stack frame and I do not', 'tokens': [50740, 12187, 30, 440, 6798, 2564, 486, 312, 12187, 412, 512, 4914, 294, 264, 48324, 8630, 3920, 293, 286, 360, 406, 51152], 'temperature': 0.0, 'avg_logprob': -0.13768521944681802, 'compression_ratio': 1.7352941176470589, 'no_speech_prob': 0.01743515022099018}, {'id': 73, 'seek': 57150, 'start': 587.26, 'end': 596.3, 'text': ' know where it is. See because what is happening is so this is in the caller what is happening in the', 'tokens': [51152, 458, 689, 309, 307, 13, 3008, 570, 437, 307, 2737, 307, 370, 341, 307, 294, 264, 48324, 437, 307, 2737, 294, 264, 51604], 'temperature': 0.0, 'avg_logprob': -0.13768521944681802, 'compression_ratio': 1.7352941176470589, 'no_speech_prob': 0.01743515022099018}, {'id': 74, 'seek': 59630, 'start': 596.3, 'end': 603.66, 'text': ' callee. So, in callee I need to access the parameter. So, I can access the parameter using', 'tokens': [50364, 818, 1653, 13, 407, 11, 294, 818, 1653, 286, 643, 281, 2105, 264, 13075, 13, 407, 11, 286, 393, 2105, 264, 13075, 1228, 50732], 'temperature': 0.0, 'avg_logprob': -0.11373017893897162, 'compression_ratio': 1.5668789808917198, 'no_speech_prob': 0.0035925721749663353}, {'id': 75, 'seek': 59630, 'start': 603.66, 'end': 616.62, 'text': ' ebp plus 4 ebp plus 8 ebp plus 12 and so on. But I do not know where is this string stored', 'tokens': [50732, 308, 65, 79, 1804, 1017, 308, 65, 79, 1804, 1649, 308, 65, 79, 1804, 2272, 293, 370, 322, 13, 583, 286, 360, 406, 458, 689, 307, 341, 6798, 12187, 51380], 'temperature': 0.0, 'avg_logprob': -0.11373017893897162, 'compression_ratio': 1.5668789808917198, 'no_speech_prob': 0.0035925721749663353}, {'id': 76, 'seek': 59630, 'start': 618.3, 'end': 622.38, 'text': ' right because it will depend on how many parameters were passed.', 'tokens': [51464, 558, 570, 309, 486, 5672, 322, 577, 867, 9834, 645, 4678, 13, 51668], 'temperature': 0.0, 'avg_logprob': -0.11373017893897162, 'compression_ratio': 1.5668789808917198, 'no_speech_prob': 0.0035925721749663353}, {'id': 77, 'seek': 62238, 'start': 622.38, 'end': 629.82, 'text': ' Instead let us look at it differently. If I pass things in right to left order then caller', 'tokens': [50364, 7156, 718, 505, 574, 412, 309, 7614, 13, 759, 286, 1320, 721, 294, 558, 281, 1411, 1668, 550, 48324, 50736], 'temperature': 0.0, 'avg_logprob': -0.11661155223846435, 'compression_ratio': 1.4275862068965517, 'no_speech_prob': 0.0329863615334034}, {'id': 78, 'seek': 62238, 'start': 630.54, 'end': 640.54, 'text': ' will look like this. So, I have w I have y x sorry I have z y x percent s.', 'tokens': [50772, 486, 574, 411, 341, 13, 407, 11, 286, 362, 261, 286, 362, 288, 2031, 2597, 286, 362, 710, 288, 2031, 3043, 262, 13, 51272], 'temperature': 0.0, 'avg_logprob': -0.11661155223846435, 'compression_ratio': 1.4275862068965517, 'no_speech_prob': 0.0329863615334034}, {'id': 79, 'seek': 62238, 'start': 641.9, 'end': 643.58, 'text': ' How does callee know where is the string?', 'tokens': [51340, 1012, 775, 818, 1653, 458, 689, 307, 264, 6798, 30, 51424], 'temperature': 0.0, 'avg_logprob': -0.11661155223846435, 'compression_ratio': 1.4275862068965517, 'no_speech_prob': 0.0329863615334034}, {'id': 80, 'seek': 64358, 'start': 643.58, 'end': 655.26, 'text': ' ebp plus 4. So, first parameter always is at deterministic location no matter how many other', 'tokens': [50364, 308, 65, 79, 1804, 1017, 13, 407, 11, 700, 13075, 1009, 307, 412, 15957, 3142, 4914, 572, 1871, 577, 867, 661, 50948], 'temperature': 0.0, 'avg_logprob': -0.1946898275806058, 'compression_ratio': 1.9379310344827587, 'no_speech_prob': 0.04600788652896881}, {'id': 81, 'seek': 64358, 'start': 655.26, 'end': 660.7, 'text': ' parameters were passed. So, no matter 100 parameters were passed or 200 parameters were', 'tokens': [50948, 9834, 645, 4678, 13, 407, 11, 572, 1871, 2319, 9834, 645, 4678, 420, 2331, 9834, 645, 51220], 'temperature': 0.0, 'avg_logprob': -0.1946898275806058, 'compression_ratio': 1.9379310344827587, 'no_speech_prob': 0.04600788652896881}, {'id': 82, 'seek': 64358, 'start': 660.7, 'end': 668.0600000000001, 'text': ' passed first parameter will always be at deterministic location which allows us to implement var arc', 'tokens': [51220, 4678, 700, 13075, 486, 1009, 312, 412, 15957, 3142, 4914, 597, 4045, 505, 281, 4445, 1374, 10346, 51588], 'temperature': 0.0, 'avg_logprob': -0.1946898275806058, 'compression_ratio': 1.9379310344827587, 'no_speech_prob': 0.04600788652896881}, {'id': 83, 'seek': 66806, 'start': 668.06, 'end': 675.3399999999999, 'text': ' functions. If you do not have var arc function it does not matter whether you pass left to right', 'tokens': [50364, 6828, 13, 759, 291, 360, 406, 362, 1374, 10346, 2445, 309, 775, 406, 1871, 1968, 291, 1320, 1411, 281, 558, 50728], 'temperature': 0.0, 'avg_logprob': -0.05494749169600637, 'compression_ratio': 1.784037558685446, 'no_speech_prob': 0.016399119049310684}, {'id': 84, 'seek': 66806, 'start': 675.3399999999999, 'end': 681.26, 'text': ' or right to left or even any other order for that matter. For example, I might say I will first pass', 'tokens': [50728, 420, 558, 281, 1411, 420, 754, 604, 661, 1668, 337, 300, 1871, 13, 1171, 1365, 11, 286, 1062, 584, 286, 486, 700, 1320, 51024], 'temperature': 0.0, 'avg_logprob': -0.05494749169600637, 'compression_ratio': 1.784037558685446, 'no_speech_prob': 0.016399119049310684}, {'id': 85, 'seek': 66806, 'start': 681.26, 'end': 686.6199999999999, 'text': ' middle parameter then one on the left one on the right and keep going. So, it does not matter as', 'tokens': [51024, 2808, 13075, 550, 472, 322, 264, 1411, 472, 322, 264, 558, 293, 1066, 516, 13, 407, 11, 309, 775, 406, 1871, 382, 51292], 'temperature': 0.0, 'avg_logprob': -0.05494749169600637, 'compression_ratio': 1.784037558685446, 'no_speech_prob': 0.016399119049310684}, {'id': 86, 'seek': 66806, 'start': 686.6199999999999, 'end': 693.9799999999999, 'text': ' long as both of them agree on something. So, var arc function causes us to have this.', 'tokens': [51292, 938, 382, 1293, 295, 552, 3986, 322, 746, 13, 407, 11, 1374, 10346, 2445, 7700, 505, 281, 362, 341, 13, 51660], 'temperature': 0.0, 'avg_logprob': -0.05494749169600637, 'compression_ratio': 1.784037558685446, 'no_speech_prob': 0.016399119049310684}, {'id': 87, 'seek': 69398, 'start': 694.94, 'end': 703.4200000000001, 'text': ' Now, can you help answer this quiz? So, I have two functions foo and bar both of which print', 'tokens': [50412, 823, 11, 393, 291, 854, 1867, 341, 15450, 30, 407, 11, 286, 362, 732, 6828, 726, 78, 293, 2159, 1293, 295, 597, 4482, 50836], 'temperature': 0.0, 'avg_logprob': -0.21903711850525903, 'compression_ratio': 1.3987341772151898, 'no_speech_prob': 0.002180809387937188}, {'id': 88, 'seek': 69398, 'start': 703.4200000000001, 'end': 710.78, 'text': ' their name and return some value and then in printf I call foo and bar. We know parameters are passed', 'tokens': [50836, 641, 1315, 293, 2736, 512, 2158, 293, 550, 294, 4482, 69, 286, 818, 726, 78, 293, 2159, 13, 492, 458, 9834, 366, 4678, 51204], 'temperature': 0.0, 'avg_logprob': -0.21903711850525903, 'compression_ratio': 1.3987341772151898, 'no_speech_prob': 0.002180809387937188}, {'id': 89, 'seek': 69398, 'start': 710.78, 'end': 719.9, 'text': ' from right to left. Sorry.', 'tokens': [51204, 490, 558, 281, 1411, 13, 4919, 13, 51660], 'temperature': 0.0, 'avg_logprob': -0.21903711850525903, 'compression_ratio': 1.3987341772151898, 'no_speech_prob': 0.002180809387937188}, {'id': 90, 'seek': 71990, 'start': 719.9, 'end': 735.74, 'text': ' First we call bar. So, are you saying the output will be 2 4. So,', 'tokens': [50364, 2386, 321, 818, 2159, 13, 407, 11, 366, 291, 1566, 264, 5598, 486, 312, 568, 1017, 13, 407, 11, 51156], 'temperature': 0.0, 'avg_logprob': -0.4247339497441831, 'compression_ratio': 0.9701492537313433, 'no_speech_prob': 0.014551359228789806}, {'id': 91, 'seek': 73574, 'start': 736.62, 'end': 751.34, 'text': ' is the output. So, one output can you tell me exact output bar then foo', 'tokens': [50408, 307, 264, 5598, 13, 407, 11, 472, 5598, 393, 291, 980, 385, 1900, 5598, 2159, 550, 726, 78, 51144], 'temperature': 0.0, 'avg_logprob': -0.3987903594970703, 'compression_ratio': 1.109375, 'no_speech_prob': 0.15131494402885437}, {'id': 92, 'seek': 75134, 'start': 751.34, 'end': 773.1800000000001, 'text': ' 4 2. So, this is one possible answer we have got bar foo 4 2 any other. Bar foo 2 4.', 'tokens': [50364, 1017, 568, 13, 407, 11, 341, 307, 472, 1944, 1867, 321, 362, 658, 2159, 726, 78, 1017, 568, 604, 661, 13, 4156, 726, 78, 568, 1017, 13, 51456], 'temperature': 0.0, 'avg_logprob': -0.2868874765211536, 'compression_ratio': 1.05, 'no_speech_prob': 0.2847362458705902}, {'id': 93, 'seek': 77318, 'start': 773.5, 'end': 785.02, 'text': ' Okay. Any other answers.', 'tokens': [50380, 1033, 13, 2639, 661, 6338, 13, 50956], 'temperature': 0.0, 'avg_logprob': -0.611568980746799, 'compression_ratio': 0.9333333333333333, 'no_speech_prob': 0.1854764074087143}, {'id': 94, 'seek': 77318, 'start': 786.8599999999999, 'end': 799.02, 'text': ' Yes. Okay. Sorry.', 'tokens': [51048, 1079, 13, 1033, 13, 4919, 13, 51656], 'temperature': 0.0, 'avg_logprob': -0.611568980746799, 'compression_ratio': 0.9333333333333333, 'no_speech_prob': 0.1854764074087143}, {'id': 95, 'seek': 79902, 'start': 799.34, 'end': 806.14, 'text': ' Bar foo 2 4 previous one. So, this one is discarded. Can you explain why you discarded this option?', 'tokens': [50380, 4156, 726, 78, 568, 1017, 3894, 472, 13, 407, 11, 341, 472, 307, 45469, 13, 1664, 291, 2903, 983, 291, 45469, 341, 3614, 30, 50720], 'temperature': 0.0, 'avg_logprob': -0.24920571368673575, 'compression_ratio': 1.5459770114942528, 'no_speech_prob': 0.08984976261854172}, {'id': 96, 'seek': 79902, 'start': 809.9, 'end': 816.54, 'text': ' Correct. Correct. Okay. So, the param no matter order in which parameters are passed', 'tokens': [50908, 12753, 13, 12753, 13, 1033, 13, 407, 11, 264, 6220, 572, 1871, 1668, 294, 597, 9834, 366, 4678, 51240], 'temperature': 0.0, 'avg_logprob': -0.24920571368673575, 'compression_ratio': 1.5459770114942528, 'no_speech_prob': 0.08984976261854172}, {'id': 97, 'seek': 79902, 'start': 817.1, 'end': 821.8199999999999, 'text': ' foo is still printed. I mean whatever value returned by foo will be printed as first', 'tokens': [51268, 726, 78, 307, 920, 13567, 13, 286, 914, 2035, 2158, 8752, 538, 726, 78, 486, 312, 13567, 382, 700, 51504], 'temperature': 0.0, 'avg_logprob': -0.24920571368673575, 'compression_ratio': 1.5459770114942528, 'no_speech_prob': 0.08984976261854172}, {'id': 98, 'seek': 82182, 'start': 821.9000000000001, 'end': 827.6600000000001, 'text': ' and whatever value of bar is printed here. So, this has to print 2 and 4.', 'tokens': [50368, 293, 2035, 2158, 295, 2159, 307, 13567, 510, 13, 407, 11, 341, 575, 281, 4482, 568, 293, 1017, 13, 50656], 'temperature': 0.0, 'avg_logprob': -0.21230265498161316, 'compression_ratio': 1.4405594405594406, 'no_speech_prob': 0.031121162697672844}, {'id': 99, 'seek': 82182, 'start': 828.7800000000001, 'end': 836.5400000000001, 'text': ' Yeah. Okay. And then since things 4 and 2 and then bar and foo any other answers. Yes.', 'tokens': [50712, 865, 13, 1033, 13, 400, 550, 1670, 721, 1017, 293, 568, 293, 550, 2159, 293, 726, 78, 604, 661, 6338, 13, 1079, 13, 51100], 'temperature': 0.0, 'avg_logprob': -0.21230265498161316, 'compression_ratio': 1.4405594405594406, 'no_speech_prob': 0.031121162697672844}, {'id': 100, 'seek': 82182, 'start': 838.5400000000001, 'end': 845.6600000000001, 'text': ' Okay. So, we have someone saying foo bar 4 2.', 'tokens': [51200, 1033, 13, 407, 11, 321, 362, 1580, 1566, 726, 78, 2159, 1017, 568, 13, 51556], 'temperature': 0.0, 'avg_logprob': -0.21230265498161316, 'compression_ratio': 1.4405594405594406, 'no_speech_prob': 0.031121162697672844}, {'id': 101, 'seek': 84566, 'start': 845.66, 'end': 852.3, 'text': ' Can this also come?', 'tokens': [50364, 1664, 341, 611, 808, 30, 50696], 'temperature': 0.0, 'avg_logprob': -0.22872750899370978, 'compression_ratio': 1.1855670103092784, 'no_speech_prob': 0.0052170236594974995}, {'id': 102, 'seek': 84566, 'start': 857.66, 'end': 867.5, 'text': ' How many of you think first answer is correct? Raise your hand. Okay. Majority. How many of you', 'tokens': [50964, 1012, 867, 295, 291, 519, 700, 1867, 307, 3006, 30, 30062, 428, 1011, 13, 1033, 13, 15581, 507, 13, 1012, 867, 295, 291, 51456], 'temperature': 0.0, 'avg_logprob': -0.22872750899370978, 'compression_ratio': 1.1855670103092784, 'no_speech_prob': 0.0052170236594974995}, {'id': 103, 'seek': 86750, 'start': 867.5, 'end': 879.9, 'text': ' think second answer is correct? Okay. Minority. Any other answers? Any one for f, b, o, a something', 'tokens': [50364, 519, 1150, 1867, 307, 3006, 30, 1033, 13, 36117, 507, 13, 2639, 661, 6338, 30, 2639, 472, 337, 283, 11, 272, 11, 277, 11, 257, 746, 50984], 'temperature': 0.0, 'avg_logprob': -0.2198836549799493, 'compression_ratio': 1.4098360655737705, 'no_speech_prob': 0.023266837000846863}, {'id': 104, 'seek': 86750, 'start': 879.9, 'end': 897.42, 'text': ' some mix. Okay. So, the reasoning why second answer is coming is because', 'tokens': [50984, 512, 2890, 13, 1033, 13, 407, 11, 264, 21577, 983, 1150, 1867, 307, 1348, 307, 570, 51860], 'temperature': 0.0, 'avg_logprob': -0.2198836549799493, 'compression_ratio': 1.4098360655737705, 'no_speech_prob': 0.023266837000846863}, {'id': 105, 'seek': 89750, 'start': 897.66, 'end': 904.46, 'text': ' it will evaluate foo first by looking at first percent d and then it will look at evaluate bar', 'tokens': [50372, 309, 486, 13059, 726, 78, 700, 538, 1237, 412, 700, 3043, 274, 293, 550, 309, 486, 574, 412, 13059, 2159, 50712], 'temperature': 0.0, 'avg_logprob': -0.18083391825358072, 'compression_ratio': 1.6964285714285714, 'no_speech_prob': 4.3298077798681334e-05}, {'id': 106, 'seek': 89750, 'start': 904.46, 'end': 914.06, 'text': ' by looking at second percent d. Okay. So, what is the correct answer? Okay. So, this is where we get', 'tokens': [50712, 538, 1237, 412, 1150, 3043, 274, 13, 1033, 13, 407, 11, 437, 307, 264, 3006, 1867, 30, 1033, 13, 407, 11, 341, 307, 689, 321, 483, 51192], 'temperature': 0.0, 'avg_logprob': -0.18083391825358072, 'compression_ratio': 1.6964285714285714, 'no_speech_prob': 4.3298077798681334e-05}, {'id': 107, 'seek': 89750, 'start': 914.06, 'end': 923.02, 'text': ' into unspecified behavior. Okay. Both answers are correct. Okay. But you have to remember', 'tokens': [51192, 666, 2693, 494, 66, 2587, 5223, 13, 1033, 13, 6767, 6338, 366, 3006, 13, 1033, 13, 583, 291, 362, 281, 1604, 51640], 'temperature': 0.0, 'avg_logprob': -0.18083391825358072, 'compression_ratio': 1.6964285714285714, 'no_speech_prob': 4.3298077798681334e-05}, {'id': 108, 'seek': 92302, 'start': 923.02, 'end': 935.1, 'text': ' order of parameter passing is not order of evaluation. Okay. Nothing in c says that foo', 'tokens': [50364, 1668, 295, 13075, 8437, 307, 406, 1668, 295, 13344, 13, 1033, 13, 6693, 294, 269, 1619, 300, 726, 78, 50968], 'temperature': 0.0, 'avg_logprob': -0.10080975752610427, 'compression_ratio': 1.7197452229299364, 'no_speech_prob': 9.31375689106062e-05}, {'id': 109, 'seek': 92302, 'start': 935.1, 'end': 943.5799999999999, 'text': ' must be done first and bar must be done after that or vice versa. So, order of parameter passing', 'tokens': [50968, 1633, 312, 1096, 700, 293, 2159, 1633, 312, 1096, 934, 300, 420, 11964, 25650, 13, 407, 11, 1668, 295, 13075, 8437, 51392], 'temperature': 0.0, 'avg_logprob': -0.10080975752610427, 'compression_ratio': 1.7197452229299364, 'no_speech_prob': 9.31375689106062e-05}, {'id': 110, 'seek': 92302, 'start': 943.5799999999999, 'end': 949.8199999999999, 'text': ' does not influence order of evaluation. So, this code is actually equivalent to this.', 'tokens': [51392, 775, 406, 6503, 1668, 295, 13344, 13, 407, 11, 341, 3089, 307, 767, 10344, 281, 341, 13, 51704], 'temperature': 0.0, 'avg_logprob': -0.10080975752610427, 'compression_ratio': 1.7197452229299364, 'no_speech_prob': 9.31375689106062e-05}, {'id': 111, 'seek': 94982, 'start': 949.9000000000001, 'end': 958.3000000000001, 'text': ' T is equal to foo, T2 is equal to bar or T is equal to bar and T2 equal to foo. Okay.', 'tokens': [50368, 314, 307, 2681, 281, 726, 78, 11, 314, 17, 307, 2681, 281, 2159, 420, 314, 307, 2681, 281, 2159, 293, 314, 17, 2681, 281, 726, 78, 13, 1033, 13, 50788], 'temperature': 0.0, 'avg_logprob': -0.19247467838116547, 'compression_ratio': 1.5586206896551724, 'no_speech_prob': 0.02224985882639885}, {'id': 112, 'seek': 94982, 'start': 960.86, 'end': 965.82, 'text': ' Just for that matter you must have by now you should be preparing for your campus interviews.', 'tokens': [50916, 1449, 337, 300, 1871, 291, 1633, 362, 538, 586, 291, 820, 312, 10075, 337, 428, 4828, 12318, 13, 51164], 'temperature': 0.0, 'avg_logprob': -0.19247467838116547, 'compression_ratio': 1.5586206896551724, 'no_speech_prob': 0.02224985882639885}, {'id': 113, 'seek': 94982, 'start': 965.82, 'end': 968.1400000000001, 'text': ' Right. So, you must have seen codes like this.', 'tokens': [51164, 1779, 13, 407, 11, 291, 1633, 362, 1612, 14211, 411, 341, 13, 51280], 'temperature': 0.0, 'avg_logprob': -0.19247467838116547, 'compression_ratio': 1.5586206896551724, 'no_speech_prob': 0.02224985882639885}, {'id': 114, 'seek': 96814, 'start': 968.14, 'end': 985.02, 'text': ' So, what is the order in which things are evaluated?', 'tokens': [50364, 407, 11, 437, 307, 264, 1668, 294, 597, 721, 366, 25509, 30, 51208], 'temperature': 0.0, 'avg_logprob': -0.22437707389273295, 'compression_ratio': 1.3173076923076923, 'no_speech_prob': 0.03711941838264465}, {'id': 115, 'seek': 96814, 'start': 988.06, 'end': 994.46, 'text': ' So, tell me the answer to this question. i is 1 to begin with, j is 0 to begin with.', 'tokens': [51360, 407, 11, 980, 385, 264, 1867, 281, 341, 1168, 13, 741, 307, 502, 281, 1841, 365, 11, 361, 307, 1958, 281, 1841, 365, 13, 51680], 'temperature': 0.0, 'avg_logprob': -0.22437707389273295, 'compression_ratio': 1.3173076923076923, 'no_speech_prob': 0.03711941838264465}, {'id': 116, 'seek': 99814, 'start': 999.1, 'end': 1001.74, 'text': ' What is the textbook answer for this question?', 'tokens': [50412, 708, 307, 264, 25591, 1867, 337, 341, 1168, 30, 50544], 'temperature': 0.0, 'avg_logprob': -0.15564754161428898, 'compression_ratio': 1.6390243902439023, 'no_speech_prob': 0.0018658508779481053}, {'id': 117, 'seek': 99814, 'start': 1004.78, 'end': 1014.54, 'text': ' Correct. Okay. So, eval from right to left. So, first minus minus j will happen. Then i plus 1', 'tokens': [50696, 12753, 13, 1033, 13, 407, 11, 1073, 304, 490, 558, 281, 1411, 13, 407, 11, 700, 3175, 3175, 361, 486, 1051, 13, 1396, 741, 1804, 502, 51184], 'temperature': 0.0, 'avg_logprob': -0.15564754161428898, 'compression_ratio': 1.6390243902439023, 'no_speech_prob': 0.0018658508779481053}, {'id': 118, 'seek': 99814, 'start': 1014.54, 'end': 1020.46, 'text': ' will happen. So, this will actually print 2. Then it will again print 1 and this will again increment', 'tokens': [51184, 486, 1051, 13, 407, 11, 341, 486, 767, 4482, 568, 13, 1396, 309, 486, 797, 4482, 502, 293, 341, 486, 797, 26200, 51480], 'temperature': 0.0, 'avg_logprob': -0.15564754161428898, 'compression_ratio': 1.6390243902439023, 'no_speech_prob': 0.0018658508779481053}, {'id': 119, 'seek': 99814, 'start': 1020.46, 'end': 1026.22, 'text': ' 2. So, that is the bookish answer which you must have seen in some MCQs. Right. Now, that is', 'tokens': [51480, 568, 13, 407, 11, 300, 307, 264, 1446, 742, 1867, 597, 291, 1633, 362, 1612, 294, 512, 8797, 48, 82, 13, 1779, 13, 823, 11, 300, 307, 51768], 'temperature': 0.0, 'avg_logprob': -0.15564754161428898, 'compression_ratio': 1.6390243902439023, 'no_speech_prob': 0.0018658508779481053}, {'id': 120, 'seek': 102622, 'start': 1026.22, 'end': 1032.6200000000001, 'text': ' actually incorrect. That is incorrect for two reasons. One is you do not know the order in which', 'tokens': [50364, 767, 18424, 13, 663, 307, 18424, 337, 732, 4112, 13, 1485, 307, 291, 360, 406, 458, 264, 1668, 294, 597, 50684], 'temperature': 0.0, 'avg_logprob': -0.11275342106819153, 'compression_ratio': 1.513089005235602, 'no_speech_prob': 0.0008039511740207672}, {'id': 121, 'seek': 102622, 'start': 1032.6200000000001, 'end': 1040.8600000000001, 'text': ' things are evaluated. Second is this code actually has undefined behavior. Because it is trying to', 'tokens': [50684, 721, 366, 25509, 13, 5736, 307, 341, 3089, 767, 575, 674, 5666, 2001, 5223, 13, 1436, 309, 307, 1382, 281, 51096], 'temperature': 0.0, 'avg_logprob': -0.11275342106819153, 'compression_ratio': 1.513089005235602, 'no_speech_prob': 0.0008039511740207672}, {'id': 122, 'seek': 102622, 'start': 1040.8600000000001, 'end': 1047.26, 'text': ' modify value of the same variable multiple times within something called as a sequence point.', 'tokens': [51096, 16927, 2158, 295, 264, 912, 7006, 3866, 1413, 1951, 746, 1219, 382, 257, 8310, 935, 13, 51416], 'temperature': 0.0, 'avg_logprob': -0.11275342106819153, 'compression_ratio': 1.513089005235602, 'no_speech_prob': 0.0008039511740207672}, {'id': 123, 'seek': 104726, 'start': 1048.14, 'end': 1056.06, 'text': ' Okay. So, just sequence points are the points where language says all the side effects must', 'tokens': [50408, 1033, 13, 407, 11, 445, 8310, 2793, 366, 264, 2793, 689, 2856, 1619, 439, 264, 1252, 5065, 1633, 50804], 'temperature': 0.0, 'avg_logprob': -0.10041491190592448, 'compression_ratio': 1.6147186147186148, 'no_speech_prob': 0.03206455707550049}, {'id': 124, 'seek': 104726, 'start': 1056.06, 'end': 1061.5, 'text': ' have completed prior to that. And there is no sequence point within this which causes that to', 'tokens': [50804, 362, 7365, 4059, 281, 300, 13, 400, 456, 307, 572, 8310, 935, 1951, 341, 597, 7700, 300, 281, 51076], 'temperature': 0.0, 'avg_logprob': -0.10041491190592448, 'compression_ratio': 1.6147186147186148, 'no_speech_prob': 0.03206455707550049}, {'id': 125, 'seek': 104726, 'start': 1061.5, 'end': 1068.3799999999999, 'text': ' happen. Okay. So, the answer to this question is undefined behavior. But most likely in the MCQ,', 'tokens': [51076, 1051, 13, 1033, 13, 407, 11, 264, 1867, 281, 341, 1168, 307, 674, 5666, 2001, 5223, 13, 583, 881, 3700, 294, 264, 8797, 48, 11, 51420], 'temperature': 0.0, 'avg_logprob': -0.10041491190592448, 'compression_ratio': 1.6147186147186148, 'no_speech_prob': 0.03206455707550049}, {'id': 126, 'seek': 104726, 'start': 1068.3799999999999, 'end': 1073.66, 'text': ' you will not have that option. So, remember evaluate from right to left to get the correct', 'tokens': [51420, 291, 486, 406, 362, 300, 3614, 13, 407, 11, 1604, 13059, 490, 558, 281, 1411, 281, 483, 264, 3006, 51684], 'temperature': 0.0, 'avg_logprob': -0.10041491190592448, 'compression_ratio': 1.6147186147186148, 'no_speech_prob': 0.03206455707550049}, {'id': 127, 'seek': 107366, 'start': 1074.46, 'end': 1081.02, 'text': ' answer to match the book. But it is not correct. Okay. So, if you have undefined behavior, take', 'tokens': [50404, 1867, 281, 2995, 264, 1446, 13, 583, 309, 307, 406, 3006, 13, 1033, 13, 407, 11, 498, 291, 362, 674, 5666, 2001, 5223, 11, 747, 50732], 'temperature': 0.0, 'avg_logprob': -0.09921604327941208, 'compression_ratio': 1.603864734299517, 'no_speech_prob': 0.0026310591492801905}, {'id': 128, 'seek': 107366, 'start': 1081.02, 'end': 1089.3400000000001, 'text': ' that. If you do not have, remember how to evaluate. Okay. Now, so far we have seen this that stack', 'tokens': [50732, 300, 13, 759, 291, 360, 406, 362, 11, 1604, 577, 281, 13059, 13, 1033, 13, 823, 11, 370, 1400, 321, 362, 1612, 341, 300, 8630, 51148], 'temperature': 0.0, 'avg_logprob': -0.09921604327941208, 'compression_ratio': 1.603864734299517, 'no_speech_prob': 0.0026310591492801905}, {'id': 129, 'seek': 107366, 'start': 1089.3400000000001, 'end': 1094.46, 'text': ' grows down, stack grows down. How do you detect programmatically? So, can you write program', 'tokens': [51148, 13156, 760, 11, 8630, 13156, 760, 13, 1012, 360, 291, 5531, 37648, 5030, 30, 407, 11, 393, 291, 2464, 1461, 51404], 'temperature': 0.0, 'avg_logprob': -0.09921604327941208, 'compression_ratio': 1.603864734299517, 'no_speech_prob': 0.0026310591492801905}, {'id': 130, 'seek': 107366, 'start': 1095.66, 'end': 1097.74, 'text': ' which will detect that stack is growing down?', 'tokens': [51464, 597, 486, 5531, 300, 8630, 307, 4194, 760, 30, 51568], 'temperature': 0.0, 'avg_logprob': -0.09921604327941208, 'compression_ratio': 1.603864734299517, 'no_speech_prob': 0.0026310591492801905}, {'id': 131, 'seek': 109774, 'start': 1097.74, 'end': 1111.42, 'text': ' You do not have, you do not have access to push from C. You have to write a C program to detect.', 'tokens': [50364, 509, 360, 406, 362, 11, 291, 360, 406, 362, 2105, 281, 2944, 490, 383, 13, 509, 362, 281, 2464, 257, 383, 1461, 281, 5531, 13, 51048], 'temperature': 0.0, 'avg_logprob': -0.15563363295335036, 'compression_ratio': 1.4298245614035088, 'no_speech_prob': 0.008786138147115707}, {'id': 132, 'seek': 109774, 'start': 1111.42, 'end': 1125.42, 'text': ' Okay. So, let us do this. So, I do something like this. So, I have', 'tokens': [51048, 1033, 13, 407, 11, 718, 505, 360, 341, 13, 407, 11, 286, 360, 746, 411, 341, 13, 407, 11, 286, 362, 51748], 'temperature': 0.0, 'avg_logprob': -0.15563363295335036, 'compression_ratio': 1.4298245614035088, 'no_speech_prob': 0.008786138147115707}, {'id': 133, 'seek': 112542, 'start': 1125.42, 'end': 1135.9, 'text': ' f int foo where I create x, y, z. What will I do? How do I detect stack grows down?', 'tokens': [50364, 283, 560, 726, 78, 689, 286, 1884, 2031, 11, 288, 11, 710, 13, 708, 486, 286, 360, 30, 1012, 360, 286, 5531, 8630, 13156, 760, 30, 50888], 'temperature': 0.0, 'avg_logprob': -0.19301061141185272, 'compression_ratio': 1.1515151515151516, 'no_speech_prob': 0.3184625804424286}, {'id': 134, 'seek': 112542, 'start': 1147.5800000000002, 'end': 1148.78, 'text': ' What is the problem with this?', 'tokens': [51472, 708, 307, 264, 1154, 365, 341, 30, 51532], 'temperature': 0.0, 'avg_logprob': -0.19301061141185272, 'compression_ratio': 1.1515151515151516, 'no_speech_prob': 0.3184625804424286}, {'id': 135, 'seek': 114878, 'start': 1148.78, 'end': 1160.06, 'text': ' ASLR will not play a role here. But we will see what is ASLR actually.', 'tokens': [50364, 7469, 31722, 486, 406, 862, 257, 3090, 510, 13, 583, 321, 486, 536, 437, 307, 7469, 31722, 767, 13, 50928], 'temperature': 0.0, 'avg_logprob': -0.16227786084438892, 'compression_ratio': 1.265625, 'no_speech_prob': 0.02438828907907009}, {'id': 136, 'seek': 114878, 'start': 1168.7, 'end': 1174.3, 'text': ' Correct. So, one of the things is C does not say or mandate that x must be allocated first,', 'tokens': [51360, 12753, 13, 407, 11, 472, 295, 264, 721, 307, 383, 775, 406, 584, 420, 23885, 300, 2031, 1633, 312, 29772, 700, 11, 51640], 'temperature': 0.0, 'avg_logprob': -0.16227786084438892, 'compression_ratio': 1.265625, 'no_speech_prob': 0.02438828907907009}, {'id': 137, 'seek': 117430, 'start': 1174.3, 'end': 1180.1399999999999, 'text': ' then y must be allocated and then z must be allocated. So, compiler is first free to allocate', 'tokens': [50364, 550, 288, 1633, 312, 29772, 293, 550, 710, 1633, 312, 29772, 13, 407, 11, 31958, 307, 700, 1737, 281, 35713, 50656], 'temperature': 0.0, 'avg_logprob': -0.08893285653530023, 'compression_ratio': 1.6, 'no_speech_prob': 0.004750674590468407}, {'id': 138, 'seek': 117430, 'start': 1180.1399999999999, 'end': 1189.4199999999998, 'text': ' z first or y first or x first. So, you cannot rely on the addresses of x, y and z. In what case', 'tokens': [50656, 710, 700, 420, 288, 700, 420, 2031, 700, 13, 407, 11, 291, 2644, 10687, 322, 264, 16862, 295, 2031, 11, 288, 293, 710, 13, 682, 437, 1389, 51120], 'temperature': 0.0, 'avg_logprob': -0.08893285653530023, 'compression_ratio': 1.6, 'no_speech_prob': 0.004750674590468407}, {'id': 139, 'seek': 117430, 'start': 1189.4199999999998, 'end': 1197.1, 'text': ' there is a guarantee for having contiguous is array. So, if I had ARR of something, then C', 'tokens': [51120, 456, 307, 257, 10815, 337, 1419, 660, 30525, 307, 10225, 13, 407, 11, 498, 286, 632, 8943, 49, 295, 746, 11, 550, 383, 51504], 'temperature': 0.0, 'avg_logprob': -0.08893285653530023, 'compression_ratio': 1.6, 'no_speech_prob': 0.004750674590468407}, {'id': 140, 'seek': 119710, 'start': 1197.1799999999998, 'end': 1205.26, 'text': ' mandates that array is allocated contiguously. That means address of ARR 0 and addresses of ARR', 'tokens': [50368, 48662, 300, 10225, 307, 29772, 660, 16397, 5098, 13, 663, 1355, 2985, 295, 8943, 49, 1958, 293, 16862, 295, 8943, 49, 50772], 'temperature': 0.0, 'avg_logprob': -0.06496457319993239, 'compression_ratio': 1.5818181818181818, 'no_speech_prob': 0.0012058451538905501}, {'id': 141, 'seek': 119710, 'start': 1205.26, 'end': 1209.74, 'text': ' 1, they are related and contiguous. So, how will I actually write the expression?', 'tokens': [50772, 502, 11, 436, 366, 4077, 293, 660, 30525, 13, 407, 11, 577, 486, 286, 767, 2464, 264, 6114, 30, 50996], 'temperature': 0.0, 'avg_logprob': -0.06496457319993239, 'compression_ratio': 1.5818181818181818, 'no_speech_prob': 0.0012058451538905501}, {'id': 142, 'seek': 119710, 'start': 1210.3, 'end': 1214.86, 'text': ' What should I write to actually say stack grows down? What should be the condition?', 'tokens': [51024, 708, 820, 286, 2464, 281, 767, 584, 8630, 13156, 760, 30, 708, 820, 312, 264, 4188, 30, 51252], 'temperature': 0.0, 'avg_logprob': -0.06496457319993239, 'compression_ratio': 1.5818181818181818, 'no_speech_prob': 0.0012058451538905501}, {'id': 143, 'seek': 121486, 'start': 1214.86, 'end': 1224.86, 'text': ' If blah, blah, blah printf down else', 'tokens': [50364, 759, 12288, 11, 12288, 11, 12288, 4482, 69, 760, 1646, 50864], 'temperature': 0.0, 'avg_logprob': -0.5723616893474872, 'compression_ratio': 1.0588235294117647, 'no_speech_prob': 0.8597645163536072}, {'id': 144, 'seek': 124486, 'start': 1244.9399999999998, 'end': 1246.86, 'text': ' A1.', 'tokens': [50368, 316, 16, 13, 50464], 'temperature': 0.0, 'avg_logprob': -0.43296005107738356, 'compression_ratio': 1.0229885057471264, 'no_speech_prob': 0.0946429893374443}, {'id': 145, 'seek': 124486, 'start': 1260.9399999999998, 'end': 1267.58, 'text': ' Does everyone understand how this is happening? So, if you look at even our diagrams,', 'tokens': [51168, 4402, 1518, 1223, 577, 341, 307, 2737, 30, 407, 11, 498, 291, 574, 412, 754, 527, 36709, 11, 51500], 'temperature': 0.0, 'avg_logprob': -0.43296005107738356, 'compression_ratio': 1.0229885057471264, 'no_speech_prob': 0.0946429893374443}, {'id': 146, 'seek': 126758, 'start': 1267.6599999999999, 'end': 1280.54, 'text': ' they had it that way. So, ARR of 5 addresses lower than ARR of 6 addresses.', 'tokens': [50368, 436, 632, 309, 300, 636, 13, 407, 11, 8943, 49, 295, 1025, 16862, 3126, 813, 8943, 49, 295, 1386, 16862, 13, 51012], 'temperature': 0.0, 'avg_logprob': -0.13915388207686574, 'compression_ratio': 1.3758389261744965, 'no_speech_prob': 0.038318242877721786}, {'id': 147, 'seek': 126758, 'start': 1285.8999999999999, 'end': 1290.3, 'text': ' Now, can you figure out the answer to this question? This will take some time.', 'tokens': [51280, 823, 11, 393, 291, 2573, 484, 264, 1867, 281, 341, 1168, 30, 639, 486, 747, 512, 565, 13, 51500], 'temperature': 0.0, 'avg_logprob': -0.13915388207686574, 'compression_ratio': 1.3758389261744965, 'no_speech_prob': 0.038318242877721786}, {'id': 148, 'seek': 126758, 'start': 1290.3, 'end': 1294.3, 'text': ' Please work out on paper and tell me what happens.', 'tokens': [51500, 2555, 589, 484, 322, 3035, 293, 980, 385, 437, 2314, 13, 51700], 'temperature': 0.0, 'avg_logprob': -0.13915388207686574, 'compression_ratio': 1.3758389261744965, 'no_speech_prob': 0.038318242877721786}, {'id': 149, 'seek': 129758, 'start': 1297.58, 'end': 1307.74, 'text': ' Everyone understands at least the syntax and the code.', 'tokens': [50364, 5198, 15146, 412, 1935, 264, 28431, 293, 264, 3089, 13, 50872], 'temperature': 0.0, 'avg_logprob': -0.3196420669555664, 'compression_ratio': 1.319327731092437, 'no_speech_prob': 0.012217128649353981}, {'id': 150, 'seek': 129758, 'start': 1311.58, 'end': 1314.6999999999998, 'text': ' Sorry, infinite.', 'tokens': [51064, 4919, 11, 13785, 13, 51220], 'temperature': 0.0, 'avg_logprob': -0.3196420669555664, 'compression_ratio': 1.319327731092437, 'no_speech_prob': 0.012217128649353981}, {'id': 151, 'seek': 129758, 'start': 1318.6999999999998, 'end': 1325.26, 'text': ' Okay, any other answers? So, they are saying it is some sort of infinite call to bar.', 'tokens': [51420, 1033, 11, 604, 661, 6338, 30, 407, 11, 436, 366, 1566, 309, 307, 512, 1333, 295, 13785, 818, 281, 2159, 13, 51748], 'temperature': 0.0, 'avg_logprob': -0.3196420669555664, 'compression_ratio': 1.319327731092437, 'no_speech_prob': 0.012217128649353981}, {'id': 152, 'seek': 132526, 'start': 1325.26, 'end': 1327.58, 'text': " It doesn't look like.", 'tokens': [50364, 467, 1177, 380, 574, 411, 13, 50480], 'temperature': 0.0, 'avg_logprob': -0.4535147349039714, 'compression_ratio': 1.0609756097560976, 'no_speech_prob': 0.0027145834174007177}, {'id': 153, 'seek': 132526, 'start': 1334.46, 'end': 1337.42, 'text': ' It is some simple pointer manipulation.', 'tokens': [50824, 467, 307, 512, 2199, 23918, 26475, 13, 50972], 'temperature': 0.0, 'avg_logprob': -0.4535147349039714, 'compression_ratio': 1.0609756097560976, 'no_speech_prob': 0.0027145834174007177}, {'id': 154, 'seek': 132526, 'start': 1346.46, 'end': 1347.82, 'text': ' Any other answers so far?', 'tokens': [51424, 2639, 661, 6338, 370, 1400, 30, 51492], 'temperature': 0.0, 'avg_logprob': -0.4535147349039714, 'compression_ratio': 1.0609756097560976, 'no_speech_prob': 0.0027145834174007177}, {'id': 155, 'seek': 134782, 'start': 1347.82, 'end': 1350.9399999999998, 'text': ' Yes.', 'tokens': [50364, 1079, 13, 50520], 'temperature': 0.0, 'avg_logprob': -0.2614586314216989, 'compression_ratio': 1.3950617283950617, 'no_speech_prob': 0.003610905958339572}, {'id': 156, 'seek': 134782, 'start': 1358.22, 'end': 1359.26, 'text': ' Do you need to know?', 'tokens': [50884, 1144, 291, 643, 281, 458, 30, 50936], 'temperature': 0.0, 'avg_logprob': -0.2614586314216989, 'compression_ratio': 1.3950617283950617, 'no_speech_prob': 0.003610905958339572}, {'id': 157, 'seek': 134782, 'start': 1363.82, 'end': 1368.9399999999998, 'text': " In this particular case, it shouldn't matter. But can you explain why you were curious about that?", 'tokens': [51164, 682, 341, 1729, 1389, 11, 309, 4659, 380, 1871, 13, 583, 393, 291, 2903, 983, 291, 645, 6369, 466, 300, 30, 51420], 'temperature': 0.0, 'avg_logprob': -0.2614586314216989, 'compression_ratio': 1.3950617283950617, 'no_speech_prob': 0.003610905958339572}, {'id': 158, 'seek': 134782, 'start': 1372.06, 'end': 1377.34, 'text': ' I mean, how does that help you know the answer? I am just trying to understand what is the intuition.', 'tokens': [51576, 286, 914, 11, 577, 775, 300, 854, 291, 458, 264, 1867, 30, 286, 669, 445, 1382, 281, 1223, 437, 307, 264, 24002, 13, 51840], 'temperature': 0.0, 'avg_logprob': -0.2614586314216989, 'compression_ratio': 1.3950617283950617, 'no_speech_prob': 0.003610905958339572}, {'id': 159, 'seek': 137782, 'start': 1377.82, 'end': 1383.6599999999999, 'text': ' Okay.', 'tokens': [50364, 1033, 13, 50656], 'temperature': 0.0, 'avg_logprob': -0.4189725603376116, 'compression_ratio': 1.2777777777777777, 'no_speech_prob': 0.008946564979851246}, {'id': 160, 'seek': 137782, 'start': 1388.62, 'end': 1388.9399999999998, 'text': ' Sorry.', 'tokens': [50904, 4919, 13, 50920], 'temperature': 0.0, 'avg_logprob': -0.4189725603376116, 'compression_ratio': 1.2777777777777777, 'no_speech_prob': 0.008946564979851246}, {'id': 161, 'seek': 137782, 'start': 1392.78, 'end': 1398.78, 'text': ' Okay, so it will just call infu. I mean, it will print infu and then it will print indbar. That is it.', 'tokens': [51112, 1033, 11, 370, 309, 486, 445, 818, 1536, 84, 13, 286, 914, 11, 309, 486, 4482, 1536, 84, 293, 550, 309, 486, 4482, 1016, 5356, 13, 663, 307, 309, 13, 51412], 'temperature': 0.0, 'avg_logprob': -0.4189725603376116, 'compression_ratio': 1.2777777777777777, 'no_speech_prob': 0.008946564979851246}, {'id': 162, 'seek': 139878, 'start': 1398.78, 'end': 1405.42, 'text': ' It will never return from main.', 'tokens': [50364, 467, 486, 1128, 2736, 490, 2135, 13, 50696], 'temperature': 0.0, 'avg_logprob': -0.2907147066933768, 'compression_ratio': 1.5083333333333333, 'no_speech_prob': 0.0062285736203193665}, {'id': 163, 'seek': 139878, 'start': 1405.42, 'end': 1412.62, 'text': ' It will never return from main. Okay. So, if I had put in main as a printf,', 'tokens': [50696, 467, 486, 1128, 2736, 490, 2135, 13, 1033, 13, 407, 11, 498, 286, 632, 829, 294, 2135, 382, 257, 4482, 69, 11, 51056], 'temperature': 0.0, 'avg_logprob': -0.2907147066933768, 'compression_ratio': 1.5083333333333333, 'no_speech_prob': 0.0062285736203193665}, {'id': 164, 'seek': 139878, 'start': 1412.62, 'end': 1414.78, 'text': ' then it will get printed multiple times.', 'tokens': [51056, 550, 309, 486, 483, 13567, 3866, 1413, 13, 51164], 'temperature': 0.0, 'avg_logprob': -0.2907147066933768, 'compression_ratio': 1.5083333333333333, 'no_speech_prob': 0.0062285736203193665}, {'id': 165, 'seek': 139878, 'start': 1418.62, 'end': 1420.46, 'text': ' Okay, why do you think that way?', 'tokens': [51356, 1033, 11, 983, 360, 291, 519, 300, 636, 30, 51448], 'temperature': 0.0, 'avg_logprob': -0.2907147066933768, 'compression_ratio': 1.5083333333333333, 'no_speech_prob': 0.0062285736203193665}, {'id': 166, 'seek': 142046, 'start': 1420.46, 'end': 1435.5, 'text': ' So, so far we have two answers. One is there is infu which is printed and then inbar, inbar,', 'tokens': [50364, 407, 11, 370, 1400, 321, 362, 732, 6338, 13, 1485, 307, 456, 307, 1536, 84, 597, 307, 13567, 293, 550, 294, 5356, 11, 294, 5356, 11, 51116], 'temperature': 0.0, 'avg_logprob': -0.16515523416024666, 'compression_ratio': 1.7852760736196318, 'no_speech_prob': 0.0022149933502078056}, {'id': 167, 'seek': 142046, 'start': 1435.5, 'end': 1441.26, 'text': ' inbar, inbar which is continuously printed. Then we have another answer which is infu is printed,', 'tokens': [51116, 294, 5356, 11, 294, 5356, 597, 307, 15684, 13567, 13, 1396, 321, 362, 1071, 1867, 597, 307, 1536, 84, 307, 13567, 11, 51404], 'temperature': 0.0, 'avg_logprob': -0.16515523416024666, 'compression_ratio': 1.7852760736196318, 'no_speech_prob': 0.0022149933502078056}, {'id': 168, 'seek': 142046, 'start': 1441.26, 'end': 1448.6200000000001, 'text': ' inbar is printed and then some sort of hang occurs. But neither we are infu or bar. Is that correct?', 'tokens': [51404, 294, 5356, 307, 13567, 293, 550, 512, 1333, 295, 3967, 11843, 13, 583, 9662, 321, 366, 1536, 84, 420, 2159, 13, 1119, 300, 3006, 30, 51772], 'temperature': 0.0, 'avg_logprob': -0.16515523416024666, 'compression_ratio': 1.7852760736196318, 'no_speech_prob': 0.0022149933502078056}, {'id': 169, 'seek': 144862, 'start': 1448.62, 'end': 1454.9399999999998, 'text': ' Okay. Any other answers? And one answer was infu, inbar successfully exit. No issues.', 'tokens': [50364, 1033, 13, 2639, 661, 6338, 30, 400, 472, 1867, 390, 1536, 84, 11, 294, 5356, 10727, 11043, 13, 883, 2663, 13, 50680], 'temperature': 0.0, 'avg_logprob': -0.20390820084956654, 'compression_ratio': 1.3233082706766917, 'no_speech_prob': 5.725279334001243e-05}, {'id': 170, 'seek': 144862, 'start': 1457.1799999999998, 'end': 1461.6599999999999, 'text': " Let's try. Let's I think. Okay, so I have the same code.", 'tokens': [50792, 961, 311, 853, 13, 961, 311, 286, 519, 13, 1033, 11, 370, 286, 362, 264, 912, 3089, 13, 51016], 'temperature': 0.0, 'avg_logprob': -0.20390820084956654, 'compression_ratio': 1.3233082706766917, 'no_speech_prob': 5.725279334001243e-05}, {'id': 171, 'seek': 144862, 'start': 1467.9799999999998, 'end': 1469.4199999999998, 'text': ' Okay, now we are going to run it.', 'tokens': [51332, 1033, 11, 586, 321, 366, 516, 281, 1190, 309, 13, 51404], 'temperature': 0.0, 'avg_logprob': -0.20390820084956654, 'compression_ratio': 1.3233082706766917, 'no_speech_prob': 5.725279334001243e-05}, {'id': 172, 'seek': 146942, 'start': 1470.22, 'end': 1480.38, 'text': ' So, it is some sort of a loop in bar. Okay, so this answer that it successfully terminates is', 'tokens': [50404, 407, 11, 309, 307, 512, 1333, 295, 257, 6367, 294, 2159, 13, 1033, 11, 370, 341, 1867, 300, 309, 10727, 10761, 1024, 307, 50912], 'temperature': 0.0, 'avg_logprob': -0.14992902013990614, 'compression_ratio': 1.6153846153846154, 'no_speech_prob': 0.02283097244799137}, {'id': 173, 'seek': 146942, 'start': 1480.38, 'end': 1486.3000000000002, 'text': ' incorrect. Your answer that it somehow will be an infinite loop in main is incorrect.', 'tokens': [50912, 18424, 13, 2260, 1867, 300, 309, 6063, 486, 312, 364, 13785, 6367, 294, 2135, 307, 18424, 13, 51208], 'temperature': 0.0, 'avg_logprob': -0.14992902013990614, 'compression_ratio': 1.6153846153846154, 'no_speech_prob': 0.02283097244799137}, {'id': 174, 'seek': 146942, 'start': 1487.18, 'end': 1495.26, 'text': " Let's look at what has happened here. Okay, so let's see what happens here. So, when we first", 'tokens': [51252, 961, 311, 574, 412, 437, 575, 2011, 510, 13, 1033, 11, 370, 718, 311, 536, 437, 2314, 510, 13, 407, 11, 562, 321, 700, 51656], 'temperature': 0.0, 'avg_logprob': -0.14992902013990614, 'compression_ratio': 1.6153846153846154, 'no_speech_prob': 0.02283097244799137}, {'id': 175, 'seek': 149526, 'start': 1495.26, 'end': 1500.7, 'text': ' call foo, there is no problem so far. We are just calling a normal function. We come here.', 'tokens': [50364, 818, 726, 78, 11, 456, 307, 572, 1154, 370, 1400, 13, 492, 366, 445, 5141, 257, 2710, 2445, 13, 492, 808, 510, 13, 50636], 'temperature': 0.0, 'avg_logprob': -0.11564313847085704, 'compression_ratio': 1.654708520179372, 'no_speech_prob': 0.005904900375753641}, {'id': 176, 'seek': 149526, 'start': 1502.14, 'end': 1508.14, 'text': ' What is the layout of stack as soon as we enter foo? So, stack looks something like this. So,', 'tokens': [50708, 708, 307, 264, 13333, 295, 8630, 382, 2321, 382, 321, 3242, 726, 78, 30, 407, 11, 8630, 1542, 746, 411, 341, 13, 407, 11, 51008], 'temperature': 0.0, 'avg_logprob': -0.11564313847085704, 'compression_ratio': 1.654708520179372, 'no_speech_prob': 0.005904900375753641}, {'id': 177, 'seek': 149526, 'start': 1508.14, 'end': 1514.3799999999999, 'text': ' we had parameters which are passed which is a essentially. Then we have return address.', 'tokens': [51008, 321, 632, 9834, 597, 366, 4678, 597, 307, 257, 4476, 13, 1396, 321, 362, 2736, 2985, 13, 51320], 'temperature': 0.0, 'avg_logprob': -0.11564313847085704, 'compression_ratio': 1.654708520179372, 'no_speech_prob': 0.005904900375753641}, {'id': 178, 'seek': 149526, 'start': 1516.62, 'end': 1521.34, 'text': ' Remember params were passed in the caller stack frame and after that return address was present.', 'tokens': [51432, 5459, 971, 4070, 645, 4678, 294, 264, 48324, 8630, 3920, 293, 934, 300, 2736, 2985, 390, 1974, 13, 51668], 'temperature': 0.0, 'avg_logprob': -0.11564313847085704, 'compression_ratio': 1.654708520179372, 'no_speech_prob': 0.005904900375753641}, {'id': 179, 'seek': 152134, 'start': 1521.82, 'end': 1533.26, 'text': ' Right. So, p holds address of a. So, p is pointing here. Right. Then we say minus minus p.', 'tokens': [50388, 1779, 13, 407, 11, 280, 9190, 2985, 295, 257, 13, 407, 11, 280, 307, 12166, 510, 13, 1779, 13, 1396, 321, 584, 3175, 3175, 280, 13, 50960], 'temperature': 0.0, 'avg_logprob': -0.1812883279262445, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.0005702213384211063}, {'id': 180, 'seek': 152134, 'start': 1534.78, 'end': 1544.54, 'text': ' Okay, that means p now starts pointing here. Okay. And we save this value to val. Val now holds', 'tokens': [51036, 1033, 11, 300, 1355, 280, 586, 3719, 12166, 510, 13, 1033, 13, 400, 321, 3155, 341, 2158, 281, 1323, 13, 7188, 586, 9190, 51524], 'temperature': 0.0, 'avg_logprob': -0.1812883279262445, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.0005702213384211063}, {'id': 181, 'seek': 152134, 'start': 1544.54, 'end': 1550.3799999999999, 'text': ' return address. What is return address in this case when foo is called? What is the return address?', 'tokens': [51524, 2736, 2985, 13, 708, 307, 2736, 2985, 294, 341, 1389, 562, 726, 78, 307, 1219, 30, 708, 307, 264, 2736, 2985, 30, 51816], 'temperature': 0.0, 'avg_logprob': -0.1812883279262445, 'compression_ratio': 1.7228915662650603, 'no_speech_prob': 0.0005702213384211063}, {'id': 182, 'seek': 155134, 'start': 1551.98, 'end': 1558.54, 'text': ' It is the instruction following foo. That means it is called to bar. So, if this statement was', 'tokens': [50396, 467, 307, 264, 10951, 3480, 726, 78, 13, 663, 1355, 309, 307, 1219, 281, 2159, 13, 407, 11, 498, 341, 5629, 390, 50724], 'temperature': 0.0, 'avg_logprob': -0.11913441322945259, 'compression_ratio': 1.4722222222222223, 'no_speech_prob': 0.00010068018309539184}, {'id': 183, 'seek': 155134, 'start': 1558.54, 'end': 1567.1, 'text': ' location 0x100 and if this location was 0x200, then this value is holding 200.', 'tokens': [50724, 4914, 1958, 87, 6879, 293, 498, 341, 4914, 390, 1958, 87, 7629, 11, 550, 341, 2158, 307, 5061, 2331, 13, 51152], 'temperature': 0.0, 'avg_logprob': -0.11913441322945259, 'compression_ratio': 1.4722222222222223, 'no_speech_prob': 0.00010068018309539184}, {'id': 184, 'seek': 155134, 'start': 1569.34, 'end': 1576.54, 'text': ' Everyone got so far? Okay. Now, then we print foo and then we return. Where will we return?', 'tokens': [51264, 5198, 658, 370, 1400, 30, 1033, 13, 823, 11, 550, 321, 4482, 726, 78, 293, 550, 321, 2736, 13, 2305, 486, 321, 2736, 30, 51624], 'temperature': 0.0, 'avg_logprob': -0.11913441322945259, 'compression_ratio': 1.4722222222222223, 'no_speech_prob': 0.00010068018309539184}, {'id': 185, 'seek': 157654, 'start': 1576.54, 'end': 1585.02, 'text': ' 200. Sorry. 200. So, we will return here. See, we have not done anything. Okay. We have simply', 'tokens': [50364, 2331, 13, 4919, 13, 2331, 13, 407, 11, 321, 486, 2736, 510, 13, 3008, 11, 321, 362, 406, 1096, 1340, 13, 1033, 13, 492, 362, 2935, 50788], 'temperature': 0.0, 'avg_logprob': -0.18560381288881656, 'compression_ratio': 1.371212121212121, 'no_speech_prob': 0.00048723467625677586}, {'id': 186, 'seek': 157654, 'start': 1585.02, 'end': 1593.5, 'text': ' copied that value. Okay. Then we call bar. We come here. So, the stack frame will look', 'tokens': [50788, 25365, 300, 2158, 13, 1033, 13, 1396, 321, 818, 2159, 13, 492, 808, 510, 13, 407, 11, 264, 8630, 3920, 486, 574, 51212], 'temperature': 0.0, 'avg_logprob': -0.18560381288881656, 'compression_ratio': 1.371212121212121, 'no_speech_prob': 0.00048723467625677586}, {'id': 187, 'seek': 159350, 'start': 1594.14, 'end': 1609.1, 'text': ' somewhat similar to this where we have parameter b and p is pointing to b and then we decrement p.', 'tokens': [50396, 8344, 2531, 281, 341, 689, 321, 362, 13075, 272, 293, 280, 307, 12166, 281, 272, 293, 550, 321, 6853, 518, 280, 13, 51144], 'temperature': 0.0, 'avg_logprob': -0.0926668820557771, 'compression_ratio': 1.4732824427480915, 'no_speech_prob': 0.0016731680370867252}, {'id': 188, 'seek': 159350, 'start': 1609.1, 'end': 1618.38, 'text': ' So, p is now pointing here and what we do is we say p is equal to 0x200. That means we changed', 'tokens': [51144, 407, 11, 280, 307, 586, 12166, 510, 293, 437, 321, 360, 307, 321, 584, 280, 307, 2681, 281, 1958, 87, 7629, 13, 663, 1355, 321, 3105, 51608], 'temperature': 0.0, 'avg_logprob': -0.0926668820557771, 'compression_ratio': 1.4732824427480915, 'no_speech_prob': 0.0016731680370867252}, {'id': 189, 'seek': 161838, 'start': 1618.38, 'end': 1630.7, 'text': ' the return address to then in bar prints and where will bar function return? 200. What is at', 'tokens': [50364, 264, 2736, 2985, 281, 550, 294, 2159, 22305, 293, 689, 486, 2159, 2445, 2736, 30, 2331, 13, 708, 307, 412, 50980], 'temperature': 0.0, 'avg_logprob': -0.1429012005145733, 'compression_ratio': 1.6022099447513811, 'no_speech_prob': 0.003703273134306073}, {'id': 190, 'seek': 161838, 'start': 1630.7, 'end': 1640.46, 'text': ' 200? Call to foo. It again comes here. Again does the same thing. Again. So, it keeps doing the same', 'tokens': [50980, 2331, 30, 7807, 281, 726, 78, 13, 467, 797, 1487, 510, 13, 3764, 775, 264, 912, 551, 13, 3764, 13, 407, 11, 309, 5965, 884, 264, 912, 51468], 'temperature': 0.0, 'avg_logprob': -0.1429012005145733, 'compression_ratio': 1.6022099447513811, 'no_speech_prob': 0.003703273134306073}, {'id': 191, 'seek': 161838, 'start': 1640.46, 'end': 1648.14, 'text': ' thing. So, what we did is we overwrote the return address such that it calls bar multiple times.', 'tokens': [51468, 551, 13, 407, 11, 437, 321, 630, 307, 321, 670, 7449, 1370, 264, 2736, 2985, 1270, 300, 309, 5498, 2159, 3866, 1413, 13, 51852], 'temperature': 0.0, 'avg_logprob': -0.1429012005145733, 'compression_ratio': 1.6022099447513811, 'no_speech_prob': 0.003703273134306073}, {'id': 192, 'seek': 164814, 'start': 1648.94, 'end': 1655.3400000000001, 'text': ' This is actually one of the security holes. This forms basis of something called as buffer', 'tokens': [50404, 639, 307, 767, 472, 295, 264, 3825, 8118, 13, 639, 6422, 5143, 295, 746, 1219, 382, 21762, 50724], 'temperature': 0.0, 'avg_logprob': -0.13206392015729632, 'compression_ratio': 1.5297297297297296, 'no_speech_prob': 0.00017659190052654594}, {'id': 193, 'seek': 164814, 'start': 1655.3400000000001, 'end': 1663.42, 'text': ' overflow attack. Has anyone heard of it? Yes. Okay. So, imagine see here I did something simpler,', 'tokens': [50724, 37772, 2690, 13, 8646, 2878, 2198, 295, 309, 30, 1079, 13, 1033, 13, 407, 11, 3811, 536, 510, 286, 630, 746, 18587, 11, 51128], 'temperature': 0.0, 'avg_logprob': -0.13206392015729632, 'compression_ratio': 1.5297297297297296, 'no_speech_prob': 0.00017659190052654594}, {'id': 194, 'seek': 164814, 'start': 1663.42, 'end': 1672.7, 'text': ' but imagine if I could somehow do it something like this. So, if I said val here, val actually', 'tokens': [51128, 457, 3811, 498, 286, 727, 6063, 360, 309, 746, 411, 341, 13, 407, 11, 498, 286, 848, 1323, 510, 11, 1323, 767, 51592], 'temperature': 0.0, 'avg_logprob': -0.13206392015729632, 'compression_ratio': 1.5297297297297296, 'no_speech_prob': 0.00017659190052654594}, {'id': 195, 'seek': 167270, 'start': 1672.7, 'end': 1683.18, 'text': ' is some function man in the middle. If I somehow changed return address to a functions address', 'tokens': [50364, 307, 512, 2445, 587, 294, 264, 2808, 13, 759, 286, 6063, 3105, 2736, 2985, 281, 257, 6828, 2985, 50888], 'temperature': 0.0, 'avg_logprob': -0.06214087149676155, 'compression_ratio': 1.9246575342465753, 'no_speech_prob': 0.0013039461337029934}, {'id': 196, 'seek': 167270, 'start': 1683.18, 'end': 1690.54, 'text': ' called man in the middle, then what will happen? Bar will return to function man in the middle.', 'tokens': [50888, 1219, 587, 294, 264, 2808, 11, 550, 437, 486, 1051, 30, 4156, 486, 2736, 281, 2445, 587, 294, 264, 2808, 13, 51256], 'temperature': 0.0, 'avg_logprob': -0.06214087149676155, 'compression_ratio': 1.9246575342465753, 'no_speech_prob': 0.0013039461337029934}, {'id': 197, 'seek': 167270, 'start': 1691.26, 'end': 1697.5800000000002, 'text': ' Man in the middle will do whatever it wants to do and then can do whatever it needs to do.', 'tokens': [51292, 2458, 294, 264, 2808, 486, 360, 2035, 309, 2738, 281, 360, 293, 550, 393, 360, 2035, 309, 2203, 281, 360, 13, 51608], 'temperature': 0.0, 'avg_logprob': -0.06214087149676155, 'compression_ratio': 1.9246575342465753, 'no_speech_prob': 0.0013039461337029934}, {'id': 198, 'seek': 169758, 'start': 1698.1399999999999, 'end': 1704.3, 'text': ' Right. So, what we have got access to is access to the return address of a function.', 'tokens': [50392, 1779, 13, 407, 11, 437, 321, 362, 658, 2105, 281, 307, 2105, 281, 264, 2736, 2985, 295, 257, 2445, 13, 50700], 'temperature': 0.0, 'avg_logprob': -0.14519166946411133, 'compression_ratio': 1.626865671641791, 'no_speech_prob': 0.00038585488800890744}, {'id': 199, 'seek': 169758, 'start': 1705.1799999999998, 'end': 1712.86, 'text': ' And if we overwrite it or manipulate it, we can manipulate things very easily and we can do some', 'tokens': [50744, 400, 498, 321, 670, 21561, 309, 420, 20459, 309, 11, 321, 393, 20459, 721, 588, 3612, 293, 321, 393, 360, 512, 51128], 'temperature': 0.0, 'avg_logprob': -0.14519166946411133, 'compression_ratio': 1.626865671641791, 'no_speech_prob': 0.00038585488800890744}, {'id': 200, 'seek': 169758, 'start': 1712.86, 'end': 1716.54, 'text': ' interesting things with it. Okay. So, for example, let us look at it this way.', 'tokens': [51128, 1880, 721, 365, 309, 13, 1033, 13, 407, 11, 337, 1365, 11, 718, 505, 574, 412, 309, 341, 636, 13, 51312], 'temperature': 0.0, 'avg_logprob': -0.14519166946411133, 'compression_ratio': 1.626865671641791, 'no_speech_prob': 0.00038585488800890744}, {'id': 201, 'seek': 169758, 'start': 1717.8999999999999, 'end': 1724.86, 'text': ' So, let us say I had printf in main. Right. And I simply did this.', 'tokens': [51380, 407, 11, 718, 505, 584, 286, 632, 4482, 69, 294, 2135, 13, 1779, 13, 400, 286, 2935, 630, 341, 13, 51728], 'temperature': 0.0, 'avg_logprob': -0.14519166946411133, 'compression_ratio': 1.626865671641791, 'no_speech_prob': 0.00038585488800890744}, {'id': 202, 'seek': 172758, 'start': 1728.54, 'end': 1734.3, 'text': ' Okay. Now, let us invoke this code.', 'tokens': [50412, 1033, 13, 823, 11, 718, 505, 41117, 341, 3089, 13, 50700], 'temperature': 0.0, 'avg_logprob': -0.4186995710645403, 'compression_ratio': 0.813953488372093, 'no_speech_prob': 0.0847373977303505}, {'id': 203, 'seek': 173430, 'start': 1734.3, 'end': 1759.6599999999999, 'text': ' Okay. So, it has now gone to in foo, in bar, in main. So, I was able to successfully execute', 'tokens': [50364, 1033, 13, 407, 11, 309, 575, 586, 2780, 281, 294, 726, 78, 11, 294, 2159, 11, 294, 2135, 13, 407, 11, 286, 390, 1075, 281, 10727, 14483, 51632], 'temperature': 0.0, 'avg_logprob': -0.1464354145911432, 'compression_ratio': 1.0952380952380953, 'no_speech_prob': 0.0061665927059948444}, {'id': 204, 'seek': 175966, 'start': 1759.66, 'end': 1767.18, 'text': ' main in between foo and bar and do something in it. And this could be a function which has some', 'tokens': [50364, 2135, 294, 1296, 726, 78, 293, 2159, 293, 360, 746, 294, 309, 13, 400, 341, 727, 312, 257, 2445, 597, 575, 512, 50740], 'temperature': 0.0, 'avg_logprob': -0.08080985572900665, 'compression_ratio': 1.6849315068493151, 'no_speech_prob': 0.003478055354207754}, {'id': 205, 'seek': 175966, 'start': 1767.18, 'end': 1774.6200000000001, 'text': ' malicious code which can actually do something harm foo. Okay. So, having written address on stack', 'tokens': [50740, 33496, 3089, 597, 393, 767, 360, 746, 6491, 726, 78, 13, 1033, 13, 407, 11, 1419, 3720, 2985, 322, 8630, 51112], 'temperature': 0.0, 'avg_logprob': -0.08080985572900665, 'compression_ratio': 1.6849315068493151, 'no_speech_prob': 0.003478055354207754}, {'id': 206, 'seek': 175966, 'start': 1774.6200000000001, 'end': 1780.0600000000002, 'text': ' actually poses some security problems. Okay. There are some ways to deal with it,', 'tokens': [51112, 767, 26059, 512, 3825, 2740, 13, 1033, 13, 821, 366, 512, 2098, 281, 2028, 365, 309, 11, 51384], 'temperature': 0.0, 'avg_logprob': -0.08080985572900665, 'compression_ratio': 1.6849315068493151, 'no_speech_prob': 0.003478055354207754}, {'id': 207, 'seek': 175966, 'start': 1780.0600000000002, 'end': 1787.66, 'text': ' but in most cases you have this security issue in your system. And that is why you must have', 'tokens': [51384, 457, 294, 881, 3331, 291, 362, 341, 3825, 2734, 294, 428, 1185, 13, 400, 300, 307, 983, 291, 1633, 362, 51764], 'temperature': 0.0, 'avg_logprob': -0.08080985572900665, 'compression_ratio': 1.6849315068493151, 'no_speech_prob': 0.003478055354207754}, {'id': 208, 'seek': 178766, 'start': 1788.3000000000002, 'end': 1796.6200000000001, 'text': ' probably read somewhere, do not use strcpy, use strncpy. Right. Those kinds of things are there', 'tokens': [50396, 1391, 1401, 4079, 11, 360, 406, 764, 1056, 66, 8200, 11, 764, 1056, 77, 66, 8200, 13, 1779, 13, 3950, 3685, 295, 721, 366, 456, 50812], 'temperature': 0.0, 'avg_logprob': -0.09616836359803106, 'compression_ratio': 1.695906432748538, 'no_speech_prob': 0.0032714386470615864}, {'id': 209, 'seek': 178766, 'start': 1796.6200000000001, 'end': 1803.9, 'text': ' because you do not want to accidentally overwrite variables on the stack. See, if you accidentally', 'tokens': [50812, 570, 291, 360, 406, 528, 281, 15715, 670, 21561, 9102, 322, 264, 8630, 13, 3008, 11, 498, 291, 15715, 51176], 'temperature': 0.0, 'avg_logprob': -0.09616836359803106, 'compression_ratio': 1.695906432748538, 'no_speech_prob': 0.0032714386470615864}, {'id': 210, 'seek': 178766, 'start': 1803.9, 'end': 1809.3400000000001, 'text': ' overwrite variables on the stack, you will actually corrupting the return address. And when you', 'tokens': [51176, 670, 21561, 9102, 322, 264, 8630, 11, 291, 486, 767, 17366, 278, 264, 2736, 2985, 13, 400, 562, 291, 51448], 'temperature': 0.0, 'avg_logprob': -0.09616836359803106, 'compression_ratio': 1.695906432748538, 'no_speech_prob': 0.0032714386470615864}, {'id': 211, 'seek': 180934, 'start': 1809.34, 'end': 1817.82, 'text': ' corrupt return address, something bad can happen. Okay. So, so far, just to recollect,', 'tokens': [50364, 17366, 2736, 2985, 11, 746, 1578, 393, 1051, 13, 1033, 13, 407, 11, 370, 1400, 11, 445, 281, 39495, 557, 11, 50788], 'temperature': 0.0, 'avg_logprob': -0.10422316464510831, 'compression_ratio': 1.6726457399103138, 'no_speech_prob': 0.04466000571846962}, {'id': 212, 'seek': 180934, 'start': 1817.82, 'end': 1823.8999999999999, 'text': ' before the break we looked into how things were passed as a control, how parameters were passed,', 'tokens': [50788, 949, 264, 1821, 321, 2956, 666, 577, 721, 645, 4678, 382, 257, 1969, 11, 577, 9834, 645, 4678, 11, 51092], 'temperature': 0.0, 'avg_logprob': -0.10422316464510831, 'compression_ratio': 1.6726457399103138, 'no_speech_prob': 0.04466000571846962}, {'id': 213, 'seek': 180934, 'start': 1823.8999999999999, 'end': 1828.86, 'text': ' how local variables were done. Now, let us look at return value which is the last thing which is', 'tokens': [51092, 577, 2654, 9102, 645, 1096, 13, 823, 11, 718, 505, 574, 412, 2736, 2158, 597, 307, 264, 1036, 551, 597, 307, 51340], 'temperature': 0.0, 'avg_logprob': -0.10422316464510831, 'compression_ratio': 1.6726457399103138, 'no_speech_prob': 0.04466000571846962}, {'id': 214, 'seek': 180934, 'start': 1828.86, 'end': 1834.9399999999998, 'text': ' remaining. Right. So, return value is actually comparatively simpler because what happens is', 'tokens': [51340, 8877, 13, 1779, 13, 407, 11, 2736, 2158, 307, 767, 6311, 19020, 18587, 570, 437, 2314, 307, 51644], 'temperature': 0.0, 'avg_logprob': -0.10422316464510831, 'compression_ratio': 1.6726457399103138, 'no_speech_prob': 0.04466000571846962}, {'id': 215, 'seek': 183494, 'start': 1834.94, 'end': 1840.6200000000001, 'text': ' most of the programming languages support only one return value. So, they say you can only return', 'tokens': [50364, 881, 295, 264, 9410, 8650, 1406, 787, 472, 2736, 2158, 13, 407, 11, 436, 584, 291, 393, 787, 2736, 50648], 'temperature': 0.0, 'avg_logprob': -0.0691135436930555, 'compression_ratio': 1.7962962962962963, 'no_speech_prob': 0.0174331646412611}, {'id': 216, 'seek': 183494, 'start': 1840.6200000000001, 'end': 1847.02, 'text': ' one value from a function. You cannot return multiple values. Right. So, that you can actually', 'tokens': [50648, 472, 2158, 490, 257, 2445, 13, 509, 2644, 2736, 3866, 4190, 13, 1779, 13, 407, 11, 300, 291, 393, 767, 50968], 'temperature': 0.0, 'avg_logprob': -0.0691135436930555, 'compression_ratio': 1.7962962962962963, 'no_speech_prob': 0.0174331646412611}, {'id': 217, 'seek': 183494, 'start': 1847.02, 'end': 1854.7, 'text': ' do by register itself. So, most of the implementations including x86 simply pass return value via', 'tokens': [50968, 360, 538, 7280, 2564, 13, 407, 11, 881, 295, 264, 4445, 763, 3009, 2031, 22193, 2935, 1320, 2736, 2158, 5766, 51352], 'temperature': 0.0, 'avg_logprob': -0.0691135436930555, 'compression_ratio': 1.7962962962962963, 'no_speech_prob': 0.0174331646412611}, {'id': 218, 'seek': 183494, 'start': 1854.7, 'end': 1860.54, 'text': ' register. They do not put it on the stack. So, you can return. So, whatever is your return value,', 'tokens': [51352, 7280, 13, 814, 360, 406, 829, 309, 322, 264, 8630, 13, 407, 11, 291, 393, 2736, 13, 407, 11, 2035, 307, 428, 2736, 2158, 11, 51644], 'temperature': 0.0, 'avg_logprob': -0.0691135436930555, 'compression_ratio': 1.7962962962962963, 'no_speech_prob': 0.0174331646412611}, {'id': 219, 'seek': 186054, 'start': 1860.54, 'end': 1866.54, 'text': ' just before returning, you populate that value into EAX and the caller function will access', 'tokens': [50364, 445, 949, 12678, 11, 291, 1665, 5256, 300, 2158, 666, 35747, 55, 293, 264, 48324, 2445, 486, 2105, 50664], 'temperature': 0.0, 'avg_logprob': -0.08129014514741444, 'compression_ratio': 1.6566523605150214, 'no_speech_prob': 0.003074292792007327}, {'id': 220, 'seek': 186054, 'start': 1867.42, 'end': 1876.06, 'text': ' EAX to get that value. Okay. Now, if you return a large struct, what will happen? See, C says', 'tokens': [50708, 35747, 55, 281, 483, 300, 2158, 13, 1033, 13, 823, 11, 498, 291, 2736, 257, 2416, 6594, 11, 437, 486, 1051, 30, 3008, 11, 383, 1619, 51140], 'temperature': 0.0, 'avg_logprob': -0.08129014514741444, 'compression_ratio': 1.6566523605150214, 'no_speech_prob': 0.003074292792007327}, {'id': 221, 'seek': 186054, 'start': 1876.06, 'end': 1881.98, 'text': ' return only one value, but it does not say it has to be a 32-bit value. It can be a structure. Right.', 'tokens': [51140, 2736, 787, 472, 2158, 11, 457, 309, 775, 406, 584, 309, 575, 281, 312, 257, 8858, 12, 5260, 2158, 13, 467, 393, 312, 257, 3877, 13, 1779, 13, 51436], 'temperature': 0.0, 'avg_logprob': -0.08129014514741444, 'compression_ratio': 1.6566523605150214, 'no_speech_prob': 0.003074292792007327}, {'id': 222, 'seek': 186054, 'start': 1881.98, 'end': 1889.18, 'text': ' I can have a structure of 100 elements. How will I return? See, if I have a function which returns', 'tokens': [51436, 286, 393, 362, 257, 3877, 295, 2319, 4959, 13, 1012, 486, 286, 2736, 30, 3008, 11, 498, 286, 362, 257, 2445, 597, 11247, 51796], 'temperature': 0.0, 'avg_logprob': -0.08129014514741444, 'compression_ratio': 1.6566523605150214, 'no_speech_prob': 0.003074292792007327}, {'id': 223, 'seek': 188918, 'start': 1889.18, 'end': 1899.3400000000001, 'text': ' a structure, so the simplest thing which most of the implementations do is EAX is a 32-bit value.', 'tokens': [50364, 257, 3877, 11, 370, 264, 22811, 551, 597, 881, 295, 264, 4445, 763, 360, 307, 35747, 55, 307, 257, 8858, 12, 5260, 2158, 13, 50872], 'temperature': 0.0, 'avg_logprob': -0.08353320654336509, 'compression_ratio': 1.5706521739130435, 'no_speech_prob': 0.0014100781409069896}, {'id': 224, 'seek': 188918, 'start': 1899.3400000000001, 'end': 1905.66, 'text': ' So, it can at least hold a pointer for 32-bit systems. Right. So, what you can do is you can', 'tokens': [50872, 407, 11, 309, 393, 412, 1935, 1797, 257, 23918, 337, 8858, 12, 5260, 3652, 13, 1779, 13, 407, 11, 437, 291, 393, 360, 307, 291, 393, 51188], 'temperature': 0.0, 'avg_logprob': -0.08353320654336509, 'compression_ratio': 1.5706521739130435, 'no_speech_prob': 0.0014100781409069896}, {'id': 225, 'seek': 188918, 'start': 1905.66, 'end': 1913.42, 'text': ' actually, the caller function actually creates the structure on the stack and it is some sort of a', 'tokens': [51188, 767, 11, 264, 48324, 2445, 767, 7829, 264, 3877, 322, 264, 8630, 293, 309, 307, 512, 1333, 295, 257, 51576], 'temperature': 0.0, 'avg_logprob': -0.08353320654336509, 'compression_ratio': 1.5706521739130435, 'no_speech_prob': 0.0014100781409069896}, {'id': 226, 'seek': 191342, 'start': 1913.42, 'end': 1919.3400000000001, 'text': ' call by address where you pass that address to the callee function. The callee function modifies', 'tokens': [50364, 818, 538, 2985, 689, 291, 1320, 300, 2985, 281, 264, 818, 1653, 2445, 13, 440, 818, 1653, 2445, 1072, 11221, 50660], 'temperature': 0.0, 'avg_logprob': -0.07701006040468321, 'compression_ratio': 1.820754716981132, 'no_speech_prob': 0.18233460187911987}, {'id': 227, 'seek': 191342, 'start': 1919.3400000000001, 'end': 1926.8600000000001, 'text': ' whatever it wants and EAX holds address to that and you use that. Okay. Does everyone get this?', 'tokens': [50660, 2035, 309, 2738, 293, 35747, 55, 9190, 2985, 281, 300, 293, 291, 764, 300, 13, 1033, 13, 4402, 1518, 483, 341, 30, 51036], 'temperature': 0.0, 'avg_logprob': -0.07701006040468321, 'compression_ratio': 1.820754716981132, 'no_speech_prob': 0.18233460187911987}, {'id': 228, 'seek': 191342, 'start': 1926.8600000000001, 'end': 1933.1000000000001, 'text': ' So, when you are calling a function, you pass a hidden parameter. The hidden parameter will be', 'tokens': [51036, 407, 11, 562, 291, 366, 5141, 257, 2445, 11, 291, 1320, 257, 7633, 13075, 13, 440, 7633, 13075, 486, 312, 51348], 'temperature': 0.0, 'avg_logprob': -0.07701006040468321, 'compression_ratio': 1.820754716981132, 'no_speech_prob': 0.18233460187911987}, {'id': 229, 'seek': 191342, 'start': 1933.1000000000001, 'end': 1940.3000000000002, 'text': ' essentially address of the structure which is the return value. Okay. You call the callee function', 'tokens': [51348, 4476, 2985, 295, 264, 3877, 597, 307, 264, 2736, 2158, 13, 1033, 13, 509, 818, 264, 818, 1653, 2445, 51708], 'temperature': 0.0, 'avg_logprob': -0.07701006040468321, 'compression_ratio': 1.820754716981132, 'no_speech_prob': 0.18233460187911987}, {'id': 230, 'seek': 194030, 'start': 1940.3, 'end': 1946.78, 'text': ' will do whatever update it needs to do in that address and then return address of that variable', 'tokens': [50364, 486, 360, 2035, 5623, 309, 2203, 281, 360, 294, 300, 2985, 293, 550, 2736, 2985, 295, 300, 7006, 50688], 'temperature': 0.0, 'avg_logprob': -0.09870070399660053, 'compression_ratio': 1.5730994152046784, 'no_speech_prob': 0.019118446856737137}, {'id': 231, 'seek': 194030, 'start': 1947.34, 'end': 1955.58, 'text': ' as EAX and the caller function can use that address in EAX to refer to the structure. Okay.', 'tokens': [50716, 382, 35747, 55, 293, 264, 48324, 2445, 393, 764, 300, 2985, 294, 35747, 55, 281, 2864, 281, 264, 3877, 13, 1033, 13, 51128], 'temperature': 0.0, 'avg_logprob': -0.09870070399660053, 'compression_ratio': 1.5730994152046784, 'no_speech_prob': 0.019118446856737137}, {'id': 232, 'seek': 194030, 'start': 1955.58, 'end': 1961.1, 'text': ' That is how you return a larger value which does not fit into EAX register. Okay.', 'tokens': [51128, 663, 307, 577, 291, 2736, 257, 4833, 2158, 597, 775, 406, 3318, 666, 35747, 55, 7280, 13, 1033, 13, 51404], 'temperature': 0.0, 'avg_logprob': -0.09870070399660053, 'compression_ratio': 1.5730994152046784, 'no_speech_prob': 0.019118446856737137}, {'id': 233, 'seek': 197030, 'start': 1970.3, 'end': 1985.74, 'text': ' Correct. Yes. So, that is a problem. So, the problem which Ujwal is trying to raise is', 'tokens': [50364, 12753, 13, 1079, 13, 407, 11, 300, 307, 257, 1154, 13, 407, 11, 264, 1154, 597, 624, 73, 29530, 307, 1382, 281, 5300, 307, 51136], 'temperature': 0.0, 'avg_logprob': -0.16230179713322565, 'compression_ratio': 1.6529411764705881, 'no_speech_prob': 0.0075744143687188625}, {'id': 234, 'seek': 197030, 'start': 1986.46, 'end': 1992.22, 'text': ' return values are optional. Right. The caller function does not need to say x is equal to foo.', 'tokens': [51172, 2736, 4190, 366, 17312, 13, 1779, 13, 440, 48324, 2445, 775, 406, 643, 281, 584, 2031, 307, 2681, 281, 726, 78, 13, 51460], 'temperature': 0.0, 'avg_logprob': -0.16230179713322565, 'compression_ratio': 1.6529411764705881, 'no_speech_prob': 0.0075744143687188625}, {'id': 235, 'seek': 197030, 'start': 1992.22, 'end': 1997.4199999999998, 'text': ' It can simply say foo although foo is a returning a value. So, the caller function does not need to', 'tokens': [51460, 467, 393, 2935, 584, 726, 78, 4878, 726, 78, 307, 257, 12678, 257, 2158, 13, 407, 11, 264, 48324, 2445, 775, 406, 643, 281, 51720], 'temperature': 0.0, 'avg_logprob': -0.16230179713322565, 'compression_ratio': 1.6529411764705881, 'no_speech_prob': 0.0075744143687188625}, {'id': 236, 'seek': 199742, 'start': 1997.42, 'end': 2004.54, 'text': ' collect the return value. Right. But you will still have the overhead just because foo was', 'tokens': [50364, 2500, 264, 2736, 2158, 13, 1779, 13, 583, 291, 486, 920, 362, 264, 19922, 445, 570, 726, 78, 390, 50720], 'temperature': 0.0, 'avg_logprob': -0.10621901060405531, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.003074731444939971}, {'id': 237, 'seek': 199742, 'start': 2004.54, 'end': 2010.54, 'text': ' returning struct. It had to populate all of that. Right. And that is needed because when you are', 'tokens': [50720, 12678, 6594, 13, 467, 632, 281, 1665, 5256, 439, 295, 300, 13, 1779, 13, 400, 300, 307, 2978, 570, 562, 291, 366, 51020], 'temperature': 0.0, 'avg_logprob': -0.10621901060405531, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.003074731444939971}, {'id': 238, 'seek': 199742, 'start': 2010.54, 'end': 2016.3000000000002, 'text': ' compiling foo, you have no idea whether return value will actually be used or not used. So,', 'tokens': [51020, 715, 4883, 726, 78, 11, 291, 362, 572, 1558, 1968, 2736, 2158, 486, 767, 312, 1143, 420, 406, 1143, 13, 407, 11, 51308], 'temperature': 0.0, 'avg_logprob': -0.10621901060405531, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.003074731444939971}, {'id': 239, 'seek': 199742, 'start': 2016.3000000000002, 'end': 2022.3000000000002, 'text': ' you have to be conservative and do that. You cannot do much about it. Does everyone get this point?', 'tokens': [51308, 291, 362, 281, 312, 13780, 293, 360, 300, 13, 509, 2644, 360, 709, 466, 309, 13, 4402, 1518, 483, 341, 935, 30, 51608], 'temperature': 0.0, 'avg_logprob': -0.10621901060405531, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.003074731444939971}, {'id': 240, 'seek': 202230, 'start': 2022.3, 'end': 2029.18, 'text': ' Because foo might be defined in a different file than the main function and foo function does not', 'tokens': [50364, 1436, 726, 78, 1062, 312, 7642, 294, 257, 819, 3991, 813, 264, 2135, 2445, 293, 726, 78, 2445, 775, 406, 50708], 'temperature': 0.0, 'avg_logprob': -0.08746831808517229, 'compression_ratio': 1.5524861878453038, 'no_speech_prob': 0.1965179294347763}, {'id': 241, 'seek': 202230, 'start': 2029.18, 'end': 2034.1399999999999, 'text': ' know whether main is actually going to use the return value or not. So, it still has to do', 'tokens': [50708, 458, 1968, 2135, 307, 767, 516, 281, 764, 264, 2736, 2158, 420, 406, 13, 407, 11, 309, 920, 575, 281, 360, 50956], 'temperature': 0.0, 'avg_logprob': -0.08746831808517229, 'compression_ratio': 1.5524861878453038, 'no_speech_prob': 0.1965179294347763}, {'id': 242, 'seek': 202230, 'start': 2034.1399999999999, 'end': 2040.86, 'text': ' whatever is required assuming worst case in which case it will actually use the value. Okay.', 'tokens': [50956, 2035, 307, 4739, 11926, 5855, 1389, 294, 597, 1389, 309, 486, 767, 764, 264, 2158, 13, 1033, 13, 51292], 'temperature': 0.0, 'avg_logprob': -0.08746831808517229, 'compression_ratio': 1.5524861878453038, 'no_speech_prob': 0.1965179294347763}, {'id': 243, 'seek': 204086, 'start': 2040.86, 'end': 2054.22, 'text': ' This is same as how parameters are. So, think of it this way that compiler simply translated', 'tokens': [50364, 639, 307, 912, 382, 577, 9834, 366, 13, 407, 11, 519, 295, 309, 341, 636, 300, 31958, 2935, 16805, 51032], 'temperature': 0.0, 'avg_logprob': -0.21284158179100524, 'compression_ratio': 1.3777777777777778, 'no_speech_prob': 0.00689453212544322}, {'id': 244, 'seek': 204086, 'start': 2054.22, 'end': 2065.8199999999997, 'text': ' a function like this struct as foo with int x int y to something equivalent to this. Wide foo', 'tokens': [51032, 257, 2445, 411, 341, 6594, 382, 726, 78, 365, 560, 2031, 560, 288, 281, 746, 10344, 281, 341, 13, 42543, 726, 78, 51612], 'temperature': 0.0, 'avg_logprob': -0.21284158179100524, 'compression_ratio': 1.3777777777777778, 'no_speech_prob': 0.00689453212544322}, {'id': 245, 'seek': 206582, 'start': 2065.82, 'end': 2079.98, 'text': ' int x int y struct as star. So, it passed this as a hidden parameter, did all the updates and', 'tokens': [50364, 560, 2031, 560, 288, 6594, 382, 3543, 13, 407, 11, 309, 4678, 341, 382, 257, 7633, 13075, 11, 630, 439, 264, 9205, 293, 51072], 'temperature': 0.0, 'avg_logprob': -0.24353837966918945, 'compression_ratio': 1.5737704918032787, 'no_speech_prob': 0.008842743933200836}, {'id': 246, 'seek': 206582, 'start': 2079.98, 'end': 2091.46, 'text': ' simply returned actually this should be int star or struct star struct as star and simply returned', 'tokens': [51072, 2935, 8752, 767, 341, 820, 312, 560, 3543, 420, 6594, 3543, 6594, 382, 3543, 293, 2935, 8752, 51646], 'temperature': 0.0, 'avg_logprob': -0.24353837966918945, 'compression_ratio': 1.5737704918032787, 'no_speech_prob': 0.008842743933200836}, {'id': 247, 'seek': 209146, 'start': 2091.46, 'end': 2116.38, 'text': ' address of that. I will come to who specifies these things. Correct. So, it is in the caller', 'tokens': [50364, 2985, 295, 300, 13, 286, 486, 808, 281, 567, 1608, 11221, 613, 721, 13, 12753, 13, 407, 11, 309, 307, 294, 264, 48324, 51610], 'temperature': 0.0, 'avg_logprob': -0.1937245969419126, 'compression_ratio': 1.0823529411764705, 'no_speech_prob': 0.9239036440849304}, {'id': 248, 'seek': 211638, 'start': 2116.5, 'end': 2125.9, 'text': ' stack. So, so far we have seen how things actually work between function calls. Now,', 'tokens': [50370, 8630, 13, 407, 11, 370, 1400, 321, 362, 1612, 577, 721, 767, 589, 1296, 2445, 5498, 13, 823, 11, 50840], 'temperature': 0.0, 'avg_logprob': -0.12518751898477243, 'compression_ratio': 1.86, 'no_speech_prob': 0.5384149551391602}, {'id': 249, 'seek': 211638, 'start': 2125.9, 'end': 2132.46, 'text': ' one thing which is remaining which I think was coming earlier in couple of times is both the', 'tokens': [50840, 472, 551, 597, 307, 8877, 597, 286, 519, 390, 1348, 3071, 294, 1916, 295, 1413, 307, 1293, 264, 51168], 'temperature': 0.0, 'avg_logprob': -0.12518751898477243, 'compression_ratio': 1.86, 'no_speech_prob': 0.5384149551391602}, {'id': 250, 'seek': 211638, 'start': 2132.46, 'end': 2138.06, 'text': ' caller function and callee function are using the same hardware. It is not that caller function is', 'tokens': [51168, 48324, 2445, 293, 818, 1653, 2445, 366, 1228, 264, 912, 8837, 13, 467, 307, 406, 300, 48324, 2445, 307, 51448], 'temperature': 0.0, 'avg_logprob': -0.12518751898477243, 'compression_ratio': 1.86, 'no_speech_prob': 0.5384149551391602}, {'id': 251, 'seek': 211638, 'start': 2138.06, 'end': 2143.5, 'text': ' executing on one hardware and callee is executing on other hardware. So, they have to share the', 'tokens': [51448, 32368, 322, 472, 8837, 293, 818, 1653, 307, 32368, 322, 661, 8837, 13, 407, 11, 436, 362, 281, 2073, 264, 51720], 'temperature': 0.0, 'avg_logprob': -0.12518751898477243, 'compression_ratio': 1.86, 'no_speech_prob': 0.5384149551391602}, {'id': 252, 'seek': 214350, 'start': 2143.58, 'end': 2150.7, 'text': ' hardware. That means they have to share the registers and someone was saying what if so,', 'tokens': [50368, 8837, 13, 663, 1355, 436, 362, 281, 2073, 264, 38351, 293, 1580, 390, 1566, 437, 498, 370, 11, 50724], 'temperature': 0.0, 'avg_logprob': -0.15630130145860754, 'compression_ratio': 1.7980769230769231, 'no_speech_prob': 0.04206504672765732}, {'id': 253, 'seek': 214350, 'start': 2150.7, 'end': 2155.22, 'text': ' when we were talking about things like written address. So, what if the callee function needs', 'tokens': [50724, 562, 321, 645, 1417, 466, 721, 411, 3720, 2985, 13, 407, 11, 437, 498, 264, 818, 1653, 2445, 2203, 50950], 'temperature': 0.0, 'avg_logprob': -0.15630130145860754, 'compression_ratio': 1.7980769230769231, 'no_speech_prob': 0.04206504672765732}, {'id': 254, 'seek': 214350, 'start': 2155.22, 'end': 2162.86, 'text': ' eax and it overwrites it. So, in this case what is happening is caller function is moving value 5', 'tokens': [50950, 308, 2797, 293, 309, 670, 86, 30931, 309, 13, 407, 11, 294, 341, 1389, 437, 307, 2737, 307, 48324, 2445, 307, 2684, 2158, 1025, 51332], 'temperature': 0.0, 'avg_logprob': -0.15630130145860754, 'compression_ratio': 1.7980769230769231, 'no_speech_prob': 0.04206504672765732}, {'id': 255, 'seek': 214350, 'start': 2162.86, 'end': 2170.1, 'text': ' into edx then calling the callee function and callee function is overwriting edx and when the', 'tokens': [51332, 666, 1257, 87, 550, 5141, 264, 818, 1653, 2445, 293, 818, 1653, 2445, 307, 670, 19868, 1257, 87, 293, 562, 264, 51694], 'temperature': 0.0, 'avg_logprob': -0.15630130145860754, 'compression_ratio': 1.7980769230769231, 'no_speech_prob': 0.04206504672765732}, {'id': 256, 'seek': 217010, 'start': 2170.1, 'end': 2177.7799999999997, 'text': ' control comes back this edx value is no longer present because there is only one register called', 'tokens': [50364, 1969, 1487, 646, 341, 1257, 87, 2158, 307, 572, 2854, 1974, 570, 456, 307, 787, 472, 7280, 1219, 50748], 'temperature': 0.0, 'avg_logprob': -0.1476520432366265, 'compression_ratio': 1.5714285714285714, 'no_speech_prob': 0.01639687269926071}, {'id': 257, 'seek': 217010, 'start': 2177.7799999999997, 'end': 2188.14, 'text': ' edx in the hardware. There is no caller underscore edx or callee underscore edx. So, it was overwritten.', 'tokens': [50748, 1257, 87, 294, 264, 8837, 13, 821, 307, 572, 48324, 37556, 1257, 87, 420, 818, 1653, 37556, 1257, 87, 13, 407, 11, 309, 390, 670, 26859, 13, 51266], 'temperature': 0.0, 'avg_logprob': -0.1476520432366265, 'compression_ratio': 1.5714285714285714, 'no_speech_prob': 0.01639687269926071}, {'id': 258, 'seek': 217010, 'start': 2188.14, 'end': 2196.14, 'text': ' So, edx must be somehow saved before and after call instruction. Who should save it?', 'tokens': [51266, 407, 11, 1257, 87, 1633, 312, 6063, 6624, 949, 293, 934, 818, 10951, 13, 2102, 820, 3155, 309, 30, 51666], 'temperature': 0.0, 'avg_logprob': -0.1476520432366265, 'compression_ratio': 1.5714285714285714, 'no_speech_prob': 0.01639687269926071}, {'id': 259, 'seek': 219614, 'start': 2196.14, 'end': 2210.2999999999997, 'text': ' Yeah. So, let us go with some step by step things. So, let us say so, what is the requirement?', 'tokens': [50364, 865, 13, 407, 11, 718, 505, 352, 365, 512, 1823, 538, 1823, 721, 13, 407, 11, 718, 505, 584, 370, 11, 437, 307, 264, 11695, 30, 51072], 'temperature': 0.0, 'avg_logprob': -0.1485910415649414, 'compression_ratio': 1.7898089171974523, 'no_speech_prob': 0.0027964578475803137}, {'id': 260, 'seek': 219614, 'start': 2210.2999999999997, 'end': 2215.66, 'text': ' Requirement is caller function should save and restore all the registers before and after call', 'tokens': [51072, 42029, 28575, 307, 48324, 2445, 820, 3155, 293, 15227, 439, 264, 38351, 949, 293, 934, 818, 51340], 'temperature': 0.0, 'avg_logprob': -0.1485910415649414, 'compression_ratio': 1.7898089171974523, 'no_speech_prob': 0.0027964578475803137}, {'id': 261, 'seek': 219614, 'start': 2215.66, 'end': 2221.06, 'text': ' it is going to use and callee function should save and restore registers it is using in the', 'tokens': [51340, 309, 307, 516, 281, 764, 293, 818, 1653, 2445, 820, 3155, 293, 15227, 38351, 309, 307, 1228, 294, 264, 51610], 'temperature': 0.0, 'avg_logprob': -0.1485910415649414, 'compression_ratio': 1.7898089171974523, 'no_speech_prob': 0.0027964578475803137}, {'id': 262, 'seek': 222106, 'start': 2221.06, 'end': 2226.66, 'text': ' function body. So, caller function uses some registers it saves and restores them across the', 'tokens': [50364, 2445, 1772, 13, 407, 11, 48324, 2445, 4960, 512, 38351, 309, 19155, 293, 1472, 2706, 552, 2108, 264, 50644], 'temperature': 0.0, 'avg_logprob': -0.12831770718752683, 'compression_ratio': 1.9891891891891893, 'no_speech_prob': 0.2686687707901001}, {'id': 263, 'seek': 222106, 'start': 2226.66, 'end': 2233.2599999999998, 'text': ' call instruction. If callee function uses some registers it saves and restores them. Now,', 'tokens': [50644, 818, 10951, 13, 759, 818, 1653, 2445, 4960, 512, 38351, 309, 19155, 293, 1472, 2706, 552, 13, 823, 11, 50974], 'temperature': 0.0, 'avg_logprob': -0.12831770718752683, 'compression_ratio': 1.9891891891891893, 'no_speech_prob': 0.2686687707901001}, {'id': 264, 'seek': 222106, 'start': 2233.2599999999998, 'end': 2239.82, 'text': ' if there is a register which is used by both of them then there is possibly redundancy. So,', 'tokens': [50974, 498, 456, 307, 257, 7280, 597, 307, 1143, 538, 1293, 295, 552, 550, 456, 307, 6264, 27830, 6717, 13, 407, 11, 51302], 'temperature': 0.0, 'avg_logprob': -0.12831770718752683, 'compression_ratio': 1.9891891891891893, 'no_speech_prob': 0.2686687707901001}, {'id': 265, 'seek': 222106, 'start': 2239.82, 'end': 2248.94, 'text': ' let us say there is eax register is being used by caller. So, caller is saying that okay I am', 'tokens': [51302, 718, 505, 584, 456, 307, 308, 2797, 7280, 307, 885, 1143, 538, 48324, 13, 407, 11, 48324, 307, 1566, 300, 1392, 286, 669, 51758], 'temperature': 0.0, 'avg_logprob': -0.12831770718752683, 'compression_ratio': 1.9891891891891893, 'no_speech_prob': 0.2686687707901001}, {'id': 266, 'seek': 224894, 'start': 2248.94, 'end': 2254.82, 'text': ' using this so I must save this register. So, it has saved that register. Now, callee comes callee', 'tokens': [50364, 1228, 341, 370, 286, 1633, 3155, 341, 7280, 13, 407, 11, 309, 575, 6624, 300, 7280, 13, 823, 11, 818, 1653, 1487, 818, 1653, 50658], 'temperature': 0.0, 'avg_logprob': -0.13362271735008727, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.014478960074484348}, {'id': 267, 'seek': 224894, 'start': 2254.82, 'end': 2260.94, 'text': ' is saying I also need to use eax. So, I should save it. So, there is unnecessary saving which', 'tokens': [50658, 307, 1566, 286, 611, 643, 281, 764, 308, 2797, 13, 407, 11, 286, 820, 3155, 309, 13, 407, 11, 456, 307, 19350, 6816, 597, 50964], 'temperature': 0.0, 'avg_logprob': -0.13362271735008727, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.014478960074484348}, {'id': 268, 'seek': 224894, 'start': 2260.94, 'end': 2267.14, 'text': ' is happening because both of them were using it both of them are saving it without it would', 'tokens': [50964, 307, 2737, 570, 1293, 295, 552, 645, 1228, 309, 1293, 295, 552, 366, 6816, 309, 1553, 309, 576, 51274], 'temperature': 0.0, 'avg_logprob': -0.13362271735008727, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.014478960074484348}, {'id': 269, 'seek': 224894, 'start': 2267.14, 'end': 2272.82, 'text': ' have been ideal if only one of them saved it because that would save some time and same', 'tokens': [51274, 362, 668, 7157, 498, 787, 472, 295, 552, 6624, 309, 570, 300, 576, 3155, 512, 565, 293, 912, 51558], 'temperature': 0.0, 'avg_logprob': -0.13362271735008727, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.014478960074484348}, {'id': 270, 'seek': 227282, 'start': 2272.82, 'end': 2281.5800000000004, 'text': ' thing will happen is the question really is does the caller function know which registers', 'tokens': [50364, 551, 486, 1051, 307, 264, 1168, 534, 307, 775, 264, 48324, 2445, 458, 597, 38351, 50802], 'temperature': 0.0, 'avg_logprob': -0.12855832278728485, 'compression_ratio': 1.957142857142857, 'no_speech_prob': 0.07112377136945724}, {'id': 271, 'seek': 227282, 'start': 2281.5800000000004, 'end': 2287.7400000000002, 'text': ' callee function is using and does callee function know which registers caller is using does it know.', 'tokens': [50802, 818, 1653, 2445, 307, 1228, 293, 775, 818, 1653, 2445, 458, 597, 38351, 48324, 307, 1228, 775, 309, 458, 13, 51110], 'temperature': 0.0, 'avg_logprob': -0.12855832278728485, 'compression_ratio': 1.957142857142857, 'no_speech_prob': 0.07112377136945724}, {'id': 272, 'seek': 227282, 'start': 2287.7400000000002, 'end': 2295.98, 'text': ' So, when you call a function foo do you know which registers are being used by foo?', 'tokens': [51110, 407, 11, 562, 291, 818, 257, 2445, 726, 78, 360, 291, 458, 597, 38351, 366, 885, 1143, 538, 726, 78, 30, 51522], 'temperature': 0.0, 'avg_logprob': -0.12855832278728485, 'compression_ratio': 1.957142857142857, 'no_speech_prob': 0.07112377136945724}, {'id': 273, 'seek': 229598, 'start': 2295.98, 'end': 2307.58, 'text': " You do not know because foo's definition may not be available and you have to do inter procedural", 'tokens': [50364, 509, 360, 406, 458, 570, 726, 78, 311, 7123, 815, 406, 312, 2435, 293, 291, 362, 281, 360, 728, 43951, 50944], 'temperature': 0.0, 'avg_logprob': -0.19373405390772327, 'compression_ratio': 1.6511627906976745, 'no_speech_prob': 0.004117976874113083}, {'id': 274, 'seek': 229598, 'start': 2307.58, 'end': 2315.86, 'text': ' analysis. Did you learn anything about inter procedural analysis in your okay and obviously', 'tokens': [50944, 5215, 13, 2589, 291, 1466, 1340, 466, 728, 43951, 5215, 294, 428, 1392, 293, 2745, 51358], 'temperature': 0.0, 'avg_logprob': -0.19373405390772327, 'compression_ratio': 1.6511627906976745, 'no_speech_prob': 0.004117976874113083}, {'id': 275, 'seek': 229598, 'start': 2315.86, 'end': 2321.46, 'text': ' in separate compilation things I mean separate compilation is the biggest hammer which kind of', 'tokens': [51358, 294, 4994, 40261, 721, 286, 914, 4994, 40261, 307, 264, 3880, 13017, 597, 733, 295, 51638], 'temperature': 0.0, 'avg_logprob': -0.19373405390772327, 'compression_ratio': 1.6511627906976745, 'no_speech_prob': 0.004117976874113083}, {'id': 276, 'seek': 232146, 'start': 2321.46, 'end': 2328.3, 'text': ' puts everything outside the scope of compiler. Compiler has simply no way to deal with it.', 'tokens': [50364, 8137, 1203, 2380, 264, 11923, 295, 31958, 13, 6620, 5441, 575, 2935, 572, 636, 281, 2028, 365, 309, 13, 50706], 'temperature': 0.0, 'avg_logprob': -0.14700563748677573, 'compression_ratio': 1.6715686274509804, 'no_speech_prob': 0.01131938025355339}, {'id': 277, 'seek': 232146, 'start': 2329.1, 'end': 2334.48, 'text': ' So, if foo is defined in the file you can do something but you still have to do inter', 'tokens': [50746, 407, 11, 498, 726, 78, 307, 7642, 294, 264, 3991, 291, 393, 360, 746, 457, 291, 920, 362, 281, 360, 728, 51015], 'temperature': 0.0, 'avg_logprob': -0.14700563748677573, 'compression_ratio': 1.6715686274509804, 'no_speech_prob': 0.01131938025355339}, {'id': 278, 'seek': 232146, 'start': 2334.48, 'end': 2341.26, 'text': ' procedural analysis and if foo is defined outside then you simply cannot do much. So,', 'tokens': [51015, 43951, 5215, 293, 498, 726, 78, 307, 7642, 2380, 550, 291, 2935, 2644, 360, 709, 13, 407, 11, 51354], 'temperature': 0.0, 'avg_logprob': -0.14700563748677573, 'compression_ratio': 1.6715686274509804, 'no_speech_prob': 0.01131938025355339}, {'id': 279, 'seek': 232146, 'start': 2341.26, 'end': 2346.78, 'text': ' in most practical cases you would not know which registers are being used. So,', 'tokens': [51354, 294, 881, 8496, 3331, 291, 576, 406, 458, 597, 38351, 366, 885, 1143, 13, 407, 11, 51630], 'temperature': 0.0, 'avg_logprob': -0.14700563748677573, 'compression_ratio': 1.6715686274509804, 'no_speech_prob': 0.01131938025355339}, {'id': 280, 'seek': 234678, 'start': 2346.82, 'end': 2354.1800000000003, 'text': ' let us use the convention. Let us not the up the guideline which we want to have is we want to', 'tokens': [50366, 718, 505, 764, 264, 10286, 13, 961, 505, 406, 264, 493, 264, 41653, 597, 321, 528, 281, 362, 307, 321, 528, 281, 50734], 'temperature': 0.0, 'avg_logprob': -0.15231155355771384, 'compression_ratio': 1.945, 'no_speech_prob': 0.01690693572163582}, {'id': 281, 'seek': 234678, 'start': 2354.1800000000003, 'end': 2360.02, 'text': ' avoid unnecessary saves and restores. So, we do not want duplication of the work. So, let us come up', 'tokens': [50734, 5042, 19350, 19155, 293, 1472, 2706, 13, 407, 11, 321, 360, 406, 528, 17154, 399, 295, 264, 589, 13, 407, 11, 718, 505, 808, 493, 51026], 'temperature': 0.0, 'avg_logprob': -0.15231155355771384, 'compression_ratio': 1.945, 'no_speech_prob': 0.01690693572163582}, {'id': 282, 'seek': 234678, 'start': 2360.02, 'end': 2367.5400000000004, 'text': ' with a convention that caller saves all the registers. So, caller function saves and restores', 'tokens': [51026, 365, 257, 10286, 300, 48324, 19155, 439, 264, 38351, 13, 407, 11, 48324, 2445, 19155, 293, 1472, 2706, 51402], 'temperature': 0.0, 'avg_logprob': -0.15231155355771384, 'compression_ratio': 1.945, 'no_speech_prob': 0.01690693572163582}, {'id': 283, 'seek': 234678, 'start': 2367.5400000000004, 'end': 2374.5, 'text': ' all the registers before doing the call. So, what will happen is this is the caller function and it', 'tokens': [51402, 439, 264, 38351, 949, 884, 264, 818, 13, 407, 11, 437, 486, 1051, 307, 341, 307, 264, 48324, 2445, 293, 309, 51750], 'temperature': 0.0, 'avg_logprob': -0.15231155355771384, 'compression_ratio': 1.945, 'no_speech_prob': 0.01690693572163582}, {'id': 284, 'seek': 237450, 'start': 2374.5, 'end': 2382.18, 'text': ' is calling a callee it will save all the registers before doing the call. Calls the callee function', 'tokens': [50364, 307, 5141, 257, 818, 1653, 309, 486, 3155, 439, 264, 38351, 949, 884, 264, 818, 13, 7807, 82, 264, 818, 1653, 2445, 50748], 'temperature': 0.0, 'avg_logprob': -0.1386125221681059, 'compression_ratio': 2.0594594594594593, 'no_speech_prob': 0.0038213811349123716}, {'id': 285, 'seek': 237450, 'start': 2382.18, 'end': 2387.1, 'text': ' callee function does not do any save restore. So, callee function is happily using all the', 'tokens': [50748, 818, 1653, 2445, 775, 406, 360, 604, 3155, 15227, 13, 407, 11, 818, 1653, 2445, 307, 19909, 1228, 439, 264, 50994], 'temperature': 0.0, 'avg_logprob': -0.1386125221681059, 'compression_ratio': 2.0594594594594593, 'no_speech_prob': 0.0038213811349123716}, {'id': 286, 'seek': 237450, 'start': 2387.1, 'end': 2393.58, 'text': ' registers and returns and then callee function caller function restores all the registers.', 'tokens': [50994, 38351, 293, 11247, 293, 550, 818, 1653, 2445, 48324, 2445, 1472, 2706, 439, 264, 38351, 13, 51318], 'temperature': 0.0, 'avg_logprob': -0.1386125221681059, 'compression_ratio': 2.0594594594594593, 'no_speech_prob': 0.0038213811349123716}, {'id': 287, 'seek': 237450, 'start': 2393.58, 'end': 2402.06, 'text': ' Okay now the problem with this is every time a function is called you have to do this save restore.', 'tokens': [51318, 1033, 586, 264, 1154, 365, 341, 307, 633, 565, 257, 2445, 307, 1219, 291, 362, 281, 360, 341, 3155, 15227, 13, 51742], 'temperature': 0.0, 'avg_logprob': -0.1386125221681059, 'compression_ratio': 2.0594594594594593, 'no_speech_prob': 0.0038213811349123716}, {'id': 288, 'seek': 240206, 'start': 2402.18, 'end': 2413.14, 'text': ' So, the save restore is happening at every call instruction. And the problem is caller since it', 'tokens': [50370, 407, 11, 264, 3155, 15227, 307, 2737, 412, 633, 818, 10951, 13, 400, 264, 1154, 307, 48324, 1670, 309, 50918], 'temperature': 0.0, 'avg_logprob': -0.13096451229519315, 'compression_ratio': 1.8066037735849056, 'no_speech_prob': 0.0006770528852939606}, {'id': 289, 'seek': 240206, 'start': 2413.14, 'end': 2418.06, 'text': ' does not know what registers are being actually used it may actually end up save and restoring', 'tokens': [50918, 775, 406, 458, 437, 38351, 366, 885, 767, 1143, 309, 815, 767, 917, 493, 3155, 293, 36349, 51164], 'temperature': 0.0, 'avg_logprob': -0.13096451229519315, 'compression_ratio': 1.8066037735849056, 'no_speech_prob': 0.0006770528852939606}, {'id': 290, 'seek': 240206, 'start': 2418.06, 'end': 2424.62, 'text': ' registers which are not even used. For example, let us say ESI register callee does not even use', 'tokens': [51164, 38351, 597, 366, 406, 754, 1143, 13, 1171, 1365, 11, 718, 505, 584, 12564, 40, 7280, 818, 1653, 775, 406, 754, 764, 51492], 'temperature': 0.0, 'avg_logprob': -0.13096451229519315, 'compression_ratio': 1.8066037735849056, 'no_speech_prob': 0.0006770528852939606}, {'id': 291, 'seek': 240206, 'start': 2424.62, 'end': 2430.02, 'text': ' that. So, but caller since it does not know it will still save and restore it which is waste of', 'tokens': [51492, 300, 13, 407, 11, 457, 48324, 1670, 309, 775, 406, 458, 309, 486, 920, 3155, 293, 15227, 309, 597, 307, 5964, 295, 51762], 'temperature': 0.0, 'avg_logprob': -0.13096451229519315, 'compression_ratio': 1.8066037735849056, 'no_speech_prob': 0.0006770528852939606}, {'id': 292, 'seek': 243002, 'start': 2430.02, 'end': 2436.38, 'text': ' time. Now, the question is does caller really need to save and restore all the registers.', 'tokens': [50364, 565, 13, 823, 11, 264, 1168, 307, 775, 48324, 534, 643, 281, 3155, 293, 15227, 439, 264, 38351, 13, 50682], 'temperature': 0.0, 'avg_logprob': -0.13847951486077106, 'compression_ratio': 1.7643312101910829, 'no_speech_prob': 0.000237771135289222}, {'id': 293, 'seek': 243002, 'start': 2436.38, 'end': 2449.22, 'text': ' Correct. So, caller really need to save and restores only the registers which are used by', 'tokens': [50682, 12753, 13, 407, 11, 48324, 534, 643, 281, 3155, 293, 1472, 2706, 787, 264, 38351, 597, 366, 1143, 538, 51324], 'temperature': 0.0, 'avg_logprob': -0.13847951486077106, 'compression_ratio': 1.7643312101910829, 'no_speech_prob': 0.000237771135289222}, {'id': 294, 'seek': 243002, 'start': 2449.22, 'end': 2455.42, 'text': ' caller. So, for example, let us say there was a register EBX which was not at all used in caller.', 'tokens': [51324, 48324, 13, 407, 11, 337, 1365, 11, 718, 505, 584, 456, 390, 257, 7280, 50148, 55, 597, 390, 406, 412, 439, 1143, 294, 48324, 13, 51634], 'temperature': 0.0, 'avg_logprob': -0.13847951486077106, 'compression_ratio': 1.7643312101910829, 'no_speech_prob': 0.000237771135289222}, {'id': 295, 'seek': 245542, 'start': 2455.54, 'end': 2463.38, 'text': ' Now, no matter whether callee uses it or not you do not have to save and restore it. Okay,', 'tokens': [50370, 823, 11, 572, 1871, 1968, 818, 1653, 4960, 309, 420, 406, 291, 360, 406, 362, 281, 3155, 293, 15227, 309, 13, 1033, 11, 50762], 'temperature': 0.0, 'avg_logprob': -0.130150576432546, 'compression_ratio': 1.7027027027027026, 'no_speech_prob': 0.0006262202514335513}, {'id': 296, 'seek': 245542, 'start': 2463.38, 'end': 2468.54, 'text': ' does that make sense? So, if there is a register which is not at all used in the caller you do', 'tokens': [50762, 775, 300, 652, 2020, 30, 407, 11, 498, 456, 307, 257, 7280, 597, 307, 406, 412, 439, 1143, 294, 264, 48324, 291, 360, 51020], 'temperature': 0.0, 'avg_logprob': -0.130150576432546, 'compression_ratio': 1.7027027027027026, 'no_speech_prob': 0.0006262202514335513}, {'id': 297, 'seek': 245542, 'start': 2468.54, 'end': 2474.2200000000003, 'text': ' not save restore. So, you have one optimization even when caller was supposed to do all the', 'tokens': [51020, 406, 3155, 15227, 13, 407, 11, 291, 362, 472, 19618, 754, 562, 48324, 390, 3442, 281, 360, 439, 264, 51304], 'temperature': 0.0, 'avg_logprob': -0.130150576432546, 'compression_ratio': 1.7027027027027026, 'no_speech_prob': 0.0006262202514335513}, {'id': 298, 'seek': 245542, 'start': 2474.2200000000003, 'end': 2485.06, 'text': ' saving. The other is if caller is using a register, but the register live range ends just before the', 'tokens': [51304, 6816, 13, 440, 661, 307, 498, 48324, 307, 1228, 257, 7280, 11, 457, 264, 7280, 1621, 3613, 5314, 445, 949, 264, 51846], 'temperature': 0.0, 'avg_logprob': -0.130150576432546, 'compression_ratio': 1.7027027027027026, 'no_speech_prob': 0.0006262202514335513}, {'id': 299, 'seek': 248506, 'start': 2485.06, 'end': 2491.1, 'text': ' call instruction. Does everyone understand what is live range of a register? Right. So,', 'tokens': [50364, 818, 10951, 13, 4402, 1518, 1223, 437, 307, 1621, 3613, 295, 257, 7280, 30, 1779, 13, 407, 11, 50666], 'temperature': 0.0, 'avg_logprob': -0.15002185695773954, 'compression_ratio': 1.927461139896373, 'no_speech_prob': 0.001000406569801271}, {'id': 300, 'seek': 248506, 'start': 2491.1, 'end': 2497.82, 'text': ' if the register live range does not cross the call instruction that means caller was using', 'tokens': [50666, 498, 264, 7280, 1621, 3613, 775, 406, 3278, 264, 818, 10951, 300, 1355, 48324, 390, 1228, 51002], 'temperature': 0.0, 'avg_logprob': -0.15002185695773954, 'compression_ratio': 1.927461139896373, 'no_speech_prob': 0.001000406569801271}, {'id': 301, 'seek': 248506, 'start': 2497.82, 'end': 2506.46, 'text': ' EBX register, but does not use beyond this point or overrides it beyond this point then it does', 'tokens': [51002, 50148, 55, 7280, 11, 457, 775, 406, 764, 4399, 341, 935, 420, 670, 81, 1875, 309, 4399, 341, 935, 550, 309, 775, 51434], 'temperature': 0.0, 'avg_logprob': -0.15002185695773954, 'compression_ratio': 1.927461139896373, 'no_speech_prob': 0.001000406569801271}, {'id': 302, 'seek': 248506, 'start': 2506.46, 'end': 2512.94, 'text': ' not need to save restore. So, it does not need to save restore a dead register. So, if there is a', 'tokens': [51434, 406, 643, 281, 3155, 15227, 13, 407, 11, 309, 775, 406, 643, 281, 3155, 15227, 257, 3116, 7280, 13, 407, 11, 498, 456, 307, 257, 51758], 'temperature': 0.0, 'avg_logprob': -0.15002185695773954, 'compression_ratio': 1.927461139896373, 'no_speech_prob': 0.001000406569801271}, {'id': 303, 'seek': 251294, 'start': 2513.02, 'end': 2518.7400000000002, 'text': ' register which is not at all used or which is dead across the call instruction it does not need', 'tokens': [50368, 7280, 597, 307, 406, 412, 439, 1143, 420, 597, 307, 3116, 2108, 264, 818, 10951, 309, 775, 406, 643, 50654], 'temperature': 0.0, 'avg_logprob': -0.10459670813187309, 'compression_ratio': 1.768181818181818, 'no_speech_prob': 0.00806022435426712}, {'id': 304, 'seek': 251294, 'start': 2518.7400000000002, 'end': 2525.86, 'text': ' to save restore. So, this is one convention, but there is still downside that every call has this', 'tokens': [50654, 281, 3155, 15227, 13, 407, 11, 341, 307, 472, 10286, 11, 457, 456, 307, 920, 25060, 300, 633, 818, 575, 341, 51010], 'temperature': 0.0, 'avg_logprob': -0.10459670813187309, 'compression_ratio': 1.768181818181818, 'no_speech_prob': 0.00806022435426712}, {'id': 305, 'seek': 251294, 'start': 2525.86, 'end': 2533.06, 'text': ' save and restore logic. Let us look at the extreme other case where callee is responsible for doing', 'tokens': [51010, 3155, 293, 15227, 9952, 13, 961, 505, 574, 412, 264, 8084, 661, 1389, 689, 818, 1653, 307, 6250, 337, 884, 51370], 'temperature': 0.0, 'avg_logprob': -0.10459670813187309, 'compression_ratio': 1.768181818181818, 'no_speech_prob': 0.00806022435426712}, {'id': 306, 'seek': 251294, 'start': 2533.06, 'end': 2539.82, 'text': ' every save and restore. Caller is happily using all the registers. So, callee will save all the', 'tokens': [51370, 633, 3155, 293, 15227, 13, 7807, 260, 307, 19909, 1228, 439, 264, 38351, 13, 407, 11, 818, 1653, 486, 3155, 439, 264, 51708], 'temperature': 0.0, 'avg_logprob': -0.10459670813187309, 'compression_ratio': 1.768181818181818, 'no_speech_prob': 0.00806022435426712}, {'id': 307, 'seek': 253982, 'start': 2539.82, 'end': 2546.2200000000003, 'text': ' registers at the start of the function and will restore them before returning. So, callee will', 'tokens': [50364, 38351, 412, 264, 722, 295, 264, 2445, 293, 486, 15227, 552, 949, 12678, 13, 407, 11, 818, 1653, 486, 50684], 'temperature': 0.0, 'avg_logprob': -0.10170061643733534, 'compression_ratio': 1.890547263681592, 'no_speech_prob': 0.01449515763670206}, {'id': 308, 'seek': 253982, 'start': 2546.2200000000003, 'end': 2554.6600000000003, 'text': ' save all the registers and restore all the registers. Again here you can do an optimization where', 'tokens': [50684, 3155, 439, 264, 38351, 293, 15227, 439, 264, 38351, 13, 3764, 510, 291, 393, 360, 364, 19618, 689, 51106], 'temperature': 0.0, 'avg_logprob': -0.10170061643733534, 'compression_ratio': 1.890547263681592, 'no_speech_prob': 0.01449515763670206}, {'id': 309, 'seek': 253982, 'start': 2554.6600000000003, 'end': 2563.1800000000003, 'text': ' callee will save and restore only registers which are being used. And one other better advantage is', 'tokens': [51106, 818, 1653, 486, 3155, 293, 15227, 787, 38351, 597, 366, 885, 1143, 13, 400, 472, 661, 1101, 5002, 307, 51532], 'temperature': 0.0, 'avg_logprob': -0.10170061643733534, 'compression_ratio': 1.890547263681592, 'no_speech_prob': 0.01449515763670206}, {'id': 310, 'seek': 253982, 'start': 2563.1800000000003, 'end': 2568.6600000000003, 'text': ' the code to do save and restore is kind of localized to the function. It is not kind of', 'tokens': [51532, 264, 3089, 281, 360, 3155, 293, 15227, 307, 733, 295, 44574, 281, 264, 2445, 13, 467, 307, 406, 733, 295, 51806], 'temperature': 0.0, 'avg_logprob': -0.10170061643733534, 'compression_ratio': 1.890547263681592, 'no_speech_prob': 0.01449515763670206}, {'id': 311, 'seek': 256866, 'start': 2568.66, 'end': 2574.22, 'text': ' spread around everywhere. So, that is I mean when you are reading assembly it is kind of spread', 'tokens': [50364, 3974, 926, 5315, 13, 407, 11, 300, 307, 286, 914, 562, 291, 366, 3760, 12103, 309, 307, 733, 295, 3974, 50642], 'temperature': 0.0, 'avg_logprob': -0.12112911181016402, 'compression_ratio': 1.6695278969957081, 'no_speech_prob': 0.0024722313974052668}, {'id': 312, 'seek': 256866, 'start': 2574.22, 'end': 2582.66, 'text': ' around in the prior convention. Here it is at least localized and here again the same problem', 'tokens': [50642, 926, 294, 264, 4059, 10286, 13, 1692, 309, 307, 412, 1935, 44574, 293, 510, 797, 264, 912, 1154, 51064], 'temperature': 0.0, 'avg_logprob': -0.12112911181016402, 'compression_ratio': 1.6695278969957081, 'no_speech_prob': 0.0024722313974052668}, {'id': 313, 'seek': 256866, 'start': 2582.66, 'end': 2589.1, 'text': ' happens it callee does not know whether a function register is being used. So, we should try to get', 'tokens': [51064, 2314, 309, 818, 1653, 775, 406, 458, 1968, 257, 2445, 7280, 307, 885, 1143, 13, 407, 11, 321, 820, 853, 281, 483, 51386], 'temperature': 0.0, 'avg_logprob': -0.12112911181016402, 'compression_ratio': 1.6695278969957081, 'no_speech_prob': 0.0024722313974052668}, {'id': 314, 'seek': 256866, 'start': 2589.1, 'end': 2595.22, 'text': ' best of both worlds. So, essentially you say that there are some registers which are responsibility', 'tokens': [51386, 1151, 295, 1293, 13401, 13, 407, 11, 4476, 291, 584, 300, 456, 366, 512, 38351, 597, 366, 6357, 51692], 'temperature': 0.0, 'avg_logprob': -0.12112911181016402, 'compression_ratio': 1.6695278969957081, 'no_speech_prob': 0.0024722313974052668}, {'id': 315, 'seek': 259522, 'start': 2595.22, 'end': 2601.8999999999996, 'text': ' of caller which caller will save. The other registers are responsibility of callee. So,', 'tokens': [50364, 295, 48324, 597, 48324, 486, 3155, 13, 440, 661, 38351, 366, 6357, 295, 818, 1653, 13, 407, 11, 50698], 'temperature': 0.0, 'avg_logprob': -0.14394280939926335, 'compression_ratio': 2.0233918128654973, 'no_speech_prob': 0.047407396137714386}, {'id': 316, 'seek': 259522, 'start': 2601.8999999999996, 'end': 2608.02, 'text': ' you divide your registers into two parts. One is responsibility of caller other is', 'tokens': [50698, 291, 9845, 428, 38351, 666, 732, 3166, 13, 1485, 307, 6357, 295, 48324, 661, 307, 51004], 'temperature': 0.0, 'avg_logprob': -0.14394280939926335, 'compression_ratio': 2.0233918128654973, 'no_speech_prob': 0.047407396137714386}, {'id': 317, 'seek': 259522, 'start': 2608.02, 'end': 2617.5, 'text': ' a responsibility of callee and you do this. So, this is register saving convention. So,', 'tokens': [51004, 257, 6357, 295, 818, 1653, 293, 291, 360, 341, 13, 407, 11, 341, 307, 7280, 6816, 10286, 13, 407, 11, 51478], 'temperature': 0.0, 'avg_logprob': -0.14394280939926335, 'compression_ratio': 2.0233918128654973, 'no_speech_prob': 0.047407396137714386}, {'id': 318, 'seek': 259522, 'start': 2617.5, 'end': 2623.06, 'text': ' you split your sets into two sets. One is something called as a caller saved registers.', 'tokens': [51478, 291, 7472, 428, 6352, 666, 732, 6352, 13, 1485, 307, 746, 1219, 382, 257, 48324, 6624, 38351, 13, 51756], 'temperature': 0.0, 'avg_logprob': -0.14394280939926335, 'compression_ratio': 2.0233918128654973, 'no_speech_prob': 0.047407396137714386}, {'id': 319, 'seek': 262306, 'start': 2623.06, 'end': 2629.1, 'text': " As the name indicates it is caller's responsibility to save these registers before", 'tokens': [50364, 1018, 264, 1315, 16203, 309, 307, 48324, 311, 6357, 281, 3155, 613, 38351, 949, 50666], 'temperature': 0.0, 'avg_logprob': -0.2155949627911603, 'compression_ratio': 1.7761194029850746, 'no_speech_prob': 0.005382473114877939}, {'id': 320, 'seek': 262306, 'start': 2629.1, 'end': 2633.14, 'text': ' doing the function call and restore them after the function call is being done.', 'tokens': [50666, 884, 264, 2445, 818, 293, 15227, 552, 934, 264, 2445, 818, 307, 885, 1096, 13, 50868], 'temperature': 0.0, 'avg_logprob': -0.2155949627911603, 'compression_ratio': 1.7761194029850746, 'no_speech_prob': 0.005382473114877939}, {'id': 321, 'seek': 262306, 'start': 2633.14, 'end': 2644.86, 'text': ' No. So, only caller saved registers need to be saved and there it can do an optimization if', 'tokens': [50868, 883, 13, 407, 11, 787, 48324, 6624, 38351, 643, 281, 312, 6624, 293, 456, 309, 393, 360, 364, 19618, 498, 51454], 'temperature': 0.0, 'avg_logprob': -0.2155949627911603, 'compression_ratio': 1.7761194029850746, 'no_speech_prob': 0.005382473114877939}, {'id': 322, 'seek': 262306, 'start': 2644.86, 'end': 2650.18, 'text': ' there is a dead register or a registers whose live range does not cross then it does not need to save.', 'tokens': [51454, 456, 307, 257, 3116, 7280, 420, 257, 38351, 6104, 1621, 3613, 775, 406, 3278, 550, 309, 775, 406, 643, 281, 3155, 13, 51720], 'temperature': 0.0, 'avg_logprob': -0.2155949627911603, 'compression_ratio': 1.7761194029850746, 'no_speech_prob': 0.005382473114877939}, {'id': 323, 'seek': 265018, 'start': 2651.14, 'end': 2657.22, 'text': ' If something is being. So, think of it this way any caller saved register callee is free to', 'tokens': [50412, 759, 746, 307, 885, 13, 407, 11, 519, 295, 309, 341, 636, 604, 48324, 6624, 7280, 818, 1653, 307, 1737, 281, 50716], 'temperature': 0.0, 'avg_logprob': -0.1387883770850397, 'compression_ratio': 1.8866995073891626, 'no_speech_prob': 0.0018663813825696707}, {'id': 324, 'seek': 265018, 'start': 2657.22, 'end': 2663.54, 'text': ' overwrite it without having to worry about it. That is why these are called as scratch registers.', 'tokens': [50716, 670, 21561, 309, 1553, 1419, 281, 3292, 466, 309, 13, 663, 307, 983, 613, 366, 1219, 382, 8459, 38351, 13, 51032], 'temperature': 0.0, 'avg_logprob': -0.1387883770850397, 'compression_ratio': 1.8866995073891626, 'no_speech_prob': 0.0018663813825696707}, {'id': 325, 'seek': 265018, 'start': 2663.54, 'end': 2670.2599999999998, 'text': ' So, these are scratch for the callee function. So, callee function is free to overwrite them', 'tokens': [51032, 407, 11, 613, 366, 8459, 337, 264, 818, 1653, 2445, 13, 407, 11, 818, 1653, 2445, 307, 1737, 281, 670, 21561, 552, 51368], 'temperature': 0.0, 'avg_logprob': -0.1387883770850397, 'compression_ratio': 1.8866995073891626, 'no_speech_prob': 0.0018663813825696707}, {'id': 326, 'seek': 265018, 'start': 2670.2599999999998, 'end': 2676.74, 'text': ' without worrying about what will happen at caller. If caller wants to use it across the call then it', 'tokens': [51368, 1553, 18788, 466, 437, 486, 1051, 412, 48324, 13, 759, 48324, 2738, 281, 764, 309, 2108, 264, 818, 550, 309, 51692], 'temperature': 0.0, 'avg_logprob': -0.1387883770850397, 'compression_ratio': 1.8866995073891626, 'no_speech_prob': 0.0018663813825696707}, {'id': 327, 'seek': 267674, 'start': 2676.74, 'end': 2683.74, 'text': ' better saves it. If it does not want to use it, it does not need to save it. But callee does not', 'tokens': [50364, 1101, 19155, 309, 13, 759, 309, 775, 406, 528, 281, 764, 309, 11, 309, 775, 406, 643, 281, 3155, 309, 13, 583, 818, 1653, 775, 406, 50714], 'temperature': 0.0, 'avg_logprob': -0.13268944312786235, 'compression_ratio': 1.905, 'no_speech_prob': 0.005727236624807119}, {'id': 328, 'seek': 267674, 'start': 2683.74, 'end': 2690.62, 'text': ' have any responsibility of saving and restoring. Then there is callee saved registers which is', 'tokens': [50714, 362, 604, 6357, 295, 6816, 293, 36349, 13, 1396, 456, 307, 818, 1653, 6624, 38351, 597, 307, 51058], 'temperature': 0.0, 'avg_logprob': -0.13268944312786235, 'compression_ratio': 1.905, 'no_speech_prob': 0.005727236624807119}, {'id': 329, 'seek': 267674, 'start': 2690.62, 'end': 2699.2999999999997, 'text': " exact opposite which is essentially callee's responsibility to save and restore. And caller", 'tokens': [51058, 1900, 6182, 597, 307, 4476, 818, 1653, 311, 6357, 281, 3155, 293, 15227, 13, 400, 48324, 51492], 'temperature': 0.0, 'avg_logprob': -0.13268944312786235, 'compression_ratio': 1.905, 'no_speech_prob': 0.005727236624807119}, {'id': 330, 'seek': 267674, 'start': 2699.2999999999997, 'end': 2706.4199999999996, 'text': ' function is free to use these registers across the call without having to save restore. And these', 'tokens': [51492, 2445, 307, 1737, 281, 764, 613, 38351, 2108, 264, 818, 1553, 1419, 281, 3155, 15227, 13, 400, 613, 51848], 'temperature': 0.0, 'avg_logprob': -0.13268944312786235, 'compression_ratio': 1.905, 'no_speech_prob': 0.005727236624807119}, {'id': 331, 'seek': 270642, 'start': 2706.42, 'end': 2711.9, 'text': ' are called preserved registers. These are preserved because the value of these registers', 'tokens': [50364, 366, 1219, 22242, 38351, 13, 1981, 366, 22242, 570, 264, 2158, 295, 613, 38351, 50638], 'temperature': 0.0, 'avg_logprob': -0.1780792762493265, 'compression_ratio': 1.7402597402597402, 'no_speech_prob': 0.0006065949564799666}, {'id': 332, 'seek': 270642, 'start': 2711.9, 'end': 2716.94, 'text': ' does not change across the call instruction. So, they are preserved across the call instruction.', 'tokens': [50638, 775, 406, 1319, 2108, 264, 818, 10951, 13, 407, 11, 436, 366, 22242, 2108, 264, 818, 10951, 13, 50890], 'temperature': 0.0, 'avg_logprob': -0.1780792762493265, 'compression_ratio': 1.7402597402597402, 'no_speech_prob': 0.0006065949564799666}, {'id': 333, 'seek': 270642, 'start': 2718.02, 'end': 2726.38, 'text': ' And this is yet another agreement between the caller and callee. And where to yes.', 'tokens': [50944, 400, 341, 307, 1939, 1071, 8106, 1296, 264, 48324, 293, 818, 1653, 13, 400, 689, 281, 2086, 13, 51362], 'temperature': 0.0, 'avg_logprob': -0.1780792762493265, 'compression_ratio': 1.7402597402597402, 'no_speech_prob': 0.0006065949564799666}, {'id': 334, 'seek': 272638, 'start': 2726.38, 'end': 2740.1800000000003, 'text': ' We will get to that. Now, where we have been saying that it is save and restore save and', 'tokens': [50364, 492, 486, 483, 281, 300, 13, 823, 11, 689, 321, 362, 668, 1566, 300, 309, 307, 3155, 293, 15227, 3155, 293, 51054], 'temperature': 0.0, 'avg_logprob': -0.20165225821481625, 'compression_ratio': 1.5988700564971752, 'no_speech_prob': 0.03842288255691528}, {'id': 335, 'seek': 272638, 'start': 2740.1800000000003, 'end': 2745.1800000000003, 'text': ' restore. So, where to actually save it right. Yeah, stack by now you should be able to articulate', 'tokens': [51054, 15227, 13, 407, 11, 689, 281, 767, 3155, 309, 558, 13, 865, 11, 8630, 538, 586, 291, 820, 312, 1075, 281, 30305, 51304], 'temperature': 0.0, 'avg_logprob': -0.20165225821481625, 'compression_ratio': 1.5988700564971752, 'no_speech_prob': 0.03842288255691528}, {'id': 336, 'seek': 272638, 'start': 2745.1800000000003, 'end': 2752.06, 'text': ' why global variables will not work and so on. So, answer is stack. You should whatever registers', 'tokens': [51304, 983, 4338, 9102, 486, 406, 589, 293, 370, 322, 13, 407, 11, 1867, 307, 8630, 13, 509, 820, 2035, 38351, 51648], 'temperature': 0.0, 'avg_logprob': -0.20165225821481625, 'compression_ratio': 1.5988700564971752, 'no_speech_prob': 0.03842288255691528}, {'id': 337, 'seek': 275206, 'start': 2752.06, 'end': 2756.68, 'text': ' you need to save, you save them in stack. So, essentially this is what happens. So,', 'tokens': [50364, 291, 643, 281, 3155, 11, 291, 3155, 552, 294, 8630, 13, 407, 11, 4476, 341, 307, 437, 2314, 13, 407, 11, 50595], 'temperature': 0.0, 'avg_logprob': -0.15828732081821986, 'compression_ratio': 1.7523809523809524, 'no_speech_prob': 0.3410898745059967}, {'id': 338, 'seek': 275206, 'start': 2756.68, 'end': 2763.5, 'text': ' let us say EAX is the register and it is caller save. Let us assume. Then before calling the', 'tokens': [50595, 718, 505, 584, 35747, 55, 307, 264, 7280, 293, 309, 307, 48324, 3155, 13, 961, 505, 6552, 13, 1396, 949, 5141, 264, 50936], 'temperature': 0.0, 'avg_logprob': -0.15828732081821986, 'compression_ratio': 1.7523809523809524, 'no_speech_prob': 0.3410898745059967}, {'id': 339, 'seek': 275206, 'start': 2763.5, 'end': 2769.98, 'text': ' callee function, the caller function will push this on to the stack and come to callee. Let us', 'tokens': [50936, 818, 1653, 2445, 11, 264, 48324, 2445, 486, 2944, 341, 322, 281, 264, 8630, 293, 808, 281, 818, 1653, 13, 961, 505, 51260], 'temperature': 0.0, 'avg_logprob': -0.15828732081821986, 'compression_ratio': 1.7523809523809524, 'no_speech_prob': 0.3410898745059967}, {'id': 340, 'seek': 275206, 'start': 2769.98, 'end': 2778.86, 'text': ' say EDI is a callee saved register. Then callee function will save it before using it and pop it', 'tokens': [51260, 584, 462, 3085, 307, 257, 818, 1653, 6624, 7280, 13, 1396, 818, 1653, 2445, 486, 3155, 309, 949, 1228, 309, 293, 1665, 309, 51704], 'temperature': 0.0, 'avg_logprob': -0.15828732081821986, 'compression_ratio': 1.7523809523809524, 'no_speech_prob': 0.3410898745059967}, {'id': 341, 'seek': 277886, 'start': 2778.86, 'end': 2785.94, 'text': ' before returning. And then callee function is free to use EDI without having to save restore.', 'tokens': [50364, 949, 12678, 13, 400, 550, 818, 1653, 2445, 307, 1737, 281, 764, 462, 3085, 1553, 1419, 281, 3155, 15227, 13, 50718], 'temperature': 0.0, 'avg_logprob': -0.1852731415719697, 'compression_ratio': 1.4216867469879517, 'no_speech_prob': 0.017977945506572723}, {'id': 342, 'seek': 277886, 'start': 2785.94, 'end': 2790.5, 'text': ' But for EAX it has to pop from the stack. Yes.', 'tokens': [50718, 583, 337, 35747, 55, 309, 575, 281, 1665, 490, 264, 8630, 13, 1079, 13, 50946], 'temperature': 0.0, 'avg_logprob': -0.1852731415719697, 'compression_ratio': 1.4216867469879517, 'no_speech_prob': 0.017977945506572723}, {'id': 343, 'seek': 277886, 'start': 2790.5, 'end': 2802.88, 'text': ' We will come to that. Any other questions so far? So, so far we have two questions. What is the', 'tokens': [50946, 492, 486, 808, 281, 300, 13, 2639, 661, 1651, 370, 1400, 30, 407, 11, 370, 1400, 321, 362, 732, 1651, 13, 708, 307, 264, 51565], 'temperature': 0.0, 'avg_logprob': -0.1852731415719697, 'compression_ratio': 1.4216867469879517, 'no_speech_prob': 0.017977945506572723}, {'id': 344, 'seek': 280288, 'start': 2802.88, 'end': 2809.4, 'text': ' EAX register? Is it caller saved, callee saved? And second is what happens when a function is', 'tokens': [50364, 35747, 55, 7280, 30, 1119, 309, 48324, 6624, 11, 818, 1653, 6624, 30, 400, 1150, 307, 437, 2314, 562, 257, 2445, 307, 50690], 'temperature': 0.0, 'avg_logprob': -0.1896233739732187, 'compression_ratio': 1.4894736842105263, 'no_speech_prob': 0.2015969604253769}, {'id': 345, 'seek': 280288, 'start': 2809.4, 'end': 2821.92, 'text': " caller as well as callee? Correct. We will come to that also. Any other things? Sorry. You didn't", 'tokens': [50690, 48324, 382, 731, 382, 818, 1653, 30, 12753, 13, 492, 486, 808, 281, 300, 611, 13, 2639, 661, 721, 30, 4919, 13, 509, 994, 380, 51316], 'temperature': 0.0, 'avg_logprob': -0.1896233739732187, 'compression_ratio': 1.4894736842105263, 'no_speech_prob': 0.2015969604253769}, {'id': 346, 'seek': 280288, 'start': 2821.92, 'end': 2830.48, 'text': ' get the benefit. So, the question is why are we doing this? So, one is essentially you. So,', 'tokens': [51316, 483, 264, 5121, 13, 407, 11, 264, 1168, 307, 983, 366, 321, 884, 341, 30, 407, 11, 472, 307, 4476, 291, 13, 407, 11, 51744], 'temperature': 0.0, 'avg_logprob': -0.1896233739732187, 'compression_ratio': 1.4894736842105263, 'no_speech_prob': 0.2015969604253769}, {'id': 347, 'seek': 283048, 'start': 2830.48, 'end': 2836.32, 'text': ' let us look at the various options we had. The first option we had is both caller and callee', 'tokens': [50364, 718, 505, 574, 412, 264, 3683, 3956, 321, 632, 13, 440, 700, 3614, 321, 632, 307, 1293, 48324, 293, 818, 1653, 50656], 'temperature': 0.0, 'avg_logprob': -0.09209623838725843, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.0116723095998168}, {'id': 348, 'seek': 283048, 'start': 2836.32, 'end': 2843.32, 'text': ' save all the registers. So, there is some redundancy. We said that then caller is responsible', 'tokens': [50656, 3155, 439, 264, 38351, 13, 407, 11, 456, 307, 512, 27830, 6717, 13, 492, 848, 300, 550, 48324, 307, 6250, 51006], 'temperature': 0.0, 'avg_logprob': -0.09209623838725843, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.0116723095998168}, {'id': 349, 'seek': 283048, 'start': 2843.32, 'end': 2850.2, 'text': ' for saving everything. There is some issue with that. So, this is also not perfect, but it is', 'tokens': [51006, 337, 6816, 1203, 13, 821, 307, 512, 2734, 365, 300, 13, 407, 11, 341, 307, 611, 406, 2176, 11, 457, 309, 307, 51350], 'temperature': 0.0, 'avg_logprob': -0.09209623838725843, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.0116723095998168}, {'id': 350, 'seek': 283048, 'start': 2850.2, 'end': 2855.6, 'text': " trying to just load balance the two things. So, we don't want to burden too much caller or too", 'tokens': [51350, 1382, 281, 445, 3677, 4772, 264, 732, 721, 13, 407, 11, 321, 500, 380, 528, 281, 12578, 886, 709, 48324, 420, 886, 51620], 'temperature': 0.0, 'avg_logprob': -0.09209623838725843, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.0116723095998168}, {'id': 351, 'seek': 285560, 'start': 2856.08, 'end': 2861.12, 'text': ' much callee. We are just trying to get best of both things. And this actually enables some', 'tokens': [50388, 709, 818, 1653, 13, 492, 366, 445, 1382, 281, 483, 1151, 295, 1293, 721, 13, 400, 341, 767, 17077, 512, 50640], 'temperature': 0.0, 'avg_logprob': -0.14596932108809307, 'compression_ratio': 1.415, 'no_speech_prob': 0.03405822813510895}, {'id': 352, 'seek': 285560, 'start': 2861.12, 'end': 2867.7999999999997, 'text': ' optimizations which we will see on having this split. So, to answer your question, if you look', 'tokens': [50640, 5028, 14455, 597, 321, 486, 536, 322, 1419, 341, 7472, 13, 407, 11, 281, 1867, 428, 1168, 11, 498, 291, 574, 50974], 'temperature': 0.0, 'avg_logprob': -0.14596932108809307, 'compression_ratio': 1.415, 'no_speech_prob': 0.03405822813510895}, {'id': 353, 'seek': 285560, 'start': 2867.7999999999997, 'end': 2879.8399999999997, 'text': ' at x86, these are caller saved registers EAX, ECX, EDX. Callee save is EBX, ESI, EDI. And special', 'tokens': [50974, 412, 2031, 22193, 11, 613, 366, 48324, 6624, 38351, 35747, 55, 11, 19081, 55, 11, 18050, 55, 13, 7807, 1653, 3155, 307, 50148, 55, 11, 12564, 40, 11, 462, 3085, 13, 400, 2121, 51576], 'temperature': 0.0, 'avg_logprob': -0.14596932108809307, 'compression_ratio': 1.415, 'no_speech_prob': 0.03405822813510895}, {'id': 354, 'seek': 287984, 'start': 2879.84, 'end': 2888.6000000000004, 'text': ' registers ESP and EBP are callee saved. Now, can someone answer why stack pointer needs to', 'tokens': [50364, 38351, 12564, 47, 293, 50148, 47, 366, 818, 1653, 6624, 13, 823, 11, 393, 1580, 1867, 983, 8630, 23918, 2203, 281, 50802], 'temperature': 0.0, 'avg_logprob': -0.15393830909103642, 'compression_ratio': 1.4102564102564104, 'no_speech_prob': 0.48368290066719055}, {'id': 355, 'seek': 287984, 'start': 2888.6000000000004, 'end': 2894.76, 'text': ' be callee saved? What will happen if it? So, let us say I was designing my system. Can I make my', 'tokens': [50802, 312, 818, 1653, 6624, 30, 708, 486, 1051, 498, 309, 30, 407, 11, 718, 505, 584, 286, 390, 14685, 452, 1185, 13, 1664, 286, 652, 452, 51110], 'temperature': 0.0, 'avg_logprob': -0.15393830909103642, 'compression_ratio': 1.4102564102564104, 'no_speech_prob': 0.48368290066719055}, {'id': 356, 'seek': 287984, 'start': 2894.76, 'end': 2898.48, 'text': ' stack pointer caller saved? Yes.', 'tokens': [51110, 8630, 23918, 48324, 6624, 30, 1079, 13, 51296], 'temperature': 0.0, 'avg_logprob': -0.15393830909103642, 'compression_ratio': 1.4102564102564104, 'no_speech_prob': 0.48368290066719055}, {'id': 357, 'seek': 290984, 'start': 2909.84, 'end': 2923.08, 'text': ' But that is the semantic of callee saved. Callee saved is saying that if something is callee', 'tokens': [50364, 583, 300, 307, 264, 47982, 295, 818, 1653, 6624, 13, 7807, 1653, 6624, 307, 1566, 300, 498, 746, 307, 818, 1653, 51026], 'temperature': 0.0, 'avg_logprob': -0.13198978250676935, 'compression_ratio': 1.6975308641975309, 'no_speech_prob': 0.017958348616957664}, {'id': 358, 'seek': 290984, 'start': 2923.08, 'end': 2930.6800000000003, 'text': ' saved, callee is responsible for saving and restoring it. So, before returning from callee,', 'tokens': [51026, 6624, 11, 818, 1653, 307, 6250, 337, 6816, 293, 36349, 309, 13, 407, 11, 949, 12678, 490, 818, 1653, 11, 51406], 'temperature': 0.0, 'avg_logprob': -0.13198978250676935, 'compression_ratio': 1.6975308641975309, 'no_speech_prob': 0.017958348616957664}, {'id': 359, 'seek': 290984, 'start': 2930.6800000000003, 'end': 2937.1600000000003, 'text': ' the callee function must ensure that the stack pointer is pointing to the correct address.', 'tokens': [51406, 264, 818, 1653, 2445, 1633, 5586, 300, 264, 8630, 23918, 307, 12166, 281, 264, 3006, 2985, 13, 51730], 'temperature': 0.0, 'avg_logprob': -0.13198978250676935, 'compression_ratio': 1.6975308641975309, 'no_speech_prob': 0.017958348616957664}, {'id': 360, 'seek': 293716, 'start': 2937.16, 'end': 2947.48, 'text': " So, I didn't get why you think that makes it callee callers saved or callees.", 'tokens': [50364, 407, 11, 286, 994, 380, 483, 983, 291, 519, 300, 1669, 309, 818, 1653, 818, 433, 6624, 420, 818, 4031, 13, 50880], 'temperature': 0.0, 'avg_logprob': -0.4069650650024414, 'compression_ratio': 1.0405405405405406, 'no_speech_prob': 0.07794032245874405}, {'id': 361, 'seek': 294748, 'start': 2947.48, 'end': 2967.64, 'text': ' Correct. Does everyone get this? So, essentially, let us try to play this hypothetically. So,', 'tokens': [50364, 12753, 13, 4402, 1518, 483, 341, 30, 407, 11, 4476, 11, 718, 505, 853, 281, 862, 341, 24371, 22652, 13, 407, 11, 51372], 'temperature': 0.0, 'avg_logprob': -0.1294503410657247, 'compression_ratio': 1.3410852713178294, 'no_speech_prob': 0.0517907440662384}, {'id': 362, 'seek': 294748, 'start': 2967.64, 'end': 2973.76, 'text': ' let us say ESP was caller saved. So, what will happen is before doing the call,', 'tokens': [51372, 718, 505, 584, 12564, 47, 390, 48324, 6624, 13, 407, 11, 437, 486, 1051, 307, 949, 884, 264, 818, 11, 51678], 'temperature': 0.0, 'avg_logprob': -0.1294503410657247, 'compression_ratio': 1.3410852713178294, 'no_speech_prob': 0.0517907440662384}, {'id': 363, 'seek': 297376, 'start': 2973.76, 'end': 2982.44, 'text': ' caller will save it onto the stack. Now, control will transfer to the callee saved function. Now,', 'tokens': [50364, 48324, 486, 3155, 309, 3911, 264, 8630, 13, 823, 11, 1969, 486, 5003, 281, 264, 818, 1653, 6624, 2445, 13, 823, 11, 50798], 'temperature': 0.0, 'avg_logprob': -0.1504223922203327, 'compression_ratio': 1.7281553398058251, 'no_speech_prob': 0.0758105218410492}, {'id': 364, 'seek': 297376, 'start': 2982.44, 'end': 2987.36, 'text': ' since it is a caller saved register, callee function is free to modify it and does not', 'tokens': [50798, 1670, 309, 307, 257, 48324, 6624, 7280, 11, 818, 1653, 2445, 307, 1737, 281, 16927, 309, 293, 775, 406, 51044], 'temperature': 0.0, 'avg_logprob': -0.1504223922203327, 'compression_ratio': 1.7281553398058251, 'no_speech_prob': 0.0758105218410492}, {'id': 365, 'seek': 297376, 'start': 2987.36, 'end': 2994.0400000000004, 'text': ' have to change it to the original value. It is responsibility of the caller. So,', 'tokens': [51044, 362, 281, 1319, 309, 281, 264, 3380, 2158, 13, 467, 307, 6357, 295, 264, 48324, 13, 407, 11, 51378], 'temperature': 0.0, 'avg_logprob': -0.1504223922203327, 'compression_ratio': 1.7281553398058251, 'no_speech_prob': 0.0758105218410492}, {'id': 366, 'seek': 297376, 'start': 2994.0400000000004, 'end': 3003.1200000000003, 'text': ' callee function happily keeps modifying stack pointer. Then the RET instruction comes. RET', 'tokens': [51378, 818, 1653, 2445, 19909, 5965, 42626, 8630, 23918, 13, 1396, 264, 497, 4850, 10951, 1487, 13, 497, 4850, 51832], 'temperature': 0.0, 'avg_logprob': -0.1504223922203327, 'compression_ratio': 1.7281553398058251, 'no_speech_prob': 0.0758105218410492}, {'id': 367, 'seek': 300312, 'start': 3003.12, 'end': 3011.08, 'text': " instruction requires the stack pointer to point to stop a stack. If callee doesn't adjust it,", 'tokens': [50364, 10951, 7029, 264, 8630, 23918, 281, 935, 281, 1590, 257, 8630, 13, 759, 818, 1653, 1177, 380, 4369, 309, 11, 50762], 'temperature': 0.0, 'avg_logprob': -0.1087782655443464, 'compression_ratio': 1.5879120879120878, 'no_speech_prob': 0.0012440400896593928}, {'id': 368, 'seek': 300312, 'start': 3011.08, 'end': 3016.7999999999997, 'text': ' then RET instruction will not work properly and it will start popping random stuff from the stack', 'tokens': [50762, 550, 497, 4850, 10951, 486, 406, 589, 6108, 293, 309, 486, 722, 18374, 4974, 1507, 490, 264, 8630, 51048], 'temperature': 0.0, 'avg_logprob': -0.1087782655443464, 'compression_ratio': 1.5879120879120878, 'no_speech_prob': 0.0012440400896593928}, {'id': 369, 'seek': 300312, 'start': 3016.7999999999997, 'end': 3024.16, 'text': ' when RET executes. That is why it is callee saved because callee anyway has to clean up the stack', 'tokens': [51048, 562, 497, 4850, 4454, 1819, 13, 663, 307, 983, 309, 307, 818, 1653, 6624, 570, 818, 1653, 4033, 575, 281, 2541, 493, 264, 8630, 51416], 'temperature': 0.0, 'avg_logprob': -0.1087782655443464, 'compression_ratio': 1.5879120879120878, 'no_speech_prob': 0.0012440400896593928}, {'id': 370, 'seek': 302416, 'start': 3024.16, 'end': 3033.52, 'text': ' to get to that. Does that make sense? Now, to answer your question on how many are here', 'tokens': [50364, 281, 483, 281, 300, 13, 4402, 300, 652, 2020, 30, 823, 11, 281, 1867, 428, 1168, 322, 577, 867, 366, 510, 50832], 'temperature': 0.0, 'avg_logprob': -0.12595673611289576, 'compression_ratio': 1.6196581196581197, 'no_speech_prob': 0.11250315606594086}, {'id': 371, 'seek': 302416, 'start': 3033.52, 'end': 3040.6, 'text': ' and how many are here, it is actually a performance thing. There is no right or wrong answer except', 'tokens': [50832, 293, 577, 867, 366, 510, 11, 309, 307, 767, 257, 3389, 551, 13, 821, 307, 572, 558, 420, 2085, 1867, 3993, 51186], 'temperature': 0.0, 'avg_logprob': -0.12595673611289576, 'compression_ratio': 1.6196581196581197, 'no_speech_prob': 0.11250315606594086}, {'id': 372, 'seek': 302416, 'start': 3040.6, 'end': 3047.3199999999997, 'text': ' in special case like this where semantics mandate you to have it callee saved. I could have very', 'tokens': [51186, 294, 2121, 1389, 411, 341, 689, 4361, 45298, 23885, 291, 281, 362, 309, 818, 1653, 6624, 13, 286, 727, 362, 588, 51522], 'temperature': 0.0, 'avg_logprob': -0.12595673611289576, 'compression_ratio': 1.6196581196581197, 'no_speech_prob': 0.11250315606594086}, {'id': 373, 'seek': 302416, 'start': 3047.3199999999997, 'end': 3053.8399999999997, 'text': ' well said that EAX is my callee saved registers. So, there is nothing in the hardware which is', 'tokens': [51522, 731, 848, 300, 35747, 55, 307, 452, 818, 1653, 6624, 38351, 13, 407, 11, 456, 307, 1825, 294, 264, 8837, 597, 307, 51848], 'temperature': 0.0, 'avg_logprob': -0.12595673611289576, 'compression_ratio': 1.6196581196581197, 'no_speech_prob': 0.11250315606594086}, {'id': 374, 'seek': 305384, 'start': 3053.84, 'end': 3060.44, 'text': ' forcing you to make EAX callers saved or callee saved. It is some convention which is decided and', 'tokens': [50364, 19030, 291, 281, 652, 35747, 55, 818, 433, 6624, 420, 818, 1653, 6624, 13, 467, 307, 512, 10286, 597, 307, 3047, 293, 50694], 'temperature': 0.0, 'avg_logprob': -0.17352379474443258, 'compression_ratio': 1.6101694915254237, 'no_speech_prob': 0.0009107085061259568}, {'id': 375, 'seek': 305384, 'start': 3060.44, 'end': 3066.88, 'text': ' usually there is a lot of tuning which happens to decide this split. But it is an engineering', 'tokens': [50694, 2673, 456, 307, 257, 688, 295, 15164, 597, 2314, 281, 4536, 341, 7472, 13, 583, 309, 307, 364, 7043, 51016], 'temperature': 0.0, 'avg_logprob': -0.17352379474443258, 'compression_ratio': 1.6101694915254237, 'no_speech_prob': 0.0009107085061259568}, {'id': 376, 'seek': 305384, 'start': 3066.88, 'end': 3073.4, 'text': ' trade-off. There is no conceptual answer to that that it must be this way and the other way is', 'tokens': [51016, 4923, 12, 4506, 13, 821, 307, 572, 24106, 1867, 281, 300, 300, 309, 1633, 312, 341, 636, 293, 264, 661, 636, 307, 51342], 'temperature': 0.0, 'avg_logprob': -0.17352379474443258, 'compression_ratio': 1.6101694915254237, 'no_speech_prob': 0.0009107085061259568}, {'id': 377, 'seek': 305384, 'start': 3073.4, 'end': 3082.92, 'text': ' incorrect. Now, let us look at these quizzes. So, let us say you have a function foo which is', 'tokens': [51342, 18424, 13, 823, 11, 718, 505, 574, 412, 613, 48955, 13, 407, 11, 718, 505, 584, 291, 362, 257, 2445, 726, 78, 597, 307, 51818], 'temperature': 0.0, 'avg_logprob': -0.17352379474443258, 'compression_ratio': 1.6101694915254237, 'no_speech_prob': 0.0009107085061259568}, {'id': 378, 'seek': 308292, 'start': 3082.92, 'end': 3090.0, 'text': ' calling bar. Now, let us say foo happens to be a very complex function. By complex, I mean it has', 'tokens': [50364, 5141, 2159, 13, 823, 11, 718, 505, 584, 726, 78, 2314, 281, 312, 257, 588, 3997, 2445, 13, 3146, 3997, 11, 286, 914, 309, 575, 50718], 'temperature': 0.0, 'avg_logprob': -0.14465490652590382, 'compression_ratio': 1.7671232876712328, 'no_speech_prob': 0.00205039931461215}, {'id': 379, 'seek': 308292, 'start': 3090.0, 'end': 3096.52, 'text': ' lot of instructions, doing lot of computations and so on. And function bar is very simple. And', 'tokens': [50718, 688, 295, 9415, 11, 884, 688, 295, 2807, 763, 293, 370, 322, 13, 400, 2445, 2159, 307, 588, 2199, 13, 400, 51044], 'temperature': 0.0, 'avg_logprob': -0.14465490652590382, 'compression_ratio': 1.7671232876712328, 'no_speech_prob': 0.00205039931461215}, {'id': 380, 'seek': 308292, 'start': 3096.52, 'end': 3105.4, 'text': ' you are an optimizing compiler. So, you have to do register allocation. Now, when you are generating', 'tokens': [51044, 291, 366, 364, 40425, 31958, 13, 407, 11, 291, 362, 281, 360, 7280, 27599, 13, 823, 11, 562, 291, 366, 17746, 51488], 'temperature': 0.0, 'avg_logprob': -0.14465490652590382, 'compression_ratio': 1.7671232876712328, 'no_speech_prob': 0.00205039931461215}, {'id': 381, 'seek': 308292, 'start': 3105.4, 'end': 3110.96, 'text': ' code for foo, should you use more callers saved registers or should you use more callee saved', 'tokens': [51488, 3089, 337, 726, 78, 11, 820, 291, 764, 544, 818, 433, 6624, 38351, 420, 820, 291, 764, 544, 818, 1653, 6624, 51766], 'temperature': 0.0, 'avg_logprob': -0.14465490652590382, 'compression_ratio': 1.7671232876712328, 'no_speech_prob': 0.00205039931461215}, {'id': 382, 'seek': 311096, 'start': 3110.96, 'end': 3117.12, 'text': ' registers? Is the question clear? So, there is a function foo which is very complex. It is calling', 'tokens': [50364, 38351, 30, 1119, 264, 1168, 1850, 30, 407, 11, 456, 307, 257, 2445, 726, 78, 597, 307, 588, 3997, 13, 467, 307, 5141, 50672], 'temperature': 0.0, 'avg_logprob': -0.11021959434435205, 'compression_ratio': 1.811926605504587, 'no_speech_prob': 0.27477723360061646}, {'id': 383, 'seek': 311096, 'start': 3117.12, 'end': 3126.2400000000002, 'text': ' a simple function bar. So, bar is likely have small set of instructions. Foo is going to be very large', 'tokens': [50672, 257, 2199, 2445, 2159, 13, 407, 11, 2159, 307, 3700, 362, 1359, 992, 295, 9415, 13, 479, 1986, 307, 516, 281, 312, 588, 2416, 51128], 'temperature': 0.0, 'avg_logprob': -0.11021959434435205, 'compression_ratio': 1.811926605504587, 'no_speech_prob': 0.27477723360061646}, {'id': 384, 'seek': 311096, 'start': 3126.2400000000002, 'end': 3133.44, 'text': ' and foo is calling bar. Now, when you are register allocating function foo, should you use more', 'tokens': [51128, 293, 726, 78, 307, 5141, 2159, 13, 823, 11, 562, 291, 366, 7280, 12660, 990, 2445, 726, 78, 11, 820, 291, 764, 544, 51488], 'temperature': 0.0, 'avg_logprob': -0.11021959434435205, 'compression_ratio': 1.811926605504587, 'no_speech_prob': 0.27477723360061646}, {'id': 385, 'seek': 311096, 'start': 3133.44, 'end': 3139.52, 'text': ' callers saved registers in foo or should you use more callee saved registers into foo? Why callee', 'tokens': [51488, 818, 433, 6624, 38351, 294, 726, 78, 420, 820, 291, 764, 544, 818, 1653, 6624, 38351, 666, 726, 78, 30, 1545, 818, 1653, 51792], 'temperature': 0.0, 'avg_logprob': -0.11021959434435205, 'compression_ratio': 1.811926605504587, 'no_speech_prob': 0.27477723360061646}, {'id': 386, 'seek': 313952, 'start': 3139.64, 'end': 3151.88, 'text': ' saved? Okay, so they are saying foo should use callee saved register, more callee saved registers.', 'tokens': [50370, 6624, 30, 1033, 11, 370, 436, 366, 1566, 726, 78, 820, 764, 818, 1653, 6624, 7280, 11, 544, 818, 1653, 6624, 38351, 13, 50982], 'temperature': 0.0, 'avg_logprob': -0.15854291121164957, 'compression_ratio': 1.6057142857142856, 'no_speech_prob': 0.10659664124250412}, {'id': 387, 'seek': 313952, 'start': 3151.88, 'end': 3163.08, 'text': ' Correct. So, what will happen is since foo is complex, you could assume that foo is going to', 'tokens': [50982, 12753, 13, 407, 11, 437, 486, 1051, 307, 1670, 726, 78, 307, 3997, 11, 291, 727, 6552, 300, 726, 78, 307, 516, 281, 51542], 'temperature': 0.0, 'avg_logprob': -0.15854291121164957, 'compression_ratio': 1.6057142857142856, 'no_speech_prob': 0.10659664124250412}, {'id': 388, 'seek': 313952, 'start': 3163.08, 'end': 3168.72, 'text': ' use many registers. And many variables will be mapped to different set of registers. Now,', 'tokens': [51542, 764, 867, 38351, 13, 400, 867, 9102, 486, 312, 33318, 281, 819, 992, 295, 38351, 13, 823, 11, 51824], 'temperature': 0.0, 'avg_logprob': -0.15854291121164957, 'compression_ratio': 1.6057142857142856, 'no_speech_prob': 0.10659664124250412}, {'id': 389, 'seek': 316872, 'start': 3168.72, 'end': 3175.48, 'text': ' if you use more callers saved registers, then every time bar is called, it is callers responsibility', 'tokens': [50364, 498, 291, 764, 544, 818, 433, 6624, 38351, 11, 550, 633, 565, 2159, 307, 1219, 11, 309, 307, 818, 433, 6357, 50702], 'temperature': 0.0, 'avg_logprob': -0.10278089267691386, 'compression_ratio': 1.76036866359447, 'no_speech_prob': 0.0005883126286789775}, {'id': 390, 'seek': 316872, 'start': 3175.48, 'end': 3181.7999999999997, 'text': ' to save and restore them. So, foo has to do additional work plus it is already constrained', 'tokens': [50702, 281, 3155, 293, 15227, 552, 13, 407, 11, 726, 78, 575, 281, 360, 4497, 589, 1804, 309, 307, 1217, 38901, 51018], 'temperature': 0.0, 'avg_logprob': -0.10278089267691386, 'compression_ratio': 1.76036866359447, 'no_speech_prob': 0.0005883126286789775}, {'id': 391, 'seek': 316872, 'start': 3181.7999999999997, 'end': 3189.3199999999997, 'text': ' on the registers because it is going to be large. So, it is useful for foo to use more callee saved', 'tokens': [51018, 322, 264, 38351, 570, 309, 307, 516, 281, 312, 2416, 13, 407, 11, 309, 307, 4420, 337, 726, 78, 281, 764, 544, 818, 1653, 6624, 51394], 'temperature': 0.0, 'avg_logprob': -0.10278089267691386, 'compression_ratio': 1.76036866359447, 'no_speech_prob': 0.0005883126286789775}, {'id': 392, 'seek': 316872, 'start': 3189.3199999999997, 'end': 3196.7999999999997, 'text': " registers. This kind of tries to answer the question which you had. So, if you didn't have", 'tokens': [51394, 38351, 13, 639, 733, 295, 9898, 281, 1867, 264, 1168, 597, 291, 632, 13, 407, 11, 498, 291, 994, 380, 362, 51768], 'temperature': 0.0, 'avg_logprob': -0.10278089267691386, 'compression_ratio': 1.76036866359447, 'no_speech_prob': 0.0005883126286789775}, {'id': 393, 'seek': 319680, 'start': 3196.8, 'end': 3203.04, 'text': ' this kind of split, both foo and bar will be responsible for saving all the registers,', 'tokens': [50364, 341, 733, 295, 7472, 11, 1293, 726, 78, 293, 2159, 486, 312, 6250, 337, 6816, 439, 264, 38351, 11, 50676], 'temperature': 0.0, 'avg_logprob': -0.12205067740546333, 'compression_ratio': 1.7110091743119267, 'no_speech_prob': 0.007567388005554676}, {'id': 394, 'seek': 319680, 'start': 3203.04, 'end': 3208.84, 'text': ' in which case both of them have to do equal redundant work, in which case you are doing', 'tokens': [50676, 294, 597, 1389, 1293, 295, 552, 362, 281, 360, 2681, 40997, 589, 11, 294, 597, 1389, 291, 366, 884, 50966], 'temperature': 0.0, 'avg_logprob': -0.12205067740546333, 'compression_ratio': 1.7110091743119267, 'no_speech_prob': 0.007567388005554676}, {'id': 395, 'seek': 319680, 'start': 3208.84, 'end': 3215.48, 'text': ' suboptimal use of your resources. Instead, if you divide your responsibility between foo and bar,', 'tokens': [50966, 1422, 5747, 10650, 764, 295, 428, 3593, 13, 7156, 11, 498, 291, 9845, 428, 6357, 1296, 726, 78, 293, 2159, 11, 51298], 'temperature': 0.0, 'avg_logprob': -0.12205067740546333, 'compression_ratio': 1.7110091743119267, 'no_speech_prob': 0.007567388005554676}, {'id': 396, 'seek': 319680, 'start': 3215.48, 'end': 3224.2000000000003, 'text': ' and depending on how complex either of them are, you could tune your register allocator to use more,', 'tokens': [51298, 293, 5413, 322, 577, 3997, 2139, 295, 552, 366, 11, 291, 727, 10864, 428, 7280, 12660, 1639, 281, 764, 544, 11, 51734], 'temperature': 0.0, 'avg_logprob': -0.12205067740546333, 'compression_ratio': 1.7110091743119267, 'no_speech_prob': 0.007567388005554676}, {'id': 397, 'seek': 322420, 'start': 3224.2799999999997, 'end': 3230.9199999999996, 'text': ' shift more burden onto the simpler function than pulling it on yourself. Does that make sense?', 'tokens': [50368, 5513, 544, 12578, 3911, 264, 18587, 2445, 813, 8407, 309, 322, 1803, 13, 4402, 300, 652, 2020, 30, 50700], 'temperature': 0.0, 'avg_logprob': -0.13291493706081225, 'compression_ratio': 1.6050420168067228, 'no_speech_prob': 0.003706773743033409}, {'id': 398, 'seek': 322420, 'start': 3230.9199999999996, 'end': 3237.3599999999997, 'text': ' That is why compilers register allocation also need to be aware of these facts, not just for', 'tokens': [50700, 663, 307, 983, 715, 388, 433, 7280, 27599, 611, 643, 281, 312, 3650, 295, 613, 9130, 11, 406, 445, 337, 51022], 'temperature': 0.0, 'avg_logprob': -0.13291493706081225, 'compression_ratio': 1.6050420168067228, 'no_speech_prob': 0.003706773743033409}, {'id': 399, 'seek': 322420, 'start': 3237.3599999999997, 'end': 3246.3599999999997, 'text': ' generating code, but also for optimizations. And obviously, what will you do in the opposite case?', 'tokens': [51022, 17746, 3089, 11, 457, 611, 337, 5028, 14455, 13, 400, 2745, 11, 437, 486, 291, 360, 294, 264, 6182, 1389, 30, 51472], 'temperature': 0.0, 'avg_logprob': -0.13291493706081225, 'compression_ratio': 1.6050420168067228, 'no_speech_prob': 0.003706773743033409}, {'id': 400, 'seek': 322420, 'start': 3246.3599999999997, 'end': 3251.96, 'text': ' If foo was simple and bar was complex, you would do the opposite, where you will say foo should', 'tokens': [51472, 759, 726, 78, 390, 2199, 293, 2159, 390, 3997, 11, 291, 576, 360, 264, 6182, 11, 689, 291, 486, 584, 726, 78, 820, 51752], 'temperature': 0.0, 'avg_logprob': -0.13291493706081225, 'compression_ratio': 1.6050420168067228, 'no_speech_prob': 0.003706773743033409}, {'id': 401, 'seek': 325196, 'start': 3251.96, 'end': 3263.8, 'text': ' use more callee saved registers. Now, let us say foo calls bar, but bar does not call any other', 'tokens': [50364, 764, 544, 818, 1653, 6624, 38351, 13, 823, 11, 718, 505, 584, 726, 78, 5498, 2159, 11, 457, 2159, 775, 406, 818, 604, 661, 50956], 'temperature': 0.0, 'avg_logprob': -0.10407162393842424, 'compression_ratio': 1.7098765432098766, 'no_speech_prob': 0.01798269711434841}, {'id': 402, 'seek': 325196, 'start': 3263.8, 'end': 3271.68, 'text': ' function. So, foo is calling a function bar and bar does not do any other call. So, bar simply', 'tokens': [50956, 2445, 13, 407, 11, 726, 78, 307, 5141, 257, 2445, 2159, 293, 2159, 775, 406, 360, 604, 661, 818, 13, 407, 11, 2159, 2935, 51350], 'temperature': 0.0, 'avg_logprob': -0.10407162393842424, 'compression_ratio': 1.7098765432098766, 'no_speech_prob': 0.01798269711434841}, {'id': 403, 'seek': 325196, 'start': 3271.68, 'end': 3276.2, 'text': ' computes whatever it needs without calling any additional function and simply returns.', 'tokens': [51350, 715, 1819, 2035, 309, 2203, 1553, 5141, 604, 4497, 2445, 293, 2935, 11247, 13, 51576], 'temperature': 0.0, 'avg_logprob': -0.10407162393842424, 'compression_ratio': 1.7098765432098766, 'no_speech_prob': 0.01798269711434841}, {'id': 404, 'seek': 327620, 'start': 3276.2, 'end': 3284.12, 'text': ' So, when allocating for bar, which register should you use? Should you use more caller', 'tokens': [50364, 407, 11, 562, 12660, 990, 337, 2159, 11, 597, 7280, 820, 291, 764, 30, 6454, 291, 764, 544, 48324, 50760], 'temperature': 0.0, 'avg_logprob': -0.22696093150547572, 'compression_ratio': 1.7216494845360826, 'no_speech_prob': 0.019110657274723053}, {'id': 405, 'seek': 327620, 'start': 3284.12, 'end': 3292.96, 'text': ' saved registers or should you use more callee saved registers? Why callee saved?', 'tokens': [50760, 6624, 38351, 420, 820, 291, 764, 544, 818, 1653, 6624, 38351, 30, 1545, 818, 1653, 6624, 30, 51202], 'temperature': 0.0, 'avg_logprob': -0.22696093150547572, 'compression_ratio': 1.7216494845360826, 'no_speech_prob': 0.019110657274723053}, {'id': 406, 'seek': 329296, 'start': 3292.96, 'end': 3305.8, 'text': ' Okay.', 'tokens': [50364, 1033, 13, 51006], 'temperature': 0.0, 'avg_logprob': -0.7507001399993897, 'compression_ratio': 0.38461538461538464, 'no_speech_prob': 0.8907474875450134}, {'id': 407, 'seek': 332296, 'start': 3323.96, 'end': 3330.0, 'text': ' Correct. So, to answer this question, let us go back to the earlier question which we were getting.', 'tokens': [50414, 12753, 13, 407, 11, 281, 1867, 341, 1168, 11, 718, 505, 352, 646, 281, 264, 3071, 1168, 597, 321, 645, 1242, 13, 50716], 'temperature': 0.0, 'avg_logprob': -0.1320045976077809, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.211883082985878}, {'id': 408, 'seek': 332296, 'start': 3330.0, 'end': 3335.88, 'text': ' So, what happens when you have a function which is being called by someone else and it is also', 'tokens': [50716, 407, 11, 437, 2314, 562, 291, 362, 257, 2445, 597, 307, 885, 1219, 538, 1580, 1646, 293, 309, 307, 611, 51010], 'temperature': 0.0, 'avg_logprob': -0.1320045976077809, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.211883082985878}, {'id': 409, 'seek': 332296, 'start': 3335.88, 'end': 3341.56, 'text': ' calling some other function. So, let us say that we have a chain, main calls foo and foo calls bar.', 'tokens': [51010, 5141, 512, 661, 2445, 13, 407, 11, 718, 505, 584, 300, 321, 362, 257, 5021, 11, 2135, 5498, 726, 78, 293, 726, 78, 5498, 2159, 13, 51294], 'temperature': 0.0, 'avg_logprob': -0.1320045976077809, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.211883082985878}, {'id': 410, 'seek': 332296, 'start': 3341.56, 'end': 3349.2400000000002, 'text': ' So, let us talk about function foo. So, function foo is being called as well as it is calling', 'tokens': [51294, 407, 11, 718, 505, 751, 466, 2445, 726, 78, 13, 407, 11, 2445, 726, 78, 307, 885, 1219, 382, 731, 382, 309, 307, 5141, 51678], 'temperature': 0.0, 'avg_logprob': -0.1320045976077809, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.211883082985878}, {'id': 411, 'seek': 334924, 'start': 3349.24, 'end': 3356.56, 'text': ' other function. So, foo acts as a callee from point of view of main and foo acts as a caller', 'tokens': [50364, 661, 2445, 13, 407, 11, 726, 78, 10672, 382, 257, 818, 1653, 490, 935, 295, 1910, 295, 2135, 293, 726, 78, 10672, 382, 257, 48324, 50730], 'temperature': 0.0, 'avg_logprob': -0.14022759693424877, 'compression_ratio': 1.7705882352941176, 'no_speech_prob': 0.29391637444496155}, {'id': 412, 'seek': 334924, 'start': 3356.56, 'end': 3364.56, 'text': ' from point of view of bar. So, foo has a responsibility in worst case to do both the worlds because when it', 'tokens': [50730, 490, 935, 295, 1910, 295, 2159, 13, 407, 11, 726, 78, 575, 257, 6357, 294, 5855, 1389, 281, 360, 1293, 264, 13401, 570, 562, 309, 51130], 'temperature': 0.0, 'avg_logprob': -0.14022759693424877, 'compression_ratio': 1.7705882352941176, 'no_speech_prob': 0.29391637444496155}, {'id': 413, 'seek': 334924, 'start': 3364.56, 'end': 3374.0, 'text': ' is called from main, it has to save all the callee saved registers which it is using. And when it is', 'tokens': [51130, 307, 1219, 490, 2135, 11, 309, 575, 281, 3155, 439, 264, 818, 1653, 6624, 38351, 597, 309, 307, 1228, 13, 400, 562, 309, 307, 51602], 'temperature': 0.0, 'avg_logprob': -0.14022759693424877, 'compression_ratio': 1.7705882352941176, 'no_speech_prob': 0.29391637444496155}, {'id': 414, 'seek': 337400, 'start': 3374.04, 'end': 3382.12, 'text': ' calling bar, it has to save all the caller saved registers. So, foo has to do worst of both worlds.', 'tokens': [50366, 5141, 2159, 11, 309, 575, 281, 3155, 439, 264, 48324, 6624, 38351, 13, 407, 11, 726, 78, 575, 281, 360, 5855, 295, 1293, 13401, 13, 50770], 'temperature': 0.0, 'avg_logprob': -0.11902965643467048, 'compression_ratio': 1.7763975155279503, 'no_speech_prob': 0.09528861194849014}, {'id': 415, 'seek': 337400, 'start': 3382.12, 'end': 3392.84, 'text': ' Now, if foo was not calling a function and if you use callee saved registers, then what it means is', 'tokens': [50770, 823, 11, 498, 726, 78, 390, 406, 5141, 257, 2445, 293, 498, 291, 764, 818, 1653, 6624, 38351, 11, 550, 437, 309, 1355, 307, 51306], 'temperature': 0.0, 'avg_logprob': -0.11902965643467048, 'compression_ratio': 1.7763975155279503, 'no_speech_prob': 0.09528861194849014}, {'id': 416, 'seek': 337400, 'start': 3392.84, 'end': 3399.84, 'text': ' foo has to save and restore at least callee saved registers. But if foo was using only', 'tokens': [51306, 726, 78, 575, 281, 3155, 293, 15227, 412, 1935, 818, 1653, 6624, 38351, 13, 583, 498, 726, 78, 390, 1228, 787, 51656], 'temperature': 0.0, 'avg_logprob': -0.11902965643467048, 'compression_ratio': 1.7763975155279503, 'no_speech_prob': 0.09528861194849014}, {'id': 417, 'seek': 339984, 'start': 3400.0, 'end': 3406.96, 'text': ' caller saved registers, then it has to do nothing. So, a function which does not call any other', 'tokens': [50372, 48324, 6624, 38351, 11, 550, 309, 575, 281, 360, 1825, 13, 407, 11, 257, 2445, 597, 775, 406, 818, 604, 661, 50720], 'temperature': 0.0, 'avg_logprob': -0.10019285600263994, 'compression_ratio': 2.17877094972067, 'no_speech_prob': 0.021602574735879898}, {'id': 418, 'seek': 339984, 'start': 3406.96, 'end': 3415.76, 'text': ' function actually benefits from using caller saved registers which is what he was trying to say. So,', 'tokens': [50720, 2445, 767, 5311, 490, 1228, 48324, 6624, 38351, 597, 307, 437, 415, 390, 1382, 281, 584, 13, 407, 11, 51160], 'temperature': 0.0, 'avg_logprob': -0.10019285600263994, 'compression_ratio': 2.17877094972067, 'no_speech_prob': 0.021602574735879898}, {'id': 419, 'seek': 339984, 'start': 3415.76, 'end': 3420.84, 'text': ' if you have a function which does not call any other function, if you use caller saved registers,', 'tokens': [51160, 498, 291, 362, 257, 2445, 597, 775, 406, 818, 604, 661, 2445, 11, 498, 291, 764, 48324, 6624, 38351, 11, 51414], 'temperature': 0.0, 'avg_logprob': -0.10019285600263994, 'compression_ratio': 2.17877094972067, 'no_speech_prob': 0.021602574735879898}, {'id': 420, 'seek': 339984, 'start': 3420.84, 'end': 3428.2400000000002, 'text': ' that function has to do nothing as far as save restore goes. If it uses callee saved registers,', 'tokens': [51414, 300, 2445, 575, 281, 360, 1825, 382, 1400, 382, 3155, 15227, 1709, 13, 759, 309, 4960, 818, 1653, 6624, 38351, 11, 51784], 'temperature': 0.0, 'avg_logprob': -0.10019285600263994, 'compression_ratio': 2.17877094972067, 'no_speech_prob': 0.021602574735879898}, {'id': 421, 'seek': 342824, 'start': 3428.3199999999997, 'end': 3434.7999999999997, 'text': ' then it has to do save and restore. And for an intermediate function as in a non-leaf function,', 'tokens': [50368, 550, 309, 575, 281, 360, 3155, 293, 15227, 13, 400, 337, 364, 19376, 2445, 382, 294, 257, 2107, 12, 306, 2792, 2445, 11, 50692], 'temperature': 0.0, 'avg_logprob': -0.17091415239417035, 'compression_ratio': 1.826086956521739, 'no_speech_prob': 0.002050381852313876}, {'id': 422, 'seek': 342824, 'start': 3434.7999999999997, 'end': 3441.56, 'text': ' it has to do both of them. So, leaf functions typically can do things without save and restore.', 'tokens': [50692, 309, 575, 281, 360, 1293, 295, 552, 13, 407, 11, 10871, 6828, 5850, 393, 360, 721, 1553, 3155, 293, 15227, 13, 51030], 'temperature': 0.0, 'avg_logprob': -0.17091415239417035, 'compression_ratio': 1.826086956521739, 'no_speech_prob': 0.002050381852313876}, {'id': 423, 'seek': 342824, 'start': 3442.2799999999997, 'end': 3448.6, 'text': ' Now, the third question. So, let us say you are compiler. In which order you should compile', 'tokens': [51066, 823, 11, 264, 2636, 1168, 13, 407, 11, 718, 505, 584, 291, 366, 31958, 13, 682, 597, 1668, 291, 820, 31413, 51382], 'temperature': 0.0, 'avg_logprob': -0.17091415239417035, 'compression_ratio': 1.826086956521739, 'no_speech_prob': 0.002050381852313876}, {'id': 424, 'seek': 342824, 'start': 3448.6, 'end': 3454.52, 'text': ' functions? So, should you compile and register allocate caller first or should you compile and', 'tokens': [51382, 6828, 30, 407, 11, 820, 291, 31413, 293, 7280, 35713, 48324, 700, 420, 820, 291, 31413, 293, 51678], 'temperature': 0.0, 'avg_logprob': -0.17091415239417035, 'compression_ratio': 1.826086956521739, 'no_speech_prob': 0.002050381852313876}, {'id': 425, 'seek': 345452, 'start': 3454.52, 'end': 3460.4, 'text': ' register allocate callee first? Does the question make sense? See, it is not that you are going to', 'tokens': [50364, 7280, 35713, 818, 1653, 700, 30, 4402, 264, 1168, 652, 2020, 30, 3008, 11, 309, 307, 406, 300, 291, 366, 516, 281, 50658], 'temperature': 0.0, 'avg_logprob': -0.13860802496633223, 'compression_ratio': 1.6951219512195121, 'no_speech_prob': 0.09261246025562286}, {'id': 426, 'seek': 345452, 'start': 3460.4, 'end': 3465.8, 'text': ' register allocate entire program. You will probably do function by function. In which case,', 'tokens': [50658, 7280, 35713, 2302, 1461, 13, 509, 486, 1391, 360, 2445, 538, 2445, 13, 682, 597, 1389, 11, 50928], 'temperature': 0.0, 'avg_logprob': -0.13860802496633223, 'compression_ratio': 1.6951219512195121, 'no_speech_prob': 0.09261246025562286}, {'id': 427, 'seek': 345452, 'start': 3465.8, 'end': 3471.0, 'text': ' should you compile callee function first and register allocate it or should you compile', 'tokens': [50928, 820, 291, 31413, 818, 1653, 2445, 700, 293, 7280, 35713, 309, 420, 820, 291, 31413, 51188], 'temperature': 0.0, 'avg_logprob': -0.13860802496633223, 'compression_ratio': 1.6951219512195121, 'no_speech_prob': 0.09261246025562286}, {'id': 428, 'seek': 347100, 'start': 3471.0, 'end': 3489.28, 'text': ' caller function first and register allocate it? So, going back to this first example,', 'tokens': [50364, 48324, 2445, 700, 293, 7280, 35713, 309, 30, 407, 11, 516, 646, 281, 341, 700, 1365, 11, 51278], 'temperature': 0.0, 'avg_logprob': -0.20822886931590545, 'compression_ratio': 1.3739837398373984, 'no_speech_prob': 0.05337962880730629}, {'id': 429, 'seek': 347100, 'start': 3489.28, 'end': 3496.32, 'text': ' we utilize the information whether foo is complex or bar is complex and decided our', 'tokens': [51278, 321, 16117, 264, 1589, 1968, 726, 78, 307, 3997, 420, 2159, 307, 3997, 293, 3047, 527, 51630], 'temperature': 0.0, 'avg_logprob': -0.20822886931590545, 'compression_ratio': 1.3739837398373984, 'no_speech_prob': 0.05337962880730629}, {'id': 430, 'seek': 349632, 'start': 3496.4, 'end': 3501.6800000000003, 'text': ' register allocation scheme. So, if you knew more information about the function which you are', 'tokens': [50368, 7280, 27599, 12232, 13, 407, 11, 498, 291, 2586, 544, 1589, 466, 264, 2445, 597, 291, 366, 50632], 'temperature': 0.0, 'avg_logprob': -0.13090116327459161, 'compression_ratio': 1.7453703703703705, 'no_speech_prob': 0.058285173028707504}, {'id': 431, 'seek': 349632, 'start': 3501.6800000000003, 'end': 3508.32, 'text': ' calling, not in terms of exact all the things, but even if you simply know that this function', 'tokens': [50632, 5141, 11, 406, 294, 2115, 295, 1900, 439, 264, 721, 11, 457, 754, 498, 291, 2935, 458, 300, 341, 2445, 50964], 'temperature': 0.0, 'avg_logprob': -0.13090116327459161, 'compression_ratio': 1.7453703703703705, 'no_speech_prob': 0.058285173028707504}, {'id': 432, 'seek': 349632, 'start': 3508.32, 'end': 3513.1600000000003, 'text': ' is using these many registers and these type of registers, you could take that decision and', 'tokens': [50964, 307, 1228, 613, 867, 38351, 293, 613, 2010, 295, 38351, 11, 291, 727, 747, 300, 3537, 293, 51206], 'temperature': 0.0, 'avg_logprob': -0.13090116327459161, 'compression_ratio': 1.7453703703703705, 'no_speech_prob': 0.058285173028707504}, {'id': 433, 'seek': 349632, 'start': 3513.1600000000003, 'end': 3521.52, 'text': ' feed back to the caller. So, that is what most compilers would actually do. So, they would prefer', 'tokens': [51206, 3154, 646, 281, 264, 48324, 13, 407, 11, 300, 307, 437, 881, 715, 388, 433, 576, 767, 360, 13, 407, 11, 436, 576, 4382, 51624], 'temperature': 0.0, 'avg_logprob': -0.13090116327459161, 'compression_ratio': 1.7453703703703705, 'no_speech_prob': 0.058285173028707504}, {'id': 434, 'seek': 352152, 'start': 3521.68, 'end': 3527.64, 'text': ' to compile callee first and then caller and feed back the information from caller to caller,', 'tokens': [50372, 281, 31413, 818, 1653, 700, 293, 550, 48324, 293, 3154, 646, 264, 1589, 490, 48324, 281, 48324, 11, 50670], 'temperature': 0.0, 'avg_logprob': -0.19519656191590012, 'compression_ratio': 1.735159817351598, 'no_speech_prob': 0.022968195378780365}, {'id': 435, 'seek': 352152, 'start': 3527.64, 'end': 3536.88, 'text': ' so, callee to caller and use that to influence the optimizations. Again, in whole program only,', 'tokens': [50670, 370, 11, 818, 1653, 281, 48324, 293, 764, 300, 281, 6503, 264, 5028, 14455, 13, 3764, 11, 294, 1379, 1461, 787, 11, 51132], 'temperature': 0.0, 'avg_logprob': -0.19519656191590012, 'compression_ratio': 1.735159817351598, 'no_speech_prob': 0.022968195378780365}, {'id': 436, 'seek': 352152, 'start': 3536.88, 'end': 3541.12, 'text': ' if you have separate compilation, everything goes for a toss. So, you have to be conservative', 'tokens': [51132, 498, 291, 362, 4994, 40261, 11, 1203, 1709, 337, 257, 14432, 13, 407, 11, 291, 362, 281, 312, 13780, 51344], 'temperature': 0.0, 'avg_logprob': -0.19519656191590012, 'compression_ratio': 1.735159817351598, 'no_speech_prob': 0.022968195378780365}, {'id': 437, 'seek': 352152, 'start': 3541.12, 'end': 3551.08, 'text': ' and do the worst thing. So far, are things clear? So, so far, we have seen some contracts between', 'tokens': [51344, 293, 360, 264, 5855, 551, 13, 407, 1400, 11, 366, 721, 1850, 30, 407, 11, 370, 1400, 11, 321, 362, 1612, 512, 13952, 1296, 51842], 'temperature': 0.0, 'avg_logprob': -0.19519656191590012, 'compression_ratio': 1.735159817351598, 'no_speech_prob': 0.022968195378780365}, {'id': 438, 'seek': 355108, 'start': 3551.24, 'end': 3557.12, 'text': ' caller function and callee function. We saw the contract, the first contract was where the return', 'tokens': [50372, 48324, 2445, 293, 818, 1653, 2445, 13, 492, 1866, 264, 4364, 11, 264, 700, 4364, 390, 689, 264, 2736, 50666], 'temperature': 0.0, 'avg_logprob': -0.17962650676350017, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.002979801967740059}, {'id': 439, 'seek': 355108, 'start': 3557.12, 'end': 3565.44, 'text': ' address is and we learned that on x86, it is part of the stack as per when we push the call the', 'tokens': [50666, 2985, 307, 293, 321, 3264, 300, 322, 2031, 22193, 11, 309, 307, 644, 295, 264, 8630, 382, 680, 562, 321, 2944, 264, 818, 264, 51082], 'temperature': 0.0, 'avg_logprob': -0.17962650676350017, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.002979801967740059}, {'id': 440, 'seek': 355108, 'start': 3565.44, 'end': 3570.96, 'text': ' instruction and how are parameters stored on to the stack and in what order they are stored on to', 'tokens': [51082, 10951, 293, 577, 366, 9834, 12187, 322, 281, 264, 8630, 293, 294, 437, 1668, 436, 366, 12187, 322, 281, 51358], 'temperature': 0.0, 'avg_logprob': -0.17962650676350017, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.002979801967740059}, {'id': 441, 'seek': 355108, 'start': 3570.96, 'end': 3579.0, 'text': ' the stack. Where is the return value and how it is obtained and which registers are caller saved', 'tokens': [51358, 264, 8630, 13, 2305, 307, 264, 2736, 2158, 293, 577, 309, 307, 14879, 293, 597, 38351, 366, 48324, 6624, 51760], 'temperature': 0.0, 'avg_logprob': -0.17962650676350017, 'compression_ratio': 1.8743961352657006, 'no_speech_prob': 0.002979801967740059}, {'id': 442, 'seek': 357900, 'start': 3579.0, 'end': 3584.56, 'text': ' and which registers are callee saved. So far, we have seen these as contracts between the two.', 'tokens': [50364, 293, 597, 38351, 366, 818, 1653, 6624, 13, 407, 1400, 11, 321, 362, 1612, 613, 382, 13952, 1296, 264, 732, 13, 50642], 'temperature': 0.0, 'avg_logprob': -0.12765296729835304, 'compression_ratio': 1.8521400778210118, 'no_speech_prob': 0.001366644399240613}, {'id': 443, 'seek': 357900, 'start': 3584.56, 'end': 3593.16, 'text': ' If any of the contract is violated, then we have a problem because if say caller is assuming that', 'tokens': [50642, 759, 604, 295, 264, 4364, 307, 33239, 11, 550, 321, 362, 257, 1154, 570, 498, 584, 48324, 307, 11926, 300, 51072], 'temperature': 0.0, 'avg_logprob': -0.12765296729835304, 'compression_ratio': 1.8521400778210118, 'no_speech_prob': 0.001366644399240613}, {'id': 444, 'seek': 357900, 'start': 3593.16, 'end': 3598.04, 'text': ' I need to pass registers in left to right or parameters in left to right order and callee', 'tokens': [51072, 286, 643, 281, 1320, 38351, 294, 1411, 281, 558, 420, 9834, 294, 1411, 281, 558, 1668, 293, 818, 1653, 51316], 'temperature': 0.0, 'avg_logprob': -0.12765296729835304, 'compression_ratio': 1.8521400778210118, 'no_speech_prob': 0.001366644399240613}, {'id': 445, 'seek': 357900, 'start': 3598.04, 'end': 3603.24, 'text': ' assumes parameters are from right to left, then it is not going to work as expected. Similarly,', 'tokens': [51316, 37808, 9834, 366, 490, 558, 281, 1411, 11, 550, 309, 307, 406, 516, 281, 589, 382, 5176, 13, 13157, 11, 51576], 'temperature': 0.0, 'avg_logprob': -0.12765296729835304, 'compression_ratio': 1.8521400778210118, 'no_speech_prob': 0.001366644399240613}, {'id': 446, 'seek': 357900, 'start': 3603.24, 'end': 3608.12, 'text': ' if caller assumes that the return address is passed by a global variable, but the callee function', 'tokens': [51576, 498, 48324, 37808, 300, 264, 2736, 2985, 307, 4678, 538, 257, 4338, 7006, 11, 457, 264, 818, 1653, 2445, 51820], 'temperature': 0.0, 'avg_logprob': -0.12765296729835304, 'compression_ratio': 1.8521400778210118, 'no_speech_prob': 0.001366644399240613}, {'id': 447, 'seek': 360812, 'start': 3608.12, 'end': 3613.72, 'text': ' is looking at it from the stack, then it is not going to work. So, both caller and callee function', 'tokens': [50364, 307, 1237, 412, 309, 490, 264, 8630, 11, 550, 309, 307, 406, 516, 281, 589, 13, 407, 11, 1293, 48324, 293, 818, 1653, 2445, 50644], 'temperature': 0.0, 'avg_logprob': -0.1187439477571877, 'compression_ratio': 1.838095238095238, 'no_speech_prob': 0.0006068937364034355}, {'id': 448, 'seek': 360812, 'start': 3613.72, 'end': 3621.3599999999997, 'text': ' must agree upon something. So, these contracts are actually called as calling conventions. So,', 'tokens': [50644, 1633, 3986, 3564, 746, 13, 407, 11, 613, 13952, 366, 767, 1219, 382, 5141, 33520, 13, 407, 11, 51026], 'temperature': 0.0, 'avg_logprob': -0.1187439477571877, 'compression_ratio': 1.838095238095238, 'no_speech_prob': 0.0006068937364034355}, {'id': 449, 'seek': 360812, 'start': 3621.3599999999997, 'end': 3628.08, 'text': ' these set of contracts, there is a term called as calling convention. Now, coming back to the', 'tokens': [51026, 613, 992, 295, 13952, 11, 456, 307, 257, 1433, 1219, 382, 5141, 10286, 13, 823, 11, 1348, 646, 281, 264, 51362], 'temperature': 0.0, 'avg_logprob': -0.1187439477571877, 'compression_ratio': 1.838095238095238, 'no_speech_prob': 0.0006068937364034355}, {'id': 450, 'seek': 360812, 'start': 3628.08, 'end': 3635.72, 'text': ' question of who decides calling convention? Is it hardware? Is it compiler? Is it someone else? Is', 'tokens': [51362, 1168, 295, 567, 14898, 5141, 10286, 30, 1119, 309, 8837, 30, 1119, 309, 31958, 30, 1119, 309, 1580, 1646, 30, 1119, 51744], 'temperature': 0.0, 'avg_logprob': -0.1187439477571877, 'compression_ratio': 1.838095238095238, 'no_speech_prob': 0.0006068937364034355}, {'id': 451, 'seek': 363572, 'start': 3636.2, 'end': 3642.3199999999997, 'text': ' it me? Is it you? So, calling conventions are actually decided by something called as', 'tokens': [50388, 309, 385, 30, 1119, 309, 291, 30, 407, 11, 5141, 33520, 366, 767, 3047, 538, 746, 1219, 382, 50694], 'temperature': 0.0, 'avg_logprob': -0.13576691186250145, 'compression_ratio': 1.4944444444444445, 'no_speech_prob': 0.0022509165573865175}, {'id': 452, 'seek': 363572, 'start': 3642.3199999999997, 'end': 3649.72, 'text': ' application binary interface or ABI. How many of you have heard this term ABI? So,', 'tokens': [50694, 3861, 17434, 9226, 420, 316, 11291, 13, 1012, 867, 295, 291, 362, 2198, 341, 1433, 316, 11291, 30, 407, 11, 51064], 'temperature': 0.0, 'avg_logprob': -0.13576691186250145, 'compression_ratio': 1.4944444444444445, 'no_speech_prob': 0.0022509165573865175}, {'id': 453, 'seek': 363572, 'start': 3649.72, 'end': 3659.9199999999996, 'text': ' ABI is a contract which exists between binaries, binary interface and it is published by a platform.', 'tokens': [51064, 316, 11291, 307, 257, 4364, 597, 8198, 1296, 5171, 4889, 11, 17434, 9226, 293, 309, 307, 6572, 538, 257, 3663, 13, 51574], 'temperature': 0.0, 'avg_logprob': -0.13576691186250145, 'compression_ratio': 1.4944444444444445, 'no_speech_prob': 0.0022509165573865175}, {'id': 454, 'seek': 365992, 'start': 3659.92, 'end': 3667.2400000000002, 'text': ' It is not operating system alone. It is not hardware alone. It is a combination. So,', 'tokens': [50364, 467, 307, 406, 7447, 1185, 3312, 13, 467, 307, 406, 8837, 3312, 13, 467, 307, 257, 6562, 13, 407, 11, 50730], 'temperature': 0.0, 'avg_logprob': -0.1665509908627241, 'compression_ratio': 1.6385542168674698, 'no_speech_prob': 0.011329430155456066}, {'id': 455, 'seek': 365992, 'start': 3667.2400000000002, 'end': 3680.12, 'text': ' x86 does not have ABI. x86 Linux has an ABI. x86 Windows has an ABI and each ABI can be different.', 'tokens': [50730, 2031, 22193, 775, 406, 362, 316, 11291, 13, 2031, 22193, 18734, 575, 364, 316, 11291, 13, 2031, 22193, 8591, 575, 364, 316, 11291, 293, 1184, 316, 11291, 393, 312, 819, 13, 51374], 'temperature': 0.0, 'avg_logprob': -0.1665509908627241, 'compression_ratio': 1.6385542168674698, 'no_speech_prob': 0.011329430155456066}, {'id': 456, 'seek': 365992, 'start': 3681.4, 'end': 3688.54, 'text': ' Just like we saw caller saved callee saved convention, x86 Windows may decide I may have', 'tokens': [51438, 1449, 411, 321, 1866, 48324, 6624, 818, 1653, 6624, 10286, 11, 2031, 22193, 8591, 815, 4536, 286, 815, 362, 51795], 'temperature': 0.0, 'avg_logprob': -0.1665509908627241, 'compression_ratio': 1.6385542168674698, 'no_speech_prob': 0.011329430155456066}, {'id': 457, 'seek': 368854, 'start': 3688.54, 'end': 3696.9, 'text': ' a different convention than x86 Linux. But every platform provides an application binary interface', 'tokens': [50364, 257, 819, 10286, 813, 2031, 22193, 18734, 13, 583, 633, 3663, 6417, 364, 3861, 17434, 9226, 50782], 'temperature': 0.0, 'avg_logprob': -0.11132126885491449, 'compression_ratio': 1.6416184971098267, 'no_speech_prob': 0.0013667074963450432}, {'id': 458, 'seek': 368854, 'start': 3696.9, 'end': 3706.34, 'text': ' and all the tools which are involved on that platform need to comply to that ABI. So, GCC has', 'tokens': [50782, 293, 439, 264, 3873, 597, 366, 3288, 322, 300, 3663, 643, 281, 27956, 281, 300, 316, 11291, 13, 407, 11, 460, 11717, 575, 51254], 'temperature': 0.0, 'avg_logprob': -0.11132126885491449, 'compression_ratio': 1.6416184971098267, 'no_speech_prob': 0.0013667074963450432}, {'id': 459, 'seek': 368854, 'start': 3706.34, 'end': 3717.82, 'text': ' to comply to the ABI which is on x86 Linux. C lang on Linux has to comply on x86 Linux ABI.', 'tokens': [51254, 281, 27956, 281, 264, 316, 11291, 597, 307, 322, 2031, 22193, 18734, 13, 383, 2265, 322, 18734, 575, 281, 27956, 322, 2031, 22193, 18734, 316, 11291, 13, 51828], 'temperature': 0.0, 'avg_logprob': -0.11132126885491449, 'compression_ratio': 1.6416184971098267, 'no_speech_prob': 0.0013667074963450432}, {'id': 460, 'seek': 371782, 'start': 3717.82, 'end': 3726.46, 'text': ' C lang on Windows has to comply to x86 Windows ABI. Does that make sense? ABI decides calling', 'tokens': [50364, 383, 2265, 322, 8591, 575, 281, 27956, 281, 2031, 22193, 8591, 316, 11291, 13, 4402, 300, 652, 2020, 30, 316, 11291, 14898, 5141, 50796], 'temperature': 0.0, 'avg_logprob': -0.14720428906954253, 'compression_ratio': 1.5053191489361701, 'no_speech_prob': 2.1780651877634227e-05}, {'id': 461, 'seek': 371782, 'start': 3726.46, 'end': 3732.5, 'text': ' conventions, but there are other parts of the ABI also. For example, size of integer. It is', 'tokens': [50796, 33520, 11, 457, 456, 366, 661, 3166, 295, 264, 316, 11291, 611, 13, 1171, 1365, 11, 2744, 295, 24922, 13, 467, 307, 51098], 'temperature': 0.0, 'avg_logprob': -0.14720428906954253, 'compression_ratio': 1.5053191489361701, 'no_speech_prob': 2.1780651877634227e-05}, {'id': 462, 'seek': 371782, 'start': 3732.5, 'end': 3740.98, 'text': ' not specified by compiler. So, do not think size of int is 4. It is compiler dependent. It is ABI', 'tokens': [51098, 406, 22206, 538, 31958, 13, 407, 11, 360, 406, 519, 2744, 295, 560, 307, 1017, 13, 467, 307, 31958, 12334, 13, 467, 307, 316, 11291, 51522], 'temperature': 0.0, 'avg_logprob': -0.14720428906954253, 'compression_ratio': 1.5053191489361701, 'no_speech_prob': 2.1780651877634227e-05}, {'id': 463, 'seek': 374098, 'start': 3740.98, 'end': 3749.42, 'text': ' dependent. ABI is the interface which is actually specifying what is the size of int. For example,', 'tokens': [50364, 12334, 13, 316, 11291, 307, 264, 9226, 597, 307, 767, 1608, 5489, 437, 307, 264, 2744, 295, 560, 13, 1171, 1365, 11, 50786], 'temperature': 0.0, 'avg_logprob': -0.13867244385836416, 'compression_ratio': 1.381294964028777, 'no_speech_prob': 0.0116850221529603}, {'id': 464, 'seek': 374098, 'start': 3749.42, 'end': 3760.98, 'text': ' long int has worst ABI. So, long int on 32-bit Linux is 32-bit. Long int on 32-bit Windows is', 'tokens': [50786, 938, 560, 575, 5855, 316, 11291, 13, 407, 11, 938, 560, 322, 8858, 12, 5260, 18734, 307, 8858, 12, 5260, 13, 8282, 560, 322, 8858, 12, 5260, 8591, 307, 51364], 'temperature': 0.0, 'avg_logprob': -0.13867244385836416, 'compression_ratio': 1.381294964028777, 'no_speech_prob': 0.0116850221529603}, {'id': 465, 'seek': 376098, 'start': 3760.98, 'end': 3771.66, 'text': ' 32-bit. Long int on 64-bit Linux is 64-bit and long int on Windows is 32-bit. So, Windows has a', 'tokens': [50364, 8858, 12, 5260, 13, 8282, 560, 322, 12145, 12, 5260, 18734, 307, 12145, 12, 5260, 293, 938, 560, 322, 8591, 307, 8858, 12, 5260, 13, 407, 11, 8591, 575, 257, 50898], 'temperature': 0.0, 'avg_logprob': -0.12089226966680483, 'compression_ratio': 1.695906432748538, 'no_speech_prob': 0.036192815750837326}, {'id': 466, 'seek': 376098, 'start': 3771.66, 'end': 3779.14, 'text': ' weird ABI for long int where it says long int on Windows is going to be 32-bit. And that they had', 'tokens': [50898, 3657, 316, 11291, 337, 938, 560, 689, 309, 1619, 938, 560, 322, 8591, 307, 516, 281, 312, 8858, 12, 5260, 13, 400, 300, 436, 632, 51272], 'temperature': 0.0, 'avg_logprob': -0.12089226966680483, 'compression_ratio': 1.695906432748538, 'no_speech_prob': 0.036192815750837326}, {'id': 467, 'seek': 376098, 'start': 3779.14, 'end': 3786.34, 'text': ' done for portability reasons, but it is odd man out. And that is why you should not use long int', 'tokens': [51272, 1096, 337, 2436, 2310, 4112, 11, 457, 309, 307, 7401, 587, 484, 13, 400, 300, 307, 983, 291, 820, 406, 764, 938, 560, 51632], 'temperature': 0.0, 'avg_logprob': -0.12089226966680483, 'compression_ratio': 1.695906432748538, 'no_speech_prob': 0.036192815750837326}, {'id': 468, 'seek': 378634, 'start': 3786.7400000000002, 'end': 3791.98, 'text': ' as a data type in your program because it makes it less portable. Because if you are writing', 'tokens': [50384, 382, 257, 1412, 2010, 294, 428, 1461, 570, 309, 1669, 309, 1570, 21800, 13, 1436, 498, 291, 366, 3579, 50646], 'temperature': 0.0, 'avg_logprob': -0.11342927683954654, 'compression_ratio': 1.691304347826087, 'no_speech_prob': 0.08258359879255295}, {'id': 469, 'seek': 378634, 'start': 3791.98, 'end': 3798.6600000000003, 'text': ' something as long int, assuming it will be 64-bit, then your code will not run on Windows 64 as', 'tokens': [50646, 746, 382, 938, 560, 11, 11926, 309, 486, 312, 12145, 12, 5260, 11, 550, 428, 3089, 486, 406, 1190, 322, 8591, 12145, 382, 50980], 'temperature': 0.0, 'avg_logprob': -0.11342927683954654, 'compression_ratio': 1.691304347826087, 'no_speech_prob': 0.08258359879255295}, {'id': 470, 'seek': 378634, 'start': 3798.6600000000003, 'end': 3808.6200000000003, 'text': ' expected. So, knowing ABI helps you write portable programs. The same thing you need to follow when', 'tokens': [50980, 5176, 13, 407, 11, 5276, 316, 11291, 3665, 291, 2464, 21800, 4268, 13, 440, 912, 551, 291, 643, 281, 1524, 562, 51478], 'temperature': 0.0, 'avg_logprob': -0.11342927683954654, 'compression_ratio': 1.691304347826087, 'no_speech_prob': 0.08258359879255295}, {'id': 471, 'seek': 378634, 'start': 3808.6200000000003, 'end': 3815.02, 'text': ' you are writing assembly. So, if you are writing assembly program which might be called from another', 'tokens': [51478, 291, 366, 3579, 12103, 13, 407, 11, 498, 291, 366, 3579, 12103, 1461, 597, 1062, 312, 1219, 490, 1071, 51798], 'temperature': 0.0, 'avg_logprob': -0.11342927683954654, 'compression_ratio': 1.691304347826087, 'no_speech_prob': 0.08258359879255295}, {'id': 472, 'seek': 381502, 'start': 3815.1, 'end': 3824.62, 'text': ' C program, your assembly program must comply to the ABI. So, your program must expect the', 'tokens': [50368, 383, 1461, 11, 428, 12103, 1461, 1633, 27956, 281, 264, 316, 11291, 13, 407, 11, 428, 1461, 1633, 2066, 264, 50844], 'temperature': 0.0, 'avg_logprob': -0.1125378316762496, 'compression_ratio': 1.9191919191919191, 'no_speech_prob': 0.003705584444105625}, {'id': 473, 'seek': 381502, 'start': 3824.62, 'end': 3829.98, 'text': ' pointers parameters are passed in this order and so on and so forth. So, you have to as an assembly', 'tokens': [50844, 44548, 9834, 366, 4678, 294, 341, 1668, 293, 370, 322, 293, 370, 5220, 13, 407, 11, 291, 362, 281, 382, 364, 12103, 51112], 'temperature': 0.0, 'avg_logprob': -0.1125378316762496, 'compression_ratio': 1.9191919191919191, 'no_speech_prob': 0.003705584444105625}, {'id': 474, 'seek': 381502, 'start': 3829.98, 'end': 3835.9, 'text': ' programmer, you have to know what is the ABI which is being followed. As a compiler writer,', 'tokens': [51112, 32116, 11, 291, 362, 281, 458, 437, 307, 264, 316, 11291, 597, 307, 885, 6263, 13, 1018, 257, 31958, 9936, 11, 51408], 'temperature': 0.0, 'avg_logprob': -0.1125378316762496, 'compression_ratio': 1.9191919191919191, 'no_speech_prob': 0.003705584444105625}, {'id': 475, 'seek': 381502, 'start': 3835.9, 'end': 3841.3, 'text': ' you need to know what is the ABI being followed. So, you can generate code for that ABI. Does that', 'tokens': [51408, 291, 643, 281, 458, 437, 307, 264, 316, 11291, 885, 6263, 13, 407, 11, 291, 393, 8460, 3089, 337, 300, 316, 11291, 13, 4402, 300, 51678], 'temperature': 0.0, 'avg_logprob': -0.1125378316762496, 'compression_ratio': 1.9191919191919191, 'no_speech_prob': 0.003705584444105625}, {'id': 476, 'seek': 384130, 'start': 3841.5, 'end': 3847.38, 'text': ' make sense? Now, the question is, is there only one calling convention specified by the ABI?', 'tokens': [50374, 652, 2020, 30, 823, 11, 264, 1168, 307, 11, 307, 456, 787, 472, 5141, 10286, 22206, 538, 264, 316, 11291, 30, 50668], 'temperature': 0.0, 'avg_logprob': -0.18242902341096298, 'compression_ratio': 1.5136612021857923, 'no_speech_prob': 0.004328558687120676}, {'id': 477, 'seek': 384130, 'start': 3847.38, 'end': 3865.5, 'text': ' What are issues with only one calling convention? Correct. So, so far whatever we have seen were', 'tokens': [50668, 708, 366, 2663, 365, 787, 472, 5141, 10286, 30, 12753, 13, 407, 11, 370, 1400, 2035, 321, 362, 1612, 645, 51574], 'temperature': 0.0, 'avg_logprob': -0.18242902341096298, 'compression_ratio': 1.5136612021857923, 'no_speech_prob': 0.004328558687120676}, {'id': 478, 'seek': 384130, 'start': 3865.5, 'end': 3871.0600000000004, 'text': ' mostly trade-offs. There is no truly right answer and truly wrong answer. It was just a', 'tokens': [51574, 5240, 4923, 12, 19231, 13, 821, 307, 572, 4908, 558, 1867, 293, 4908, 2085, 1867, 13, 467, 390, 445, 257, 51852], 'temperature': 0.0, 'avg_logprob': -0.18242902341096298, 'compression_ratio': 1.5136612021857923, 'no_speech_prob': 0.004328558687120676}, {'id': 479, 'seek': 387106, 'start': 3871.06, 'end': 3876.38, 'text': ' judgmental call that four caller saved registers is okay, four callee saved is okay. Whatever', 'tokens': [50364, 12216, 304, 818, 300, 1451, 48324, 6624, 38351, 307, 1392, 11, 1451, 818, 1653, 6624, 307, 1392, 13, 8541, 50630], 'temperature': 0.0, 'avg_logprob': -0.14322486131087594, 'compression_ratio': 1.625531914893617, 'no_speech_prob': 0.0011149175697937608}, {'id': 480, 'seek': 387106, 'start': 3876.38, 'end': 3885.46, 'text': ' applies to broad class of programs makes sense. But as he said, it is not optimal for a specific', 'tokens': [50630, 13165, 281, 4152, 1508, 295, 4268, 1669, 2020, 13, 583, 382, 415, 848, 11, 309, 307, 406, 16252, 337, 257, 2685, 51084], 'temperature': 0.0, 'avg_logprob': -0.14322486131087594, 'compression_ratio': 1.625531914893617, 'no_speech_prob': 0.0011149175697937608}, {'id': 481, 'seek': 387106, 'start': 3885.46, 'end': 3892.66, 'text': ' use case. For example, if I know I am going to pass only two parameters to a function and my', 'tokens': [51084, 764, 1389, 13, 1171, 1365, 11, 498, 286, 458, 286, 669, 516, 281, 1320, 787, 732, 9834, 281, 257, 2445, 293, 452, 51444], 'temperature': 0.0, 'avg_logprob': -0.14322486131087594, 'compression_ratio': 1.625531914893617, 'no_speech_prob': 0.0011149175697937608}, {'id': 482, 'seek': 387106, 'start': 3892.66, 'end': 3899.1, 'text': ' function is very critical. Let us say my function is called deeply within some set of nested loops', 'tokens': [51444, 2445, 307, 588, 4924, 13, 961, 505, 584, 452, 2445, 307, 1219, 8760, 1951, 512, 992, 295, 15646, 292, 16121, 51766], 'temperature': 0.0, 'avg_logprob': -0.14322486131087594, 'compression_ratio': 1.625531914893617, 'no_speech_prob': 0.0011149175697937608}, {'id': 483, 'seek': 389910, 'start': 3899.1, 'end': 3904.46, 'text': ' and is very important for performance. Do I really want to pass my parameters via stack?', 'tokens': [50364, 293, 307, 588, 1021, 337, 3389, 13, 1144, 286, 534, 528, 281, 1320, 452, 9834, 5766, 8630, 30, 50632], 'temperature': 0.0, 'avg_logprob': -0.13973449838572535, 'compression_ratio': 1.6150442477876106, 'no_speech_prob': 0.005908864550292492}, {'id': 484, 'seek': 389910, 'start': 3904.46, 'end': 3912.7799999999997, 'text': ' Because remember stack is a memory access and memory access goes through a hierarchy of accesses', 'tokens': [50632, 1436, 1604, 8630, 307, 257, 4675, 2105, 293, 4675, 2105, 1709, 807, 257, 22333, 295, 2105, 279, 51048], 'temperature': 0.0, 'avg_logprob': -0.13973449838572535, 'compression_ratio': 1.6150442477876106, 'no_speech_prob': 0.005908864550292492}, {'id': 485, 'seek': 389910, 'start': 3912.7799999999997, 'end': 3917.58, 'text': ' and if it is not in cache, then you will hit to DRAM and it will take a lot of time to come.', 'tokens': [51048, 293, 498, 309, 307, 406, 294, 19459, 11, 550, 291, 486, 2045, 281, 12118, 2865, 293, 309, 486, 747, 257, 688, 295, 565, 281, 808, 13, 51288], 'temperature': 0.0, 'avg_logprob': -0.13973449838572535, 'compression_ratio': 1.6150442477876106, 'no_speech_prob': 0.005908864550292492}, {'id': 486, 'seek': 389910, 'start': 3918.22, 'end': 3925.7, 'text': ' So, there are multiple calling conventions which are specified. So, there is something', 'tokens': [51320, 407, 11, 456, 366, 3866, 5141, 33520, 597, 366, 22206, 13, 407, 11, 456, 307, 746, 51694], 'temperature': 0.0, 'avg_logprob': -0.13973449838572535, 'compression_ratio': 1.6150442477876106, 'no_speech_prob': 0.005908864550292492}, {'id': 487, 'seek': 392570, 'start': 3925.8599999999997, 'end': 3930.46, 'text': ' called as fast call. I do not know how many of you have heard of it. But fast call essentially', 'tokens': [50372, 1219, 382, 2370, 818, 13, 286, 360, 406, 458, 577, 867, 295, 291, 362, 2198, 295, 309, 13, 583, 2370, 818, 4476, 50602], 'temperature': 0.0, 'avg_logprob': -0.1403128196453226, 'compression_ratio': 1.7822878228782288, 'no_speech_prob': 0.033044565469026566}, {'id': 488, 'seek': 392570, 'start': 3930.46, 'end': 3936.58, 'text': ' says first two arguments of the function are passed via register. So, instead of using stack,', 'tokens': [50602, 1619, 700, 732, 12869, 295, 264, 2445, 366, 4678, 5766, 7280, 13, 407, 11, 2602, 295, 1228, 8630, 11, 50908], 'temperature': 0.0, 'avg_logprob': -0.1403128196453226, 'compression_ratio': 1.7822878228782288, 'no_speech_prob': 0.033044565469026566}, {'id': 489, 'seek': 392570, 'start': 3936.58, 'end': 3942.24, 'text': ' if you have first two parameters will be passed on to the registers. And again you have to realize', 'tokens': [50908, 498, 291, 362, 700, 732, 9834, 486, 312, 4678, 322, 281, 264, 38351, 13, 400, 797, 291, 362, 281, 4325, 51191], 'temperature': 0.0, 'avg_logprob': -0.1403128196453226, 'compression_ratio': 1.7822878228782288, 'no_speech_prob': 0.033044565469026566}, {'id': 490, 'seek': 392570, 'start': 3942.24, 'end': 3948.18, 'text': ' that it is not only caller who decides. Both of them have to agree and both when you are compiling', 'tokens': [51191, 300, 309, 307, 406, 787, 48324, 567, 14898, 13, 6767, 295, 552, 362, 281, 3986, 293, 1293, 562, 291, 366, 715, 4883, 51488], 'temperature': 0.0, 'avg_logprob': -0.1403128196453226, 'compression_ratio': 1.7822878228782288, 'no_speech_prob': 0.033044565469026566}, {'id': 491, 'seek': 392570, 'start': 3948.18, 'end': 3953.5, 'text': ' both caller and both callee, you need to know whether it is going to be called with X convention', 'tokens': [51488, 1293, 48324, 293, 1293, 818, 1653, 11, 291, 643, 281, 458, 1968, 309, 307, 516, 281, 312, 1219, 365, 1783, 10286, 51754], 'temperature': 0.0, 'avg_logprob': -0.1403128196453226, 'compression_ratio': 1.7822878228782288, 'no_speech_prob': 0.033044565469026566}, {'id': 492, 'seek': 395350, 'start': 3953.5, 'end': 3959.78, 'text': ' or Y convention. It cannot be arbitrary convention. So, there are bunch of other', 'tokens': [50364, 420, 398, 10286, 13, 467, 2644, 312, 23211, 10286, 13, 407, 11, 456, 366, 3840, 295, 661, 50678], 'temperature': 0.0, 'avg_logprob': -0.12031974792480468, 'compression_ratio': 1.835978835978836, 'no_speech_prob': 0.0017002783715724945}, {'id': 493, 'seek': 395350, 'start': 3959.78, 'end': 3966.86, 'text': ' calling conventions which are specified. And so, let us say there are no callee. So,', 'tokens': [50678, 5141, 33520, 597, 366, 22206, 13, 400, 370, 11, 718, 505, 584, 456, 366, 572, 818, 1653, 13, 407, 11, 51032], 'temperature': 0.0, 'avg_logprob': -0.12031974792480468, 'compression_ratio': 1.835978835978836, 'no_speech_prob': 0.0017002783715724945}, {'id': 494, 'seek': 395350, 'start': 3966.86, 'end': 3972.46, 'text': ' there is only one calling convention. Let us hypothetically assume. Can calling convention', 'tokens': [51032, 456, 307, 787, 472, 5141, 10286, 13, 961, 505, 24371, 22652, 6552, 13, 1664, 5141, 10286, 51312], 'temperature': 0.0, 'avg_logprob': -0.12031974792480468, 'compression_ratio': 1.835978835978836, 'no_speech_prob': 0.0017002783715724945}, {'id': 495, 'seek': 395350, 'start': 3972.46, 'end': 3979.26, 'text': ' be relaxed by compiler? Can compiler do that? So, let us say there is a function foo which', 'tokens': [51312, 312, 14628, 538, 31958, 30, 1664, 31958, 360, 300, 30, 407, 11, 718, 505, 584, 456, 307, 257, 2445, 726, 78, 597, 51652], 'temperature': 0.0, 'avg_logprob': -0.12031974792480468, 'compression_ratio': 1.835978835978836, 'no_speech_prob': 0.0017002783715724945}, {'id': 496, 'seek': 397926, 'start': 3979.26, 'end': 3986.7000000000003, 'text': ' is called from main. Compiler says I see foo is being used in a very critical loop. So,', 'tokens': [50364, 307, 1219, 490, 2135, 13, 6620, 5441, 1619, 286, 536, 726, 78, 307, 885, 1143, 294, 257, 588, 4924, 6367, 13, 407, 11, 50736], 'temperature': 0.0, 'avg_logprob': -0.12803446992914727, 'compression_ratio': 1.3233082706766917, 'no_speech_prob': 0.10077990591526031}, {'id': 497, 'seek': 397926, 'start': 3986.7000000000003, 'end': 3993.86, 'text': ' let me instead of using stack pass things via registers. Is compiler allowed to do that?', 'tokens': [50736, 718, 385, 2602, 295, 1228, 8630, 1320, 721, 5766, 38351, 13, 1119, 31958, 4350, 281, 360, 300, 30, 51094], 'temperature': 0.0, 'avg_logprob': -0.12803446992914727, 'compression_ratio': 1.3233082706766917, 'no_speech_prob': 0.10077990591526031}, {'id': 498, 'seek': 399386, 'start': 3993.86, 'end': 4011.42, 'text': ' Correct. So, compiler in theory can do it because it is generating code for main as well as foo.', 'tokens': [50364, 12753, 13, 407, 11, 31958, 294, 5261, 393, 360, 309, 570, 309, 307, 17746, 3089, 337, 2135, 382, 731, 382, 726, 78, 13, 51242], 'temperature': 0.0, 'avg_logprob': -0.17245767666743353, 'compression_ratio': 1.3776223776223777, 'no_speech_prob': 0.010642039589583874}, {'id': 499, 'seek': 399386, 'start': 4011.42, 'end': 4018.58, 'text': ' But what are the preconditions? So, let us say you come up with this optimization where you will say', 'tokens': [51242, 583, 437, 366, 264, 4346, 684, 2451, 30, 407, 11, 718, 505, 584, 291, 808, 493, 365, 341, 19618, 689, 291, 486, 584, 51600], 'temperature': 0.0, 'avg_logprob': -0.17245767666743353, 'compression_ratio': 1.3776223776223777, 'no_speech_prob': 0.010642039589583874}, {'id': 500, 'seek': 401858, 'start': 4018.58, 'end': 4026.22, 'text': ' that I will do some analysis and figure out I should call this function and pass parameters', 'tokens': [50364, 300, 286, 486, 360, 512, 5215, 293, 2573, 484, 286, 820, 818, 341, 2445, 293, 1320, 9834, 50746], 'temperature': 0.0, 'avg_logprob': -0.17976045608520508, 'compression_ratio': 1.5363128491620113, 'no_speech_prob': 0.07571108639240265}, {'id': 501, 'seek': 401858, 'start': 4026.22, 'end': 4032.86, 'text': ' via registers. What are the preconditions for that optimization to kick in? In what cases', 'tokens': [50746, 5766, 38351, 13, 708, 366, 264, 4346, 684, 2451, 337, 300, 19618, 281, 4437, 294, 30, 682, 437, 3331, 51078], 'temperature': 0.0, 'avg_logprob': -0.17976045608520508, 'compression_ratio': 1.5363128491620113, 'no_speech_prob': 0.07571108639240265}, {'id': 502, 'seek': 401858, 'start': 4032.86, 'end': 4047.2999999999997, 'text': ' compiler cannot do that optimization? Programmer cannot assume that because language standard', 'tokens': [51078, 31958, 2644, 360, 300, 19618, 30, 8338, 936, 2644, 6552, 300, 570, 2856, 3832, 51800], 'temperature': 0.0, 'avg_logprob': -0.17976045608520508, 'compression_ratio': 1.5363128491620113, 'no_speech_prob': 0.07571108639240265}, {'id': 503, 'seek': 404730, 'start': 4047.3, 'end': 4055.46, 'text': ' does not say that programmer can assume that. See, because when you are generating code as a', 'tokens': [50364, 775, 406, 584, 300, 32116, 393, 6552, 300, 13, 3008, 11, 570, 562, 291, 366, 17746, 3089, 382, 257, 50772], 'temperature': 0.0, 'avg_logprob': -0.13840391370985244, 'compression_ratio': 1.7677725118483412, 'no_speech_prob': 0.0329841785132885}, {'id': 504, 'seek': 404730, 'start': 4055.46, 'end': 4061.5800000000004, 'text': ' compiler and whenever you are doing optimization, one of the most important aspect of optimization', 'tokens': [50772, 31958, 293, 5699, 291, 366, 884, 19618, 11, 472, 295, 264, 881, 1021, 4171, 295, 19618, 51078], 'temperature': 0.0, 'avg_logprob': -0.13840391370985244, 'compression_ratio': 1.7677725118483412, 'no_speech_prob': 0.0329841785132885}, {'id': 505, 'seek': 404730, 'start': 4061.5800000000004, 'end': 4067.5, 'text': ' is to not break semantics of the program. So, no matter how good is your optimization,', 'tokens': [51078, 307, 281, 406, 1821, 4361, 45298, 295, 264, 1461, 13, 407, 11, 572, 1871, 577, 665, 307, 428, 19618, 11, 51374], 'temperature': 0.0, 'avg_logprob': -0.13840391370985244, 'compression_ratio': 1.7677725118483412, 'no_speech_prob': 0.0329841785132885}, {'id': 506, 'seek': 404730, 'start': 4067.5, 'end': 4074.3, 'text': ' if it breaks the program semantics, it is illegal. So, what are the preconditions for you? So,', 'tokens': [51374, 498, 309, 9857, 264, 1461, 4361, 45298, 11, 309, 307, 11905, 13, 407, 11, 437, 366, 264, 4346, 684, 2451, 337, 291, 30, 407, 11, 51714], 'temperature': 0.0, 'avg_logprob': -0.13840391370985244, 'compression_ratio': 1.7677725118483412, 'no_speech_prob': 0.0329841785132885}, {'id': 507, 'seek': 407430, 'start': 4074.3, 'end': 4079.7000000000003, 'text': ' let us say you implemented this optimization. When what will be the conditions you will check', 'tokens': [50364, 718, 505, 584, 291, 12270, 341, 19618, 13, 1133, 437, 486, 312, 264, 4487, 291, 486, 1520, 50634], 'temperature': 0.0, 'avg_logprob': -0.2918713720221269, 'compression_ratio': 1.6584158415841583, 'no_speech_prob': 0.01636112853884697}, {'id': 508, 'seek': 407430, 'start': 4079.7000000000003, 'end': 4083.82, 'text': ' under which you can apply this and in what conditions you cannot apply this?', 'tokens': [50634, 833, 597, 291, 393, 3079, 341, 293, 294, 437, 4487, 291, 2644, 3079, 341, 30, 50840], 'temperature': 0.0, 'avg_logprob': -0.2918713720221269, 'compression_ratio': 1.6584158415841583, 'no_speech_prob': 0.01636112853884697}, {'id': 509, 'seek': 407430, 'start': 4083.82, 'end': 4093.7400000000002, 'text': ' Can a parameter be covered by argument? Okay, so there are some sanity checks that', 'tokens': [50840, 1664, 257, 13075, 312, 5343, 538, 6770, 30, 1033, 11, 370, 456, 366, 512, 47892, 13834, 300, 51336], 'temperature': 0.0, 'avg_logprob': -0.2918713720221269, 'compression_ratio': 1.6584158415841583, 'no_speech_prob': 0.01636112853884697}, {'id': 510, 'seek': 407430, 'start': 4093.7400000000002, 'end': 4100.02, 'text': ' the optimization is only for function with two parameters. So, that is one check.', 'tokens': [51336, 264, 19618, 307, 787, 337, 2445, 365, 732, 9834, 13, 407, 11, 300, 307, 472, 1520, 13, 51650], 'temperature': 0.0, 'avg_logprob': -0.2918713720221269, 'compression_ratio': 1.6584158415841583, 'no_speech_prob': 0.01636112853884697}, {'id': 511, 'seek': 410002, 'start': 4100.02, 'end': 4112.38, 'text': ' Okay, so if the parameters are such that you cannot put them into physical register,', 'tokens': [50364, 1033, 11, 370, 498, 264, 9834, 366, 1270, 300, 291, 2644, 829, 552, 666, 4001, 7280, 11, 50982], 'temperature': 0.0, 'avg_logprob': -0.20812730320164416, 'compression_ratio': 1.4508670520231215, 'no_speech_prob': 0.006652767304331064}, {'id': 512, 'seek': 410002, 'start': 4112.38, 'end': 4116.740000000001, 'text': ' like they are like 64 bit values or something like that, maybe you. So,', 'tokens': [50982, 411, 436, 366, 411, 12145, 857, 4190, 420, 746, 411, 300, 11, 1310, 291, 13, 407, 11, 51200], 'temperature': 0.0, 'avg_logprob': -0.20812730320164416, 'compression_ratio': 1.4508670520231215, 'no_speech_prob': 0.006652767304331064}, {'id': 513, 'seek': 410002, 'start': 4116.740000000001, 'end': 4124.3, 'text': ' two checks. Any other things you need to check. Remember, programmer is not asking compiler to', 'tokens': [51200, 732, 13834, 13, 2639, 661, 721, 291, 643, 281, 1520, 13, 5459, 11, 32116, 307, 406, 3365, 31958, 281, 51578], 'temperature': 0.0, 'avg_logprob': -0.20812730320164416, 'compression_ratio': 1.4508670520231215, 'no_speech_prob': 0.006652767304331064}, {'id': 514, 'seek': 412430, 'start': 4124.3, 'end': 4135.78, 'text': ' do this. Compiler is kind of doing it out of its own magic. What if compiler does not know', 'tokens': [50364, 360, 341, 13, 6620, 5441, 307, 733, 295, 884, 309, 484, 295, 1080, 1065, 5585, 13, 708, 498, 31958, 775, 406, 458, 50938], 'temperature': 0.0, 'avg_logprob': -0.11587319691975911, 'compression_ratio': 1.5730337078651686, 'no_speech_prob': 0.08485763520002365}, {'id': 515, 'seek': 412430, 'start': 4135.78, 'end': 4142.18, 'text': ' all the callers of the function? So, the function foo is being called, it takes two parameters,', 'tokens': [50938, 439, 264, 818, 433, 295, 264, 2445, 30, 407, 11, 264, 2445, 726, 78, 307, 885, 1219, 11, 309, 2516, 732, 9834, 11, 51258], 'temperature': 0.0, 'avg_logprob': -0.11587319691975911, 'compression_ratio': 1.5730337078651686, 'no_speech_prob': 0.08485763520002365}, {'id': 516, 'seek': 412430, 'start': 4142.18, 'end': 4148.9400000000005, 'text': ' but I do not know from what all positions foo might be called. In what cases can that happen?', 'tokens': [51258, 457, 286, 360, 406, 458, 490, 437, 439, 8432, 726, 78, 1062, 312, 1219, 13, 682, 437, 3331, 393, 300, 1051, 30, 51596], 'temperature': 0.0, 'avg_logprob': -0.11587319691975911, 'compression_ratio': 1.5730337078651686, 'no_speech_prob': 0.08485763520002365}, {'id': 517, 'seek': 414894, 'start': 4148.94, 'end': 4167.139999999999, 'text': ' Foo is defined in current file. But when can callers of foo come from other file? So,', 'tokens': [50364, 479, 1986, 307, 7642, 294, 2190, 3991, 13, 583, 562, 393, 818, 433, 295, 726, 78, 808, 490, 661, 3991, 30, 407, 11, 51274], 'temperature': 0.0, 'avg_logprob': -0.2055143928527832, 'compression_ratio': 1.5593220338983051, 'no_speech_prob': 0.004595812410116196}, {'id': 518, 'seek': 414894, 'start': 4167.139999999999, 'end': 4173.58, 'text': ' separate compilation foo is defined. The callers of foo can be other file in separate compilation.', 'tokens': [51274, 4994, 40261, 726, 78, 307, 7642, 13, 440, 818, 433, 295, 726, 78, 393, 312, 661, 3991, 294, 4994, 40261, 13, 51596], 'temperature': 0.0, 'avg_logprob': -0.2055143928527832, 'compression_ratio': 1.5593220338983051, 'no_speech_prob': 0.004595812410116196}, {'id': 519, 'seek': 417358, 'start': 4174.3, 'end': 4179.0599999999995, 'text': ' Is there something when I am compiling that I know foo might be called from other files?', 'tokens': [50400, 1119, 456, 746, 562, 286, 669, 715, 4883, 300, 286, 458, 726, 78, 1062, 312, 1219, 490, 661, 7098, 30, 50638], 'temperature': 0.0, 'avg_logprob': -0.17915707418363389, 'compression_ratio': 1.5965909090909092, 'no_speech_prob': 0.011318255215883255}, {'id': 520, 'seek': 417358, 'start': 4179.0599999999995, 'end': 4192.0599999999995, 'text': ' Okay, does anyone know something called as static when you apply to function, what happens? So,', 'tokens': [50638, 1033, 11, 775, 2878, 458, 746, 1219, 382, 13437, 562, 291, 3079, 281, 2445, 11, 437, 2314, 30, 407, 11, 51288], 'temperature': 0.0, 'avg_logprob': -0.17915707418363389, 'compression_ratio': 1.5965909090909092, 'no_speech_prob': 0.011318255215883255}, {'id': 521, 'seek': 417358, 'start': 4192.0599999999995, 'end': 4199.34, 'text': ' let us say if I do this, what is the meaning of this? Does anyone know? When I say a function is', 'tokens': [51288, 718, 505, 584, 498, 286, 360, 341, 11, 437, 307, 264, 3620, 295, 341, 30, 4402, 2878, 458, 30, 1133, 286, 584, 257, 2445, 307, 51652], 'temperature': 0.0, 'avg_logprob': -0.17915707418363389, 'compression_ratio': 1.5965909090909092, 'no_speech_prob': 0.011318255215883255}, {'id': 522, 'seek': 419934, 'start': 4199.34, 'end': 4208.38, 'text': ' static? So, let me ask you this. What is the difference between these? So, you have to tell', 'tokens': [50364, 13437, 30, 407, 11, 718, 385, 1029, 291, 341, 13, 708, 307, 264, 2649, 1296, 613, 30, 407, 11, 291, 362, 281, 980, 50816], 'temperature': 0.0, 'avg_logprob': -0.11561788831438337, 'compression_ratio': 1.9241379310344828, 'no_speech_prob': 0.12921413779258728}, {'id': 523, 'seek': 419934, 'start': 4208.38, 'end': 4216.34, 'text': ' me difference in these four cases. So, there is int gbl, there is static int gbl2, there is void', 'tokens': [50816, 385, 2649, 294, 613, 1451, 3331, 13, 407, 11, 456, 307, 560, 290, 5199, 11, 456, 307, 13437, 560, 290, 5199, 17, 11, 456, 307, 22009, 51214], 'temperature': 0.0, 'avg_logprob': -0.11561788831438337, 'compression_ratio': 1.9241379310344828, 'no_speech_prob': 0.12921413779258728}, {'id': 524, 'seek': 419934, 'start': 4216.34, 'end': 4225.62, 'text': ' foo and there is static void bar. What is the difference between these things? What is the', 'tokens': [51214, 726, 78, 293, 456, 307, 13437, 22009, 2159, 13, 708, 307, 264, 2649, 1296, 613, 721, 30, 708, 307, 264, 51678], 'temperature': 0.0, 'avg_logprob': -0.11561788831438337, 'compression_ratio': 1.9241379310344828, 'no_speech_prob': 0.12921413779258728}, {'id': 525, 'seek': 422562, 'start': 4225.62, 'end': 4239.18, 'text': ' difference between gbl and gbl2? These are global variables by the way. So, all of this is written', 'tokens': [50364, 2649, 1296, 290, 5199, 293, 290, 5199, 17, 30, 1981, 366, 4338, 9102, 538, 264, 636, 13, 407, 11, 439, 295, 341, 307, 3720, 51042], 'temperature': 0.0, 'avg_logprob': -0.1822537694658552, 'compression_ratio': 1.0888888888888888, 'no_speech_prob': 0.11556259542703629}, {'id': 526, 'seek': 423918, 'start': 4239.18, 'end': 4256.280000000001, 'text': ' at outside main. So, is there any difference between gbl and gbl2? Yes.', 'tokens': [50364, 412, 2380, 2135, 13, 407, 11, 307, 456, 604, 2649, 1296, 290, 5199, 293, 290, 5199, 17, 30, 1079, 13, 51219], 'temperature': 0.0, 'avg_logprob': -0.18435384829839072, 'compression_ratio': 0.9594594594594594, 'no_speech_prob': 0.06729297339916229}, {'id': 527, 'seek': 425628, 'start': 4256.28, 'end': 4274.48, 'text': ' Correct. So, gbl is actually usable in other file using external int gbl. I cannot do external', 'tokens': [50364, 12753, 13, 407, 11, 290, 5199, 307, 767, 29975, 294, 661, 3991, 1228, 8320, 560, 290, 5199, 13, 286, 2644, 360, 8320, 51274], 'temperature': 0.0, 'avg_logprob': -0.2406613643352802, 'compression_ratio': 1.1058823529411765, 'no_speech_prob': 0.01580529659986496}, {'id': 528, 'seek': 427448, 'start': 4274.48, 'end': 4286.12, 'text': ' int gbl2. So, static keyword here is implying that this variable is not accessible outside', 'tokens': [50364, 560, 290, 5199, 17, 13, 407, 11, 13437, 20428, 510, 307, 704, 7310, 300, 341, 7006, 307, 406, 9515, 2380, 50946], 'temperature': 0.0, 'avg_logprob': -0.10950839841688001, 'compression_ratio': 1.6826347305389222, 'no_speech_prob': 0.0736377090215683}, {'id': 529, 'seek': 427448, 'start': 4286.12, 'end': 4295.959999999999, 'text': ' this file. Gbl is accessible outside this file. So, there is a term called as translation unit,', 'tokens': [50946, 341, 3991, 13, 460, 5199, 307, 9515, 2380, 341, 3991, 13, 407, 11, 456, 307, 257, 1433, 1219, 382, 12853, 4985, 11, 51438], 'temperature': 0.0, 'avg_logprob': -0.10950839841688001, 'compression_ratio': 1.6826347305389222, 'no_speech_prob': 0.0736377090215683}, {'id': 530, 'seek': 427448, 'start': 4295.959999999999, 'end': 4303.36, 'text': ' which you might have heard. So, gbl can be used in other translation unit, gbl2 cannot be used', 'tokens': [51438, 597, 291, 1062, 362, 2198, 13, 407, 11, 290, 5199, 393, 312, 1143, 294, 661, 12853, 4985, 11, 290, 5199, 17, 2644, 312, 1143, 51808], 'temperature': 0.0, 'avg_logprob': -0.10950839841688001, 'compression_ratio': 1.6826347305389222, 'no_speech_prob': 0.0736377090215683}, {'id': 531, 'seek': 430336, 'start': 4303.36, 'end': 4311.2, 'text': ' in other translation. In the same way foo can be used in other translation units, bar cannot be', 'tokens': [50364, 294, 661, 12853, 13, 682, 264, 912, 636, 726, 78, 393, 312, 1143, 294, 661, 12853, 6815, 11, 2159, 2644, 312, 50756], 'temperature': 0.0, 'avg_logprob': -0.13702037811279297, 'compression_ratio': 1.7852760736196318, 'no_speech_prob': 0.013219129294157028}, {'id': 532, 'seek': 430336, 'start': 4311.2, 'end': 4322.799999999999, 'text': ' used in other translation units. So, when I have a function which is static, I know all callers of', 'tokens': [50756, 1143, 294, 661, 12853, 6815, 13, 407, 11, 562, 286, 362, 257, 2445, 597, 307, 13437, 11, 286, 458, 439, 818, 433, 295, 51336], 'temperature': 0.0, 'avg_logprob': -0.13702037811279297, 'compression_ratio': 1.7852760736196318, 'no_speech_prob': 0.013219129294157028}, {'id': 533, 'seek': 430336, 'start': 4322.799999999999, 'end': 4333.32, 'text': ' that function will be in the same file, even if I am doing separate compilation. So, if I mark a', 'tokens': [51336, 300, 2445, 486, 312, 294, 264, 912, 3991, 11, 754, 498, 286, 669, 884, 4994, 40261, 13, 407, 11, 498, 286, 1491, 257, 51862], 'temperature': 0.0, 'avg_logprob': -0.13702037811279297, 'compression_ratio': 1.7852760736196318, 'no_speech_prob': 0.013219129294157028}, {'id': 534, 'seek': 433332, 'start': 4333.32, 'end': 4340.28, 'text': ' function static that is good, that allows compiler to do more optimizations, because compiler knows', 'tokens': [50364, 2445, 13437, 300, 307, 665, 11, 300, 4045, 31958, 281, 360, 544, 5028, 14455, 11, 570, 31958, 3255, 50712], 'temperature': 0.0, 'avg_logprob': -0.11023646051233466, 'compression_ratio': 1.737556561085973, 'no_speech_prob': 0.0012059662258252501}, {'id': 535, 'seek': 433332, 'start': 4340.28, 'end': 4347.24, 'text': ' that static functions cannot be called from other file. So, even though I am doing separate', 'tokens': [50712, 300, 13437, 6828, 2644, 312, 1219, 490, 661, 3991, 13, 407, 11, 754, 1673, 286, 669, 884, 4994, 51060], 'temperature': 0.0, 'avg_logprob': -0.11023646051233466, 'compression_ratio': 1.737556561085973, 'no_speech_prob': 0.0012059662258252501}, {'id': 536, 'seek': 433332, 'start': 4347.24, 'end': 4353.48, 'text': ' compilation, I can assume few things about this function. And one of the things could be relaxing', 'tokens': [51060, 40261, 11, 286, 393, 6552, 1326, 721, 466, 341, 2445, 13, 400, 472, 295, 264, 721, 727, 312, 20103, 51372], 'temperature': 0.0, 'avg_logprob': -0.11023646051233466, 'compression_ratio': 1.737556561085973, 'no_speech_prob': 0.0012059662258252501}, {'id': 537, 'seek': 433332, 'start': 4353.48, 'end': 4359.4, 'text': ' calling conventions, because I know that all the callers are in this file and they are at 0.1,', 'tokens': [51372, 5141, 33520, 11, 570, 286, 458, 300, 439, 264, 818, 433, 366, 294, 341, 3991, 293, 436, 366, 412, 1958, 13, 16, 11, 51668], 'temperature': 0.0, 'avg_logprob': -0.11023646051233466, 'compression_ratio': 1.737556561085973, 'no_speech_prob': 0.0012059662258252501}, {'id': 538, 'seek': 435940, 'start': 4359.4, 'end': 4366.5199999999995, 'text': ' 0.5, 0.10, 0.25. As long as those points match with the function, I am doing this optimization.', 'tokens': [50364, 1958, 13, 20, 11, 1958, 13, 3279, 11, 1958, 13, 6074, 13, 1018, 938, 382, 729, 2793, 2995, 365, 264, 2445, 11, 286, 669, 884, 341, 19618, 13, 50720], 'temperature': 0.0, 'avg_logprob': -0.34538140892982483, 'compression_ratio': 1.0674157303370786, 'no_speech_prob': 0.20642118155956268}, {'id': 539, 'seek': 436652, 'start': 4366.52, 'end': 4395.320000000001, 'text': ' What if someone does this? So, this code is actually doing a function pointer to bar,', 'tokens': [50364, 708, 498, 1580, 775, 341, 30, 407, 11, 341, 3089, 307, 767, 884, 257, 2445, 23918, 281, 2159, 11, 51804], 'temperature': 0.0, 'avg_logprob': -0.1878828173098357, 'compression_ratio': 1.0493827160493827, 'no_speech_prob': 0.6850371360778809}, {'id': 540, 'seek': 439532, 'start': 4395.48, 'end': 4408.32, 'text': ' and the function pointer itself can be external in other file. So, I can do external this and use.', 'tokens': [50372, 293, 264, 2445, 23918, 2564, 393, 312, 8320, 294, 661, 3991, 13, 407, 11, 286, 393, 360, 8320, 341, 293, 764, 13, 51014], 'temperature': 0.0, 'avg_logprob': -0.16354027916403377, 'compression_ratio': 1.5537190082644627, 'no_speech_prob': 0.0020503834821283817}, {'id': 541, 'seek': 439532, 'start': 4408.32, 'end': 4416.36, 'text': ' So, it is not that bar is not callable from other files, but it is not callable directly,', 'tokens': [51014, 407, 11, 309, 307, 406, 300, 2159, 307, 406, 818, 712, 490, 661, 7098, 11, 457, 309, 307, 406, 818, 712, 3838, 11, 51416], 'temperature': 0.0, 'avg_logprob': -0.16354027916403377, 'compression_ratio': 1.5537190082644627, 'no_speech_prob': 0.0020503834821283817}, {'id': 542, 'seek': 441636, 'start': 4416.44, 'end': 4425.32, 'text': ' it can be called from function pointer. So, compiler cannot simply do this for every static', 'tokens': [50368, 309, 393, 312, 1219, 490, 2445, 23918, 13, 407, 11, 31958, 2644, 2935, 360, 341, 337, 633, 13437, 50812], 'temperature': 0.0, 'avg_logprob': -0.16716637244591345, 'compression_ratio': 1.718562874251497, 'no_speech_prob': 0.00734200794249773}, {'id': 543, 'seek': 441636, 'start': 4425.32, 'end': 4435.96, 'text': ' function. It has to do it for static functions whose address is not taken or whose address is', 'tokens': [50812, 2445, 13, 467, 575, 281, 360, 309, 337, 13437, 6828, 6104, 2985, 307, 406, 2726, 420, 6104, 2985, 307, 51344], 'temperature': 0.0, 'avg_logprob': -0.16716637244591345, 'compression_ratio': 1.718562874251497, 'no_speech_prob': 0.00734200794249773}, {'id': 544, 'seek': 441636, 'start': 4435.96, 'end': 4445.4, 'text': ' taken only in static function pointers. So, there are bunch of conditions you have to match to figure', 'tokens': [51344, 2726, 787, 294, 13437, 2445, 44548, 13, 407, 11, 456, 366, 3840, 295, 4487, 291, 362, 281, 2995, 281, 2573, 51816], 'temperature': 0.0, 'avg_logprob': -0.16716637244591345, 'compression_ratio': 1.718562874251497, 'no_speech_prob': 0.00734200794249773}, {'id': 545, 'seek': 444540, 'start': 4445.4, 'end': 4453.879999999999, 'text': ' out yes. And by now you should know pointer analysis. So, even if this was static, I could', 'tokens': [50364, 484, 2086, 13, 400, 538, 586, 291, 820, 458, 23918, 5215, 13, 407, 11, 754, 498, 341, 390, 13437, 11, 286, 727, 50788], 'temperature': 0.0, 'avg_logprob': -0.12438076072269016, 'compression_ratio': 1.5561797752808988, 'no_speech_prob': 0.0013425477081909776}, {'id': 546, 'seek': 444540, 'start': 4453.879999999999, 'end': 4464.2, 'text': ' do something like this. Some other pointer is equal to fp and then whatever other magic and', 'tokens': [50788, 360, 746, 411, 341, 13, 2188, 661, 23918, 307, 2681, 281, 283, 79, 293, 550, 2035, 661, 5585, 293, 51304], 'temperature': 0.0, 'avg_logprob': -0.12438076072269016, 'compression_ratio': 1.5561797752808988, 'no_speech_prob': 0.0013425477081909776}, {'id': 547, 'seek': 444540, 'start': 4464.2, 'end': 4471.5599999999995, 'text': ' everything goes for a toss. So, as soon as you put pointers, in theory it is possible, but for', 'tokens': [51304, 1203, 1709, 337, 257, 14432, 13, 407, 11, 382, 2321, 382, 291, 829, 44548, 11, 294, 5261, 309, 307, 1944, 11, 457, 337, 51672], 'temperature': 0.0, 'avg_logprob': -0.12438076072269016, 'compression_ratio': 1.5561797752808988, 'no_speech_prob': 0.0013425477081909776}, {'id': 548, 'seek': 447156, 'start': 4471.56, 'end': 4477.240000000001, 'text': ' practical reasons it gets very hard. So, but simple condition is if your function does not', 'tokens': [50364, 8496, 4112, 309, 2170, 588, 1152, 13, 407, 11, 457, 2199, 4188, 307, 498, 428, 2445, 775, 406, 50648], 'temperature': 0.0, 'avg_logprob': -0.06653491566690166, 'compression_ratio': 1.6440677966101696, 'no_speech_prob': 0.005908028222620487}, {'id': 549, 'seek': 447156, 'start': 4477.240000000001, 'end': 4485.96, 'text': ' have address taken, you can apply this optimization. That is why whenever you are writing programs with', 'tokens': [50648, 362, 2985, 2726, 11, 291, 393, 3079, 341, 19618, 13, 663, 307, 983, 5699, 291, 366, 3579, 4268, 365, 51084], 'temperature': 0.0, 'avg_logprob': -0.06653491566690166, 'compression_ratio': 1.6440677966101696, 'no_speech_prob': 0.005908028222620487}, {'id': 550, 'seek': 447156, 'start': 4485.96, 'end': 4491.4800000000005, 'text': ' multiple files, it is very important for you to express your intent. For example, if you know', 'tokens': [51084, 3866, 7098, 11, 309, 307, 588, 1021, 337, 291, 281, 5109, 428, 8446, 13, 1171, 1365, 11, 498, 291, 458, 51360], 'temperature': 0.0, 'avg_logprob': -0.06653491566690166, 'compression_ratio': 1.6440677966101696, 'no_speech_prob': 0.005908028222620487}, {'id': 551, 'seek': 447156, 'start': 4491.4800000000005, 'end': 4497.4800000000005, 'text': ' this function is for this file only, like if you have a print routine, which is printing some data,', 'tokens': [51360, 341, 2445, 307, 337, 341, 3991, 787, 11, 411, 498, 291, 362, 257, 4482, 9927, 11, 597, 307, 14699, 512, 1412, 11, 51660], 'temperature': 0.0, 'avg_logprob': -0.06653491566690166, 'compression_ratio': 1.6440677966101696, 'no_speech_prob': 0.005908028222620487}, {'id': 552, 'seek': 449748, 'start': 4497.48, 'end': 4502.679999999999, 'text': ' it is unlikely that you want this to be called from someone else. It could be a debugging routine', 'tokens': [50364, 309, 307, 17518, 300, 291, 528, 341, 281, 312, 1219, 490, 1580, 1646, 13, 467, 727, 312, 257, 45592, 9927, 50624], 'temperature': 0.0, 'avg_logprob': -0.08190172110030901, 'compression_ratio': 1.5901639344262295, 'no_speech_prob': 0.0008829534635879099}, {'id': 553, 'seek': 449748, 'start': 4502.679999999999, 'end': 4508.599999999999, 'text': ' which you have written. So, you want that to be marked static so that it will enable compiler to', 'tokens': [50624, 597, 291, 362, 3720, 13, 407, 11, 291, 528, 300, 281, 312, 12658, 13437, 370, 300, 309, 486, 9528, 31958, 281, 50920], 'temperature': 0.0, 'avg_logprob': -0.08190172110030901, 'compression_ratio': 1.5901639344262295, 'no_speech_prob': 0.0008829534635879099}, {'id': 554, 'seek': 449748, 'start': 4508.599999999999, 'end': 4519.799999999999, 'text': ' do more things. And obviously, separate compilation is a problem. So, separate compilation poses', 'tokens': [50920, 360, 544, 721, 13, 400, 2745, 11, 4994, 40261, 307, 257, 1154, 13, 407, 11, 4994, 40261, 26059, 51480], 'temperature': 0.0, 'avg_logprob': -0.08190172110030901, 'compression_ratio': 1.5901639344262295, 'no_speech_prob': 0.0008829534635879099}, {'id': 555, 'seek': 451980, 'start': 4519.8, 'end': 4527.4800000000005, 'text': ' problem. Function pointers create problems. So far we have seen calling conventions. Now,', 'tokens': [50364, 1154, 13, 11166, 882, 44548, 1884, 2740, 13, 407, 1400, 321, 362, 1612, 5141, 33520, 13, 823, 11, 50748], 'temperature': 0.0, 'avg_logprob': -0.19827734507047212, 'compression_ratio': 1.313868613138686, 'no_speech_prob': 0.04334981366991997}, {'id': 556, 'seek': 451980, 'start': 4527.4800000000005, 'end': 4539.08, 'text': ' x86-64, which is a 64-bit architecture, x86 had only 8 registers. x86-64 has 16 registers.', 'tokens': [50748, 2031, 22193, 12, 19395, 11, 597, 307, 257, 12145, 12, 5260, 9482, 11, 2031, 22193, 632, 787, 1649, 38351, 13, 2031, 22193, 12, 19395, 575, 3165, 38351, 13, 51328], 'temperature': 0.0, 'avg_logprob': -0.19827734507047212, 'compression_ratio': 1.313868613138686, 'no_speech_prob': 0.04334981366991997}, {'id': 557, 'seek': 453908, 'start': 4539.8, 'end': 4551.96, 'text': ' And the Linux ABI is something like this. First 6 parameters are passed by registers. For first 6', 'tokens': [50400, 400, 264, 18734, 316, 11291, 307, 746, 411, 341, 13, 2386, 1386, 9834, 366, 4678, 538, 38351, 13, 1171, 700, 1386, 51008], 'temperature': 0.0, 'avg_logprob': -0.1276504867955258, 'compression_ratio': 1.719298245614035, 'no_speech_prob': 0.013423736207187176}, {'id': 558, 'seek': 453908, 'start': 4551.96, 'end': 4557.72, 'text': ' parameters, you do not need to use stack. And they are passed in this order. First parameter will be', 'tokens': [51008, 9834, 11, 291, 360, 406, 643, 281, 764, 8630, 13, 400, 436, 366, 4678, 294, 341, 1668, 13, 2386, 13075, 486, 312, 51296], 'temperature': 0.0, 'avg_logprob': -0.1276504867955258, 'compression_ratio': 1.719298245614035, 'no_speech_prob': 0.013423736207187176}, {'id': 559, 'seek': 453908, 'start': 4557.72, 'end': 4567.5599999999995, 'text': ' in RDI register, second will be in RSI register, third will be RDX and so on. And frame pointer', 'tokens': [51296, 294, 497, 3085, 7280, 11, 1150, 486, 312, 294, 497, 20262, 7280, 11, 2636, 486, 312, 49488, 55, 293, 370, 322, 13, 400, 3920, 23918, 51788], 'temperature': 0.0, 'avg_logprob': -0.1276504867955258, 'compression_ratio': 1.719298245614035, 'no_speech_prob': 0.013423736207187176}, {'id': 560, 'seek': 456756, 'start': 4567.56, 'end': 4576.120000000001, 'text': ' is optional. There is no need for frame pointer. All the references will be relative to stack.', 'tokens': [50364, 307, 17312, 13, 821, 307, 572, 643, 337, 3920, 23918, 13, 1057, 264, 15400, 486, 312, 4972, 281, 8630, 13, 50792], 'temperature': 0.0, 'avg_logprob': -0.0943370470924983, 'compression_ratio': 1.6153846153846154, 'no_speech_prob': 0.0012444558087736368}, {'id': 561, 'seek': 456756, 'start': 4579.72, 'end': 4585.240000000001, 'text': ' Then how will debugger work? Remember we were using EBP for debugger.', 'tokens': [50972, 1396, 577, 486, 24083, 1321, 589, 30, 5459, 321, 645, 1228, 50148, 47, 337, 24083, 1321, 13, 51248], 'temperature': 0.0, 'avg_logprob': -0.0943370470924983, 'compression_ratio': 1.6153846153846154, 'no_speech_prob': 0.0012444558087736368}, {'id': 562, 'seek': 456756, 'start': 4587.400000000001, 'end': 4592.52, 'text': ' How will debugger work? How will debugger know where is the caller function stack free?', 'tokens': [51356, 1012, 486, 24083, 1321, 589, 30, 1012, 486, 24083, 1321, 458, 689, 307, 264, 48324, 2445, 8630, 1737, 30, 51612], 'temperature': 0.0, 'avg_logprob': -0.0943370470924983, 'compression_ratio': 1.6153846153846154, 'no_speech_prob': 0.0012444558087736368}, {'id': 563, 'seek': 459756, 'start': 4597.56, 'end': 4611.4800000000005, 'text': ' So, with hyphen g, he is saying you can still have RBP.', 'tokens': [50364, 407, 11, 365, 2477, 47059, 290, 11, 415, 307, 1566, 291, 393, 920, 362, 40302, 47, 13, 51060], 'temperature': 0.0, 'avg_logprob': -0.3560428846450079, 'compression_ratio': 0.873015873015873, 'no_speech_prob': 0.12218082696199417}, {'id': 564, 'seek': 461148, 'start': 4611.719999999999, 'end': 4627.719999999999, 'text': ' So, you simulate something. But you still waste space on stack and so on. So, compilers do', 'tokens': [50376, 407, 11, 291, 27817, 746, 13, 583, 291, 920, 5964, 1901, 322, 8630, 293, 370, 322, 13, 407, 11, 715, 388, 433, 360, 51176], 'temperature': 0.0, 'avg_logprob': -0.16738508145014444, 'compression_ratio': 1.3984962406015038, 'no_speech_prob': 0.027564281597733498}, {'id': 565, 'seek': 461148, 'start': 4627.719999999999, 'end': 4633.719999999999, 'text': ' something more interesting, which we will get to in the last phase of the session to solve this', 'tokens': [51176, 746, 544, 1880, 11, 597, 321, 486, 483, 281, 294, 264, 1036, 5574, 295, 264, 5481, 281, 5039, 341, 51476], 'temperature': 0.0, 'avg_logprob': -0.16738508145014444, 'compression_ratio': 1.3984962406015038, 'no_speech_prob': 0.027564281597733498}, {'id': 566, 'seek': 463372, 'start': 4633.72, 'end': 4642.12, 'text': ' problem. And then rax continues to be the return address register. So, x86-64 changes the ABI in', 'tokens': [50364, 1154, 13, 400, 550, 367, 2797, 6515, 281, 312, 264, 2736, 2985, 7280, 13, 407, 11, 2031, 22193, 12, 19395, 2962, 264, 316, 11291, 294, 50784], 'temperature': 0.0, 'avg_logprob': -0.09501934051513672, 'compression_ratio': 1.6075949367088607, 'no_speech_prob': 0.08027748763561249}, {'id': 567, 'seek': 463372, 'start': 4642.12, 'end': 4649.16, 'text': ' two particular ways. That one is frame pointer is now optional. Debuggers cannot rely on compiler', 'tokens': [50784, 732, 1729, 2098, 13, 663, 472, 307, 3920, 23918, 307, 586, 17312, 13, 27347, 3562, 433, 2644, 10687, 322, 31958, 51136], 'temperature': 0.0, 'avg_logprob': -0.09501934051513672, 'compression_ratio': 1.6075949367088607, 'no_speech_prob': 0.08027748763561249}, {'id': 568, 'seek': 463372, 'start': 4649.16, 'end': 4654.76, 'text': ' would have populated the frame pointer. And frame pointer becomes available as a general purpose', 'tokens': [51136, 576, 362, 32998, 264, 3920, 23918, 13, 400, 3920, 23918, 3643, 2435, 382, 257, 2674, 4334, 51416], 'temperature': 0.0, 'avg_logprob': -0.09501934051513672, 'compression_ratio': 1.6075949367088607, 'no_speech_prob': 0.08027748763561249}, {'id': 569, 'seek': 463372, 'start': 4654.76, 'end': 4663.400000000001, 'text': ' register for compiler to use. rax is same and it has first 6 parameters in the registers.', 'tokens': [51416, 7280, 337, 31958, 281, 764, 13, 367, 2797, 307, 912, 293, 309, 575, 700, 1386, 9834, 294, 264, 38351, 13, 51848], 'temperature': 0.0, 'avg_logprob': -0.09501934051513672, 'compression_ratio': 1.6075949367088607, 'no_speech_prob': 0.08027748763561249}, {'id': 570, 'seek': 466340, 'start': 4663.639999999999, 'end': 4669.96, 'text': ' It is an improvement. If you are compiling your program to x86-64 and if you are using limited', 'tokens': [50376, 467, 307, 364, 10444, 13, 759, 291, 366, 715, 4883, 428, 1461, 281, 2031, 22193, 12, 19395, 293, 498, 291, 366, 1228, 5567, 50692], 'temperature': 0.0, 'avg_logprob': -0.13624165647773331, 'compression_ratio': 1.7037037037037037, 'no_speech_prob': 0.0011512651108205318}, {'id': 571, 'seek': 466340, 'start': 4669.96, 'end': 4673.799999999999, 'text': ' parameters, most of them will get passed via register. You do not have to access stack.', 'tokens': [50692, 9834, 11, 881, 295, 552, 486, 483, 4678, 5766, 7280, 13, 509, 360, 406, 362, 281, 2105, 8630, 13, 50884], 'temperature': 0.0, 'avg_logprob': -0.13624165647773331, 'compression_ratio': 1.7037037037037037, 'no_speech_prob': 0.0011512651108205318}, {'id': 572, 'seek': 466340, 'start': 4675.879999999999, 'end': 4683.08, 'text': ' So, this is how the stack frame will look. You have parameters which are 7 plus in the stack.', 'tokens': [50988, 407, 11, 341, 307, 577, 264, 8630, 3920, 486, 574, 13, 509, 362, 9834, 597, 366, 1614, 1804, 294, 264, 8630, 13, 51348], 'temperature': 0.0, 'avg_logprob': -0.13624165647773331, 'compression_ratio': 1.7037037037037037, 'no_speech_prob': 0.0011512651108205318}, {'id': 573, 'seek': 466340, 'start': 4683.719999999999, 'end': 4688.759999999999, 'text': ' First parameters are in registers. So, they do not appear in stack frame. And frame pointer', 'tokens': [51380, 2386, 9834, 366, 294, 38351, 13, 407, 11, 436, 360, 406, 4204, 294, 8630, 3920, 13, 400, 3920, 23918, 51632], 'temperature': 0.0, 'avg_logprob': -0.13624165647773331, 'compression_ratio': 1.7037037037037037, 'no_speech_prob': 0.0011512651108205318}, {'id': 574, 'seek': 468876, 'start': 4688.76, 'end': 4697.56, 'text': ' itself is optional. Now, there is something called as a red zone here. This is an optimization for', 'tokens': [50364, 2564, 307, 17312, 13, 823, 11, 456, 307, 746, 1219, 382, 257, 2182, 6668, 510, 13, 639, 307, 364, 19618, 337, 50804], 'temperature': 0.0, 'avg_logprob': -0.1081986141204834, 'compression_ratio': 1.4, 'no_speech_prob': 0.008575787767767906}, {'id': 575, 'seek': 468876, 'start': 4697.56, 'end': 4709.8, 'text': ' leaf functions. So, what red zone allows, it is a region of 128 bytes, which the function can use', 'tokens': [50804, 10871, 6828, 13, 407, 11, 437, 2182, 6668, 4045, 11, 309, 307, 257, 4458, 295, 29810, 36088, 11, 597, 264, 2445, 393, 764, 51416], 'temperature': 0.0, 'avg_logprob': -0.1081986141204834, 'compression_ratio': 1.4, 'no_speech_prob': 0.008575787767767906}, {'id': 576, 'seek': 470980, 'start': 4710.4400000000005, 'end': 4721.8, 'text': ' without having to update the stack part. So, if I have to use some variables which fit within 128', 'tokens': [50396, 1553, 1419, 281, 5623, 264, 8630, 644, 13, 407, 11, 498, 286, 362, 281, 764, 512, 9102, 597, 3318, 1951, 29810, 50964], 'temperature': 0.0, 'avg_logprob': -0.10069380579768, 'compression_ratio': 1.6432748538011697, 'no_speech_prob': 0.017977461218833923}, {'id': 577, 'seek': 470980, 'start': 4721.8, 'end': 4728.68, 'text': ' bytes and need to be on stack for various reasons. We saw that if there was an array,', 'tokens': [50964, 36088, 293, 643, 281, 312, 322, 8630, 337, 3683, 4112, 13, 492, 1866, 300, 498, 456, 390, 364, 10225, 11, 51308], 'temperature': 0.0, 'avg_logprob': -0.10069380579768, 'compression_ratio': 1.6432748538011697, 'no_speech_prob': 0.017977461218833923}, {'id': 578, 'seek': 470980, 'start': 4729.320000000001, 'end': 4735.96, 'text': ' it has to be on stack. If there was in the address of something was taken, it had to be on stack.', 'tokens': [51340, 309, 575, 281, 312, 322, 8630, 13, 759, 456, 390, 294, 264, 2985, 295, 746, 390, 2726, 11, 309, 632, 281, 312, 322, 8630, 13, 51672], 'temperature': 0.0, 'avg_logprob': -0.10069380579768, 'compression_ratio': 1.6432748538011697, 'no_speech_prob': 0.017977461218833923}, {'id': 579, 'seek': 473596, 'start': 4735.96, 'end': 4743.0, 'text': ' So, if there is some local variables up to 128 bytes, I can actually put them on the stack', 'tokens': [50364, 407, 11, 498, 456, 307, 512, 2654, 9102, 493, 281, 29810, 36088, 11, 286, 393, 767, 829, 552, 322, 264, 8630, 50716], 'temperature': 0.0, 'avg_logprob': -0.11829624437306026, 'compression_ratio': 1.567251461988304, 'no_speech_prob': 0.0010002967901527882}, {'id': 580, 'seek': 473596, 'start': 4743.56, 'end': 4751.08, 'text': ' without having to update the stack pointer. Now, why do I want to do this? This seems a bit', 'tokens': [50744, 1553, 1419, 281, 5623, 264, 8630, 23918, 13, 823, 11, 983, 360, 286, 528, 281, 360, 341, 30, 639, 2544, 257, 857, 51120], 'temperature': 0.0, 'avg_logprob': -0.11829624437306026, 'compression_ratio': 1.567251461988304, 'no_speech_prob': 0.0010002967901527882}, {'id': 581, 'seek': 473596, 'start': 4751.08, 'end': 4757.32, 'text': ' bizarre. I want to use stack, but I do not want to use update the stack pointer. Why?', 'tokens': [51120, 18265, 13, 286, 528, 281, 764, 8630, 11, 457, 286, 360, 406, 528, 281, 764, 5623, 264, 8630, 23918, 13, 1545, 30, 51432], 'temperature': 0.0, 'avg_logprob': -0.11829624437306026, 'compression_ratio': 1.567251461988304, 'no_speech_prob': 0.0010002967901527882}, {'id': 582, 'seek': 475732, 'start': 4758.12, 'end': 4773.08, 'text': ' Why do I want to avoid stack pointer update? But that again compiler would do. If it updates,', 'tokens': [50404, 1545, 360, 286, 528, 281, 5042, 8630, 23918, 5623, 30, 583, 300, 797, 31958, 576, 360, 13, 759, 309, 9205, 11, 51152], 'temperature': 0.0, 'avg_logprob': -0.21152467930570562, 'compression_ratio': 1.335820895522388, 'no_speech_prob': 0.0007792586693540215}, {'id': 583, 'seek': 475732, 'start': 4773.08, 'end': 4782.679999999999, 'text': ' it has to adjust the offset. So, one thing is remember stack pointer is callee saved.', 'tokens': [51152, 309, 575, 281, 4369, 264, 18687, 13, 407, 11, 472, 551, 307, 1604, 8630, 23918, 307, 818, 1653, 6624, 13, 51632], 'temperature': 0.0, 'avg_logprob': -0.21152467930570562, 'compression_ratio': 1.335820895522388, 'no_speech_prob': 0.0007792586693540215}, {'id': 584, 'seek': 478268, 'start': 4783.0, 'end': 4790.84, 'text': ' So, if callee updates the stack pointer in any way, it has to restore it. That means it has to', 'tokens': [50380, 407, 11, 498, 818, 1653, 9205, 264, 8630, 23918, 294, 604, 636, 11, 309, 575, 281, 15227, 309, 13, 663, 1355, 309, 575, 281, 50772], 'temperature': 0.0, 'avg_logprob': -0.12747061880011307, 'compression_ratio': 1.8164556962025316, 'no_speech_prob': 0.0006262798560783267}, {'id': 585, 'seek': 478268, 'start': 4790.84, 'end': 4801.320000000001, 'text': ' save it and it has to restore it. So, it has to do at least two instructions. To avoid those two', 'tokens': [50772, 3155, 309, 293, 309, 575, 281, 15227, 309, 13, 407, 11, 309, 575, 281, 360, 412, 1935, 732, 9415, 13, 1407, 5042, 729, 732, 51296], 'temperature': 0.0, 'avg_logprob': -0.12747061880011307, 'compression_ratio': 1.8164556962025316, 'no_speech_prob': 0.0006262798560783267}, {'id': 586, 'seek': 478268, 'start': 4801.320000000001, 'end': 4809.16, 'text': ' instructions, this exists. So, I want to use stack without having to save and restore the stack', 'tokens': [51296, 9415, 11, 341, 8198, 13, 407, 11, 286, 528, 281, 764, 8630, 1553, 1419, 281, 3155, 293, 15227, 264, 8630, 51688], 'temperature': 0.0, 'avg_logprob': -0.12747061880011307, 'compression_ratio': 1.8164556962025316, 'no_speech_prob': 0.0006262798560783267}, {'id': 587, 'seek': 480916, 'start': 4809.16, 'end': 4817.16, 'text': ' pointer. This I can do for leaf functions because leaf functions are not going to call any other', 'tokens': [50364, 23918, 13, 639, 286, 393, 360, 337, 10871, 6828, 570, 10871, 6828, 366, 406, 516, 281, 818, 604, 661, 50764], 'temperature': 0.0, 'avg_logprob': -0.0823663870493571, 'compression_ratio': 1.6222222222222222, 'no_speech_prob': 0.0015975486021488905}, {'id': 588, 'seek': 480916, 'start': 4817.16, 'end': 4825.639999999999, 'text': ' function. So, I know the stack frame is not going to grow. So, if I simply access the variables which', 'tokens': [50764, 2445, 13, 407, 11, 286, 458, 264, 8630, 3920, 307, 406, 516, 281, 1852, 13, 407, 11, 498, 286, 2935, 2105, 264, 9102, 597, 51188], 'temperature': 0.0, 'avg_logprob': -0.0823663870493571, 'compression_ratio': 1.6222222222222222, 'no_speech_prob': 0.0015975486021488905}, {'id': 589, 'seek': 480916, 'start': 4825.639999999999, 'end': 4833.32, 'text': ' live beyond the stack, then I am safe to use that because they will not be overwritten by the', 'tokens': [51188, 1621, 4399, 264, 8630, 11, 550, 286, 669, 3273, 281, 764, 300, 570, 436, 486, 406, 312, 670, 26859, 538, 264, 51572], 'temperature': 0.0, 'avg_logprob': -0.0823663870493571, 'compression_ratio': 1.6222222222222222, 'no_speech_prob': 0.0015975486021488905}, {'id': 590, 'seek': 483332, 'start': 4833.32, 'end': 4843.4, 'text': ' subsequent calls. Does that make sense? So, it is an optimization to having to avoid save and restore.', 'tokens': [50364, 19962, 5498, 13, 4402, 300, 652, 2020, 30, 407, 11, 309, 307, 364, 19618, 281, 1419, 281, 5042, 3155, 293, 15227, 13, 50868], 'temperature': 0.0, 'avg_logprob': -0.1308778037487621, 'compression_ratio': 1.5572916666666667, 'no_speech_prob': 0.008058471605181694}, {'id': 591, 'seek': 483332, 'start': 4847.24, 'end': 4853.24, 'text': ' And leaf functions can use it. So, leaf functions can get away without having to do anything in the', 'tokens': [51060, 400, 10871, 6828, 393, 764, 309, 13, 407, 11, 10871, 6828, 393, 483, 1314, 1553, 1419, 281, 360, 1340, 294, 264, 51360], 'temperature': 0.0, 'avg_logprob': -0.1308778037487621, 'compression_ratio': 1.5572916666666667, 'no_speech_prob': 0.008058471605181694}, {'id': 592, 'seek': 483332, 'start': 4853.24, 'end': 4860.28, 'text': ' stack. If they use caller saved registers, which was their preference, and they can use red zone', 'tokens': [51360, 8630, 13, 759, 436, 764, 48324, 6624, 38351, 11, 597, 390, 641, 17502, 11, 293, 436, 393, 764, 2182, 6668, 51712], 'temperature': 0.0, 'avg_logprob': -0.1308778037487621, 'compression_ratio': 1.5572916666666667, 'no_speech_prob': 0.008058471605181694}, {'id': 593, 'seek': 486028, 'start': 4860.28, 'end': 4872.759999999999, 'text': ' to save some simple variables. Any questions so far? So, so far what we have seen is we have seen', 'tokens': [50364, 281, 3155, 512, 2199, 9102, 13, 2639, 1651, 370, 1400, 30, 407, 11, 370, 1400, 437, 321, 362, 1612, 307, 321, 362, 1612, 50988], 'temperature': 0.0, 'avg_logprob': -0.0897264964338662, 'compression_ratio': 1.6368715083798884, 'no_speech_prob': 0.0031706737354397774}, {'id': 594, 'seek': 486028, 'start': 4872.759999999999, 'end': 4880.12, 'text': ' how functions call actually work. We started off with how to transfer the controls. We then looked', 'tokens': [50988, 577, 6828, 818, 767, 589, 13, 492, 1409, 766, 365, 577, 281, 5003, 264, 9003, 13, 492, 550, 2956, 51356], 'temperature': 0.0, 'avg_logprob': -0.0897264964338662, 'compression_ratio': 1.6368715083798884, 'no_speech_prob': 0.0031706737354397774}, {'id': 595, 'seek': 486028, 'start': 4880.12, 'end': 4885.48, 'text': ' at how parameters are passed. We looked at how return address is populated. We looked at calling', 'tokens': [51356, 412, 577, 9834, 366, 4678, 13, 492, 2956, 412, 577, 2736, 2985, 307, 32998, 13, 492, 2956, 412, 5141, 51624], 'temperature': 0.0, 'avg_logprob': -0.0897264964338662, 'compression_ratio': 1.6368715083798884, 'no_speech_prob': 0.0031706737354397774}, {'id': 596, 'seek': 488548, 'start': 4885.48, 'end': 4891.48, 'text': ' conventions and register saving and other things related to them. So, that kind of completes whatever', 'tokens': [50364, 33520, 293, 7280, 6816, 293, 661, 721, 4077, 281, 552, 13, 407, 11, 300, 733, 295, 36362, 2035, 50664], 'temperature': 0.0, 'avg_logprob': -0.15116091432242557, 'compression_ratio': 1.2666666666666666, 'no_speech_prob': 0.0899653434753418}, {'id': 597, 'seek': 488548, 'start': 4891.48, 'end': 4894.919999999999, 'text': ' happens for the function calls.', 'tokens': [50664, 2314, 337, 264, 2445, 5498, 13, 50836], 'temperature': 0.0, 'avg_logprob': -0.15116091432242557, 'compression_ratio': 1.2666666666666666, 'no_speech_prob': 0.0899653434753418}]