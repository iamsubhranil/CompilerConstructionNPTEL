[{'id': 0, 'seek': 0, 'start': 0.0, 'end': 13.56, 'text': ' So, what we saw is about the data hazard, we will see how data hazards need to be handled.', 'tokens': [50364, 407, 11, 437, 321, 1866, 307, 466, 264, 1412, 20790, 11, 321, 486, 536, 577, 1412, 34516, 643, 281, 312, 18033, 13, 51042], 'temperature': 0.0, 'avg_logprob': -0.22043828964233397, 'compression_ratio': 1.5857988165680474, 'no_speech_prob': 0.11146730184555054}, {'id': 1, 'seek': 0, 'start': 13.56, 'end': 19.16, 'text': ' As I mentioned earlier whenever you have a true dependency or what is called a read after', 'tokens': [51042, 1018, 286, 2835, 3071, 5699, 291, 362, 257, 2074, 33621, 420, 437, 307, 1219, 257, 1401, 934, 51322], 'temperature': 0.0, 'avg_logprob': -0.22043828964233397, 'compression_ratio': 1.5857988165680474, 'no_speech_prob': 0.11146730184555054}, {'id': 2, 'seek': 0, 'start': 19.16, 'end': 25.64, 'text': ' write dependency, the subsequent instruction has to wait until the previous instruction', 'tokens': [51322, 2464, 33621, 11, 264, 19962, 10951, 575, 281, 1699, 1826, 264, 3894, 10951, 51646], 'temperature': 0.0, 'avg_logprob': -0.22043828964233397, 'compression_ratio': 1.5857988165680474, 'no_speech_prob': 0.11146730184555054}, {'id': 3, 'seek': 2564, 'start': 25.64, 'end': 31.560000000000002, 'text': ' writes a result back in the register. Let us look at a situation in which my ith instruction', 'tokens': [50364, 13657, 257, 1874, 646, 294, 264, 7280, 13, 961, 505, 574, 412, 257, 2590, 294, 597, 452, 309, 71, 10951, 50660], 'temperature': 0.0, 'avg_logprob': -0.21589446736273366, 'compression_ratio': 1.9137931034482758, 'no_speech_prob': 0.7613787651062012}, {'id': 4, 'seek': 2564, 'start': 31.560000000000002, 'end': 38.28, 'text': ' produces a value, but the i plus oneth and i plus second instruction do not need this,', 'tokens': [50660, 14725, 257, 2158, 11, 457, 264, 741, 1804, 322, 3293, 293, 741, 1804, 1150, 10951, 360, 406, 643, 341, 11, 50996], 'temperature': 0.0, 'avg_logprob': -0.21589446736273366, 'compression_ratio': 1.9137931034482758, 'no_speech_prob': 0.7613787651062012}, {'id': 5, 'seek': 2564, 'start': 38.28, 'end': 42.760000000000005, 'text': ' but let us say the i plus fourth or the i plus fifth instruction need that value. Then', 'tokens': [50996, 457, 718, 505, 584, 264, 741, 1804, 6409, 420, 264, 741, 1804, 9266, 10951, 643, 300, 2158, 13, 1396, 51220], 'temperature': 0.0, 'avg_logprob': -0.21589446736273366, 'compression_ratio': 1.9137931034482758, 'no_speech_prob': 0.7613787651062012}, {'id': 6, 'seek': 2564, 'start': 42.760000000000005, 'end': 47.36, 'text': ' what happens in that situation? So, let us not worry about the immediate second or third', 'tokens': [51220, 437, 2314, 294, 300, 2590, 30, 407, 11, 718, 505, 406, 3292, 466, 264, 11629, 1150, 420, 2636, 51450], 'temperature': 0.0, 'avg_logprob': -0.21589446736273366, 'compression_ratio': 1.9137931034482758, 'no_speech_prob': 0.7613787651062012}, {'id': 7, 'seek': 2564, 'start': 47.36, 'end': 53.24, 'text': ' instructions, but let us say that dependency is a little further away, may be the fourth', 'tokens': [51450, 9415, 11, 457, 718, 505, 584, 300, 33621, 307, 257, 707, 3052, 1314, 11, 815, 312, 264, 6409, 51744], 'temperature': 0.0, 'avg_logprob': -0.21589446736273366, 'compression_ratio': 1.9137931034482758, 'no_speech_prob': 0.7613787651062012}, {'id': 8, 'seek': 5324, 'start': 53.24, 'end': 58.36, 'text': ' or fifth instruction. In this case there is no problem, right. There is a dependency,', 'tokens': [50364, 420, 9266, 10951, 13, 682, 341, 1389, 456, 307, 572, 1154, 11, 558, 13, 821, 307, 257, 33621, 11, 50620], 'temperature': 0.0, 'avg_logprob': -0.25600585552177046, 'compression_ratio': 1.909871244635193, 'no_speech_prob': 0.07836057245731354}, {'id': 9, 'seek': 5324, 'start': 58.36, 'end': 63.2, 'text': ' but there may not be a stall because by that time that instruction goes into the so called', 'tokens': [50620, 457, 456, 815, 406, 312, 257, 19633, 570, 538, 300, 565, 300, 10951, 1709, 666, 264, 370, 1219, 50862], 'temperature': 0.0, 'avg_logprob': -0.25600585552177046, 'compression_ratio': 1.909871244635193, 'no_speech_prob': 0.07836057245731354}, {'id': 10, 'seek': 5324, 'start': 63.2, 'end': 68.32000000000001, 'text': ' instruction fetch phase, this instruction would have completed its execution, correct.', 'tokens': [50862, 10951, 23673, 5574, 11, 341, 10951, 576, 362, 7365, 1080, 15058, 11, 3006, 13, 51118], 'temperature': 0.0, 'avg_logprob': -0.25600585552177046, 'compression_ratio': 1.909871244635193, 'no_speech_prob': 0.07836057245731354}, {'id': 11, 'seek': 5324, 'start': 68.32000000000001, 'end': 74.12, 'text': ' So, the problem happens only if the dependent instructions are within one or two instructions', 'tokens': [51118, 407, 11, 264, 1154, 2314, 787, 498, 264, 12334, 9415, 366, 1951, 472, 420, 732, 9415, 51408], 'temperature': 0.0, 'avg_logprob': -0.25600585552177046, 'compression_ratio': 1.909871244635193, 'no_speech_prob': 0.07836057245731354}, {'id': 12, 'seek': 5324, 'start': 74.12, 'end': 78.88, 'text': ' away. If you are assuming two stall cycles, then it is one or two instructions away. If', 'tokens': [51408, 1314, 13, 759, 291, 366, 11926, 732, 19633, 17796, 11, 550, 309, 307, 472, 420, 732, 9415, 1314, 13, 759, 51646], 'temperature': 0.0, 'avg_logprob': -0.25600585552177046, 'compression_ratio': 1.909871244635193, 'no_speech_prob': 0.07836057245731354}, {'id': 13, 'seek': 7888, 'start': 79.56, 'end': 83.88, 'text': ' assuming one stall cycle, then it is only one instruction. There are some hardware solutions', 'tokens': [50398, 11926, 472, 19633, 6586, 11, 550, 309, 307, 787, 472, 10951, 13, 821, 366, 512, 8837, 6547, 50614], 'temperature': 0.0, 'avg_logprob': -0.16595110846954642, 'compression_ratio': 1.9475982532751093, 'no_speech_prob': 0.0519210547208786}, {'id': 14, 'seek': 7888, 'start': 83.88, 'end': 89.47999999999999, 'text': ' for data hazards and that can actually reduce the data hazards stalls to one cycle in most', 'tokens': [50614, 337, 1412, 34516, 293, 300, 393, 767, 5407, 264, 1412, 34516, 50248, 281, 472, 6586, 294, 881, 50894], 'temperature': 0.0, 'avg_logprob': -0.16595110846954642, 'compression_ratio': 1.9475982532751093, 'no_speech_prob': 0.0519210547208786}, {'id': 15, 'seek': 7888, 'start': 89.47999999999999, 'end': 94.44, 'text': ' of the cases, okay. But we are not going to focus on the hardware solution, we are going', 'tokens': [50894, 295, 264, 3331, 11, 1392, 13, 583, 321, 366, 406, 516, 281, 1879, 322, 264, 8837, 3827, 11, 321, 366, 516, 51142], 'temperature': 0.0, 'avg_logprob': -0.16595110846954642, 'compression_ratio': 1.9475982532751093, 'no_speech_prob': 0.0519210547208786}, {'id': 16, 'seek': 7888, 'start': 94.44, 'end': 100.8, 'text': ' to focus more on the software solution and let us see what can be done in software to', 'tokens': [51142, 281, 1879, 544, 322, 264, 4722, 3827, 293, 718, 505, 536, 437, 393, 312, 1096, 294, 4722, 281, 51460], 'temperature': 0.0, 'avg_logprob': -0.16595110846954642, 'compression_ratio': 1.9475982532751093, 'no_speech_prob': 0.0519210547208786}, {'id': 17, 'seek': 7888, 'start': 100.8, 'end': 105.6, 'text': ' take care of this. Instruction scheduling is a technique which can be used to take care', 'tokens': [51460, 747, 1127, 295, 341, 13, 2730, 3826, 29055, 307, 257, 6532, 597, 393, 312, 1143, 281, 747, 1127, 51700], 'temperature': 0.0, 'avg_logprob': -0.16595110846954642, 'compression_ratio': 1.9475982532751093, 'no_speech_prob': 0.0519210547208786}, {'id': 18, 'seek': 10560, 'start': 105.6, 'end': 112.08, 'text': ' of this problem. As I mentioned earlier, only if the dependent instructions are close', 'tokens': [50364, 295, 341, 1154, 13, 1018, 286, 2835, 3071, 11, 787, 498, 264, 12334, 9415, 366, 1998, 50688], 'temperature': 0.0, 'avg_logprob': -0.21126964569091797, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.03015025332570076}, {'id': 19, 'seek': 10560, 'start': 112.08, 'end': 117.75999999999999, 'text': ' to each other, that is one or two instructions within each other, then the stalls matter.', 'tokens': [50688, 281, 1184, 661, 11, 300, 307, 472, 420, 732, 9415, 1951, 1184, 661, 11, 550, 264, 50248, 1871, 13, 50972], 'temperature': 0.0, 'avg_logprob': -0.21126964569091797, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.03015025332570076}, {'id': 20, 'seek': 10560, 'start': 117.75999999999999, 'end': 122.19999999999999, 'text': ' Otherwise the dependencies would have been any way been satisfied and you do not incur', 'tokens': [50972, 10328, 264, 36606, 576, 362, 668, 604, 636, 668, 11239, 293, 291, 360, 406, 35774, 51194], 'temperature': 0.0, 'avg_logprob': -0.21126964569091797, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.03015025332570076}, {'id': 21, 'seek': 10560, 'start': 122.19999999999999, 'end': 128.07999999999998, 'text': ' a stall. So, the question is, is it possible for me to reorder my instructions so that', 'tokens': [51194, 257, 19633, 13, 407, 11, 264, 1168, 307, 11, 307, 309, 1944, 337, 385, 281, 319, 4687, 452, 9415, 370, 300, 51488], 'temperature': 0.0, 'avg_logprob': -0.21126964569091797, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.03015025332570076}, {'id': 22, 'seek': 10560, 'start': 128.07999999999998, 'end': 133.84, 'text': ' dependent instructions are a little further apart. That is the question, okay. Let us', 'tokens': [51488, 12334, 9415, 366, 257, 707, 3052, 4936, 13, 663, 307, 264, 1168, 11, 1392, 13, 961, 505, 51776], 'temperature': 0.0, 'avg_logprob': -0.21126964569091797, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.03015025332570076}, {'id': 23, 'seek': 13384, 'start': 133.84, 'end': 139.64000000000001, 'text': ' make the question little bit more specific. If I assume, right, the dependent instructions', 'tokens': [50364, 652, 264, 1168, 707, 857, 544, 2685, 13, 759, 286, 6552, 11, 558, 11, 264, 12334, 9415, 50654], 'temperature': 0.0, 'avg_logprob': -0.1878194442162147, 'compression_ratio': 1.7414634146341463, 'no_speech_prob': 0.020668942481279373}, {'id': 24, 'seek': 13384, 'start': 139.64000000000001, 'end': 146.36, 'text': ' cannot happen within one cycle. That means that between i and i plus one cycle alone', 'tokens': [50654, 2644, 1051, 1951, 472, 6586, 13, 663, 1355, 300, 1296, 741, 293, 741, 1804, 472, 6586, 3312, 50990], 'temperature': 0.0, 'avg_logprob': -0.1878194442162147, 'compression_ratio': 1.7414634146341463, 'no_speech_prob': 0.020668942481279373}, {'id': 25, 'seek': 13384, 'start': 146.36, 'end': 151.52, 'text': ' I need to worry about. Or more specifically for certain types of instructions like load', 'tokens': [50990, 286, 643, 281, 3292, 466, 13, 1610, 544, 4682, 337, 1629, 3467, 295, 9415, 411, 3677, 51248], 'temperature': 0.0, 'avg_logprob': -0.1878194442162147, 'compression_ratio': 1.7414634146341463, 'no_speech_prob': 0.020668942481279373}, {'id': 26, 'seek': 13384, 'start': 151.52, 'end': 157.68, 'text': ' instruction, right. I say if the load instruction loads some value, then the next instruction', 'tokens': [51248, 10951, 11, 558, 13, 286, 584, 498, 264, 3677, 10951, 12668, 512, 2158, 11, 550, 264, 958, 10951, 51556], 'temperature': 0.0, 'avg_logprob': -0.1878194442162147, 'compression_ratio': 1.7414634146341463, 'no_speech_prob': 0.020668942481279373}, {'id': 27, 'seek': 15768, 'start': 158.68, 'end': 164.92000000000002, 'text': ' on that. But let us say the i plus second onwards can be dependent on that, right. Supposing', 'tokens': [50414, 322, 300, 13, 583, 718, 505, 584, 264, 741, 1804, 1150, 34230, 393, 312, 12334, 322, 300, 11, 558, 13, 9391, 6110, 50726], 'temperature': 0.0, 'avg_logprob': -0.2476736294325962, 'compression_ratio': 1.6077586206896552, 'no_speech_prob': 0.4166727364063263}, {'id': 28, 'seek': 15768, 'start': 164.92000000000002, 'end': 171.36, 'text': ' if that is what we want to look at as a problem, then can compiler help us? That is the question,', 'tokens': [50726, 498, 300, 307, 437, 321, 528, 281, 574, 412, 382, 257, 1154, 11, 550, 393, 31958, 854, 505, 30, 663, 307, 264, 1168, 11, 51048], 'temperature': 0.0, 'avg_logprob': -0.2476736294325962, 'compression_ratio': 1.6077586206896552, 'no_speech_prob': 0.4166727364063263}, {'id': 29, 'seek': 15768, 'start': 171.36, 'end': 176.24, 'text': ' right. So, instruction scheduling is a technique. We are going to see more about this in the', 'tokens': [51048, 558, 13, 407, 11, 10951, 29055, 307, 257, 6532, 13, 492, 366, 516, 281, 536, 544, 466, 341, 294, 264, 51292], 'temperature': 0.0, 'avg_logprob': -0.2476736294325962, 'compression_ratio': 1.6077586206896552, 'no_speech_prob': 0.4166727364063263}, {'id': 30, 'seek': 15768, 'start': 176.24, 'end': 183.32, 'text': ' next lecture, okay, in the probably on probably tomorrow afternoon or on Friday, Thursday', 'tokens': [51292, 958, 7991, 11, 1392, 11, 294, 264, 1391, 322, 1391, 4153, 6499, 420, 322, 6984, 11, 10383, 51646], 'temperature': 0.0, 'avg_logprob': -0.2476736294325962, 'compression_ratio': 1.6077586206896552, 'no_speech_prob': 0.4166727364063263}, {'id': 31, 'seek': 18332, 'start': 183.32, 'end': 188.95999999999998, 'text': ' afternoon or Friday. We will see more about that, right. Essentially that tries to place', 'tokens': [50364, 6499, 420, 6984, 13, 492, 486, 536, 544, 466, 300, 11, 558, 13, 23596, 300, 9898, 281, 1081, 50646], 'temperature': 0.0, 'avg_logprob': -0.19846453565232297, 'compression_ratio': 1.7489539748953975, 'no_speech_prob': 0.006068230140954256}, {'id': 32, 'seek': 18332, 'start': 188.95999999999998, 'end': 193.6, 'text': ' instructions so that dependent instructions are kept a little further apart from each', 'tokens': [50646, 9415, 370, 300, 12334, 9415, 366, 4305, 257, 707, 3052, 4936, 490, 1184, 50878], 'temperature': 0.0, 'avg_logprob': -0.19846453565232297, 'compression_ratio': 1.7489539748953975, 'no_speech_prob': 0.006068230140954256}, {'id': 33, 'seek': 18332, 'start': 193.6, 'end': 198.95999999999998, 'text': ' other. But when you do this you have to ensure that all the dependences are satisfied, right.', 'tokens': [50878, 661, 13, 583, 562, 291, 360, 341, 291, 362, 281, 5586, 300, 439, 264, 5672, 2667, 366, 11239, 11, 558, 13, 51146], 'temperature': 0.0, 'avg_logprob': -0.19846453565232297, 'compression_ratio': 1.7489539748953975, 'no_speech_prob': 0.006068230140954256}, {'id': 34, 'seek': 18332, 'start': 198.95999999999998, 'end': 202.32, 'text': ' The true dependences are satisfied and so on, okay.', 'tokens': [51146, 440, 2074, 5672, 2667, 366, 11239, 293, 370, 322, 11, 1392, 13, 51314], 'temperature': 0.0, 'avg_logprob': -0.19846453565232297, 'compression_ratio': 1.7489539748953975, 'no_speech_prob': 0.006068230140954256}, {'id': 35, 'seek': 18332, 'start': 202.32, 'end': 208.0, 'text': ' Now if you look at this technique is essentially what we call as a compile time technique because', 'tokens': [51314, 823, 498, 291, 574, 412, 341, 6532, 307, 4476, 437, 321, 818, 382, 257, 31413, 565, 6532, 570, 51598], 'temperature': 0.0, 'avg_logprob': -0.19846453565232297, 'compression_ratio': 1.7489539748953975, 'no_speech_prob': 0.006068230140954256}, {'id': 36, 'seek': 20800, 'start': 208.0, 'end': 213.4, 'text': ' the compiler reorders these instructions, right. And then make sure that the dependent', 'tokens': [50364, 264, 31958, 319, 10400, 613, 9415, 11, 558, 13, 400, 550, 652, 988, 300, 264, 12334, 50634], 'temperature': 0.0, 'avg_logprob': -0.16817989545999115, 'compression_ratio': 1.748, 'no_speech_prob': 0.08844226598739624}, {'id': 37, 'seek': 20800, 'start': 213.4, 'end': 217.96, 'text': ' instructions are kept further away from each other. There is also a run time solution to', 'tokens': [50634, 9415, 366, 4305, 3052, 1314, 490, 1184, 661, 13, 821, 307, 611, 257, 1190, 565, 3827, 281, 50862], 'temperature': 0.0, 'avg_logprob': -0.16817989545999115, 'compression_ratio': 1.748, 'no_speech_prob': 0.08844226598739624}, {'id': 38, 'seek': 20800, 'start': 217.96, 'end': 223.32, 'text': ' this problem where the hardware does this reordering of instructions in terms of not', 'tokens': [50862, 341, 1154, 689, 264, 8837, 775, 341, 319, 765, 1794, 295, 9415, 294, 2115, 295, 406, 51130], 'temperature': 0.0, 'avg_logprob': -0.16817989545999115, 'compression_ratio': 1.748, 'no_speech_prob': 0.08844226598739624}, {'id': 39, 'seek': 20800, 'start': 223.32, 'end': 228.4, 'text': ' necessarily moving them out, but in terms of the order in which they are being executed,', 'tokens': [51130, 4725, 2684, 552, 484, 11, 457, 294, 2115, 295, 264, 1668, 294, 597, 436, 366, 885, 17577, 11, 51384], 'temperature': 0.0, 'avg_logprob': -0.16817989545999115, 'compression_ratio': 1.748, 'no_speech_prob': 0.08844226598739624}, {'id': 40, 'seek': 20800, 'start': 228.4, 'end': 233.12, 'text': ' issued and executed. We will not again go into the details of this because we are again', 'tokens': [51384, 14379, 293, 17577, 13, 492, 486, 406, 797, 352, 666, 264, 4365, 295, 341, 570, 321, 366, 797, 51620], 'temperature': 0.0, 'avg_logprob': -0.16817989545999115, 'compression_ratio': 1.748, 'no_speech_prob': 0.08844226598739624}, {'id': 41, 'seek': 23312, 'start': 233.12, 'end': 238.64000000000001, 'text': ' focusing on the compiler related topics here, okay.', 'tokens': [50364, 8416, 322, 264, 31958, 4077, 8378, 510, 11, 1392, 13, 50640], 'temperature': 0.0, 'avg_logprob': -0.15696037058927576, 'compression_ratio': 1.7125, 'no_speech_prob': 0.0715690404176712}, {'id': 42, 'seek': 23312, 'start': 238.64000000000001, 'end': 244.04, 'text': ' So as I mentioned earlier we are going to talk about a specific form of a delay called', 'tokens': [50640, 407, 382, 286, 2835, 3071, 321, 366, 516, 281, 751, 466, 257, 2685, 1254, 295, 257, 8577, 1219, 50910], 'temperature': 0.0, 'avg_logprob': -0.15696037058927576, 'compression_ratio': 1.7125, 'no_speech_prob': 0.0715690404176712}, {'id': 43, 'seek': 23312, 'start': 244.04, 'end': 249.64000000000001, 'text': ' load delay slot. In that what we essentially mean is that if the i-th instruction is a', 'tokens': [50910, 3677, 8577, 14747, 13, 682, 300, 437, 321, 4476, 914, 307, 300, 498, 264, 741, 12, 392, 10951, 307, 257, 51190], 'temperature': 0.0, 'avg_logprob': -0.15696037058927576, 'compression_ratio': 1.7125, 'no_speech_prob': 0.0715690404176712}, {'id': 44, 'seek': 23312, 'start': 249.64000000000001, 'end': 256.24, 'text': ' load instruction then the i plus 1-th instruction cannot be dependent on that. That is the only', 'tokens': [51190, 3677, 10951, 550, 264, 741, 1804, 502, 12, 392, 10951, 2644, 312, 12334, 322, 300, 13, 663, 307, 264, 787, 51520], 'temperature': 0.0, 'avg_logprob': -0.15696037058927576, 'compression_ratio': 1.7125, 'no_speech_prob': 0.0715690404176712}, {'id': 45, 'seek': 23312, 'start': 256.24, 'end': 260.76, 'text': ' problem that we are trying to solve. In all other cases we will say the hardware solution', 'tokens': [51520, 1154, 300, 321, 366, 1382, 281, 5039, 13, 682, 439, 661, 3331, 321, 486, 584, 264, 8837, 3827, 51746], 'temperature': 0.0, 'avg_logprob': -0.15696037058927576, 'compression_ratio': 1.7125, 'no_speech_prob': 0.0715690404176712}, {'id': 46, 'seek': 26076, 'start': 260.76, 'end': 267.76, 'text': ' will take care of things, right. Only in the case of this load delay, right, the software', 'tokens': [50364, 486, 747, 1127, 295, 721, 11, 558, 13, 5686, 294, 264, 1389, 295, 341, 3677, 8577, 11, 558, 11, 264, 4722, 50714], 'temperature': 0.0, 'avg_logprob': -0.14609198136763138, 'compression_ratio': 1.6150234741784038, 'no_speech_prob': 0.22911356389522552}, {'id': 47, 'seek': 26076, 'start': 267.76, 'end': 274.76, 'text': ' or the compiler has to help, right. Let us look at that particular problem, okay.', 'tokens': [50714, 420, 264, 31958, 575, 281, 854, 11, 558, 13, 961, 505, 574, 412, 300, 1729, 1154, 11, 1392, 13, 51064], 'temperature': 0.0, 'avg_logprob': -0.14609198136763138, 'compression_ratio': 1.6150234741784038, 'no_speech_prob': 0.22911356389522552}, {'id': 48, 'seek': 26076, 'start': 274.76, 'end': 280.52, 'text': ' So here is what I mean by this. Here is an example. So you have a load instruction and', 'tokens': [51064, 407, 510, 307, 437, 286, 914, 538, 341, 13, 1692, 307, 364, 1365, 13, 407, 291, 362, 257, 3677, 10951, 293, 51352], 'temperature': 0.0, 'avg_logprob': -0.14609198136763138, 'compression_ratio': 1.6150234741784038, 'no_speech_prob': 0.22911356389522552}, {'id': 49, 'seek': 26076, 'start': 280.52, 'end': 285.84, 'text': ' that load instruction produces a value in R3 register which has to be consumed by the', 'tokens': [51352, 300, 3677, 10951, 14725, 257, 2158, 294, 497, 18, 7280, 597, 575, 281, 312, 21226, 538, 264, 51618], 'temperature': 0.0, 'avg_logprob': -0.14609198136763138, 'compression_ratio': 1.6150234741784038, 'no_speech_prob': 0.22911356389522552}, {'id': 50, 'seek': 28584, 'start': 285.91999999999996, 'end': 291.79999999999995, 'text': ' subsequent add instruction, right. Similarly and then there is one more add instruction', 'tokens': [50368, 19962, 909, 10951, 11, 558, 13, 13157, 293, 550, 456, 307, 472, 544, 909, 10951, 50662], 'temperature': 0.0, 'avg_logprob': -0.14469259663632042, 'compression_ratio': 1.901098901098901, 'no_speech_prob': 0.055113304406404495}, {'id': 51, 'seek': 28584, 'start': 291.79999999999995, 'end': 297.71999999999997, 'text': ' which is also dependent on R3. Then another load instruction and again that load instruction', 'tokens': [50662, 597, 307, 611, 12334, 322, 497, 18, 13, 1396, 1071, 3677, 10951, 293, 797, 300, 3677, 10951, 50958], 'temperature': 0.0, 'avg_logprob': -0.14469259663632042, 'compression_ratio': 1.901098901098901, 'no_speech_prob': 0.055113304406404495}, {'id': 52, 'seek': 28584, 'start': 297.71999999999997, 'end': 304.71999999999997, 'text': ' produces a value in R13 which is being consumed by this instruction, right.', 'tokens': [50958, 14725, 257, 2158, 294, 497, 7668, 597, 307, 885, 21226, 538, 341, 10951, 11, 558, 13, 51308], 'temperature': 0.0, 'avg_logprob': -0.14469259663632042, 'compression_ratio': 1.901098901098901, 'no_speech_prob': 0.055113304406404495}, {'id': 53, 'seek': 28584, 'start': 304.71999999999997, 'end': 309.2, 'text': ' And by what we have described earlier if there is a load instruction and then there is an', 'tokens': [51308, 400, 538, 437, 321, 362, 7619, 3071, 498, 456, 307, 257, 3677, 10951, 293, 550, 456, 307, 364, 51532], 'temperature': 0.0, 'avg_logprob': -0.14469259663632042, 'compression_ratio': 1.901098901098901, 'no_speech_prob': 0.055113304406404495}, {'id': 54, 'seek': 30920, 'start': 309.24, 'end': 315.56, 'text': ' immediate dependent instruction there will be one stall cycle between them, correct.', 'tokens': [50366, 11629, 12334, 10951, 456, 486, 312, 472, 19633, 6586, 1296, 552, 11, 3006, 13, 50682], 'temperature': 0.0, 'avg_logprob': -0.14826534854041207, 'compression_ratio': 1.7783505154639174, 'no_speech_prob': 0.017092347145080566}, {'id': 55, 'seek': 30920, 'start': 315.56, 'end': 321.15999999999997, 'text': ' So again you can see that because of this dependency and if these instructions happen', 'tokens': [50682, 407, 797, 291, 393, 536, 300, 570, 295, 341, 33621, 293, 498, 613, 9415, 1051, 50962], 'temperature': 0.0, 'avg_logprob': -0.14826534854041207, 'compression_ratio': 1.7783505154639174, 'no_speech_prob': 0.017092347145080566}, {'id': 56, 'seek': 30920, 'start': 321.15999999999997, 'end': 328.15999999999997, 'text': ' to be successive instructions there will be one stall cycle. Similarly here also. So if', 'tokens': [50962, 281, 312, 48043, 9415, 456, 486, 312, 472, 19633, 6586, 13, 13157, 510, 611, 13, 407, 498, 51312], 'temperature': 0.0, 'avg_logprob': -0.14826534854041207, 'compression_ratio': 1.7783505154639174, 'no_speech_prob': 0.017092347145080566}, {'id': 57, 'seek': 30920, 'start': 328.15999999999997, 'end': 334.84, 'text': ' I present this code from my compiler to this machine then that machine would incur two', 'tokens': [51312, 286, 1974, 341, 3089, 490, 452, 31958, 281, 341, 3479, 550, 300, 3479, 576, 35774, 732, 51646], 'temperature': 0.0, 'avg_logprob': -0.14826534854041207, 'compression_ratio': 1.7783505154639174, 'no_speech_prob': 0.017092347145080566}, {'id': 58, 'seek': 33484, 'start': 334.84, 'end': 340.03999999999996, 'text': ' stall cycles. That means that if I am only considering these five instructions then the', 'tokens': [50364, 19633, 17796, 13, 663, 1355, 300, 498, 286, 669, 787, 8079, 613, 1732, 9415, 550, 264, 50624], 'temperature': 0.0, 'avg_logprob': -0.1773038844472354, 'compression_ratio': 1.8833333333333333, 'no_speech_prob': 0.036221958696842194}, {'id': 59, 'seek': 33484, 'start': 340.03999999999996, 'end': 345.11999999999995, 'text': ' time it would take to execute these five instructions looking at from a throughput point of view', 'tokens': [50624, 565, 309, 576, 747, 281, 14483, 613, 1732, 9415, 1237, 412, 490, 257, 44629, 935, 295, 1910, 50878], 'temperature': 0.0, 'avg_logprob': -0.1773038844472354, 'compression_ratio': 1.8833333333333333, 'no_speech_prob': 0.036221958696842194}, {'id': 60, 'seek': 33484, 'start': 345.11999999999995, 'end': 351.35999999999996, 'text': ' is that it will produce the results of these pipeline instructions, right. Five instructions', 'tokens': [50878, 307, 300, 309, 486, 5258, 264, 3542, 295, 613, 15517, 9415, 11, 558, 13, 9436, 9415, 51190], 'temperature': 0.0, 'avg_logprob': -0.1773038844472354, 'compression_ratio': 1.8833333333333333, 'no_speech_prob': 0.036221958696842194}, {'id': 61, 'seek': 33484, 'start': 351.35999999999996, 'end': 356.35999999999996, 'text': ' in seven cycles. That is really what would happen because of these two stall cycles,', 'tokens': [51190, 294, 3407, 17796, 13, 663, 307, 534, 437, 576, 1051, 570, 295, 613, 732, 19633, 17796, 11, 51440], 'temperature': 0.0, 'avg_logprob': -0.1773038844472354, 'compression_ratio': 1.8833333333333333, 'no_speech_prob': 0.036221958696842194}, {'id': 62, 'seek': 33484, 'start': 356.35999999999996, 'end': 362.64, 'text': ' right. So that is why it is important to remove these stall cycles if possible from this,', 'tokens': [51440, 558, 13, 407, 300, 307, 983, 309, 307, 1021, 281, 4159, 613, 19633, 17796, 498, 1944, 490, 341, 11, 51754], 'temperature': 0.0, 'avg_logprob': -0.1773038844472354, 'compression_ratio': 1.8833333333333333, 'no_speech_prob': 0.036221958696842194}, {'id': 63, 'seek': 36264, 'start': 362.64, 'end': 369.64, 'text': ' right. Let us see what happens. If I am allowed to reorder these instructions but when I reorder', 'tokens': [50364, 558, 13, 961, 505, 536, 437, 2314, 13, 759, 286, 669, 4350, 281, 319, 4687, 613, 9415, 457, 562, 286, 319, 4687, 50714], 'temperature': 0.0, 'avg_logprob': -0.20790445935595167, 'compression_ratio': 1.6531531531531531, 'no_speech_prob': 0.007157187443226576}, {'id': 64, 'seek': 36264, 'start': 370.59999999999997, 'end': 375.52, 'text': ' the instructions I have to make sure all the dependences that are given in the instructions', 'tokens': [50762, 264, 9415, 286, 362, 281, 652, 988, 439, 264, 5672, 2667, 300, 366, 2212, 294, 264, 9415, 51008], 'temperature': 0.0, 'avg_logprob': -0.20790445935595167, 'compression_ratio': 1.6531531531531531, 'no_speech_prob': 0.007157187443226576}, {'id': 65, 'seek': 36264, 'start': 375.52, 'end': 380.76, 'text': ' are preserved. That is an important condition if I say that. Then how can I do that? For', 'tokens': [51008, 366, 22242, 13, 663, 307, 364, 1021, 4188, 498, 286, 584, 300, 13, 1396, 577, 393, 286, 360, 300, 30, 1171, 51270], 'temperature': 0.0, 'avg_logprob': -0.20790445935595167, 'compression_ratio': 1.6531531531531531, 'no_speech_prob': 0.007157187443226576}, {'id': 66, 'seek': 36264, 'start': 380.76, 'end': 387.76, 'text': ' example if I look at this instruction, right, also uses R3. So I cannot move this between', 'tokens': [51270, 1365, 498, 286, 574, 412, 341, 10951, 11, 558, 11, 611, 4960, 497, 18, 13, 407, 286, 2644, 1286, 341, 1296, 51620], 'temperature': 0.0, 'avg_logprob': -0.20790445935595167, 'compression_ratio': 1.6531531531531531, 'no_speech_prob': 0.007157187443226576}, {'id': 67, 'seek': 38776, 'start': 388.76, 'end': 394.76, 'text': ' these two instructions, right. What about this instruction? This instruction uses R11', 'tokens': [50414, 613, 732, 9415, 11, 558, 13, 708, 466, 341, 10951, 30, 639, 10951, 4960, 497, 5348, 50714], 'temperature': 0.0, 'avg_logprob': -0.15872888337998164, 'compression_ratio': 1.9627659574468086, 'no_speech_prob': 0.003178232116624713}, {'id': 68, 'seek': 38776, 'start': 394.76, 'end': 401.84, 'text': ' register and none of these instructions actually write into R11. That means that this instruction', 'tokens': [50714, 7280, 293, 6022, 295, 613, 9415, 767, 2464, 666, 497, 5348, 13, 663, 1355, 300, 341, 10951, 51068], 'temperature': 0.0, 'avg_logprob': -0.15872888337998164, 'compression_ratio': 1.9627659574468086, 'no_speech_prob': 0.003178232116624713}, {'id': 69, 'seek': 38776, 'start': 401.84, 'end': 407.8, 'text': ' is not dependent on any of these instructions, right. So the question is can I move this', 'tokens': [51068, 307, 406, 12334, 322, 604, 295, 613, 9415, 11, 558, 13, 407, 264, 1168, 307, 393, 286, 1286, 341, 51366], 'temperature': 0.0, 'avg_logprob': -0.15872888337998164, 'compression_ratio': 1.9627659574468086, 'no_speech_prob': 0.003178232116624713}, {'id': 70, 'seek': 38776, 'start': 407.8, 'end': 414.8, 'text': ' instruction, right, in between these two instructions, right. And if I do that what will I gain?', 'tokens': [51366, 10951, 11, 558, 11, 294, 1296, 613, 732, 9415, 11, 558, 13, 400, 498, 286, 360, 300, 437, 486, 286, 6052, 30, 51716], 'temperature': 0.0, 'avg_logprob': -0.15872888337998164, 'compression_ratio': 1.9627659574468086, 'no_speech_prob': 0.003178232116624713}, {'id': 71, 'seek': 41480, 'start': 415.76, 'end': 422.08, 'text': ' Okay so let us see that. So the first load instruction is there. Then the add instruction', 'tokens': [50412, 1033, 370, 718, 505, 536, 300, 13, 407, 264, 700, 3677, 10951, 307, 456, 13, 1396, 264, 909, 10951, 50728], 'temperature': 0.0, 'avg_logprob': -0.1908739652389135, 'compression_ratio': 1.9251336898395721, 'no_speech_prob': 0.002221805974841118}, {'id': 72, 'seek': 41480, 'start': 422.08, 'end': 426.0, 'text': ' is there because of the dependency I want to put some instructions in between these', 'tokens': [50728, 307, 456, 570, 295, 264, 33621, 286, 528, 281, 829, 512, 9415, 294, 1296, 613, 50924], 'temperature': 0.0, 'avg_logprob': -0.1908739652389135, 'compression_ratio': 1.9251336898395721, 'no_speech_prob': 0.002221805974841118}, {'id': 73, 'seek': 41480, 'start': 426.0, 'end': 433.0, 'text': ' two instructions. Look at see, right. If I move this load instruction in that location', 'tokens': [50924, 732, 9415, 13, 2053, 412, 536, 11, 558, 13, 759, 286, 1286, 341, 3677, 10951, 294, 300, 4914, 51274], 'temperature': 0.0, 'avg_logprob': -0.1908739652389135, 'compression_ratio': 1.9251336898395721, 'no_speech_prob': 0.002221805974841118}, {'id': 74, 'seek': 41480, 'start': 433.6, 'end': 439.94, 'text': ' then what happens is that this is an independent instruction which is between this load instruction', 'tokens': [51304, 550, 437, 2314, 307, 300, 341, 307, 364, 6695, 10951, 597, 307, 1296, 341, 3677, 10951, 51621], 'temperature': 0.0, 'avg_logprob': -0.1908739652389135, 'compression_ratio': 1.9251336898395721, 'no_speech_prob': 0.002221805974841118}, {'id': 75, 'seek': 43994, 'start': 439.94, 'end': 445.38, 'text': ' and the dependent add instruction. Now this instruction can be fetched, let us say if', 'tokens': [50364, 293, 264, 12334, 909, 10951, 13, 823, 341, 10951, 393, 312, 23673, 292, 11, 718, 505, 584, 498, 50636], 'temperature': 0.0, 'avg_logprob': -0.13321964627220517, 'compression_ratio': 2.1449275362318843, 'no_speech_prob': 0.007326913066208363}, {'id': 76, 'seek': 43994, 'start': 445.38, 'end': 449.98, 'text': ' this instruction is fetched in time t, this can be fetched in time t plus 1 and this can', 'tokens': [50636, 341, 10951, 307, 23673, 292, 294, 565, 256, 11, 341, 393, 312, 23673, 292, 294, 565, 256, 1804, 502, 293, 341, 393, 50866], 'temperature': 0.0, 'avg_logprob': -0.13321964627220517, 'compression_ratio': 2.1449275362318843, 'no_speech_prob': 0.007326913066208363}, {'id': 77, 'seek': 43994, 'start': 449.98, 'end': 454.74, 'text': ' be fetched in time t plus 2 and that will not really cause a stall because that one', 'tokens': [50866, 312, 23673, 292, 294, 565, 256, 1804, 568, 293, 300, 486, 406, 534, 3082, 257, 19633, 570, 300, 472, 51104], 'temperature': 0.0, 'avg_logprob': -0.13321964627220517, 'compression_ratio': 2.1449275362318843, 'no_speech_prob': 0.007326913066208363}, {'id': 78, 'seek': 43994, 'start': 454.74, 'end': 461.74, 'text': ' stall cycle that I am talking about I have avoided by putting this instruction in between.', 'tokens': [51104, 19633, 6586, 300, 286, 669, 1417, 466, 286, 362, 24890, 538, 3372, 341, 10951, 294, 1296, 13, 51454], 'temperature': 0.0, 'avg_logprob': -0.13321964627220517, 'compression_ratio': 2.1449275362318843, 'no_speech_prob': 0.007326913066208363}, {'id': 79, 'seek': 43994, 'start': 461.78, 'end': 466.86, 'text': ' Now what about the stall between this instruction and this instruction? I have also taken care', 'tokens': [51456, 823, 437, 466, 264, 19633, 1296, 341, 10951, 293, 341, 10951, 30, 286, 362, 611, 2726, 1127, 51710], 'temperature': 0.0, 'avg_logprob': -0.13321964627220517, 'compression_ratio': 2.1449275362318843, 'no_speech_prob': 0.007326913066208363}, {'id': 80, 'seek': 46686, 'start': 466.86, 'end': 472.06, 'text': ' of that because immediately after this instruction there is a independent instruction which is', 'tokens': [50364, 295, 300, 570, 4258, 934, 341, 10951, 456, 307, 257, 6695, 10951, 597, 307, 50624], 'temperature': 0.0, 'avg_logprob': -0.12091924810922274, 'compression_ratio': 2.022421524663677, 'no_speech_prob': 0.006888711359351873}, {'id': 81, 'seek': 46686, 'start': 472.06, 'end': 477.22, 'text': ' independent of this, right. So if I leave the rest of these instructions in the same', 'tokens': [50624, 6695, 295, 341, 11, 558, 13, 407, 498, 286, 1856, 264, 1472, 295, 613, 9415, 294, 264, 912, 50882], 'temperature': 0.0, 'avg_logprob': -0.12091924810922274, 'compression_ratio': 2.022421524663677, 'no_speech_prob': 0.006888711359351873}, {'id': 82, 'seek': 46686, 'start': 477.22, 'end': 483.5, 'text': ' order, right, you can see that I have taken care of the dependency between the load instruction', 'tokens': [50882, 1668, 11, 558, 11, 291, 393, 536, 300, 286, 362, 2726, 1127, 295, 264, 33621, 1296, 264, 3677, 10951, 51196], 'temperature': 0.0, 'avg_logprob': -0.12091924810922274, 'compression_ratio': 2.022421524663677, 'no_speech_prob': 0.006888711359351873}, {'id': 83, 'seek': 46686, 'start': 483.5, 'end': 488.74, 'text': ' and the corresponding add instruction as well as this load instruction and the respective', 'tokens': [51196, 293, 264, 11760, 909, 10951, 382, 731, 382, 341, 3677, 10951, 293, 264, 23649, 51458], 'temperature': 0.0, 'avg_logprob': -0.12091924810922274, 'compression_ratio': 2.022421524663677, 'no_speech_prob': 0.006888711359351873}, {'id': 84, 'seek': 46686, 'start': 488.74, 'end': 494.26, 'text': ' add instruction, right. They have been now separated by more than one instruction and', 'tokens': [51458, 909, 10951, 11, 558, 13, 814, 362, 668, 586, 12005, 538, 544, 813, 472, 10951, 293, 51734], 'temperature': 0.0, 'avg_logprob': -0.12091924810922274, 'compression_ratio': 2.022421524663677, 'no_speech_prob': 0.006888711359351873}, {'id': 85, 'seek': 49426, 'start': 494.26, 'end': 499.5, 'text': ' as long as they are separated by more than one instruction these stalls will not occur.', 'tokens': [50364, 382, 938, 382, 436, 366, 12005, 538, 544, 813, 472, 10951, 613, 50248, 486, 406, 5160, 13, 50626], 'temperature': 0.0, 'avg_logprob': -0.14064487968523479, 'compression_ratio': 1.8464730290456433, 'no_speech_prob': 0.02407839335501194}, {'id': 86, 'seek': 49426, 'start': 499.5, 'end': 504.82, 'text': ' So in this particular case, sorry, in this particular case I have zero stall cycles that', 'tokens': [50626, 407, 294, 341, 1729, 1389, 11, 2597, 11, 294, 341, 1729, 1389, 286, 362, 4018, 19633, 17796, 300, 50892], 'temperature': 0.0, 'avg_logprob': -0.14064487968523479, 'compression_ratio': 1.8464730290456433, 'no_speech_prob': 0.02407839335501194}, {'id': 87, 'seek': 49426, 'start': 504.82, 'end': 510.7, 'text': ' means that in a pipeline execution I can actually finish executing all these five instructions', 'tokens': [50892, 1355, 300, 294, 257, 15517, 15058, 286, 393, 767, 2413, 32368, 439, 613, 1732, 9415, 51186], 'temperature': 0.0, 'avg_logprob': -0.14064487968523479, 'compression_ratio': 1.8464730290456433, 'no_speech_prob': 0.02407839335501194}, {'id': 88, 'seek': 49426, 'start': 510.7, 'end': 515.66, 'text': ' in five cycles. So I have again, now I have improved the throughput to one instruction', 'tokens': [51186, 294, 1732, 17796, 13, 407, 286, 362, 797, 11, 586, 286, 362, 9689, 264, 44629, 281, 472, 10951, 51434], 'temperature': 0.0, 'avg_logprob': -0.14064487968523479, 'compression_ratio': 1.8464730290456433, 'no_speech_prob': 0.02407839335501194}, {'id': 89, 'seek': 49426, 'start': 515.66, 'end': 520.66, 'text': ' per cycle. So this is essentially what we call as instruction scheduling. This is done', 'tokens': [51434, 680, 6586, 13, 407, 341, 307, 4476, 437, 321, 818, 382, 10951, 29055, 13, 639, 307, 1096, 51684], 'temperature': 0.0, 'avg_logprob': -0.14064487968523479, 'compression_ratio': 1.8464730290456433, 'no_speech_prob': 0.02407839335501194}, {'id': 90, 'seek': 52066, 'start': 520.74, 'end': 526.06, 'text': ' by the compiler. We are going to spend time on Thursday and Friday trying to talk about', 'tokens': [50368, 538, 264, 31958, 13, 492, 366, 516, 281, 3496, 565, 322, 10383, 293, 6984, 1382, 281, 751, 466, 50634], 'temperature': 0.0, 'avg_logprob': -0.19376943487870066, 'compression_ratio': 1.85, 'no_speech_prob': 0.013190403580665588}, {'id': 91, 'seek': 52066, 'start': 526.06, 'end': 532.02, 'text': ' instruction scheduling, how to do instruction scheduling, right. And this is for what we', 'tokens': [50634, 10951, 29055, 11, 577, 281, 360, 10951, 29055, 11, 558, 13, 400, 341, 307, 337, 437, 321, 50932], 'temperature': 0.0, 'avg_logprob': -0.19376943487870066, 'compression_ratio': 1.85, 'no_speech_prob': 0.013190403580665588}, {'id': 92, 'seek': 52066, 'start': 532.02, 'end': 537.74, 'text': ' call as a simple pipeline processor which can issue and execute one instruction every', 'tokens': [50932, 818, 382, 257, 2199, 15517, 15321, 597, 393, 2734, 293, 14483, 472, 10951, 633, 51218], 'temperature': 0.0, 'avg_logprob': -0.19376943487870066, 'compression_ratio': 1.85, 'no_speech_prob': 0.013190403580665588}, {'id': 93, 'seek': 52066, 'start': 537.74, 'end': 543.74, 'text': ' cycle. We will also talk about this in the case where there is instruction level parallelism,', 'tokens': [51218, 6586, 13, 492, 486, 611, 751, 466, 341, 294, 264, 1389, 689, 456, 307, 10951, 1496, 8952, 1434, 11, 51518], 'temperature': 0.0, 'avg_logprob': -0.19376943487870066, 'compression_ratio': 1.85, 'no_speech_prob': 0.013190403580665588}, {'id': 94, 'seek': 52066, 'start': 543.74, 'end': 549.62, 'text': ' right. Again remember that when we talk about these dependencies, data dependencies and', 'tokens': [51518, 558, 13, 3764, 1604, 300, 562, 321, 751, 466, 613, 36606, 11, 1412, 36606, 293, 51812], 'temperature': 0.0, 'avg_logprob': -0.19376943487870066, 'compression_ratio': 1.85, 'no_speech_prob': 0.013190403580665588}, {'id': 95, 'seek': 54962, 'start': 549.62, 'end': 556.46, 'text': ' data hazards we talked about doing this, right, as a compiler technique. I will very', 'tokens': [50364, 1412, 34516, 321, 2825, 466, 884, 341, 11, 558, 11, 382, 257, 31958, 6532, 13, 286, 486, 588, 50706], 'temperature': 0.0, 'avg_logprob': -0.1859615439235574, 'compression_ratio': 1.779591836734694, 'no_speech_prob': 0.014991231262683868}, {'id': 96, 'seek': 54962, 'start': 556.46, 'end': 561.58, 'text': ' briefly talk about a runtime technique also to do this but only very briefly because again', 'tokens': [50706, 10515, 751, 466, 257, 34474, 6532, 611, 281, 360, 341, 457, 787, 588, 10515, 570, 797, 50962], 'temperature': 0.0, 'avg_logprob': -0.1859615439235574, 'compression_ratio': 1.779591836734694, 'no_speech_prob': 0.014991231262683868}, {'id': 97, 'seek': 54962, 'start': 561.58, 'end': 565.78, 'text': ' from a compiler perspective that is not very relevant for our discussion.', 'tokens': [50962, 490, 257, 31958, 4585, 300, 307, 406, 588, 7340, 337, 527, 5017, 13, 51172], 'temperature': 0.0, 'avg_logprob': -0.1859615439235574, 'compression_ratio': 1.779591836734694, 'no_speech_prob': 0.014991231262683868}, {'id': 98, 'seek': 54962, 'start': 565.78, 'end': 572.26, 'text': ' Okay, now let us talk about control hazards which is the third type of hazard, right.', 'tokens': [51172, 1033, 11, 586, 718, 505, 751, 466, 1969, 34516, 597, 307, 264, 2636, 2010, 295, 20790, 11, 558, 13, 51496], 'temperature': 0.0, 'avg_logprob': -0.1859615439235574, 'compression_ratio': 1.779591836734694, 'no_speech_prob': 0.014991231262683868}, {'id': 99, 'seek': 54962, 'start': 572.26, 'end': 578.38, 'text': ' So what happens? Let us look at the ith instruction. If the ith instruction is a branch instruction,', 'tokens': [51496, 407, 437, 2314, 30, 961, 505, 574, 412, 264, 309, 71, 10951, 13, 759, 264, 309, 71, 10951, 307, 257, 9819, 10951, 11, 51802], 'temperature': 0.0, 'avg_logprob': -0.1859615439235574, 'compression_ratio': 1.779591836734694, 'no_speech_prob': 0.014991231262683868}, {'id': 100, 'seek': 57838, 'start': 579.38, 'end': 585.1, 'text': ' then let us assume that it is fetched in the instruction fetch phase. Decoded during the', 'tokens': [50414, 550, 718, 505, 6552, 300, 309, 307, 23673, 292, 294, 264, 10951, 23673, 5574, 13, 12427, 12340, 1830, 264, 50700], 'temperature': 0.0, 'avg_logprob': -0.14679306800212336, 'compression_ratio': 1.9647577092511013, 'no_speech_prob': 0.0036702004726976156}, {'id': 101, 'seek': 57838, 'start': 585.1, 'end': 591.14, 'text': ' decode phase, the operands are also fetched. During the execute phase, we figure out whether', 'tokens': [50700, 979, 1429, 5574, 11, 264, 2208, 2967, 366, 611, 23673, 292, 13, 6842, 264, 14483, 5574, 11, 321, 2573, 484, 1968, 51002], 'temperature': 0.0, 'avg_logprob': -0.14679306800212336, 'compression_ratio': 1.9647577092511013, 'no_speech_prob': 0.0036702004726976156}, {'id': 102, 'seek': 57838, 'start': 591.14, 'end': 597.54, 'text': ' the conditions are satisfied or not and we also find out where the target location has', 'tokens': [51002, 264, 4487, 366, 11239, 420, 406, 293, 321, 611, 915, 484, 689, 264, 3779, 4914, 575, 51322], 'temperature': 0.0, 'avg_logprob': -0.14679306800212336, 'compression_ratio': 1.9647577092511013, 'no_speech_prob': 0.0036702004726976156}, {'id': 103, 'seek': 57838, 'start': 597.54, 'end': 601.9399999999999, 'text': ' to be. So let us see at the end of the execute cycle, we know whether the branch condition', 'tokens': [51322, 281, 312, 13, 407, 718, 505, 536, 412, 264, 917, 295, 264, 14483, 6586, 11, 321, 458, 1968, 264, 9819, 4188, 51542], 'temperature': 0.0, 'avg_logprob': -0.14679306800212336, 'compression_ratio': 1.9647577092511013, 'no_speech_prob': 0.0036702004726976156}, {'id': 104, 'seek': 57838, 'start': 601.9399999999999, 'end': 607.46, 'text': ' is true or not. If the branch condition is satisfied, then we have to go to the target', 'tokens': [51542, 307, 2074, 420, 406, 13, 759, 264, 9819, 4188, 307, 11239, 11, 550, 321, 362, 281, 352, 281, 264, 3779, 51818], 'temperature': 0.0, 'avg_logprob': -0.14679306800212336, 'compression_ratio': 1.9647577092511013, 'no_speech_prob': 0.0036702004726976156}, {'id': 105, 'seek': 60746, 'start': 607.46, 'end': 614.62, 'text': ' location. The target location is also computed during the execute phase, right. Now if this', 'tokens': [50364, 4914, 13, 440, 3779, 4914, 307, 611, 40610, 1830, 264, 14483, 5574, 11, 558, 13, 823, 498, 341, 50722], 'temperature': 0.0, 'avg_logprob': -0.1311741182881017, 'compression_ratio': 1.7596153846153846, 'no_speech_prob': 0.011789992451667786}, {'id': 106, 'seek': 60746, 'start': 614.62, 'end': 621.62, 'text': ' instruction is fetched in the time t, what happens in time t plus 1? The i plus 1th instruction', 'tokens': [50722, 10951, 307, 23673, 292, 294, 264, 565, 256, 11, 437, 2314, 294, 565, 256, 1804, 502, 30, 440, 741, 1804, 502, 392, 10951, 51072], 'temperature': 0.0, 'avg_logprob': -0.1311741182881017, 'compression_ratio': 1.7596153846153846, 'no_speech_prob': 0.011789992451667786}, {'id': 107, 'seek': 60746, 'start': 622.14, 'end': 628.6600000000001, 'text': ' is normally what is being fetched but if the condition is true, I should not be fetching', 'tokens': [51098, 307, 5646, 437, 307, 885, 23673, 292, 457, 498, 264, 4188, 307, 2074, 11, 286, 820, 406, 312, 23673, 278, 51424], 'temperature': 0.0, 'avg_logprob': -0.1311741182881017, 'compression_ratio': 1.7596153846153846, 'no_speech_prob': 0.011789992451667786}, {'id': 108, 'seek': 60746, 'start': 628.6600000000001, 'end': 635.1800000000001, 'text': ' this instruction, right. So during the decode phase, as soon as I figure out that the ith', 'tokens': [51424, 341, 10951, 11, 558, 13, 407, 1830, 264, 979, 1429, 5574, 11, 382, 2321, 382, 286, 2573, 484, 300, 264, 309, 71, 51750], 'temperature': 0.0, 'avg_logprob': -0.1311741182881017, 'compression_ratio': 1.7596153846153846, 'no_speech_prob': 0.011789992451667786}, {'id': 109, 'seek': 63518, 'start': 635.18, 'end': 642.18, 'text': ' instruction is a branch instruction, I should stop stalling this instruction, right. I should', 'tokens': [50364, 10951, 307, 257, 9819, 10951, 11, 286, 820, 1590, 19633, 278, 341, 10951, 11, 558, 13, 286, 820, 50714], 'temperature': 0.0, 'avg_logprob': -0.12210895798423073, 'compression_ratio': 1.9042553191489362, 'no_speech_prob': 0.008993824012577534}, {'id': 110, 'seek': 63518, 'start': 642.62, 'end': 648.8199999999999, 'text': ' really stop fetching this or doing anything with the i plus 1th instruction. But only', 'tokens': [50736, 534, 1590, 23673, 278, 341, 420, 884, 1340, 365, 264, 741, 1804, 502, 392, 10951, 13, 583, 787, 51046], 'temperature': 0.0, 'avg_logprob': -0.12210895798423073, 'compression_ratio': 1.9042553191489362, 'no_speech_prob': 0.008993824012577534}, {'id': 111, 'seek': 63518, 'start': 648.8199999999999, 'end': 654.62, 'text': ' in time t plus 2, correct, I will really know whether the branch condition is satisfied', 'tokens': [51046, 294, 565, 256, 1804, 568, 11, 3006, 11, 286, 486, 534, 458, 1968, 264, 9819, 4188, 307, 11239, 51336], 'temperature': 0.0, 'avg_logprob': -0.12210895798423073, 'compression_ratio': 1.9042553191489362, 'no_speech_prob': 0.008993824012577534}, {'id': 112, 'seek': 63518, 'start': 654.62, 'end': 661.3399999999999, 'text': ' or not. If it is satisfied, then the stalling is fine. If it is not satisfied, I can start', 'tokens': [51336, 420, 406, 13, 759, 309, 307, 11239, 11, 550, 264, 19633, 278, 307, 2489, 13, 759, 309, 307, 406, 11239, 11, 286, 393, 722, 51672], 'temperature': 0.0, 'avg_logprob': -0.12210895798423073, 'compression_ratio': 1.9042553191489362, 'no_speech_prob': 0.008993824012577534}, {'id': 113, 'seek': 66134, 'start': 661.4200000000001, 'end': 667.98, 'text': ' fetching the instruction in the next cycle, right. So let us see what happens. Again we', 'tokens': [50368, 23673, 278, 264, 10951, 294, 264, 958, 6586, 11, 558, 13, 407, 718, 505, 536, 437, 2314, 13, 3764, 321, 50696], 'temperature': 0.0, 'avg_logprob': -0.13972964578745317, 'compression_ratio': 1.7053140096618358, 'no_speech_prob': 0.020429961383342743}, {'id': 114, 'seek': 66134, 'start': 667.98, 'end': 673.5400000000001, 'text': ' stall because only at this point in time we know what we need to do. Then at the next', 'tokens': [50696, 19633, 570, 787, 412, 341, 935, 294, 565, 321, 458, 437, 321, 643, 281, 360, 13, 1396, 412, 264, 958, 50974], 'temperature': 0.0, 'avg_logprob': -0.13972964578745317, 'compression_ratio': 1.7053140096618358, 'no_speech_prob': 0.020429961383342743}, {'id': 115, 'seek': 66134, 'start': 673.5400000000001, 'end': 680.5400000000001, 'text': ' cycle, right, that is if this is t, t plus 1, t plus 2, in cycle t plus 3, we can figure', 'tokens': [50974, 6586, 11, 558, 11, 300, 307, 498, 341, 307, 256, 11, 256, 1804, 502, 11, 256, 1804, 568, 11, 294, 6586, 256, 1804, 805, 11, 321, 393, 2573, 51324], 'temperature': 0.0, 'avg_logprob': -0.13972964578745317, 'compression_ratio': 1.7053140096618358, 'no_speech_prob': 0.020429961383342743}, {'id': 116, 'seek': 66134, 'start': 681.4200000000001, 'end': 688.4200000000001, 'text': ' out whether to fetch from i plus 1 or to fetch from the target location. So again what you', 'tokens': [51368, 484, 1968, 281, 23673, 490, 741, 1804, 502, 420, 281, 23673, 490, 264, 3779, 4914, 13, 407, 797, 437, 291, 51718], 'temperature': 0.0, 'avg_logprob': -0.13972964578745317, 'compression_ratio': 1.7053140096618358, 'no_speech_prob': 0.020429961383342743}, {'id': 117, 'seek': 68842, 'start': 689.18, 'end': 695.3399999999999, 'text': ' see here is that you will see two stall cycles. Again this is for a specific pipeline with', 'tokens': [50402, 536, 510, 307, 300, 291, 486, 536, 732, 19633, 17796, 13, 3764, 341, 307, 337, 257, 2685, 15517, 365, 50710], 'temperature': 0.0, 'avg_logprob': -0.1356651168508628, 'compression_ratio': 1.9224137931034482, 'no_speech_prob': 0.0019717072136700153}, {'id': 118, 'seek': 68842, 'start': 695.3399999999999, 'end': 701.42, 'text': ' five stages assuming that condition is being evaluated here. If the condition is evaluated', 'tokens': [50710, 1732, 10232, 11926, 300, 4188, 307, 885, 25509, 510, 13, 759, 264, 4188, 307, 25509, 51014], 'temperature': 0.0, 'avg_logprob': -0.1356651168508628, 'compression_ratio': 1.9224137931034482, 'no_speech_prob': 0.0019717072136700153}, {'id': 119, 'seek': 68842, 'start': 701.42, 'end': 706.06, 'text': ' here, then the stalls will be three cycles. If the condition is evaluated only at a later', 'tokens': [51014, 510, 11, 550, 264, 50248, 486, 312, 1045, 17796, 13, 759, 264, 4188, 307, 25509, 787, 412, 257, 1780, 51246], 'temperature': 0.0, 'avg_logprob': -0.1356651168508628, 'compression_ratio': 1.9224137931034482, 'no_speech_prob': 0.0019717072136700153}, {'id': 120, 'seek': 68842, 'start': 706.06, 'end': 711.38, 'text': ' stage, stalls will be even more number of cycles, correct. So the number of stalls depends', 'tokens': [51246, 3233, 11, 50248, 486, 312, 754, 544, 1230, 295, 17796, 11, 3006, 13, 407, 264, 1230, 295, 50248, 5946, 51512], 'temperature': 0.0, 'avg_logprob': -0.1356651168508628, 'compression_ratio': 1.9224137931034482, 'no_speech_prob': 0.0019717072136700153}, {'id': 121, 'seek': 68842, 'start': 711.38, 'end': 716.9, 'text': ' on where exactly the condition and target addresses are calculated because you need', 'tokens': [51512, 322, 689, 2293, 264, 4188, 293, 3779, 16862, 366, 15598, 570, 291, 643, 51788], 'temperature': 0.0, 'avg_logprob': -0.1356651168508628, 'compression_ratio': 1.9224137931034482, 'no_speech_prob': 0.0019717072136700153}, {'id': 122, 'seek': 71690, 'start': 716.9399999999999, 'end': 723.9399999999999, 'text': ' both of them to move forward, correct. If it takes four cycles before you compute that,', 'tokens': [50366, 1293, 295, 552, 281, 1286, 2128, 11, 3006, 13, 759, 309, 2516, 1451, 17796, 949, 291, 14722, 300, 11, 50716], 'temperature': 0.0, 'avg_logprob': -0.16196856044587635, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.005306245293468237}, {'id': 123, 'seek': 71690, 'start': 724.1, 'end': 731.1, 'text': ' then there will be four stall cycles, correct. Now again compilers can do little bit of help', 'tokens': [50724, 550, 456, 486, 312, 1451, 19633, 17796, 11, 3006, 13, 823, 797, 715, 388, 433, 393, 360, 707, 857, 295, 854, 51074], 'temperature': 0.0, 'avg_logprob': -0.16196856044587635, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.005306245293468237}, {'id': 124, 'seek': 71690, 'start': 732.02, 'end': 737.62, 'text': ' here. Let us see what happens there. Again as I mentioned earlier, in order for us to', 'tokens': [51120, 510, 13, 961, 505, 536, 437, 2314, 456, 13, 3764, 382, 286, 2835, 3071, 11, 294, 1668, 337, 505, 281, 51400], 'temperature': 0.0, 'avg_logprob': -0.16196856044587635, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.005306245293468237}, {'id': 125, 'seek': 71690, 'start': 737.62, 'end': 742.62, 'text': ' resolve about conditional branches, we need to know whether the condition is satisfied', 'tokens': [51400, 14151, 466, 27708, 14770, 11, 321, 643, 281, 458, 1968, 264, 4188, 307, 11239, 51650], 'temperature': 0.0, 'avg_logprob': -0.16196856044587635, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.005306245293468237}, {'id': 126, 'seek': 74262, 'start': 742.62, 'end': 748.18, 'text': ' and we also need to compute the target address. In our example, we assumed both of these things', 'tokens': [50364, 293, 321, 611, 643, 281, 14722, 264, 3779, 2985, 13, 682, 527, 1365, 11, 321, 15895, 1293, 295, 613, 721, 50642], 'temperature': 0.0, 'avg_logprob': -0.15557638064835422, 'compression_ratio': 1.7575757575757576, 'no_speech_prob': 0.01616830751299858}, {'id': 127, 'seek': 74262, 'start': 748.18, 'end': 753.14, 'text': ' to be happening in the EX stage, but if you can build an aggressive hardware where both', 'tokens': [50642, 281, 312, 2737, 294, 264, 16385, 3233, 11, 457, 498, 291, 393, 1322, 364, 10762, 8837, 689, 1293, 50890], 'temperature': 0.0, 'avg_logprob': -0.15557638064835422, 'compression_ratio': 1.7575757575757576, 'no_speech_prob': 0.01616830751299858}, {'id': 128, 'seek': 74262, 'start': 753.14, 'end': 758.42, 'text': ' of these could be done in the ID stage itself, then you can reduce the delays to one stall', 'tokens': [50890, 295, 613, 727, 312, 1096, 294, 264, 7348, 3233, 2564, 11, 550, 291, 393, 5407, 264, 28610, 281, 472, 19633, 51154], 'temperature': 0.0, 'avg_logprob': -0.15557638064835422, 'compression_ratio': 1.7575757575757576, 'no_speech_prob': 0.01616830751299858}, {'id': 129, 'seek': 74262, 'start': 758.42, 'end': 763.78, 'text': " cycle, right. Again depends on how aggressive you want to build your hardware. Today's hardware", 'tokens': [51154, 6586, 11, 558, 13, 3764, 5946, 322, 577, 10762, 291, 528, 281, 1322, 428, 8837, 13, 2692, 311, 8837, 51422], 'temperature': 0.0, 'avg_logprob': -0.15557638064835422, 'compression_ratio': 1.7575757575757576, 'no_speech_prob': 0.01616830751299858}, {'id': 130, 'seek': 74262, 'start': 763.78, 'end': 767.86, 'text': ' can actually do that. In fact, it can do much more than that, okay.', 'tokens': [51422, 393, 767, 360, 300, 13, 682, 1186, 11, 309, 393, 360, 709, 544, 813, 300, 11, 1392, 13, 51626], 'temperature': 0.0, 'avg_logprob': -0.15557638064835422, 'compression_ratio': 1.7575757575757576, 'no_speech_prob': 0.01616830751299858}, {'id': 131, 'seek': 74262, 'start': 767.86, 'end': 771.82, 'text': ' Let us look at the case when the stall is reduced to one cycle, but minimally it at', 'tokens': [51626, 961, 505, 574, 412, 264, 1389, 562, 264, 19633, 307, 9212, 281, 472, 6586, 11, 457, 4464, 379, 309, 412, 51824], 'temperature': 0.0, 'avg_logprob': -0.15557638064835422, 'compression_ratio': 1.7575757575757576, 'no_speech_prob': 0.01616830751299858}, {'id': 132, 'seek': 77182, 'start': 771.82, 'end': 777.7800000000001, 'text': ' least requires one stall cycle because after the IF stage only you can decode and execute', 'tokens': [50364, 1935, 7029, 472, 19633, 6586, 570, 934, 264, 26080, 3233, 787, 291, 393, 979, 1429, 293, 14483, 50662], 'temperature': 0.0, 'avg_logprob': -0.14302542180190853, 'compression_ratio': 1.7427184466019416, 'no_speech_prob': 0.0023441151715815067}, {'id': 133, 'seek': 77182, 'start': 777.7800000000001, 'end': 784.7800000000001, 'text': ' the instruction. So, minimally you need one stall cycle, okay. So, one possible way to', 'tokens': [50662, 264, 10951, 13, 407, 11, 4464, 379, 291, 643, 472, 19633, 6586, 11, 1392, 13, 407, 11, 472, 1944, 636, 281, 51012], 'temperature': 0.0, 'avg_logprob': -0.14302542180190853, 'compression_ratio': 1.7427184466019416, 'no_speech_prob': 0.0023441151715815067}, {'id': 134, 'seek': 77182, 'start': 784.98, 'end': 790.3000000000001, 'text': ' handle this problem is what they call as static branch prediction technique. In a static branch', 'tokens': [51022, 4813, 341, 1154, 307, 437, 436, 818, 382, 13437, 9819, 17630, 6532, 13, 682, 257, 13437, 9819, 51288], 'temperature': 0.0, 'avg_logprob': -0.14302542180190853, 'compression_ratio': 1.7427184466019416, 'no_speech_prob': 0.0023441151715815067}, {'id': 135, 'seek': 77182, 'start': 790.3000000000001, 'end': 796.3800000000001, 'text': ' prediction technique, you have this policy of static not taken policy. That means that', 'tokens': [51288, 17630, 6532, 11, 291, 362, 341, 3897, 295, 13437, 406, 2726, 3897, 13, 663, 1355, 300, 51592], 'temperature': 0.0, 'avg_logprob': -0.14302542180190853, 'compression_ratio': 1.7427184466019416, 'no_speech_prob': 0.0023441151715815067}, {'id': 136, 'seek': 79638, 'start': 796.7, 'end': 802.7, 'text': ' even when you hit a branch, you pretend that the branch is not going to be taken, right.', 'tokens': [50380, 754, 562, 291, 2045, 257, 9819, 11, 291, 11865, 300, 264, 9819, 307, 406, 516, 281, 312, 2726, 11, 558, 13, 50680], 'temperature': 0.0, 'avg_logprob': -0.1421394262227926, 'compression_ratio': 1.9655172413793103, 'no_speech_prob': 0.018752053380012512}, {'id': 137, 'seek': 79638, 'start': 802.7, 'end': 806.9399999999999, 'text': ' And if you pretend the branch is not going to be taken, you allow the i plus 1 instruction', 'tokens': [50680, 400, 498, 291, 11865, 264, 9819, 307, 406, 516, 281, 312, 2726, 11, 291, 2089, 264, 741, 1804, 502, 10951, 50892], 'temperature': 0.0, 'avg_logprob': -0.1421394262227926, 'compression_ratio': 1.9655172413793103, 'no_speech_prob': 0.018752053380012512}, {'id': 138, 'seek': 79638, 'start': 806.9399999999999, 'end': 813.34, 'text': ' to be fixed in cycle t plus 1, right. And then one cycle later you will figure out whether', 'tokens': [50892, 281, 312, 6806, 294, 6586, 256, 1804, 502, 11, 558, 13, 400, 550, 472, 6586, 1780, 291, 486, 2573, 484, 1968, 51212], 'temperature': 0.0, 'avg_logprob': -0.1421394262227926, 'compression_ratio': 1.9655172413793103, 'no_speech_prob': 0.018752053380012512}, {'id': 139, 'seek': 79638, 'start': 813.34, 'end': 818.7, 'text': ' the condition is satisfied or not. If the condition is not satisfied, then your prediction', 'tokens': [51212, 264, 4188, 307, 11239, 420, 406, 13, 759, 264, 4188, 307, 406, 11239, 11, 550, 428, 17630, 51480], 'temperature': 0.0, 'avg_logprob': -0.1421394262227926, 'compression_ratio': 1.9655172413793103, 'no_speech_prob': 0.018752053380012512}, {'id': 140, 'seek': 79638, 'start': 818.7, 'end': 825.02, 'text': ' is correct. You can move forward without any delay, but if your condition is, if the condition', 'tokens': [51480, 307, 3006, 13, 509, 393, 1286, 2128, 1553, 604, 8577, 11, 457, 498, 428, 4188, 307, 11, 498, 264, 4188, 51796], 'temperature': 0.0, 'avg_logprob': -0.1421394262227926, 'compression_ratio': 1.9655172413793103, 'no_speech_prob': 0.018752053380012512}, {'id': 141, 'seek': 82502, 'start': 825.02, 'end': 829.86, 'text': ' is satisfied and the branch has to be taken, then your prediction is wrong, you incur one', 'tokens': [50364, 307, 11239, 293, 264, 9819, 575, 281, 312, 2726, 11, 550, 428, 17630, 307, 2085, 11, 291, 35774, 472, 50606], 'temperature': 0.0, 'avg_logprob': -0.12948331662586757, 'compression_ratio': 1.7568627450980392, 'no_speech_prob': 0.0021862871944904327}, {'id': 142, 'seek': 82502, 'start': 829.86, 'end': 835.34, 'text': ' stall cycle. But anyway you would have incurred one stall cycle. So, by taking a static not', 'tokens': [50606, 19633, 6586, 13, 583, 4033, 291, 576, 362, 35774, 986, 472, 19633, 6586, 13, 407, 11, 538, 1940, 257, 13437, 406, 50880], 'temperature': 0.0, 'avg_logprob': -0.12948331662586757, 'compression_ratio': 1.7568627450980392, 'no_speech_prob': 0.0021862871944904327}, {'id': 143, 'seek': 82502, 'start': 835.34, 'end': 841.38, 'text': ' taken policy for branches which are not taken, you can essentially avoid the stall cycle,', 'tokens': [50880, 2726, 3897, 337, 14770, 597, 366, 406, 2726, 11, 291, 393, 4476, 5042, 264, 19633, 6586, 11, 51182], 'temperature': 0.0, 'avg_logprob': -0.12948331662586757, 'compression_ratio': 1.7568627450980392, 'no_speech_prob': 0.0021862871944904327}, {'id': 144, 'seek': 82502, 'start': 841.38, 'end': 848.38, 'text': ' right. So, this idea is a very simple idea, but quite useful. So, what I want to do is', 'tokens': [51182, 558, 13, 407, 11, 341, 1558, 307, 257, 588, 2199, 1558, 11, 457, 1596, 4420, 13, 407, 11, 437, 286, 528, 281, 360, 307, 51532], 'temperature': 0.0, 'avg_logprob': -0.12948331662586757, 'compression_ratio': 1.7568627450980392, 'no_speech_prob': 0.0021862871944904327}, {'id': 145, 'seek': 82502, 'start': 848.38, 'end': 853.26, 'text': ' that if in my instruction stream, I will always assume that the branch is not going to be', 'tokens': [51532, 300, 498, 294, 452, 10951, 4309, 11, 286, 486, 1009, 6552, 300, 264, 9819, 307, 406, 516, 281, 312, 51776], 'temperature': 0.0, 'avg_logprob': -0.12948331662586757, 'compression_ratio': 1.7568627450980392, 'no_speech_prob': 0.0021862871944904327}, {'id': 146, 'seek': 85326, 'start': 853.26, 'end': 859.9399999999999, 'text': ' taken, right. And then I will build my hardware such that the i th instruction and the i plus', 'tokens': [50364, 2726, 11, 558, 13, 400, 550, 286, 486, 1322, 452, 8837, 1270, 300, 264, 741, 258, 10951, 293, 264, 741, 1804, 50698], 'temperature': 0.0, 'avg_logprob': -0.19212922510111108, 'compression_ratio': 1.8945147679324894, 'no_speech_prob': 0.016301637515425682}, {'id': 147, 'seek': 85326, 'start': 859.9399999999999, 'end': 866.46, 'text': ' 1 th instruction are always executed independent of whether the branch is taken or not taken,', 'tokens': [50698, 502, 258, 10951, 366, 1009, 17577, 6695, 295, 1968, 264, 9819, 307, 2726, 420, 406, 2726, 11, 51024], 'temperature': 0.0, 'avg_logprob': -0.19212922510111108, 'compression_ratio': 1.8945147679324894, 'no_speech_prob': 0.016301637515425682}, {'id': 148, 'seek': 85326, 'start': 866.46, 'end': 870.58, 'text': ' correct. So, I am now saying that see whenever you see a branch instruction, the idea is', 'tokens': [51024, 3006, 13, 407, 11, 286, 669, 586, 1566, 300, 536, 5699, 291, 536, 257, 9819, 10951, 11, 264, 1558, 307, 51230], 'temperature': 0.0, 'avg_logprob': -0.19212922510111108, 'compression_ratio': 1.8945147679324894, 'no_speech_prob': 0.016301637515425682}, {'id': 149, 'seek': 85326, 'start': 870.58, 'end': 875.7, 'text': ' that the condition is satisfied after the i th instruction, you go to the target. But', 'tokens': [51230, 300, 264, 4188, 307, 11239, 934, 264, 741, 258, 10951, 11, 291, 352, 281, 264, 3779, 13, 583, 51486], 'temperature': 0.0, 'avg_logprob': -0.19212922510111108, 'compression_ratio': 1.8945147679324894, 'no_speech_prob': 0.016301637515425682}, {'id': 150, 'seek': 85326, 'start': 875.7, 'end': 881.1, 'text': ' now we are building a hardware in which even if the condition is satisfied, the i plus', 'tokens': [51486, 586, 321, 366, 2390, 257, 8837, 294, 597, 754, 498, 264, 4188, 307, 11239, 11, 264, 741, 1804, 51756], 'temperature': 0.0, 'avg_logprob': -0.19212922510111108, 'compression_ratio': 1.8945147679324894, 'no_speech_prob': 0.016301637515425682}, {'id': 151, 'seek': 88110, 'start': 881.1800000000001, 'end': 886.1800000000001, 'text': ' 1 th instruction will also be executed before you go to the target location, right.', 'tokens': [50368, 502, 258, 10951, 486, 611, 312, 17577, 949, 291, 352, 281, 264, 3779, 4914, 11, 558, 13, 50618], 'temperature': 0.0, 'avg_logprob': -0.13982521722076136, 'compression_ratio': 1.8264462809917354, 'no_speech_prob': 0.01308395154774189}, {'id': 152, 'seek': 88110, 'start': 886.1800000000001, 'end': 893.1800000000001, 'text': ' So, what do you put in the i plus 1 th instruction has to be, you have to be careful about it.', 'tokens': [50618, 407, 11, 437, 360, 291, 829, 294, 264, 741, 1804, 502, 258, 10951, 575, 281, 312, 11, 291, 362, 281, 312, 5026, 466, 309, 13, 50968], 'temperature': 0.0, 'avg_logprob': -0.13982521722076136, 'compression_ratio': 1.8264462809917354, 'no_speech_prob': 0.01308395154774189}, {'id': 153, 'seek': 88110, 'start': 893.1800000000001, 'end': 897.5400000000001, 'text': ' That has to be the instruction which you anyway have to execute irrespective of whether the', 'tokens': [50968, 663, 575, 281, 312, 264, 10951, 597, 291, 4033, 362, 281, 14483, 3418, 19575, 488, 295, 1968, 264, 51186], 'temperature': 0.0, 'avg_logprob': -0.13982521722076136, 'compression_ratio': 1.8264462809917354, 'no_speech_prob': 0.01308395154774189}, {'id': 154, 'seek': 88110, 'start': 897.5400000000001, 'end': 903.66, 'text': ' branch is taken or not taken. For example, if I have an instruction above the branch', 'tokens': [51186, 9819, 307, 2726, 420, 406, 2726, 13, 1171, 1365, 11, 498, 286, 362, 364, 10951, 3673, 264, 9819, 51492], 'temperature': 0.0, 'avg_logprob': -0.13982521722076136, 'compression_ratio': 1.8264462809917354, 'no_speech_prob': 0.01308395154774189}, {'id': 155, 'seek': 88110, 'start': 903.66, 'end': 910.1600000000001, 'text': ' which is independent, right, I can possibly put it below the branch also so that i and', 'tokens': [51492, 597, 307, 6695, 11, 558, 11, 286, 393, 6264, 829, 309, 2507, 264, 9819, 611, 370, 300, 741, 293, 51817], 'temperature': 0.0, 'avg_logprob': -0.13982521722076136, 'compression_ratio': 1.8264462809917354, 'no_speech_prob': 0.01308395154774189}, {'id': 156, 'seek': 91016, 'start': 910.16, 'end': 914.56, 'text': ' i plus 1 are executed, right. That is really what we are going to talk about this rest', 'tokens': [50364, 741, 1804, 502, 366, 17577, 11, 558, 13, 663, 307, 534, 437, 321, 366, 516, 281, 751, 466, 341, 1472, 50584], 'temperature': 0.0, 'avg_logprob': -0.18244820411759194, 'compression_ratio': 1.8812785388127853, 'no_speech_prob': 0.006660066545009613}, {'id': 157, 'seek': 91016, 'start': 914.56, 'end': 918.3199999999999, 'text': ' of it is actually from a hardware perspective, not. So, what we are going to talk about is', 'tokens': [50584, 295, 309, 307, 767, 490, 257, 8837, 4585, 11, 406, 13, 407, 11, 437, 321, 366, 516, 281, 751, 466, 307, 50772], 'temperature': 0.0, 'avg_logprob': -0.18244820411759194, 'compression_ratio': 1.8812785388127853, 'no_speech_prob': 0.006660066545009613}, {'id': 158, 'seek': 91016, 'start': 918.3199999999999, 'end': 923.36, 'text': ' what we call as delayed branching. In delayed branching what we have is that you are designing', 'tokens': [50772, 437, 321, 818, 382, 20268, 9819, 278, 13, 682, 20268, 9819, 278, 437, 321, 362, 307, 300, 291, 366, 14685, 51024], 'temperature': 0.0, 'avg_logprob': -0.18244820411759194, 'compression_ratio': 1.8812785388127853, 'no_speech_prob': 0.006660066545009613}, {'id': 159, 'seek': 91016, 'start': 923.36, 'end': 929.64, 'text': ' a hardware so that irrespective of what happens to the branch instruction, the instruction', 'tokens': [51024, 257, 8837, 370, 300, 3418, 19575, 488, 295, 437, 2314, 281, 264, 9819, 10951, 11, 264, 10951, 51338], 'temperature': 0.0, 'avg_logprob': -0.18244820411759194, 'compression_ratio': 1.8812785388127853, 'no_speech_prob': 0.006660066545009613}, {'id': 160, 'seek': 91016, 'start': 929.64, 'end': 935.04, 'text': ' following the branch is also executed. Question?', 'tokens': [51338, 3480, 264, 9819, 307, 611, 17577, 13, 14464, 30, 51608], 'temperature': 0.0, 'avg_logprob': -0.18244820411759194, 'compression_ratio': 1.8812785388127853, 'no_speech_prob': 0.006660066545009613}, {'id': 161, 'seek': 93504, 'start': 935.04, 'end': 942.04, 'text': ' Sure. Yeah.', 'tokens': [50364, 4894, 13, 865, 13, 50714], 'temperature': 0.0, 'avg_logprob': -0.6553737826463653, 'compression_ratio': 1.21875, 'no_speech_prob': 0.5515344142913818}, {'id': 162, 'seek': 93504, 'start': 942.04, 'end': 946.04, 'text': ' Question? Do that.', 'tokens': [50714, 14464, 30, 1144, 300, 13, 50914], 'temperature': 0.0, 'avg_logprob': -0.6553737826463653, 'compression_ratio': 1.21875, 'no_speech_prob': 0.5515344142913818}, {'id': 163, 'seek': 93504, 'start': 946.04, 'end': 949.04, 'text': ' Question? Sorry.', 'tokens': [50914, 14464, 30, 4919, 13, 51064], 'temperature': 0.0, 'avg_logprob': -0.6553737826463653, 'compression_ratio': 1.21875, 'no_speech_prob': 0.5515344142913818}, {'id': 164, 'seek': 93504, 'start': 949.04, 'end': 959.04, 'text': ' Question? Yeah, right. In this example is what you', 'tokens': [51064, 14464, 30, 865, 11, 558, 13, 682, 341, 1365, 307, 437, 291, 51564], 'temperature': 0.0, 'avg_logprob': -0.6553737826463653, 'compression_ratio': 1.21875, 'no_speech_prob': 0.5515344142913818}, {'id': 165, 'seek': 93504, 'start': 959.04, 'end': 960.04, 'text': ' are talking about.', 'tokens': [51564, 366, 1417, 466, 13, 51614], 'temperature': 0.0, 'avg_logprob': -0.6553737826463653, 'compression_ratio': 1.21875, 'no_speech_prob': 0.5515344142913818}, {'id': 166, 'seek': 96004, 'start': 960.04, 'end': 967.04, 'text': ' Yeah, I was talking about this example. So, here let us say I have the first instruction', 'tokens': [50364, 865, 11, 286, 390, 1417, 466, 341, 1365, 13, 407, 11, 510, 718, 505, 584, 286, 362, 264, 700, 10951, 50714], 'temperature': 0.0, 'avg_logprob': -0.27103393142287796, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.06551478803157806}, {'id': 167, 'seek': 96004, 'start': 967.04, 'end': 974.04, 'text': ' and later I have the branch instruction. So, you said that in a branch instruction if you', 'tokens': [50714, 293, 1780, 286, 362, 264, 9819, 10951, 13, 407, 11, 291, 848, 300, 294, 257, 9819, 10951, 498, 291, 51064], 'temperature': 0.0, 'avg_logprob': -0.27103393142287796, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.06551478803157806}, {'id': 168, 'seek': 96004, 'start': 974.04, 'end': 975.64, 'text': ' go to the right side. Just hold on to your question for a few minutes,', 'tokens': [51064, 352, 281, 264, 558, 1252, 13, 1449, 1797, 322, 281, 428, 1168, 337, 257, 1326, 2077, 11, 51144], 'temperature': 0.0, 'avg_logprob': -0.27103393142287796, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.06551478803157806}, {'id': 169, 'seek': 96004, 'start': 975.64, 'end': 980.52, 'text': ' we will come to it because I want you to first understand what delayed branching is and exactly', 'tokens': [51144, 321, 486, 808, 281, 309, 570, 286, 528, 291, 281, 700, 1223, 437, 20268, 9819, 278, 307, 293, 2293, 51388], 'temperature': 0.0, 'avg_logprob': -0.27103393142287796, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.06551478803157806}, {'id': 170, 'seek': 96004, 'start': 980.52, 'end': 985.52, 'text': ' what I am going to do I will show you, right. So, hold on to your question for a second.', 'tokens': [51388, 437, 286, 669, 516, 281, 360, 286, 486, 855, 291, 11, 558, 13, 407, 11, 1797, 322, 281, 428, 1168, 337, 257, 1150, 13, 51638], 'temperature': 0.0, 'avg_logprob': -0.27103393142287796, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.06551478803157806}, {'id': 171, 'seek': 98552, 'start': 986.52, 'end': 991.52, 'text': ' So, let us skip this, let us go here, right. My animation is probably little bit messed', 'tokens': [50414, 407, 11, 718, 505, 10023, 341, 11, 718, 505, 352, 510, 11, 558, 13, 1222, 9603, 307, 1391, 707, 857, 16507, 50664], 'temperature': 0.0, 'avg_logprob': -0.19131649745984025, 'compression_ratio': 1.794871794871795, 'no_speech_prob': 0.30411916971206665}, {'id': 172, 'seek': 98552, 'start': 991.52, 'end': 996.52, 'text': ' up, but let us see. Supposing let us say I have the following sequence of instructions,', 'tokens': [50664, 493, 11, 457, 718, 505, 536, 13, 9391, 6110, 718, 505, 584, 286, 362, 264, 3480, 8310, 295, 9415, 11, 50914], 'temperature': 0.0, 'avg_logprob': -0.19131649745984025, 'compression_ratio': 1.794871794871795, 'no_speech_prob': 0.30411916971206665}, {'id': 173, 'seek': 98552, 'start': 996.52, 'end': 1002.52, 'text': ' right. There is an add instruction, there is a branch instruction, right. This branch', 'tokens': [50914, 558, 13, 821, 307, 364, 909, 10951, 11, 456, 307, 257, 9819, 10951, 11, 558, 13, 639, 9819, 51214], 'temperature': 0.0, 'avg_logprob': -0.19131649745984025, 'compression_ratio': 1.794871794871795, 'no_speech_prob': 0.30411916971206665}, {'id': 174, 'seek': 98552, 'start': 1002.52, 'end': 1009.52, 'text': ' instruction uses the value of R1 and R1 is not being written by this instruction, right.', 'tokens': [51214, 10951, 4960, 264, 2158, 295, 497, 16, 293, 497, 16, 307, 406, 885, 3720, 538, 341, 10951, 11, 558, 13, 51564], 'temperature': 0.0, 'avg_logprob': -0.19131649745984025, 'compression_ratio': 1.794871794871795, 'no_speech_prob': 0.30411916971206665}, {'id': 175, 'seek': 100952, 'start': 1010.52, 'end': 1016.52, 'text': ' Now, my hardware is that if the branch instruction is executed, the instruction following the', 'tokens': [50414, 823, 11, 452, 8837, 307, 300, 498, 264, 9819, 10951, 307, 17577, 11, 264, 10951, 3480, 264, 50714], 'temperature': 0.0, 'avg_logprob': -0.07928344456836431, 'compression_ratio': 2.0737327188940093, 'no_speech_prob': 0.017878782004117966}, {'id': 176, 'seek': 100952, 'start': 1016.52, 'end': 1021.52, 'text': ' branch is also executed before you either go to the instruction below that or go to', 'tokens': [50714, 9819, 307, 611, 17577, 949, 291, 2139, 352, 281, 264, 10951, 2507, 300, 420, 352, 281, 50964], 'temperature': 0.0, 'avg_logprob': -0.07928344456836431, 'compression_ratio': 2.0737327188940093, 'no_speech_prob': 0.017878782004117966}, {'id': 177, 'seek': 100952, 'start': 1021.52, 'end': 1026.52, 'text': ' this location out, right. So, this is how my hardware behaves, right. Hardware has been', 'tokens': [50964, 341, 4914, 484, 11, 558, 13, 407, 11, 341, 307, 577, 452, 8837, 36896, 11, 558, 13, 11817, 3039, 575, 668, 51214], 'temperature': 0.0, 'avg_logprob': -0.07928344456836431, 'compression_ratio': 2.0737327188940093, 'no_speech_prob': 0.017878782004117966}, {'id': 178, 'seek': 100952, 'start': 1026.52, 'end': 1031.52, 'text': ' changed such that not only the branch instruction, but the instruction following the branch is', 'tokens': [51214, 3105, 1270, 300, 406, 787, 264, 9819, 10951, 11, 457, 264, 10951, 3480, 264, 9819, 307, 51464], 'temperature': 0.0, 'avg_logprob': -0.07928344456836431, 'compression_ratio': 2.0737327188940093, 'no_speech_prob': 0.017878782004117966}, {'id': 179, 'seek': 100952, 'start': 1031.52, 'end': 1037.52, 'text': ' also being executed irrespective of whether the condition is satisfied or not. That means', 'tokens': [51464, 611, 885, 17577, 3418, 19575, 488, 295, 1968, 264, 4188, 307, 11239, 420, 406, 13, 663, 1355, 51764], 'temperature': 0.0, 'avg_logprob': -0.07928344456836431, 'compression_ratio': 2.0737327188940093, 'no_speech_prob': 0.017878782004117966}, {'id': 180, 'seek': 103752, 'start': 1037.52, 'end': 1042.52, 'text': ' that you react somewhat slowly to the branch, right. That is why it is called delayed branching.', 'tokens': [50364, 300, 291, 4515, 8344, 5692, 281, 264, 9819, 11, 558, 13, 663, 307, 983, 309, 307, 1219, 20268, 9819, 278, 13, 50614], 'temperature': 0.0, 'avg_logprob': -0.09243428932045991, 'compression_ratio': 2.2741116751269037, 'no_speech_prob': 0.0021437318064272404}, {'id': 181, 'seek': 103752, 'start': 1042.52, 'end': 1048.52, 'text': ' You are not going to jump immediately after the branch. You are going to jump one instruction', 'tokens': [50614, 509, 366, 406, 516, 281, 3012, 4258, 934, 264, 9819, 13, 509, 366, 516, 281, 3012, 472, 10951, 50914], 'temperature': 0.0, 'avg_logprob': -0.09243428932045991, 'compression_ratio': 2.2741116751269037, 'no_speech_prob': 0.0021437318064272404}, {'id': 182, 'seek': 103752, 'start': 1048.52, 'end': 1052.52, 'text': ' after means one instruction. You are going to execute one more instruction before you', 'tokens': [50914, 934, 1355, 472, 10951, 13, 509, 366, 516, 281, 14483, 472, 544, 10951, 949, 291, 51114], 'temperature': 0.0, 'avg_logprob': -0.09243428932045991, 'compression_ratio': 2.2741116751269037, 'no_speech_prob': 0.0021437318064272404}, {'id': 183, 'seek': 103752, 'start': 1052.52, 'end': 1057.52, 'text': ' take the branch. That is why it is called delayed branching. So, in delayed branching,', 'tokens': [51114, 747, 264, 9819, 13, 663, 307, 983, 309, 307, 1219, 20268, 9819, 278, 13, 407, 11, 294, 20268, 9819, 278, 11, 51364], 'temperature': 0.0, 'avg_logprob': -0.09243428932045991, 'compression_ratio': 2.2741116751269037, 'no_speech_prob': 0.0021437318064272404}, {'id': 184, 'seek': 103752, 'start': 1057.52, 'end': 1062.52, 'text': ' if the ith instruction is a branch, the i plus oneth instruction is always executed,', 'tokens': [51364, 498, 264, 309, 71, 10951, 307, 257, 9819, 11, 264, 741, 1804, 322, 3293, 10951, 307, 1009, 17577, 11, 51614], 'temperature': 0.0, 'avg_logprob': -0.09243428932045991, 'compression_ratio': 2.2741116751269037, 'no_speech_prob': 0.0021437318064272404}, {'id': 185, 'seek': 106252, 'start': 1062.52, 'end': 1068.52, 'text': ' correct. One simple way by which I can fill the i plus oneth instruction slot is to put', 'tokens': [50364, 3006, 13, 1485, 2199, 636, 538, 597, 286, 393, 2836, 264, 741, 1804, 322, 3293, 10951, 14747, 307, 281, 829, 50664], 'temperature': 0.0, 'avg_logprob': -0.09200714629830666, 'compression_ratio': 1.7901234567901234, 'no_speech_prob': 0.018778322264552116}, {'id': 186, 'seek': 106252, 'start': 1068.52, 'end': 1074.52, 'text': ' a no op instruction. A no op instruction is a no operation dummy instruction. If I put', 'tokens': [50664, 257, 572, 999, 10951, 13, 316, 572, 999, 10951, 307, 257, 572, 6916, 35064, 10951, 13, 759, 286, 829, 50964], 'temperature': 0.0, 'avg_logprob': -0.09200714629830666, 'compression_ratio': 1.7901234567901234, 'no_speech_prob': 0.018778322264552116}, {'id': 187, 'seek': 106252, 'start': 1074.52, 'end': 1080.52, 'text': ' that, nothing will happen, correct. It will execute that instruction and then after that,', 'tokens': [50964, 300, 11, 1825, 486, 1051, 11, 3006, 13, 467, 486, 14483, 300, 10951, 293, 550, 934, 300, 11, 51264], 'temperature': 0.0, 'avg_logprob': -0.09200714629830666, 'compression_ratio': 1.7901234567901234, 'no_speech_prob': 0.018778322264552116}, {'id': 188, 'seek': 106252, 'start': 1080.52, 'end': 1084.52, 'text': ' it either branches to the target location or continue its execution from that. That', 'tokens': [51264, 309, 2139, 14770, 281, 264, 3779, 4914, 420, 2354, 1080, 15058, 490, 300, 13, 663, 51464], 'temperature': 0.0, 'avg_logprob': -0.09200714629830666, 'compression_ratio': 1.7901234567901234, 'no_speech_prob': 0.018778322264552116}, {'id': 189, 'seek': 106252, 'start': 1084.52, 'end': 1089.52, 'text': ' is a very simple thing to do, but what have I achieved by that? Really nothing because', 'tokens': [51464, 307, 257, 588, 2199, 551, 281, 360, 11, 457, 437, 362, 286, 11042, 538, 300, 30, 4083, 1825, 570, 51714], 'temperature': 0.0, 'avg_logprob': -0.09200714629830666, 'compression_ratio': 1.7901234567901234, 'no_speech_prob': 0.018778322264552116}, {'id': 190, 'seek': 108952, 'start': 1089.52, 'end': 1095.52, 'text': ' no op instruction is a wasteful instruction. Instead of having a stall, I executed a wasteful', 'tokens': [50364, 572, 999, 10951, 307, 257, 5964, 906, 10951, 13, 7156, 295, 1419, 257, 19633, 11, 286, 17577, 257, 5964, 906, 50664], 'temperature': 0.0, 'avg_logprob': -0.07733004926198936, 'compression_ratio': 1.8020304568527918, 'no_speech_prob': 0.028739480301737785}, {'id': 191, 'seek': 108952, 'start': 1095.52, 'end': 1101.52, 'text': ' instruction which is equivalent to having a stall, correct. But instead of putting a', 'tokens': [50664, 10951, 597, 307, 10344, 281, 1419, 257, 19633, 11, 3006, 13, 583, 2602, 295, 3372, 257, 50964], 'temperature': 0.0, 'avg_logprob': -0.07733004926198936, 'compression_ratio': 1.8020304568527918, 'no_speech_prob': 0.028739480301737785}, {'id': 192, 'seek': 108952, 'start': 1101.52, 'end': 1108.52, 'text': ' no op, let us say in this example, if I can pull this instruction down and put it over', 'tokens': [50964, 572, 999, 11, 718, 505, 584, 294, 341, 1365, 11, 498, 286, 393, 2235, 341, 10951, 760, 293, 829, 309, 670, 51314], 'temperature': 0.0, 'avg_logprob': -0.07733004926198936, 'compression_ratio': 1.8020304568527918, 'no_speech_prob': 0.028739480301737785}, {'id': 193, 'seek': 108952, 'start': 1108.52, 'end': 1114.52, 'text': ' here because there is no dependency that I am violating, right, this instruction produces', 'tokens': [51314, 510, 570, 456, 307, 572, 33621, 300, 286, 669, 42201, 11, 558, 11, 341, 10951, 14725, 51614], 'temperature': 0.0, 'avg_logprob': -0.07733004926198936, 'compression_ratio': 1.8020304568527918, 'no_speech_prob': 0.028739480301737785}, {'id': 194, 'seek': 111452, 'start': 1114.52, 'end': 1120.52, 'text': ' a value in R3. This instruction is not dependent on that. If I pull this instruction below', 'tokens': [50364, 257, 2158, 294, 497, 18, 13, 639, 10951, 307, 406, 12334, 322, 300, 13, 759, 286, 2235, 341, 10951, 2507, 50664], 'temperature': 0.0, 'avg_logprob': -0.0940472833041487, 'compression_ratio': 1.7794117647058822, 'no_speech_prob': 0.04925543814897537}, {'id': 195, 'seek': 111452, 'start': 1120.52, 'end': 1127.52, 'text': ' and if I execute that, then I can have delayed branching. This branch can execute the instruction', 'tokens': [50664, 293, 498, 286, 14483, 300, 11, 550, 286, 393, 362, 20268, 9819, 278, 13, 639, 9819, 393, 14483, 264, 10951, 51014], 'temperature': 0.0, 'avg_logprob': -0.0940472833041487, 'compression_ratio': 1.7794117647058822, 'no_speech_prob': 0.04925543814897537}, {'id': 196, 'seek': 111452, 'start': 1128.52, 'end': 1133.52, 'text': ' following that can also execute and after that depending on the condition, either I', 'tokens': [51064, 3480, 300, 393, 611, 14483, 293, 934, 300, 5413, 322, 264, 4188, 11, 2139, 286, 51314], 'temperature': 0.0, 'avg_logprob': -0.0940472833041487, 'compression_ratio': 1.7794117647058822, 'no_speech_prob': 0.04925543814897537}, {'id': 197, 'seek': 111452, 'start': 1133.52, 'end': 1140.52, 'text': ' can follow that location or I can go to the target, correct. That is fine. So, my hardware', 'tokens': [51314, 393, 1524, 300, 4914, 420, 286, 393, 352, 281, 264, 3779, 11, 3006, 13, 663, 307, 2489, 13, 407, 11, 452, 8837, 51664], 'temperature': 0.0, 'avg_logprob': -0.0940472833041487, 'compression_ratio': 1.7794117647058822, 'no_speech_prob': 0.04925543814897537}, {'id': 198, 'seek': 114052, 'start': 1141.52, 'end': 1147.52, 'text': ' essentially allows me to, I mean hardware essentially says that I am going to execute', 'tokens': [50414, 4476, 4045, 385, 281, 11, 286, 914, 8837, 4476, 1619, 300, 286, 669, 516, 281, 14483, 50714], 'temperature': 0.0, 'avg_logprob': -0.09608047787505801, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.007824741303920746}, {'id': 199, 'seek': 114052, 'start': 1147.52, 'end': 1152.52, 'text': ' the branch instruction and the following instruction. So, if you want to put any useful instruction', 'tokens': [50714, 264, 9819, 10951, 293, 264, 3480, 10951, 13, 407, 11, 498, 291, 528, 281, 829, 604, 4420, 10951, 50964], 'temperature': 0.0, 'avg_logprob': -0.09608047787505801, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.007824741303920746}, {'id': 200, 'seek': 114052, 'start': 1152.52, 'end': 1158.52, 'text': ' in that, go ahead and put. That is essentially what the hardware tells the compiler, okay.', 'tokens': [50964, 294, 300, 11, 352, 2286, 293, 829, 13, 663, 307, 4476, 437, 264, 8837, 5112, 264, 31958, 11, 1392, 13, 51264], 'temperature': 0.0, 'avg_logprob': -0.09608047787505801, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.007824741303920746}, {'id': 201, 'seek': 114052, 'start': 1158.52, 'end': 1164.52, 'text': ' So, unfortunately the delay slot is hiding the branch instruction. So, sorry about that,', 'tokens': [51264, 407, 11, 7015, 264, 8577, 14747, 307, 10596, 264, 9819, 10951, 13, 407, 11, 2597, 466, 300, 11, 51564], 'temperature': 0.0, 'avg_logprob': -0.09608047787505801, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.007824741303920746}, {'id': 202, 'seek': 114052, 'start': 1164.52, 'end': 1168.52, 'text': ' okay. The instruction following the branch will also be executed. The slot has to be', 'tokens': [51564, 1392, 13, 440, 10951, 3480, 264, 9819, 486, 611, 312, 17577, 13, 440, 14747, 575, 281, 312, 51764], 'temperature': 0.0, 'avg_logprob': -0.09608047787505801, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.007824741303920746}, {'id': 203, 'seek': 116852, 'start': 1168.52, 'end': 1175.52, 'text': ' one step down, okay. Now, you see the action happening, right. So, technically speaking,', 'tokens': [50364, 472, 1823, 760, 11, 1392, 13, 823, 11, 291, 536, 264, 3069, 2737, 11, 558, 13, 407, 11, 12120, 4124, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.1073464941471181, 'compression_ratio': 1.7177033492822966, 'no_speech_prob': 0.025577669963240623}, {'id': 204, 'seek': 116852, 'start': 1175.52, 'end': 1181.52, 'text': ' this should have been, let me just go back and show it to you correctly. So, let us again', 'tokens': [50714, 341, 820, 362, 668, 11, 718, 385, 445, 352, 646, 293, 855, 309, 281, 291, 8944, 13, 407, 11, 718, 505, 797, 51014], 'temperature': 0.0, 'avg_logprob': -0.1073464941471181, 'compression_ratio': 1.7177033492822966, 'no_speech_prob': 0.025577669963240623}, {'id': 205, 'seek': 116852, 'start': 1181.52, 'end': 1188.52, 'text': ' look at this. So, I have the add instruction, correct, and I have the branch instruction,', 'tokens': [51014, 574, 412, 341, 13, 407, 11, 286, 362, 264, 909, 10951, 11, 3006, 11, 293, 286, 362, 264, 9819, 10951, 11, 51364], 'temperature': 0.0, 'avg_logprob': -0.1073464941471181, 'compression_ratio': 1.7177033492822966, 'no_speech_prob': 0.025577669963240623}, {'id': 206, 'seek': 116852, 'start': 1188.52, 'end': 1195.52, 'text': ' okay, and then I have the delay slot, correct. What is the hardware ensuring? The hardware', 'tokens': [51364, 1392, 11, 293, 550, 286, 362, 264, 8577, 14747, 11, 3006, 13, 708, 307, 264, 8837, 16882, 30, 440, 8837, 51714], 'temperature': 0.0, 'avg_logprob': -0.1073464941471181, 'compression_ratio': 1.7177033492822966, 'no_speech_prob': 0.025577669963240623}, {'id': 207, 'seek': 119552, 'start': 1196.52, 'end': 1202.52, 'text': ' is ensuring that after the ith instruction, the i plus oneth instruction will always be', 'tokens': [50414, 307, 16882, 300, 934, 264, 309, 71, 10951, 11, 264, 741, 1804, 322, 3293, 10951, 486, 1009, 312, 50714], 'temperature': 0.0, 'avg_logprob': -0.16970011393229167, 'compression_ratio': 1.6687898089171975, 'no_speech_prob': 0.023645471781492233}, {'id': 208, 'seek': 119552, 'start': 1202.52, 'end': 1208.52, 'text': ' executed, correct, right. This is what the hardware is saying irrespective of whether', 'tokens': [50714, 17577, 11, 3006, 11, 558, 13, 639, 307, 437, 264, 8837, 307, 1566, 3418, 19575, 488, 295, 1968, 51014], 'temperature': 0.0, 'avg_logprob': -0.16970011393229167, 'compression_ratio': 1.6687898089171975, 'no_speech_prob': 0.023645471781492233}, {'id': 209, 'seek': 119552, 'start': 1208.52, 'end': 1215.52, 'text': ' the branch condition is satisfied or not, that instruction will always execute, correct.', 'tokens': [51014, 264, 9819, 4188, 307, 11239, 420, 406, 11, 300, 10951, 486, 1009, 14483, 11, 3006, 13, 51364], 'temperature': 0.0, 'avg_logprob': -0.16970011393229167, 'compression_ratio': 1.6687898089171975, 'no_speech_prob': 0.023645471781492233}, {'id': 210, 'seek': 121552, 'start': 1215.52, 'end': 1222.52, 'text': ' Okay. So, what I am going to do is that this delay slot which is that I need to put some', 'tokens': [50364, 1033, 13, 407, 11, 437, 286, 669, 516, 281, 360, 307, 300, 341, 8577, 14747, 597, 307, 300, 286, 643, 281, 829, 512, 50714], 'temperature': 0.0, 'avg_logprob': -0.1222505914159568, 'compression_ratio': 1.8265306122448979, 'no_speech_prob': 0.005735464859753847}, {'id': 211, 'seek': 121552, 'start': 1226.24, 'end': 1232.1399999999999, 'text': ' useful instructions there. One way of doing is that take this instruction which is not', 'tokens': [50900, 4420, 9415, 456, 13, 1485, 636, 295, 884, 307, 300, 747, 341, 10951, 597, 307, 406, 51195], 'temperature': 0.0, 'avg_logprob': -0.1222505914159568, 'compression_ratio': 1.8265306122448979, 'no_speech_prob': 0.005735464859753847}, {'id': 212, 'seek': 121552, 'start': 1232.1399999999999, 'end': 1238.1399999999999, 'text': ' dependent or this branch instruction is not dependent on that and move it in this delay', 'tokens': [51195, 12334, 420, 341, 9819, 10951, 307, 406, 12334, 322, 300, 293, 1286, 309, 294, 341, 8577, 51495], 'temperature': 0.0, 'avg_logprob': -0.1222505914159568, 'compression_ratio': 1.8265306122448979, 'no_speech_prob': 0.005735464859753847}, {'id': 213, 'seek': 121552, 'start': 1238.1399999999999, 'end': 1245.1399999999999, 'text': ' slot, correct. Then what happens is that instead of having this sequence, you will have branch', 'tokens': [51495, 14747, 11, 3006, 13, 1396, 437, 2314, 307, 300, 2602, 295, 1419, 341, 8310, 11, 291, 486, 362, 9819, 51845], 'temperature': 0.0, 'avg_logprob': -0.1222505914159568, 'compression_ratio': 1.8265306122448979, 'no_speech_prob': 0.005735464859753847}, {'id': 214, 'seek': 124552, 'start': 1245.52, 'end': 1252.52, 'text': ' instruction R1 and then add R3 instruction, right. Now, if this is executed in the ith', 'tokens': [50364, 10951, 497, 16, 293, 550, 909, 497, 18, 10951, 11, 558, 13, 823, 11, 498, 341, 307, 17577, 294, 264, 309, 71, 50714], 'temperature': 0.0, 'avg_logprob': -0.17200660705566406, 'compression_ratio': 1.8429319371727748, 'no_speech_prob': 0.005917491856962442}, {'id': 215, 'seek': 124552, 'start': 1255.16, 'end': 1262.16, 'text': ' cycle and this is executed in the i plus oneth cycle, right, because of the delayed branching,', 'tokens': [50846, 6586, 293, 341, 307, 17577, 294, 264, 741, 1804, 322, 3293, 6586, 11, 558, 11, 570, 295, 264, 20268, 9819, 278, 11, 51196], 'temperature': 0.0, 'avg_logprob': -0.17200660705566406, 'compression_ratio': 1.8429319371727748, 'no_speech_prob': 0.005917491856962442}, {'id': 216, 'seek': 124552, 'start': 1262.6399999999999, 'end': 1267.36, 'text': ' you can see that the add instruction will be fetched in the next cycle and it will be', 'tokens': [51220, 291, 393, 536, 300, 264, 909, 10951, 486, 312, 23673, 292, 294, 264, 958, 6586, 293, 309, 486, 312, 51456], 'temperature': 0.0, 'avg_logprob': -0.17200660705566406, 'compression_ratio': 1.8429319371727748, 'no_speech_prob': 0.005917491856962442}, {'id': 217, 'seek': 124552, 'start': 1267.36, 'end': 1273.8799999999999, 'text': ' executed, right. And after one cycle, the branch condition would have been evaluated', 'tokens': [51456, 17577, 11, 558, 13, 400, 934, 472, 6586, 11, 264, 9819, 4188, 576, 362, 668, 25509, 51782], 'temperature': 0.0, 'avg_logprob': -0.17200660705566406, 'compression_ratio': 1.8429319371727748, 'no_speech_prob': 0.005917491856962442}, {'id': 218, 'seek': 127388, 'start': 1273.88, 'end': 1279.3600000000001, 'text': ' and you know whether you have to go to i plus 2 or to the target location out, right.', 'tokens': [50364, 293, 291, 458, 1968, 291, 362, 281, 352, 281, 741, 1804, 568, 420, 281, 264, 3779, 4914, 484, 11, 558, 13, 50638], 'temperature': 0.0, 'avg_logprob': -0.16586634318033855, 'compression_ratio': 1.6431924882629108, 'no_speech_prob': 0.0095703499391675}, {'id': 219, 'seek': 127388, 'start': 1279.3600000000001, 'end': 1285.6000000000001, 'text': ' So, after that instruction, it can jump, right. And what I have done is that this one delay', 'tokens': [50638, 407, 11, 934, 300, 10951, 11, 309, 393, 3012, 11, 558, 13, 400, 437, 286, 362, 1096, 307, 300, 341, 472, 8577, 50950], 'temperature': 0.0, 'avg_logprob': -0.16586634318033855, 'compression_ratio': 1.6431924882629108, 'no_speech_prob': 0.0095703499391675}, {'id': 220, 'seek': 127388, 'start': 1285.6000000000001, 'end': 1291.44, 'text': ' slot that we had where a useful instruction can be filled, we have moved an instruction', 'tokens': [50950, 14747, 300, 321, 632, 689, 257, 4420, 10951, 393, 312, 6412, 11, 321, 362, 4259, 364, 10951, 51242], 'temperature': 0.0, 'avg_logprob': -0.16586634318033855, 'compression_ratio': 1.6431924882629108, 'no_speech_prob': 0.0095703499391675}, {'id': 221, 'seek': 127388, 'start': 1291.44, 'end': 1298.44, 'text': ' and moved it down, correct. Now, does that answer your question? This is the kind of', 'tokens': [51242, 293, 4259, 309, 760, 11, 3006, 13, 823, 11, 775, 300, 1867, 428, 1168, 30, 639, 307, 264, 733, 295, 51592], 'temperature': 0.0, 'avg_logprob': -0.16586634318033855, 'compression_ratio': 1.6431924882629108, 'no_speech_prob': 0.0095703499391675}, {'id': 222, 'seek': 129844, 'start': 1299.0, 'end': 1306.0, 'text': ' delay slot that you want to fill in. Now, these are two independent things, right.', 'tokens': [50392, 8577, 14747, 300, 291, 528, 281, 2836, 294, 13, 823, 11, 613, 366, 732, 6695, 721, 11, 558, 13, 50742], 'temperature': 0.0, 'avg_logprob': -0.2028071556562259, 'compression_ratio': 1.751269035532995, 'no_speech_prob': 0.008517029695212841}, {'id': 223, 'seek': 129844, 'start': 1309.1200000000001, 'end': 1312.44, 'text': ' Sometimes you can move a branch instruction between a load instruction and a dependent', 'tokens': [50898, 4803, 291, 393, 1286, 257, 9819, 10951, 1296, 257, 3677, 10951, 293, 257, 12334, 51064], 'temperature': 0.0, 'avg_logprob': -0.2028071556562259, 'compression_ratio': 1.751269035532995, 'no_speech_prob': 0.008517029695212841}, {'id': 224, 'seek': 129844, 'start': 1312.44, 'end': 1317.28, 'text': ' instruction to take care of both of them. But if you have a branch instruction and if', 'tokens': [51064, 10951, 281, 747, 1127, 295, 1293, 295, 552, 13, 583, 498, 291, 362, 257, 9819, 10951, 293, 498, 51306], 'temperature': 0.0, 'avg_logprob': -0.2028071556562259, 'compression_ratio': 1.751269035532995, 'no_speech_prob': 0.008517029695212841}, {'id': 225, 'seek': 129844, 'start': 1317.28, 'end': 1321.8600000000001, 'text': ' delayed branching is supported, may not even have to be a load instruction, it can be any', 'tokens': [51306, 20268, 9819, 278, 307, 8104, 11, 815, 406, 754, 362, 281, 312, 257, 3677, 10951, 11, 309, 393, 312, 604, 51535], 'temperature': 0.0, 'avg_logprob': -0.2028071556562259, 'compression_ratio': 1.751269035532995, 'no_speech_prob': 0.008517029695212841}, {'id': 226, 'seek': 132186, 'start': 1321.86, 'end': 1327.58, 'text': ' other instruction also which can be moved, okay. That is really what we are talking,', 'tokens': [50364, 661, 10951, 611, 597, 393, 312, 4259, 11, 1392, 13, 663, 307, 534, 437, 321, 366, 1417, 11, 50650], 'temperature': 0.0, 'avg_logprob': -0.18947741064694848, 'compression_ratio': 1.7854077253218885, 'no_speech_prob': 0.006311781704425812}, {'id': 227, 'seek': 132186, 'start': 1327.58, 'end': 1332.3, 'text': ' okay, all right. So, this animation was a little bit messed up. That is why you do not', 'tokens': [50650, 1392, 11, 439, 558, 13, 407, 11, 341, 9603, 390, 257, 707, 857, 16507, 493, 13, 663, 307, 983, 291, 360, 406, 50886], 'temperature': 0.0, 'avg_logprob': -0.18947741064694848, 'compression_ratio': 1.7854077253218885, 'no_speech_prob': 0.006311781704425812}, {'id': 228, 'seek': 132186, 'start': 1332.3, 'end': 1336.4599999999998, 'text': ' see the things correctly. You see a sequence of two add instructions, but it should have', 'tokens': [50886, 536, 264, 721, 8944, 13, 509, 536, 257, 8310, 295, 732, 909, 9415, 11, 457, 309, 820, 362, 51094], 'temperature': 0.0, 'avg_logprob': -0.18947741064694848, 'compression_ratio': 1.7854077253218885, 'no_speech_prob': 0.006311781704425812}, {'id': 229, 'seek': 132186, 'start': 1336.4599999999998, 'end': 1340.62, 'text': ' been that this add instruction, there is a branch instruction and then subsequently an', 'tokens': [51094, 668, 300, 341, 909, 10951, 11, 456, 307, 257, 9819, 10951, 293, 550, 26514, 364, 51302], 'temperature': 0.0, 'avg_logprob': -0.18947741064694848, 'compression_ratio': 1.7854077253218885, 'no_speech_prob': 0.006311781704425812}, {'id': 230, 'seek': 132186, 'start': 1340.62, 'end': 1345.8999999999999, 'text': ' add instruction, okay. So, this way the stall cycles can be avoided.', 'tokens': [51302, 909, 10951, 11, 1392, 13, 407, 11, 341, 636, 264, 19633, 17796, 393, 312, 24890, 13, 51566], 'temperature': 0.0, 'avg_logprob': -0.18947741064694848, 'compression_ratio': 1.7854077253218885, 'no_speech_prob': 0.006311781704425812}, {'id': 231, 'seek': 134590, 'start': 1346.8200000000002, 'end': 1352.5400000000002, 'text': ' Now when you do this filling of delay slot, you can actually fill instructions from above', 'tokens': [50410, 823, 562, 291, 360, 341, 10623, 295, 8577, 14747, 11, 291, 393, 767, 2836, 9415, 490, 3673, 50696], 'temperature': 0.0, 'avg_logprob': -0.16875684714015526, 'compression_ratio': 1.7688442211055277, 'no_speech_prob': 0.015598345547914505}, {'id': 232, 'seek': 134590, 'start': 1352.5400000000002, 'end': 1359.5400000000002, 'text': ' the branch or sometimes you can also take instructions from below the branch, okay.', 'tokens': [50696, 264, 9819, 420, 2171, 291, 393, 611, 747, 9415, 490, 2507, 264, 9819, 11, 1392, 13, 51046], 'temperature': 0.0, 'avg_logprob': -0.16875684714015526, 'compression_ratio': 1.7688442211055277, 'no_speech_prob': 0.015598345547914505}, {'id': 233, 'seek': 134590, 'start': 1360.8000000000002, 'end': 1365.7800000000002, 'text': ' But you have to take instructions that do not affect the branching condition. Again,', 'tokens': [51109, 583, 291, 362, 281, 747, 9415, 300, 360, 406, 3345, 264, 9819, 278, 4188, 13, 3764, 11, 51358], 'temperature': 0.0, 'avg_logprob': -0.16875684714015526, 'compression_ratio': 1.7688442211055277, 'no_speech_prob': 0.015598345547914505}, {'id': 234, 'seek': 134590, 'start': 1365.7800000000002, 'end': 1371.3000000000002, 'text': ' it is essentially saying that we have to satisfy the dependencies. So, where do you get these', 'tokens': [51358, 309, 307, 4476, 1566, 300, 321, 362, 281, 19319, 264, 36606, 13, 407, 11, 689, 360, 291, 483, 613, 51634], 'temperature': 0.0, 'avg_logprob': -0.16875684714015526, 'compression_ratio': 1.7688442211055277, 'no_speech_prob': 0.015598345547914505}, {'id': 235, 'seek': 137130, 'start': 1371.34, 'end': 1377.7, 'text': ' instructions from? As I mentioned earlier, it could be from the target branch or from', 'tokens': [50366, 9415, 490, 30, 1018, 286, 2835, 3071, 11, 309, 727, 312, 490, 264, 3779, 9819, 420, 490, 50684], 'temperature': 0.0, 'avg_logprob': -0.23403294881184897, 'compression_ratio': 1.6027397260273972, 'no_speech_prob': 0.008555321954190731}, {'id': 236, 'seek': 137130, 'start': 1377.7, 'end': 1383.34, 'text': ' the fall through, okay, or from above. Any of these things is possible. I do not know', 'tokens': [50684, 264, 2100, 807, 11, 1392, 11, 420, 490, 3673, 13, 2639, 295, 613, 721, 307, 1944, 13, 286, 360, 406, 458, 50966], 'temperature': 0.0, 'avg_logprob': -0.23403294881184897, 'compression_ratio': 1.6027397260273972, 'no_speech_prob': 0.008555321954190731}, {'id': 237, 'seek': 137130, 'start': 1383.34, 'end': 1388.34, 'text': ' whether I have an example for this, but if you want, I can always say this thing, okay.', 'tokens': [50966, 1968, 286, 362, 364, 1365, 337, 341, 11, 457, 498, 291, 528, 11, 286, 393, 1009, 584, 341, 551, 11, 1392, 13, 51216], 'temperature': 0.0, 'avg_logprob': -0.23403294881184897, 'compression_ratio': 1.6027397260273972, 'no_speech_prob': 0.008555321954190731}, {'id': 238, 'seek': 137130, 'start': 1388.34, 'end': 1395.34, 'text': ' Go through this animation and the case that we discussed was one where you have from before', 'tokens': [51216, 1037, 807, 341, 9603, 293, 264, 1389, 300, 321, 7152, 390, 472, 689, 291, 362, 490, 949, 51566], 'temperature': 0.0, 'avg_logprob': -0.23403294881184897, 'compression_ratio': 1.6027397260273972, 'no_speech_prob': 0.008555321954190731}, {'id': 239, 'seek': 139534, 'start': 1395.74, 'end': 1402.74, 'text': ' the branch, right. This is because those instructions are anyway executed before the branch instruction', 'tokens': [50384, 264, 9819, 11, 558, 13, 639, 307, 570, 729, 9415, 366, 4033, 17577, 949, 264, 9819, 10951, 50734], 'temperature': 0.0, 'avg_logprob': -0.13722020149230957, 'compression_ratio': 1.8033472803347281, 'no_speech_prob': 0.00406593456864357}, {'id': 240, 'seek': 139534, 'start': 1402.74, 'end': 1408.58, 'text': ' is executed. So, if you move them down to the delay slot, it is always used, okay. But', 'tokens': [50734, 307, 17577, 13, 407, 11, 498, 291, 1286, 552, 760, 281, 264, 8577, 14747, 11, 309, 307, 1009, 1143, 11, 1392, 13, 583, 51026], 'temperature': 0.0, 'avg_logprob': -0.13722020149230957, 'compression_ratio': 1.8033472803347281, 'no_speech_prob': 0.00406593456864357}, {'id': 241, 'seek': 139534, 'start': 1408.58, 'end': 1412.86, 'text': ' you have to make sure that you are not violating any dependencies.', 'tokens': [51026, 291, 362, 281, 652, 988, 300, 291, 366, 406, 42201, 604, 36606, 13, 51240], 'temperature': 0.0, 'avg_logprob': -0.13722020149230957, 'compression_ratio': 1.8033472803347281, 'no_speech_prob': 0.00406593456864357}, {'id': 242, 'seek': 139534, 'start': 1412.86, 'end': 1417.34, 'text': ' Now if this is not possible and you do not have any independent instructions which is', 'tokens': [51240, 823, 498, 341, 307, 406, 1944, 293, 291, 360, 406, 362, 604, 6695, 9415, 597, 307, 51464], 'temperature': 0.0, 'avg_logprob': -0.13722020149230957, 'compression_ratio': 1.8033472803347281, 'no_speech_prob': 0.00406593456864357}, {'id': 243, 'seek': 139534, 'start': 1417.34, 'end': 1422.76, 'text': ' above the branch, which could be moved into the delay slot, then you can think in terms', 'tokens': [51464, 3673, 264, 9819, 11, 597, 727, 312, 4259, 666, 264, 8577, 14747, 11, 550, 291, 393, 519, 294, 2115, 51735], 'temperature': 0.0, 'avg_logprob': -0.13722020149230957, 'compression_ratio': 1.8033472803347281, 'no_speech_prob': 0.00406593456864357}, {'id': 244, 'seek': 142276, 'start': 1422.76, 'end': 1428.16, 'text': ' of taking an instruction from the target location. Remember, we were supposed to jump', 'tokens': [50364, 295, 1940, 364, 10951, 490, 264, 3779, 4914, 13, 5459, 11, 321, 645, 3442, 281, 3012, 50634], 'temperature': 0.0, 'avg_logprob': -0.13681235313415527, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.005416038446128368}, {'id': 245, 'seek': 142276, 'start': 1428.16, 'end': 1433.4, 'text': ' out whenever the condition is true, right. So, I can take the first instruction or the', 'tokens': [50634, 484, 5699, 264, 4188, 307, 2074, 11, 558, 13, 407, 11, 286, 393, 747, 264, 700, 10951, 420, 264, 50896], 'temperature': 0.0, 'avg_logprob': -0.13681235313415527, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.005416038446128368}, {'id': 246, 'seek': 142276, 'start': 1433.4, 'end': 1440.4, 'text': ' second instruction from that and I can also put it in that provided, right, certain conditions', 'tokens': [50896, 1150, 10951, 490, 300, 293, 286, 393, 611, 829, 309, 294, 300, 5649, 11, 558, 11, 1629, 4487, 51246], 'temperature': 0.0, 'avg_logprob': -0.13681235313415527, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.005416038446128368}, {'id': 247, 'seek': 142276, 'start': 1440.52, 'end': 1445.76, 'text': ' are satisfied. I have to make sure that executing that instruction does not cause any violation', 'tokens': [51252, 366, 11239, 13, 286, 362, 281, 652, 988, 300, 32368, 300, 10951, 775, 406, 3082, 604, 22840, 51514], 'temperature': 0.0, 'avg_logprob': -0.13681235313415527, 'compression_ratio': 1.7285714285714286, 'no_speech_prob': 0.005416038446128368}, {'id': 248, 'seek': 144576, 'start': 1445.76, 'end': 1452.76, 'text': ' of dependencies, okay. And that is useful only if the branch is taken more often than', 'tokens': [50364, 295, 36606, 11, 1392, 13, 400, 300, 307, 4420, 787, 498, 264, 9819, 307, 2726, 544, 2049, 813, 50714], 'temperature': 0.0, 'avg_logprob': -0.14529274094779537, 'compression_ratio': 1.8565400843881856, 'no_speech_prob': 0.009181383065879345}, {'id': 249, 'seek': 144576, 'start': 1452.92, 'end': 1458.0, 'text': ' not. If the branch is, you know, very few times it is taken, then taking an instruction', 'tokens': [50722, 406, 13, 759, 264, 9819, 307, 11, 291, 458, 11, 588, 1326, 1413, 309, 307, 2726, 11, 550, 1940, 364, 10951, 50976], 'temperature': 0.0, 'avg_logprob': -0.14529274094779537, 'compression_ratio': 1.8565400843881856, 'no_speech_prob': 0.009181383065879345}, {'id': 250, 'seek': 144576, 'start': 1458.0, 'end': 1463.2, 'text': ' from the target location and filling it up is of no use because by executing that instruction,', 'tokens': [50976, 490, 264, 3779, 4914, 293, 10623, 309, 493, 307, 295, 572, 764, 570, 538, 32368, 300, 10951, 11, 51236], 'temperature': 0.0, 'avg_logprob': -0.14529274094779537, 'compression_ratio': 1.8565400843881856, 'no_speech_prob': 0.009181383065879345}, {'id': 251, 'seek': 144576, 'start': 1463.2, 'end': 1469.7, 'text': ' I am actually doing a dummy action. When the branch is more often not taken, then I can', 'tokens': [51236, 286, 669, 767, 884, 257, 35064, 3069, 13, 1133, 264, 9819, 307, 544, 2049, 406, 2726, 11, 550, 286, 393, 51561], 'temperature': 0.0, 'avg_logprob': -0.14529274094779537, 'compression_ratio': 1.8565400843881856, 'no_speech_prob': 0.009181383065879345}, {'id': 252, 'seek': 144576, 'start': 1469.7, 'end': 1474.16, 'text': ' take an instruction from the fall through branch and I can put it in the delay slot', 'tokens': [51561, 747, 364, 10951, 490, 264, 2100, 807, 9819, 293, 286, 393, 829, 309, 294, 264, 8577, 14747, 51784], 'temperature': 0.0, 'avg_logprob': -0.14529274094779537, 'compression_ratio': 1.8565400843881856, 'no_speech_prob': 0.009181383065879345}, {'id': 253, 'seek': 147416, 'start': 1474.24, 'end': 1479.72, 'text': ' and I can do that provided again it does not violate any dependencies, okay. And this is', 'tokens': [50368, 293, 286, 393, 360, 300, 5649, 797, 309, 775, 406, 37478, 604, 36606, 11, 1392, 13, 400, 341, 307, 50642], 'temperature': 0.0, 'avg_logprob': -0.1947549951487574, 'compression_ratio': 1.669064748201439, 'no_speech_prob': 0.030999114736914635}, {'id': 254, 'seek': 147416, 'start': 1479.72, 'end': 1485.0400000000002, 'text': ' useful whenever it is more often not taken than taken. So, these are the ways by which', 'tokens': [50642, 4420, 5699, 309, 307, 544, 2049, 406, 2726, 813, 2726, 13, 407, 11, 613, 366, 264, 2098, 538, 597, 50908], 'temperature': 0.0, 'avg_logprob': -0.1947549951487574, 'compression_ratio': 1.669064748201439, 'no_speech_prob': 0.030999114736914635}, {'id': 255, 'seek': 147416, 'start': 1485.0400000000002, 'end': 1489.72, 'text': ' we can do and a compiler can actually help you to do this thing. That is why we study', 'tokens': [50908, 321, 393, 360, 293, 257, 31958, 393, 767, 854, 291, 281, 360, 341, 551, 13, 663, 307, 983, 321, 2979, 51142], 'temperature': 0.0, 'avg_logprob': -0.1947549951487574, 'compression_ratio': 1.669064748201439, 'no_speech_prob': 0.030999114736914635}, {'id': 256, 'seek': 147416, 'start': 1489.72, 'end': 1491.68, 'text': ' this here, okay.', 'tokens': [51142, 341, 510, 11, 1392, 13, 51240], 'temperature': 0.0, 'avg_logprob': -0.1947549951487574, 'compression_ratio': 1.669064748201439, 'no_speech_prob': 0.030999114736914635}, {'id': 257, 'seek': 147416, 'start': 1491.68, 'end': 1496.76, 'text': ' Now, let us move on to the next topic which is about instruction level parallelism where', 'tokens': [51240, 823, 11, 718, 505, 1286, 322, 281, 264, 958, 4829, 597, 307, 466, 10951, 1496, 8952, 1434, 689, 51494], 'temperature': 0.0, 'avg_logprob': -0.1947549951487574, 'compression_ratio': 1.669064748201439, 'no_speech_prob': 0.030999114736914635}, {'id': 258, 'seek': 147416, 'start': 1496.76, 'end': 1503.76, 'text': ' you are trying to execute more than one instruction every cycle, okay. So, here the idea is that', 'tokens': [51494, 291, 366, 1382, 281, 14483, 544, 813, 472, 10951, 633, 6586, 11, 1392, 13, 407, 11, 510, 264, 1558, 307, 300, 51844], 'temperature': 0.0, 'avg_logprob': -0.1947549951487574, 'compression_ratio': 1.669064748201439, 'no_speech_prob': 0.030999114736914635}, {'id': 259, 'seek': 150376, 'start': 1503.92, 'end': 1509.4, 'text': ' you have an instruction sequence, but from that instruction sequence you try to identify', 'tokens': [50372, 291, 362, 364, 10951, 8310, 11, 457, 490, 300, 10951, 8310, 291, 853, 281, 5876, 50646], 'temperature': 0.0, 'avg_logprob': -0.15113338769650927, 'compression_ratio': 1.8831168831168832, 'no_speech_prob': 0.0010198744712397456}, {'id': 260, 'seek': 150376, 'start': 1509.4, 'end': 1512.92, 'text': ' what are called independent instructions. Instructions which are not dependent on each', 'tokens': [50646, 437, 366, 1219, 6695, 9415, 13, 2730, 1757, 626, 597, 366, 406, 12334, 322, 1184, 50822], 'temperature': 0.0, 'avg_logprob': -0.15113338769650927, 'compression_ratio': 1.8831168831168832, 'no_speech_prob': 0.0010198744712397456}, {'id': 261, 'seek': 150376, 'start': 1512.92, 'end': 1519.92, 'text': ' other and you try to issue and execute them together in a single cycle, right. So, why', 'tokens': [50822, 661, 293, 291, 853, 281, 2734, 293, 14483, 552, 1214, 294, 257, 2167, 6586, 11, 558, 13, 407, 11, 983, 51172], 'temperature': 0.0, 'avg_logprob': -0.15113338769650927, 'compression_ratio': 1.8831168831168832, 'no_speech_prob': 0.0010198744712397456}, {'id': 262, 'seek': 150376, 'start': 1519.92, 'end': 1524.68, 'text': ' do we want to do this? We want to do this because we want to improve the throughput.', 'tokens': [51172, 360, 321, 528, 281, 360, 341, 30, 492, 528, 281, 360, 341, 570, 321, 528, 281, 3470, 264, 44629, 13, 51410], 'temperature': 0.0, 'avg_logprob': -0.15113338769650927, 'compression_ratio': 1.8831168831168832, 'no_speech_prob': 0.0010198744712397456}, {'id': 263, 'seek': 150376, 'start': 1524.68, 'end': 1529.68, 'text': ' With ideal pipelining, you get a throughput of one instruction per cycle, right. But if', 'tokens': [51410, 2022, 7157, 8489, 338, 1760, 11, 291, 483, 257, 44629, 295, 472, 10951, 680, 6586, 11, 558, 13, 583, 498, 51660], 'temperature': 0.0, 'avg_logprob': -0.15113338769650927, 'compression_ratio': 1.8831168831168832, 'no_speech_prob': 0.0010198744712397456}, {'id': 264, 'seek': 152968, 'start': 1529.68, 'end': 1533.48, 'text': ' you want to get more than one instruction per cycle, even an ideal pipeline cannot', 'tokens': [50364, 291, 528, 281, 483, 544, 813, 472, 10951, 680, 6586, 11, 754, 364, 7157, 15517, 2644, 50554], 'temperature': 0.0, 'avg_logprob': -0.136312837600708, 'compression_ratio': 1.839662447257384, 'no_speech_prob': 0.007471572607755661}, {'id': 265, 'seek': 152968, 'start': 1533.48, 'end': 1540.0, 'text': ' give that. So, an ideal superscalar processor or an ideal VLIW processor which can fetch', 'tokens': [50554, 976, 300, 13, 407, 11, 364, 7157, 37906, 9895, 289, 15321, 420, 364, 7157, 691, 48718, 54, 15321, 597, 393, 23673, 50880], 'temperature': 0.0, 'avg_logprob': -0.136312837600708, 'compression_ratio': 1.839662447257384, 'no_speech_prob': 0.007471572607755661}, {'id': 266, 'seek': 152968, 'start': 1540.0, 'end': 1545.28, 'text': ' decode and execute let us say four operations per cycle can give you an IPC or throughput', 'tokens': [50880, 979, 1429, 293, 14483, 718, 505, 584, 1451, 7705, 680, 6586, 393, 976, 291, 364, 8671, 34, 420, 44629, 51144], 'temperature': 0.0, 'avg_logprob': -0.136312837600708, 'compression_ratio': 1.839662447257384, 'no_speech_prob': 0.007471572607755661}, {'id': 267, 'seek': 152968, 'start': 1545.28, 'end': 1550.4, 'text': ' of four instructions per cycle. So, that is the reason why we want to do that. But you', 'tokens': [51144, 295, 1451, 9415, 680, 6586, 13, 407, 11, 300, 307, 264, 1778, 983, 321, 528, 281, 360, 300, 13, 583, 291, 51400], 'temperature': 0.0, 'avg_logprob': -0.136312837600708, 'compression_ratio': 1.839662447257384, 'no_speech_prob': 0.007471572607755661}, {'id': 268, 'seek': 152968, 'start': 1550.4, 'end': 1557.0800000000002, 'text': ' can only execute independent instructions in every cycle because dependent instructions', 'tokens': [51400, 393, 787, 14483, 6695, 9415, 294, 633, 6586, 570, 12334, 9415, 51734], 'temperature': 0.0, 'avg_logprob': -0.136312837600708, 'compression_ratio': 1.839662447257384, 'no_speech_prob': 0.007471572607755661}, {'id': 269, 'seek': 155708, 'start': 1557.1599999999999, 'end': 1561.6799999999998, 'text': ' have to be delayed by appropriately so that the dependences are satisfied, okay.', 'tokens': [50368, 362, 281, 312, 20268, 538, 23505, 370, 300, 264, 5672, 2667, 366, 11239, 11, 1392, 13, 50594], 'temperature': 0.0, 'avg_logprob': -0.1786863265498992, 'compression_ratio': 1.7233201581027668, 'no_speech_prob': 0.04978756606578827}, {'id': 270, 'seek': 155708, 'start': 1561.6799999999998, 'end': 1566.84, 'text': ' Now, how do we identify these independent instructions which can be issued and executed', 'tokens': [50594, 823, 11, 577, 360, 321, 5876, 613, 6695, 9415, 597, 393, 312, 14379, 293, 17577, 50852], 'temperature': 0.0, 'avg_logprob': -0.1786863265498992, 'compression_ratio': 1.7233201581027668, 'no_speech_prob': 0.04978756606578827}, {'id': 271, 'seek': 155708, 'start': 1566.84, 'end': 1572.84, 'text': ' together? That is the question, right. In superscalar processors, this is done by the', 'tokens': [50852, 1214, 30, 663, 307, 264, 1168, 11, 558, 13, 682, 37906, 9895, 289, 27751, 11, 341, 307, 1096, 538, 264, 51152], 'temperature': 0.0, 'avg_logprob': -0.1786863265498992, 'compression_ratio': 1.7233201581027668, 'no_speech_prob': 0.04978756606578827}, {'id': 272, 'seek': 155708, 'start': 1572.84, 'end': 1578.96, 'text': ' hardware. Hardware is presented a sequence of instructions. It fetches four instructions', 'tokens': [51152, 8837, 13, 11817, 3039, 307, 8212, 257, 8310, 295, 9415, 13, 467, 15136, 3781, 1451, 9415, 51458], 'temperature': 0.0, 'avg_logprob': -0.1786863265498992, 'compression_ratio': 1.7233201581027668, 'no_speech_prob': 0.04978756606578827}, {'id': 273, 'seek': 155708, 'start': 1578.96, 'end': 1584.8, 'text': ' together every cycle. It decodes this understands whether these instructions are independent', 'tokens': [51458, 1214, 633, 6586, 13, 467, 979, 4789, 341, 15146, 1968, 613, 9415, 366, 6695, 51750], 'temperature': 0.0, 'avg_logprob': -0.1786863265498992, 'compression_ratio': 1.7233201581027668, 'no_speech_prob': 0.04978756606578827}, {'id': 274, 'seek': 158480, 'start': 1584.84, 'end': 1589.9199999999998, 'text': ' or not. And if they are independent, whichever instructions which are independent, it tries', 'tokens': [50366, 420, 406, 13, 400, 498, 436, 366, 6695, 11, 24123, 9415, 597, 366, 6695, 11, 309, 9898, 50620], 'temperature': 0.0, 'avg_logprob': -0.15775108337402344, 'compression_ratio': 1.8097560975609757, 'no_speech_prob': 0.011220812797546387}, {'id': 275, 'seek': 158480, 'start': 1589.9199999999998, 'end': 1596.9199999999998, 'text': ' to issue and execute them in parallel. Whereas, in VLIW processor, VLIW stands for very long', 'tokens': [50620, 281, 2734, 293, 14483, 552, 294, 8952, 13, 13813, 11, 294, 691, 48718, 54, 15321, 11, 691, 48718, 54, 7382, 337, 588, 938, 50970], 'temperature': 0.0, 'avg_logprob': -0.15775108337402344, 'compression_ratio': 1.8097560975609757, 'no_speech_prob': 0.011220812797546387}, {'id': 276, 'seek': 158480, 'start': 1597.08, 'end': 1604.08, 'text': ' instruction word. In VLIW processor, the compiler analyzes the code, identifies these independent', 'tokens': [50978, 10951, 1349, 13, 682, 691, 48718, 54, 15321, 11, 264, 31958, 6459, 12214, 264, 3089, 11, 34597, 613, 6695, 51328], 'temperature': 0.0, 'avg_logprob': -0.15775108337402344, 'compression_ratio': 1.8097560975609757, 'no_speech_prob': 0.011220812797546387}, {'id': 277, 'seek': 158480, 'start': 1604.32, 'end': 1611.32, 'text': ' instructions and puts them in parallel, okay. And the hardware essentially fetches these', 'tokens': [51340, 9415, 293, 8137, 552, 294, 8952, 11, 1392, 13, 400, 264, 8837, 4476, 15136, 3781, 613, 51690], 'temperature': 0.0, 'avg_logprob': -0.15775108337402344, 'compression_ratio': 1.8097560975609757, 'no_speech_prob': 0.011220812797546387}, {'id': 278, 'seek': 161132, 'start': 1611.48, 'end': 1617.96, 'text': ' instructions together and executes them. We are going to spend more time on understanding', 'tokens': [50372, 9415, 1214, 293, 4454, 1819, 552, 13, 492, 366, 516, 281, 3496, 544, 565, 322, 3701, 50696], 'temperature': 0.0, 'avg_logprob': -0.11429119110107422, 'compression_ratio': 1.5657894736842106, 'no_speech_prob': 0.0019104194361716509}, {'id': 279, 'seek': 161132, 'start': 1617.96, 'end': 1623.56, 'text': ' this phase of how the compiler can do that. But very briefly, we will also see what should', 'tokens': [50696, 341, 5574, 295, 577, 264, 31958, 393, 360, 300, 13, 583, 588, 10515, 11, 321, 486, 611, 536, 437, 820, 50976], 'temperature': 0.0, 'avg_logprob': -0.11429119110107422, 'compression_ratio': 1.5657894736842106, 'no_speech_prob': 0.0019104194361716509}, {'id': 280, 'seek': 161132, 'start': 1623.56, 'end': 1628.6799999999998, 'text': ' be done here, okay. So, essentially this is pictorially what happens in a superscalar', 'tokens': [50976, 312, 1096, 510, 11, 1392, 13, 407, 11, 4476, 341, 307, 2317, 284, 2270, 437, 2314, 294, 257, 37906, 9895, 289, 51232], 'temperature': 0.0, 'avg_logprob': -0.11429119110107422, 'compression_ratio': 1.5657894736842106, 'no_speech_prob': 0.0019104194361716509}, {'id': 281, 'seek': 161132, 'start': 1628.6799999999998, 'end': 1635.6799999999998, 'text': ' processor. You have a sequence of instructions, right. So, two or four of them are fetched', 'tokens': [51232, 15321, 13, 509, 362, 257, 8310, 295, 9415, 11, 558, 13, 407, 11, 732, 420, 1451, 295, 552, 366, 23673, 292, 51582], 'temperature': 0.0, 'avg_logprob': -0.11429119110107422, 'compression_ratio': 1.5657894736842106, 'no_speech_prob': 0.0019104194361716509}, {'id': 282, 'seek': 163568, 'start': 1635.68, 'end': 1642.04, 'text': ' in each cycle in the instruction fetch phase and they are put into some kind of a queue', 'tokens': [50364, 294, 1184, 6586, 294, 264, 10951, 23673, 5574, 293, 436, 366, 829, 666, 512, 733, 295, 257, 18639, 50682], 'temperature': 0.0, 'avg_logprob': -0.13405365619844603, 'compression_ratio': 1.8697478991596639, 'no_speech_prob': 0.006694415584206581}, {'id': 283, 'seek': 163568, 'start': 1642.04, 'end': 1648.28, 'text': ' where they are being decoded. So, from here to here, things happen in program order. That', 'tokens': [50682, 689, 436, 366, 885, 979, 12340, 13, 407, 11, 490, 510, 281, 510, 11, 721, 1051, 294, 1461, 1668, 13, 663, 50994], 'temperature': 0.0, 'avg_logprob': -0.13405365619844603, 'compression_ratio': 1.8697478991596639, 'no_speech_prob': 0.006694415584206581}, {'id': 284, 'seek': 163568, 'start': 1648.28, 'end': 1653.3600000000001, 'text': ' means that in whatever order the instructions are, they are actually decoded in the same', 'tokens': [50994, 1355, 300, 294, 2035, 1668, 264, 9415, 366, 11, 436, 366, 767, 979, 12340, 294, 264, 912, 51248], 'temperature': 0.0, 'avg_logprob': -0.13405365619844603, 'compression_ratio': 1.8697478991596639, 'no_speech_prob': 0.006694415584206581}, {'id': 285, 'seek': 163568, 'start': 1653.3600000000001, 'end': 1657.16, 'text': ' order. That is when you will understand what the programmer has intended. If there is a', 'tokens': [51248, 1668, 13, 663, 307, 562, 291, 486, 1223, 437, 264, 32116, 575, 10226, 13, 759, 456, 307, 257, 51438], 'temperature': 0.0, 'avg_logprob': -0.13405365619844603, 'compression_ratio': 1.8697478991596639, 'no_speech_prob': 0.006694415584206581}, {'id': 286, 'seek': 163568, 'start': 1657.16, 'end': 1662.4, 'text': ' data dependency from this instruction to this instruction, if you decode them only in that', 'tokens': [51438, 1412, 33621, 490, 341, 10951, 281, 341, 10951, 11, 498, 291, 979, 1429, 552, 787, 294, 300, 51700], 'temperature': 0.0, 'avg_logprob': -0.13405365619844603, 'compression_ratio': 1.8697478991596639, 'no_speech_prob': 0.006694415584206581}, {'id': 287, 'seek': 166240, 'start': 1662.4, 'end': 1666.68, 'text': ' order, you will understand that the dependency is from that instruction to this instruction.', 'tokens': [50364, 1668, 11, 291, 486, 1223, 300, 264, 33621, 307, 490, 300, 10951, 281, 341, 10951, 13, 50578], 'temperature': 0.0, 'avg_logprob': -0.16644299358402917, 'compression_ratio': 1.9429824561403508, 'no_speech_prob': 0.015243638306856155}, {'id': 288, 'seek': 166240, 'start': 1666.68, 'end': 1671.76, 'text': ' Otherwise, you do not know which way is the dependency, right. So, if you look at here,', 'tokens': [50578, 10328, 11, 291, 360, 406, 458, 597, 636, 307, 264, 33621, 11, 558, 13, 407, 11, 498, 291, 574, 412, 510, 11, 50832], 'temperature': 0.0, 'avg_logprob': -0.16644299358402917, 'compression_ratio': 1.9429824561403508, 'no_speech_prob': 0.015243638306856155}, {'id': 289, 'seek': 166240, 'start': 1671.76, 'end': 1675.92, 'text': ' pictorially the green instruction happens first, then the blue instruction, then the', 'tokens': [50832, 2317, 284, 2270, 264, 3092, 10951, 2314, 700, 11, 550, 264, 3344, 10951, 11, 550, 264, 51040], 'temperature': 0.0, 'avg_logprob': -0.16644299358402917, 'compression_ratio': 1.9429824561403508, 'no_speech_prob': 0.015243638306856155}, {'id': 290, 'seek': 166240, 'start': 1675.92, 'end': 1681.3200000000002, 'text': ' red instruction, gray and then the purple instruction, correct. So, that is the order', 'tokens': [51040, 2182, 10951, 11, 10855, 293, 550, 264, 9656, 10951, 11, 3006, 13, 407, 11, 300, 307, 264, 1668, 51310], 'temperature': 0.0, 'avg_logprob': -0.16644299358402917, 'compression_ratio': 1.9429824561403508, 'no_speech_prob': 0.015243638306856155}, {'id': 291, 'seek': 166240, 'start': 1681.3200000000002, 'end': 1688.3200000000002, 'text': ' in which it has to go. So, decode is done in the program order. And after you have decoded,', 'tokens': [51310, 294, 597, 309, 575, 281, 352, 13, 407, 11, 979, 1429, 307, 1096, 294, 264, 1461, 1668, 13, 400, 934, 291, 362, 979, 12340, 11, 51660], 'temperature': 0.0, 'avg_logprob': -0.16644299358402917, 'compression_ratio': 1.9429824561403508, 'no_speech_prob': 0.015243638306856155}, {'id': 292, 'seek': 168832, 'start': 1688.48, 'end': 1693.04, 'text': ' you would understand the dependencies between the instruction, the true dependencies between', 'tokens': [50372, 291, 576, 1223, 264, 36606, 1296, 264, 10951, 11, 264, 2074, 36606, 1296, 50600], 'temperature': 0.0, 'avg_logprob': -0.13206782406323578, 'compression_ratio': 2.0451977401129944, 'no_speech_prob': 0.008218290284276009}, {'id': 293, 'seek': 168832, 'start': 1693.04, 'end': 1698.72, 'text': ' the instruction. For example, in this case, the gray instruction is dependent both on', 'tokens': [50600, 264, 10951, 13, 1171, 1365, 11, 294, 341, 1389, 11, 264, 10855, 10951, 307, 12334, 1293, 322, 50884], 'temperature': 0.0, 'avg_logprob': -0.13206782406323578, 'compression_ratio': 2.0451977401129944, 'no_speech_prob': 0.008218290284276009}, {'id': 294, 'seek': 168832, 'start': 1698.72, 'end': 1705.08, 'text': ' the green and red instructions, right. And the blue instruction produces some value which', 'tokens': [50884, 264, 3092, 293, 2182, 9415, 11, 558, 13, 400, 264, 3344, 10951, 14725, 512, 2158, 597, 51202], 'temperature': 0.0, 'avg_logprob': -0.13206782406323578, 'compression_ratio': 2.0451977401129944, 'no_speech_prob': 0.008218290284276009}, {'id': 295, 'seek': 168832, 'start': 1705.08, 'end': 1712.12, 'text': ' is being consumed by the purple instruction, right. But the gray instruction is not dependent', 'tokens': [51202, 307, 885, 21226, 538, 264, 9656, 10951, 11, 558, 13, 583, 264, 10855, 10951, 307, 406, 12334, 51554], 'temperature': 0.0, 'avg_logprob': -0.13206782406323578, 'compression_ratio': 2.0451977401129944, 'no_speech_prob': 0.008218290284276009}, {'id': 296, 'seek': 171212, 'start': 1712.12, 'end': 1719.04, 'text': ' on the red or green. The red is not dependent on the green, right. So, given this series', 'tokens': [50364, 322, 264, 2182, 420, 3092, 13, 440, 2182, 307, 406, 12334, 322, 264, 3092, 11, 558, 13, 407, 11, 2212, 341, 2638, 50710], 'temperature': 0.0, 'avg_logprob': -0.12869509061177573, 'compression_ratio': 1.8112244897959184, 'no_speech_prob': 0.02631181664764881}, {'id': 297, 'seek': 171212, 'start': 1719.04, 'end': 1725.8, 'text': ' of instructions which are decoded and after decode, the hardware now understands this', 'tokens': [50710, 295, 9415, 597, 366, 979, 12340, 293, 934, 979, 1429, 11, 264, 8837, 586, 15146, 341, 51048], 'temperature': 0.0, 'avg_logprob': -0.12869509061177573, 'compression_ratio': 1.8112244897959184, 'no_speech_prob': 0.02631181664764881}, {'id': 298, 'seek': 171212, 'start': 1725.8, 'end': 1731.52, 'text': ' dependence relations between them, right. The hardware tells that as soon as you are', 'tokens': [51048, 31704, 2299, 1296, 552, 11, 558, 13, 440, 8837, 5112, 300, 382, 2321, 382, 291, 366, 51334], 'temperature': 0.0, 'avg_logprob': -0.12869509061177573, 'compression_ratio': 1.8112244897959184, 'no_speech_prob': 0.02631181664764881}, {'id': 299, 'seek': 171212, 'start': 1731.52, 'end': 1738.52, 'text': ' ready, you can execute the red and green instruction, right. And similarly, you can execute the', 'tokens': [51334, 1919, 11, 291, 393, 14483, 264, 2182, 293, 3092, 10951, 11, 558, 13, 400, 14138, 11, 291, 393, 14483, 264, 51684], 'temperature': 0.0, 'avg_logprob': -0.12869509061177573, 'compression_ratio': 1.8112244897959184, 'no_speech_prob': 0.02631181664764881}, {'id': 300, 'seek': 173852, 'start': 1739.08, 'end': 1746.08, 'text': ' blue instruction also or you can execute all of these three instructions in parallel, right,', 'tokens': [50392, 3344, 10951, 611, 420, 291, 393, 14483, 439, 295, 613, 1045, 9415, 294, 8952, 11, 558, 11, 50742], 'temperature': 0.0, 'avg_logprob': -0.1449734981243427, 'compression_ratio': 1.894736842105263, 'no_speech_prob': 0.013207406736910343}, {'id': 301, 'seek': 173852, 'start': 1746.16, 'end': 1751.56, 'text': ' whenever you want. Let us say the hardware decides to execute the green instruction and', 'tokens': [50746, 5699, 291, 528, 13, 961, 505, 584, 264, 8837, 14898, 281, 14483, 264, 3092, 10951, 293, 51016], 'temperature': 0.0, 'avg_logprob': -0.1449734981243427, 'compression_ratio': 1.894736842105263, 'no_speech_prob': 0.013207406736910343}, {'id': 302, 'seek': 173852, 'start': 1751.56, 'end': 1757.8799999999999, 'text': ' blue instruction in the next cycle, right. And let us say they produce a value. Then', 'tokens': [51016, 3344, 10951, 294, 264, 958, 6586, 11, 558, 13, 400, 718, 505, 584, 436, 5258, 257, 2158, 13, 1396, 51332], 'temperature': 0.0, 'avg_logprob': -0.1449734981243427, 'compression_ratio': 1.894736842105263, 'no_speech_prob': 0.013207406736910343}, {'id': 303, 'seek': 173852, 'start': 1757.8799999999999, 'end': 1763.12, 'text': ' in the next cycle, because the blue instruction has finished executing, the purple instruction', 'tokens': [51332, 294, 264, 958, 6586, 11, 570, 264, 3344, 10951, 575, 4335, 32368, 11, 264, 9656, 10951, 51594], 'temperature': 0.0, 'avg_logprob': -0.1449734981243427, 'compression_ratio': 1.894736842105263, 'no_speech_prob': 0.013207406736910343}, {'id': 304, 'seek': 176312, 'start': 1763.12, 'end': 1770.12, 'text': ' can execute. But what about this gray instruction? It still has to wait. Why? The red instruction', 'tokens': [50364, 393, 14483, 13, 583, 437, 466, 341, 10855, 10951, 30, 467, 920, 575, 281, 1699, 13, 1545, 30, 440, 2182, 10951, 50714], 'temperature': 0.0, 'avg_logprob': -0.16961527459415388, 'compression_ratio': 1.8854166666666667, 'no_speech_prob': 0.028763851150870323}, {'id': 305, 'seek': 176312, 'start': 1771.52, 'end': 1778.52, 'text': ' has not finished its execution. So, this will wait until this red instruction finishes the', 'tokens': [50784, 575, 406, 4335, 1080, 15058, 13, 407, 11, 341, 486, 1699, 1826, 341, 2182, 10951, 23615, 264, 51134], 'temperature': 0.0, 'avg_logprob': -0.16961527459415388, 'compression_ratio': 1.8854166666666667, 'no_speech_prob': 0.028763851150870323}, {'id': 306, 'seek': 176312, 'start': 1778.56, 'end': 1784.2199999999998, 'text': ' execution. When the red instruction finishes execution, some kind of a signal is given', 'tokens': [51136, 15058, 13, 1133, 264, 2182, 10951, 23615, 15058, 11, 512, 733, 295, 257, 6358, 307, 2212, 51419], 'temperature': 0.0, 'avg_logprob': -0.16961527459415388, 'compression_ratio': 1.8854166666666667, 'no_speech_prob': 0.028763851150870323}, {'id': 307, 'seek': 176312, 'start': 1784.2199999999998, 'end': 1790.1599999999999, 'text': ' and the hardware figures out that the gray instruction is now ready for execution. So,', 'tokens': [51419, 293, 264, 8837, 9624, 484, 300, 264, 10855, 10951, 307, 586, 1919, 337, 15058, 13, 407, 11, 51716], 'temperature': 0.0, 'avg_logprob': -0.16961527459415388, 'compression_ratio': 1.8854166666666667, 'no_speech_prob': 0.028763851150870323}, {'id': 308, 'seek': 179016, 'start': 1790.16, 'end': 1797.16, 'text': ' in this what happens is that the instructions are decoded in program order and their dependencies', 'tokens': [50364, 294, 341, 437, 2314, 307, 300, 264, 9415, 366, 979, 12340, 294, 1461, 1668, 293, 641, 36606, 50714], 'temperature': 0.0, 'avg_logprob': -0.1558499662843469, 'compression_ratio': 1.945945945945946, 'no_speech_prob': 0.0501956082880497}, {'id': 309, 'seek': 179016, 'start': 1797.92, 'end': 1802.72, 'text': ' and they are stored in what is called the instruction window. And in the instruction', 'tokens': [50752, 293, 436, 366, 12187, 294, 437, 307, 1219, 264, 10951, 4910, 13, 400, 294, 264, 10951, 50992], 'temperature': 0.0, 'avg_logprob': -0.1558499662843469, 'compression_ratio': 1.945945945945946, 'no_speech_prob': 0.0501956082880497}, {'id': 310, 'seek': 179016, 'start': 1802.72, 'end': 1809.0400000000002, 'text': ' window, we understand the dependencies between these instructions, correct. And whenever', 'tokens': [50992, 4910, 11, 321, 1223, 264, 36606, 1296, 613, 9415, 11, 3006, 13, 400, 5699, 51308], 'temperature': 0.0, 'avg_logprob': -0.1558499662843469, 'compression_ratio': 1.945945945945946, 'no_speech_prob': 0.0501956082880497}, {'id': 311, 'seek': 179016, 'start': 1809.0400000000002, 'end': 1815.28, 'text': ' instructions have all their data operands available, they can be issued to the execution', 'tokens': [51308, 9415, 362, 439, 641, 1412, 2208, 2967, 2435, 11, 436, 393, 312, 14379, 281, 264, 15058, 51620], 'temperature': 0.0, 'avg_logprob': -0.1558499662843469, 'compression_ratio': 1.945945945945946, 'no_speech_prob': 0.0501956082880497}, {'id': 312, 'seek': 181528, 'start': 1815.28, 'end': 1822.28, 'text': ' unit, right, and they can be executed, right. And after they finish execution, right, to', 'tokens': [50364, 4985, 11, 558, 11, 293, 436, 393, 312, 17577, 11, 558, 13, 400, 934, 436, 2413, 15058, 11, 558, 11, 281, 50714], 'temperature': 0.0, 'avg_logprob': -0.15612530413969064, 'compression_ratio': 2.064327485380117, 'no_speech_prob': 0.051780398935079575}, {'id': 313, 'seek': 181528, 'start': 1826.08, 'end': 1832.28, 'text': ' the dependent instructions, they send the data value or they send some kind of a signal,', 'tokens': [50904, 264, 12334, 9415, 11, 436, 2845, 264, 1412, 2158, 420, 436, 2845, 512, 733, 295, 257, 6358, 11, 51214], 'temperature': 0.0, 'avg_logprob': -0.15612530413969064, 'compression_ratio': 2.064327485380117, 'no_speech_prob': 0.051780398935079575}, {'id': 314, 'seek': 181528, 'start': 1832.28, 'end': 1837.24, 'text': ' so that the gray instruction can figure out that the green has finished execution or the', 'tokens': [51214, 370, 300, 264, 10855, 10951, 393, 2573, 484, 300, 264, 3092, 575, 4335, 15058, 420, 264, 51462], 'temperature': 0.0, 'avg_logprob': -0.15612530413969064, 'compression_ratio': 2.064327485380117, 'no_speech_prob': 0.051780398935079575}, {'id': 315, 'seek': 181528, 'start': 1837.24, 'end': 1842.72, 'text': ' red has finished execution or when all of them has finished execution, the gray itself', 'tokens': [51462, 2182, 575, 4335, 15058, 420, 562, 439, 295, 552, 575, 4335, 15058, 11, 264, 10855, 2564, 51736], 'temperature': 0.0, 'avg_logprob': -0.15612530413969064, 'compression_ratio': 2.064327485380117, 'no_speech_prob': 0.051780398935079575}, {'id': 316, 'seek': 184272, 'start': 1842.72, 'end': 1849.72, 'text': ' can go for execution, right. And then after that, the values of each of these instructions', 'tokens': [50364, 393, 352, 337, 15058, 11, 558, 13, 400, 550, 934, 300, 11, 264, 4190, 295, 1184, 295, 613, 9415, 50714], 'temperature': 0.0, 'avg_logprob': -0.1772787254976939, 'compression_ratio': 1.803030303030303, 'no_speech_prob': 0.007997465319931507}, {'id': 317, 'seek': 184272, 'start': 1850.68, 'end': 1856.32, 'text': ' are written in the destination location again in program order. This is again important.', 'tokens': [50762, 366, 3720, 294, 264, 12236, 4914, 797, 294, 1461, 1668, 13, 639, 307, 797, 1021, 13, 51044], 'temperature': 0.0, 'avg_logprob': -0.1772787254976939, 'compression_ratio': 1.803030303030303, 'no_speech_prob': 0.007997465319931507}, {'id': 318, 'seek': 184272, 'start': 1856.32, 'end': 1863.32, 'text': ' Remember, they are decoded in program order. They are issued possibly out of program order,', 'tokens': [51044, 5459, 11, 436, 366, 979, 12340, 294, 1461, 1668, 13, 814, 366, 14379, 6264, 484, 295, 1461, 1668, 11, 51394], 'temperature': 0.0, 'avg_logprob': -0.1772787254976939, 'compression_ratio': 1.803030303030303, 'no_speech_prob': 0.007997465319931507}, {'id': 319, 'seek': 184272, 'start': 1863.76, 'end': 1868.92, 'text': ' right, that is out of order. But again, the result values are written back in program', 'tokens': [51416, 558, 11, 300, 307, 484, 295, 1668, 13, 583, 797, 11, 264, 1874, 4190, 366, 3720, 646, 294, 1461, 51674], 'temperature': 0.0, 'avg_logprob': -0.1772787254976939, 'compression_ratio': 1.803030303030303, 'no_speech_prob': 0.007997465319931507}, {'id': 320, 'seek': 186892, 'start': 1868.92, 'end': 1873.96, 'text': ' order. This is again required for certain hardware reasons. I will not go into the details', 'tokens': [50364, 1668, 13, 639, 307, 797, 4739, 337, 1629, 8837, 4112, 13, 286, 486, 406, 352, 666, 264, 4365, 50616], 'temperature': 0.0, 'avg_logprob': -0.23171041629932546, 'compression_ratio': 1.7058823529411764, 'no_speech_prob': 0.007114542182534933}, {'id': 321, 'seek': 186892, 'start': 1873.96, 'end': 1876.96, 'text': ' of that, okay. Yeah.', 'tokens': [50616, 295, 300, 11, 1392, 13, 865, 13, 50766], 'temperature': 0.0, 'avg_logprob': -0.23171041629932546, 'compression_ratio': 1.7058823529411764, 'no_speech_prob': 0.007114542182534933}, {'id': 322, 'seek': 186892, 'start': 1876.96, 'end': 1881.64, 'text': ' Sir, is this done by hardware or the entire software?', 'tokens': [50766, 6144, 11, 307, 341, 1096, 538, 8837, 420, 264, 2302, 4722, 30, 51000], 'temperature': 0.0, 'avg_logprob': -0.23171041629932546, 'compression_ratio': 1.7058823529411764, 'no_speech_prob': 0.007114542182534933}, {'id': 323, 'seek': 186892, 'start': 1881.64, 'end': 1887.16, 'text': ' All of this is done by the hardware, okay. In the superscalar processor, you give the', 'tokens': [51000, 1057, 295, 341, 307, 1096, 538, 264, 8837, 11, 1392, 13, 682, 264, 37906, 9895, 289, 15321, 11, 291, 976, 264, 51276], 'temperature': 0.0, 'avg_logprob': -0.23171041629932546, 'compression_ratio': 1.7058823529411764, 'no_speech_prob': 0.007114542182534933}, {'id': 324, 'seek': 186892, 'start': 1887.16, 'end': 1891.88, 'text': ' series of instructions just like the way we saw on the left-hand side of the static instruction', 'tokens': [51276, 2638, 295, 9415, 445, 411, 264, 636, 321, 1866, 322, 264, 1411, 12, 5543, 1252, 295, 264, 13437, 10951, 51512], 'temperature': 0.0, 'avg_logprob': -0.23171041629932546, 'compression_ratio': 1.7058823529411764, 'no_speech_prob': 0.007114542182534933}, {'id': 325, 'seek': 186892, 'start': 1891.88, 'end': 1897.1200000000001, 'text': ' scheduling example, correct. And the hardware will figure out that the first load has a', 'tokens': [51512, 29055, 1365, 11, 3006, 13, 400, 264, 8837, 486, 2573, 484, 300, 264, 700, 3677, 575, 257, 51774], 'temperature': 0.0, 'avg_logprob': -0.23171041629932546, 'compression_ratio': 1.7058823529411764, 'no_speech_prob': 0.007114542182534933}, {'id': 326, 'seek': 189712, 'start': 1897.1599999999999, 'end': 1903.6799999999998, 'text': ' dependent instruction, maybe this gray. So, it will hold on to that and it will possibly', 'tokens': [50366, 12334, 10951, 11, 1310, 341, 10855, 13, 407, 11, 309, 486, 1797, 322, 281, 300, 293, 309, 486, 6264, 50692], 'temperature': 0.0, 'avg_logprob': -0.26727972678767825, 'compression_ratio': 1.8125, 'no_speech_prob': 0.01936776377260685}, {'id': 327, 'seek': 189712, 'start': 1903.6799999999998, 'end': 1909.08, 'text': ' figure out that the blue instruction or the red instruction is another load instruction', 'tokens': [50692, 2573, 484, 300, 264, 3344, 10951, 420, 264, 2182, 10951, 307, 1071, 3677, 10951, 50962], 'temperature': 0.0, 'avg_logprob': -0.26727972678767825, 'compression_ratio': 1.8125, 'no_speech_prob': 0.01936776377260685}, {'id': 328, 'seek': 189712, 'start': 1909.08, 'end': 1913.56, 'text': ' which it will try to independently issue and execute. So, the hardware will figure out', 'tokens': [50962, 597, 309, 486, 853, 281, 21761, 2734, 293, 14483, 13, 407, 11, 264, 8837, 486, 2573, 484, 51186], 'temperature': 0.0, 'avg_logprob': -0.26727972678767825, 'compression_ratio': 1.8125, 'no_speech_prob': 0.01936776377260685}, {'id': 329, 'seek': 189712, 'start': 1913.56, 'end': 1916.56, 'text': ' all of these mechanisms.', 'tokens': [51186, 439, 295, 613, 15902, 13, 51336], 'temperature': 0.0, 'avg_logprob': -0.26727972678767825, 'compression_ratio': 1.8125, 'no_speech_prob': 0.01936776377260685}, {'id': 330, 'seek': 189712, 'start': 1916.56, 'end': 1920.84, 'text': ' Sir, what is the difference between hardware and hardware?', 'tokens': [51336, 6144, 11, 437, 307, 264, 2649, 1296, 8837, 293, 8837, 30, 51550], 'temperature': 0.0, 'avg_logprob': -0.26727972678767825, 'compression_ratio': 1.8125, 'no_speech_prob': 0.01936776377260685}, {'id': 331, 'seek': 189712, 'start': 1920.84, 'end': 1924.6, 'text': ' I am going to see in the next slide, okay. I will tell you how that is going to happen.', 'tokens': [51550, 286, 669, 516, 281, 536, 294, 264, 958, 4137, 11, 1392, 13, 286, 486, 980, 291, 577, 300, 307, 516, 281, 1051, 13, 51738], 'temperature': 0.0, 'avg_logprob': -0.26727972678767825, 'compression_ratio': 1.8125, 'no_speech_prob': 0.01936776377260685}, {'id': 332, 'seek': 192460, 'start': 1925.08, 'end': 1930.9599999999998, 'text': ' This is just at a high level pictorially what is likely to happen, okay. This is not necessarily', 'tokens': [50388, 639, 307, 445, 412, 257, 1090, 1496, 2317, 284, 2270, 437, 307, 3700, 281, 1051, 11, 1392, 13, 639, 307, 406, 4725, 50682], 'temperature': 0.0, 'avg_logprob': -0.16820987354625355, 'compression_ratio': 1.8064516129032258, 'no_speech_prob': 0.18156635761260986}, {'id': 333, 'seek': 192460, 'start': 1930.9599999999998, 'end': 1937.9599999999998, 'text': ' say anything about how it happens in the real hardware, okay. So, more question or we are', 'tokens': [50682, 584, 1340, 466, 577, 309, 2314, 294, 264, 957, 8837, 11, 1392, 13, 407, 11, 544, 1168, 420, 321, 366, 51032], 'temperature': 0.0, 'avg_logprob': -0.16820987354625355, 'compression_ratio': 1.8064516129032258, 'no_speech_prob': 0.18156635761260986}, {'id': 334, 'seek': 192460, 'start': 1939.0, 'end': 1944.8799999999999, 'text': ' okay. So, let us look at how the hardware would look like, okay. So, I have skipped', 'tokens': [51084, 1392, 13, 407, 11, 718, 505, 574, 412, 577, 264, 8837, 576, 574, 411, 11, 1392, 13, 407, 11, 286, 362, 30193, 51378], 'temperature': 0.0, 'avg_logprob': -0.16820987354625355, 'compression_ratio': 1.8064516129032258, 'no_speech_prob': 0.18156635761260986}, {'id': 335, 'seek': 192460, 'start': 1944.8799999999999, 'end': 1949.4399999999998, 'text': ' a few things and then now I am introducing what is called the instruction cache. Remember,', 'tokens': [51378, 257, 1326, 721, 293, 550, 586, 286, 669, 15424, 437, 307, 1219, 264, 10951, 19459, 13, 5459, 11, 51606], 'temperature': 0.0, 'avg_logprob': -0.16820987354625355, 'compression_ratio': 1.8064516129032258, 'no_speech_prob': 0.18156635761260986}, {'id': 336, 'seek': 192460, 'start': 1949.4399999999998, 'end': 1953.8799999999999, 'text': ' we talked about doing instruction fetch and instruction fetch if it has to happen in a', 'tokens': [51606, 321, 2825, 466, 884, 10951, 23673, 293, 10951, 23673, 498, 309, 575, 281, 1051, 294, 257, 51828], 'temperature': 0.0, 'avg_logprob': -0.16820987354625355, 'compression_ratio': 1.8064516129032258, 'no_speech_prob': 0.18156635761260986}, {'id': 337, 'seek': 195388, 'start': 1953.96, 'end': 1958.92, 'text': ' single cycle that instruction obviously has to be in the cache. So, let us assume that', 'tokens': [50368, 2167, 6586, 300, 10951, 2745, 575, 281, 312, 294, 264, 19459, 13, 407, 11, 718, 505, 6552, 300, 50616], 'temperature': 0.0, 'avg_logprob': -0.1648734151100626, 'compression_ratio': 2.123222748815166, 'no_speech_prob': 0.004111571703106165}, {'id': 338, 'seek': 195388, 'start': 1958.92, 'end': 1963.2800000000002, 'text': ' there is an instruction cache and we will fetch the data from the fetch the instruction', 'tokens': [50616, 456, 307, 364, 10951, 19459, 293, 321, 486, 23673, 264, 1412, 490, 264, 23673, 264, 10951, 50834], 'temperature': 0.0, 'avg_logprob': -0.1648734151100626, 'compression_ratio': 2.123222748815166, 'no_speech_prob': 0.004111571703106165}, {'id': 339, 'seek': 195388, 'start': 1963.2800000000002, 'end': 1970.2800000000002, 'text': ' from the instruction cache. Every cycle I will fetch multiple such instructions, right.', 'tokens': [50834, 490, 264, 10951, 19459, 13, 2048, 6586, 286, 486, 23673, 3866, 1270, 9415, 11, 558, 13, 51184], 'temperature': 0.0, 'avg_logprob': -0.1648734151100626, 'compression_ratio': 2.123222748815166, 'no_speech_prob': 0.004111571703106165}, {'id': 340, 'seek': 195388, 'start': 1970.6000000000001, 'end': 1977.0400000000002, 'text': ' Four consecutive instructions will be fetched and they will be put in the instruction buffer.', 'tokens': [51200, 7451, 30497, 9415, 486, 312, 23673, 292, 293, 436, 486, 312, 829, 294, 264, 10951, 21762, 13, 51522], 'temperature': 0.0, 'avg_logprob': -0.1648734151100626, 'compression_ratio': 2.123222748815166, 'no_speech_prob': 0.004111571703106165}, {'id': 341, 'seek': 195388, 'start': 1977.0400000000002, 'end': 1982.2800000000002, 'text': ' From the instruction buffer, okay, this part of it let us skip. From the instruction buffer', 'tokens': [51522, 3358, 264, 10951, 21762, 11, 1392, 11, 341, 644, 295, 309, 718, 505, 10023, 13, 3358, 264, 10951, 21762, 51784], 'temperature': 0.0, 'avg_logprob': -0.1648734151100626, 'compression_ratio': 2.123222748815166, 'no_speech_prob': 0.004111571703106165}, {'id': 342, 'seek': 198228, 'start': 1982.3999999999999, 'end': 1989.3999999999999, 'text': ' I move them to what is called a decode, rename and a dispatch phase, okay, where the four', 'tokens': [50370, 286, 1286, 552, 281, 437, 307, 1219, 257, 979, 1429, 11, 36741, 293, 257, 36729, 5574, 11, 1392, 11, 689, 264, 1451, 50720], 'temperature': 0.0, 'avg_logprob': -0.1746377944946289, 'compression_ratio': 1.7666666666666666, 'no_speech_prob': 0.0016351914964616299}, {'id': 343, 'seek': 198228, 'start': 1989.48, 'end': 1995.28, 'text': ' successive instructions are being decoded, right and the dependencies between them are', 'tokens': [50724, 48043, 9415, 366, 885, 979, 12340, 11, 558, 293, 264, 36606, 1296, 552, 366, 51014], 'temperature': 0.0, 'avg_logprob': -0.1746377944946289, 'compression_ratio': 1.7666666666666666, 'no_speech_prob': 0.0016351914964616299}, {'id': 344, 'seek': 198228, 'start': 1995.28, 'end': 2000.96, 'text': ' understood, okay. It also does something called the register renaming which for the time being', 'tokens': [51014, 7320, 11, 1392, 13, 467, 611, 775, 746, 1219, 264, 7280, 8124, 5184, 597, 337, 264, 565, 885, 51298], 'temperature': 0.0, 'avg_logprob': -0.1746377944946289, 'compression_ratio': 1.7666666666666666, 'no_speech_prob': 0.0016351914964616299}, {'id': 345, 'seek': 198228, 'start': 2000.96, 'end': 2005.56, 'text': ' we will skip. We will not go into the details of that, right.', 'tokens': [51298, 321, 486, 10023, 13, 492, 486, 406, 352, 666, 264, 4365, 295, 300, 11, 558, 13, 51528], 'temperature': 0.0, 'avg_logprob': -0.1746377944946289, 'compression_ratio': 1.7666666666666666, 'no_speech_prob': 0.0016351914964616299}, {'id': 346, 'seek': 198228, 'start': 2005.56, 'end': 2011.0, 'text': ' And then after the decode and the dependency information is understood, right, at the same', 'tokens': [51528, 400, 550, 934, 264, 979, 1429, 293, 264, 33621, 1589, 307, 7320, 11, 558, 11, 412, 264, 912, 51800], 'temperature': 0.0, 'avg_logprob': -0.1746377944946289, 'compression_ratio': 1.7666666666666666, 'no_speech_prob': 0.0016351914964616299}, {'id': 347, 'seek': 201100, 'start': 2011.0, 'end': 2017.12, 'text': ' time I put the order in which these instructions are decoded into my reorder buffer. This is', 'tokens': [50364, 565, 286, 829, 264, 1668, 294, 597, 613, 9415, 366, 979, 12340, 666, 452, 319, 4687, 21762, 13, 639, 307, 50670], 'temperature': 0.0, 'avg_logprob': -0.1262732239456864, 'compression_ratio': 1.9218106995884774, 'no_speech_prob': 0.006950397044420242}, {'id': 348, 'seek': 201100, 'start': 2017.12, 'end': 2021.56, 'text': ' again finally I am going to use this because I want to write the results in the destination', 'tokens': [50670, 797, 2721, 286, 669, 516, 281, 764, 341, 570, 286, 528, 281, 2464, 264, 3542, 294, 264, 12236, 50892], 'temperature': 0.0, 'avg_logprob': -0.1262732239456864, 'compression_ratio': 1.9218106995884774, 'no_speech_prob': 0.006950397044420242}, {'id': 349, 'seek': 201100, 'start': 2021.56, 'end': 2027.6, 'text': ' location in the program order. I am just trying to remember this, right. After the instructions', 'tokens': [50892, 4914, 294, 264, 1461, 1668, 13, 286, 669, 445, 1382, 281, 1604, 341, 11, 558, 13, 2381, 264, 9415, 51194], 'temperature': 0.0, 'avg_logprob': -0.1262732239456864, 'compression_ratio': 1.9218106995884774, 'no_speech_prob': 0.006950397044420242}, {'id': 350, 'seek': 201100, 'start': 2027.6, 'end': 2033.76, 'text': ' are decoded I am going to push them into appropriate instruction queues, right, in which they can', 'tokens': [51194, 366, 979, 12340, 286, 669, 516, 281, 2944, 552, 666, 6854, 10951, 631, 1247, 11, 558, 11, 294, 597, 436, 393, 51502], 'temperature': 0.0, 'avg_logprob': -0.1262732239456864, 'compression_ratio': 1.9218106995884774, 'no_speech_prob': 0.006950397044420242}, {'id': 351, 'seek': 201100, 'start': 2033.76, 'end': 2038.6, 'text': ' be from which they can be taken and executed. This can be in the form of a queue or this', 'tokens': [51502, 312, 490, 597, 436, 393, 312, 2726, 293, 17577, 13, 639, 393, 312, 294, 264, 1254, 295, 257, 18639, 420, 341, 51744], 'temperature': 0.0, 'avg_logprob': -0.1262732239456864, 'compression_ratio': 1.9218106995884774, 'no_speech_prob': 0.006950397044420242}, {'id': 352, 'seek': 203860, 'start': 2038.6, 'end': 2043.6799999999998, 'text': ' can be in the form of a buffer. It depends on the architecture. So, the instructions', 'tokens': [50364, 393, 312, 294, 264, 1254, 295, 257, 21762, 13, 467, 5946, 322, 264, 9482, 13, 407, 11, 264, 9415, 50618], 'temperature': 0.0, 'avg_logprob': -0.13672533402076134, 'compression_ratio': 1.9821428571428572, 'no_speech_prob': 0.006483160890638828}, {'id': 353, 'seek': 203860, 'start': 2043.6799999999998, 'end': 2049.4, 'text': ' go and wait there for all the operands to become available. As soon as all the operands', 'tokens': [50618, 352, 293, 1699, 456, 337, 439, 264, 2208, 2967, 281, 1813, 2435, 13, 1018, 2321, 382, 439, 264, 2208, 2967, 50904], 'temperature': 0.0, 'avg_logprob': -0.13672533402076134, 'compression_ratio': 1.9821428571428572, 'no_speech_prob': 0.006483160890638828}, {'id': 354, 'seek': 203860, 'start': 2049.4, 'end': 2055.36, 'text': ' of an instruction becomes available they can go from the instruction queue to the execution', 'tokens': [50904, 295, 364, 10951, 3643, 2435, 436, 393, 352, 490, 264, 10951, 18639, 281, 264, 15058, 51202], 'temperature': 0.0, 'avg_logprob': -0.13672533402076134, 'compression_ratio': 1.9821428571428572, 'no_speech_prob': 0.006483160890638828}, {'id': 355, 'seek': 203860, 'start': 2055.36, 'end': 2061.56, 'text': ' unit. And as you can see here there are multiple execution units. There could be an integer', 'tokens': [51202, 4985, 13, 400, 382, 291, 393, 536, 510, 456, 366, 3866, 15058, 6815, 13, 821, 727, 312, 364, 24922, 51512], 'temperature': 0.0, 'avg_logprob': -0.13672533402076134, 'compression_ratio': 1.9821428571428572, 'no_speech_prob': 0.006483160890638828}, {'id': 356, 'seek': 203860, 'start': 2061.56, 'end': 2066.68, 'text': ' add unit, there could be an integer multiply unit, there could be a floating point add,', 'tokens': [51512, 909, 4985, 11, 456, 727, 312, 364, 24922, 12972, 4985, 11, 456, 727, 312, 257, 12607, 935, 909, 11, 51768], 'temperature': 0.0, 'avg_logprob': -0.13672533402076134, 'compression_ratio': 1.9821428571428572, 'no_speech_prob': 0.006483160890638828}, {'id': 357, 'seek': 206668, 'start': 2066.9199999999996, 'end': 2071.24, 'text': ' floating point multiply or there could be multiple integer add units, there could be', 'tokens': [50376, 12607, 935, 12972, 420, 456, 727, 312, 3866, 24922, 909, 6815, 11, 456, 727, 312, 50592], 'temperature': 0.0, 'avg_logprob': -0.12879167993863425, 'compression_ratio': 2.0511627906976746, 'no_speech_prob': 0.015232989564538002}, {'id': 358, 'seek': 206668, 'start': 2071.24, 'end': 2076.16, 'text': ' a separate load store unit, there could be a separate, right, floating point unit, there', 'tokens': [50592, 257, 4994, 3677, 3531, 4985, 11, 456, 727, 312, 257, 4994, 11, 558, 11, 12607, 935, 4985, 11, 456, 50838], 'temperature': 0.0, 'avg_logprob': -0.12879167993863425, 'compression_ratio': 2.0511627906976746, 'no_speech_prob': 0.015232989564538002}, {'id': 359, 'seek': 206668, 'start': 2076.16, 'end': 2080.7999999999997, 'text': ' could be a separate branch processing unit and so on and so forth. So, there could be', 'tokens': [50838, 727, 312, 257, 4994, 9819, 9007, 4985, 293, 370, 322, 293, 370, 5220, 13, 407, 11, 456, 727, 312, 51070], 'temperature': 0.0, 'avg_logprob': -0.12879167993863425, 'compression_ratio': 2.0511627906976746, 'no_speech_prob': 0.015232989564538002}, {'id': 360, 'seek': 206668, 'start': 2080.7999999999997, 'end': 2087.96, 'text': ' multiple functional units. So, in every cycle whatever instructions whose operands are available', 'tokens': [51070, 3866, 11745, 6815, 13, 407, 11, 294, 633, 6586, 2035, 9415, 6104, 2208, 2967, 366, 2435, 51428], 'temperature': 0.0, 'avg_logprob': -0.12879167993863425, 'compression_ratio': 2.0511627906976746, 'no_speech_prob': 0.015232989564538002}, {'id': 361, 'seek': 206668, 'start': 2087.96, 'end': 2093.48, 'text': ' who have become data ready they can now be moved to the appropriate functional units', 'tokens': [51428, 567, 362, 1813, 1412, 1919, 436, 393, 586, 312, 4259, 281, 264, 6854, 11745, 6815, 51704], 'temperature': 0.0, 'avg_logprob': -0.12879167993863425, 'compression_ratio': 2.0511627906976746, 'no_speech_prob': 0.015232989564538002}, {'id': 362, 'seek': 209348, 'start': 2093.56, 'end': 2100.56, 'text': ' and can be executed. That is what we mean by they get executed in parallel. After they', 'tokens': [50368, 293, 393, 312, 17577, 13, 663, 307, 437, 321, 914, 538, 436, 483, 17577, 294, 8952, 13, 2381, 436, 50718], 'temperature': 0.0, 'avg_logprob': -0.19053600535673254, 'compression_ratio': 1.8256410256410256, 'no_speech_prob': 0.07655219733715057}, {'id': 363, 'seek': 209348, 'start': 2100.56, 'end': 2106.16, 'text': ' get executed in parallel the result values are returned to this reorder buffer which', 'tokens': [50718, 483, 17577, 294, 8952, 264, 1874, 4190, 366, 8752, 281, 341, 319, 4687, 21762, 597, 50998], 'temperature': 0.0, 'avg_logprob': -0.19053600535673254, 'compression_ratio': 1.8256410256410256, 'no_speech_prob': 0.07655219733715057}, {'id': 364, 'seek': 209348, 'start': 2106.16, 'end': 2113.16, 'text': ' stores the order of these instructions, right. And then from there it actually, my animation,', 'tokens': [50998, 9512, 264, 1668, 295, 613, 9415, 11, 558, 13, 400, 550, 490, 456, 309, 767, 11, 452, 9603, 11, 51348], 'temperature': 0.0, 'avg_logprob': -0.19053600535673254, 'compression_ratio': 1.8256410256410256, 'no_speech_prob': 0.07655219733715057}, {'id': 365, 'seek': 209348, 'start': 2113.16, 'end': 2119.56, 'text': ' yes, my animation is little bit off. So, it goes to the reorder buffer and then from there', 'tokens': [51348, 2086, 11, 452, 9603, 307, 707, 857, 766, 13, 407, 11, 309, 1709, 281, 264, 319, 4687, 21762, 293, 550, 490, 456, 51668], 'temperature': 0.0, 'avg_logprob': -0.19053600535673254, 'compression_ratio': 1.8256410256410256, 'no_speech_prob': 0.07655219733715057}, {'id': 366, 'seek': 211956, 'start': 2119.64, 'end': 2125.52, 'text': ' it goes to the register file, okay. So, essentially what happens is that instructions', 'tokens': [50368, 309, 1709, 281, 264, 7280, 3991, 11, 1392, 13, 407, 11, 4476, 437, 2314, 307, 300, 9415, 50662], 'temperature': 0.0, 'avg_logprob': -0.14316927194595336, 'compression_ratio': 1.805, 'no_speech_prob': 0.0033005611039698124}, {'id': 367, 'seek': 211956, 'start': 2125.52, 'end': 2132.0, 'text': ' are fetched in program order, decoded in program order, put into this instruction queue and', 'tokens': [50662, 366, 23673, 292, 294, 1461, 1668, 11, 979, 12340, 294, 1461, 1668, 11, 829, 666, 341, 10951, 18639, 293, 50986], 'temperature': 0.0, 'avg_logprob': -0.14316927194595336, 'compression_ratio': 1.805, 'no_speech_prob': 0.0033005611039698124}, {'id': 368, 'seek': 211956, 'start': 2132.0, 'end': 2137.44, 'text': ' in the instruction queue they need not necessarily how to be executed in program order. They', 'tokens': [50986, 294, 264, 10951, 18639, 436, 643, 406, 4725, 577, 281, 312, 17577, 294, 1461, 1668, 13, 814, 51258], 'temperature': 0.0, 'avg_logprob': -0.14316927194595336, 'compression_ratio': 1.805, 'no_speech_prob': 0.0033005611039698124}, {'id': 369, 'seek': 211956, 'start': 2137.44, 'end': 2143.56, 'text': ' can be executed depending on the availability of the data operands. And once the execution', 'tokens': [51258, 393, 312, 17577, 5413, 322, 264, 17945, 295, 264, 1412, 2208, 2967, 13, 400, 1564, 264, 15058, 51564], 'temperature': 0.0, 'avg_logprob': -0.14316927194595336, 'compression_ratio': 1.805, 'no_speech_prob': 0.0033005611039698124}, {'id': 370, 'seek': 214356, 'start': 2143.56, 'end': 2150.52, 'text': ' is complete the result is written back into the reorder buffer where it stays there, right.', 'tokens': [50364, 307, 3566, 264, 1874, 307, 3720, 646, 666, 264, 319, 4687, 21762, 689, 309, 10834, 456, 11, 558, 13, 50712], 'temperature': 0.0, 'avg_logprob': -0.19588463647024973, 'compression_ratio': 1.7488151658767772, 'no_speech_prob': 0.021730616688728333}, {'id': 371, 'seek': 214356, 'start': 2150.52, 'end': 2156.02, 'text': ' And from the reorder buffer we write the result values back into the register file in program', 'tokens': [50712, 400, 490, 264, 319, 4687, 21762, 321, 2464, 264, 1874, 4190, 646, 666, 264, 7280, 3991, 294, 1461, 50987], 'temperature': 0.0, 'avg_logprob': -0.19588463647024973, 'compression_ratio': 1.7488151658767772, 'no_speech_prob': 0.021730616688728333}, {'id': 372, 'seek': 214356, 'start': 2156.02, 'end': 2163.02, 'text': ' order, okay. That should partly answer some questions that you asked me and also your', 'tokens': [50987, 1668, 11, 1392, 13, 663, 820, 17031, 1867, 512, 1651, 300, 291, 2351, 385, 293, 611, 428, 51337], 'temperature': 0.0, 'avg_logprob': -0.19588463647024973, 'compression_ratio': 1.7488151658767772, 'no_speech_prob': 0.021730616688728333}, {'id': 373, 'seek': 214356, 'start': 2163.12, 'end': 2170.12, 'text': ' questions, right. Any more questions? Unfortunately we are not going to see more details on this.', 'tokens': [51342, 1651, 11, 558, 13, 2639, 544, 1651, 30, 8590, 321, 366, 406, 516, 281, 536, 544, 4365, 322, 341, 13, 51692], 'temperature': 0.0, 'avg_logprob': -0.19588463647024973, 'compression_ratio': 1.7488151658767772, 'no_speech_prob': 0.021730616688728333}, {'id': 374, 'seek': 217012, 'start': 2170.12, 'end': 2177.12, 'text': ' So, this is for the load instruction because load instructions has to access the data cache', 'tokens': [50364, 407, 11, 341, 307, 337, 264, 3677, 10951, 570, 3677, 9415, 575, 281, 2105, 264, 1412, 19459, 50714], 'temperature': 0.0, 'avg_logprob': -0.22860659252513538, 'compression_ratio': 1.829145728643216, 'no_speech_prob': 0.03470074012875557}, {'id': 375, 'seek': 217012, 'start': 2177.12, 'end': 2183.0, 'text': ' part of it and instruction fetch, if the instruction is not there has to also fetch it from the', 'tokens': [50714, 644, 295, 309, 293, 10951, 23673, 11, 498, 264, 10951, 307, 406, 456, 575, 281, 611, 23673, 309, 490, 264, 51008], 'temperature': 0.0, 'avg_logprob': -0.22860659252513538, 'compression_ratio': 1.829145728643216, 'no_speech_prob': 0.03470074012875557}, {'id': 376, 'seek': 217012, 'start': 2183.0, 'end': 2189.64, 'text': ' memory. So, that is a memory interface part, right. So, this is how a superscalar processor', 'tokens': [51008, 4675, 13, 407, 11, 300, 307, 257, 4675, 9226, 644, 11, 558, 13, 407, 11, 341, 307, 577, 257, 37906, 9895, 289, 15321, 51340], 'temperature': 0.0, 'avg_logprob': -0.22860659252513538, 'compression_ratio': 1.829145728643216, 'no_speech_prob': 0.03470074012875557}, {'id': 377, 'seek': 217012, 'start': 2189.64, 'end': 2195.68, 'text': ' kind of executes instructions, right. And all of this as I mentioned earlier is done', 'tokens': [51340, 733, 295, 4454, 1819, 9415, 11, 558, 13, 400, 439, 295, 341, 382, 286, 2835, 3071, 307, 1096, 51642], 'temperature': 0.0, 'avg_logprob': -0.22860659252513538, 'compression_ratio': 1.829145728643216, 'no_speech_prob': 0.03470074012875557}, {'id': 378, 'seek': 219568, 'start': 2195.68, 'end': 2202.68, 'text': ' by the hardware, okay. Software essentially presents a sequence of instructions. If it', 'tokens': [50364, 538, 264, 8837, 11, 1392, 13, 27428, 4476, 13533, 257, 8310, 295, 9415, 13, 759, 309, 50714], 'temperature': 0.0, 'avg_logprob': -0.16551328546860639, 'compression_ratio': 1.748792270531401, 'no_speech_prob': 0.013343180529773235}, {'id': 379, 'seek': 219568, 'start': 2203.06, 'end': 2210.06, 'text': ' wants it can do some instruction reordering and give the instruction to the hardware,', 'tokens': [50733, 2738, 309, 393, 360, 512, 10951, 319, 765, 1794, 293, 976, 264, 10951, 281, 264, 8837, 11, 51083], 'temperature': 0.0, 'avg_logprob': -0.16551328546860639, 'compression_ratio': 1.748792270531401, 'no_speech_prob': 0.013343180529773235}, {'id': 380, 'seek': 219568, 'start': 2210.64, 'end': 2217.64, 'text': ' but once it has done whatever it can do the rest of it is all done by the hardware, okay.', 'tokens': [51112, 457, 1564, 309, 575, 1096, 2035, 309, 393, 360, 264, 1472, 295, 309, 307, 439, 1096, 538, 264, 8837, 11, 1392, 13, 51462], 'temperature': 0.0, 'avg_logprob': -0.16551328546860639, 'compression_ratio': 1.748792270531401, 'no_speech_prob': 0.013343180529773235}, {'id': 381, 'seek': 219568, 'start': 2217.64, 'end': 2224.04, 'text': ' Any questions? Okay. Now, let us look at another kind of an instruction level parallelism processor', 'tokens': [51462, 2639, 1651, 30, 1033, 13, 823, 11, 718, 505, 574, 412, 1071, 733, 295, 364, 10951, 1496, 8952, 1434, 15321, 51782], 'temperature': 0.0, 'avg_logprob': -0.16551328546860639, 'compression_ratio': 1.748792270531401, 'no_speech_prob': 0.013343180529773235}, {'id': 382, 'seek': 222404, 'start': 2224.08, 'end': 2231.08, 'text': ' called VLIW processor, right. In the superscalar processor as I mentioned earlier independent', 'tokens': [50366, 1219, 691, 48718, 54, 15321, 11, 558, 13, 682, 264, 37906, 9895, 289, 15321, 382, 286, 2835, 3071, 6695, 50716], 'temperature': 0.0, 'avg_logprob': -0.19318335396902903, 'compression_ratio': 1.7579908675799087, 'no_speech_prob': 0.004928596317768097}, {'id': 383, 'seek': 222404, 'start': 2231.64, 'end': 2236.56, 'text': ' instructions which can be executed in parallel they are identified by hardware in this stage,', 'tokens': [50744, 9415, 597, 393, 312, 17577, 294, 8952, 436, 366, 9234, 538, 8837, 294, 341, 3233, 11, 50990], 'temperature': 0.0, 'avg_logprob': -0.19318335396902903, 'compression_ratio': 1.7579908675799087, 'no_speech_prob': 0.004928596317768097}, {'id': 384, 'seek': 222404, 'start': 2236.56, 'end': 2242.92, 'text': ' okay, when they are being put into the instruction queue, right. And therefore, this hardware', 'tokens': [50990, 1392, 11, 562, 436, 366, 885, 829, 666, 264, 10951, 18639, 11, 558, 13, 400, 4412, 11, 341, 8837, 51308], 'temperature': 0.0, 'avg_logprob': -0.19318335396902903, 'compression_ratio': 1.7579908675799087, 'no_speech_prob': 0.004928596317768097}, {'id': 385, 'seek': 222404, 'start': 2242.92, 'end': 2248.88, 'text': ' has to be a complex hardware. It has to understand what are the instructions, what are the dependencies', 'tokens': [51308, 575, 281, 312, 257, 3997, 8837, 13, 467, 575, 281, 1223, 437, 366, 264, 9415, 11, 437, 366, 264, 36606, 51606], 'temperature': 0.0, 'avg_logprob': -0.19318335396902903, 'compression_ratio': 1.7579908675799087, 'no_speech_prob': 0.004928596317768097}, {'id': 386, 'seek': 224888, 'start': 2248.88, 'end': 2254.52, 'text': ' between the instructions, which instructions have got their operands available or for which', 'tokens': [50364, 1296, 264, 9415, 11, 597, 9415, 362, 658, 641, 2208, 2967, 2435, 420, 337, 597, 50646], 'temperature': 0.0, 'avg_logprob': -0.1766494789508858, 'compression_ratio': 1.9576271186440677, 'no_speech_prob': 0.00638450775295496}, {'id': 387, 'seek': 224888, 'start': 2254.52, 'end': 2260.28, 'text': ' instructions the previous dependent instructions their predecessors have already completed execution.', 'tokens': [50646, 9415, 264, 3894, 12334, 9415, 641, 24874, 45700, 362, 1217, 7365, 15058, 13, 50934], 'temperature': 0.0, 'avg_logprob': -0.1766494789508858, 'compression_ratio': 1.9576271186440677, 'no_speech_prob': 0.00638450775295496}, {'id': 388, 'seek': 224888, 'start': 2260.28, 'end': 2264.44, 'text': ' I have to take those values, I have to take those things and then find out which instructions', 'tokens': [50934, 286, 362, 281, 747, 729, 4190, 11, 286, 362, 281, 747, 729, 721, 293, 550, 915, 484, 597, 9415, 51142], 'temperature': 0.0, 'avg_logprob': -0.1766494789508858, 'compression_ratio': 1.9576271186440677, 'no_speech_prob': 0.00638450775295496}, {'id': 389, 'seek': 224888, 'start': 2264.44, 'end': 2270.7200000000003, 'text': ' are ready I can send them to the execution unit for execution, correct. So, this piece', 'tokens': [51142, 366, 1919, 286, 393, 2845, 552, 281, 264, 15058, 4985, 337, 15058, 11, 3006, 13, 407, 11, 341, 2522, 51456], 'temperature': 0.0, 'avg_logprob': -0.1766494789508858, 'compression_ratio': 1.9576271186440677, 'no_speech_prob': 0.00638450775295496}, {'id': 390, 'seek': 224888, 'start': 2270.7200000000003, 'end': 2276.56, 'text': ' of hardware which is going to do all of this is going to be complex, right. Whereas, in', 'tokens': [51456, 295, 8837, 597, 307, 516, 281, 360, 439, 295, 341, 307, 516, 281, 312, 3997, 11, 558, 13, 13813, 11, 294, 51748], 'temperature': 0.0, 'avg_logprob': -0.1766494789508858, 'compression_ratio': 1.9576271186440677, 'no_speech_prob': 0.00638450775295496}, {'id': 391, 'seek': 227656, 'start': 2276.56, 'end': 2283.32, 'text': ' the case of a VLIW processor the compiler is going to detect all the independent instructions', 'tokens': [50364, 264, 1389, 295, 257, 691, 48718, 54, 15321, 264, 31958, 307, 516, 281, 5531, 439, 264, 6695, 9415, 50702], 'temperature': 0.0, 'avg_logprob': -0.1563280301216321, 'compression_ratio': 1.8911917098445596, 'no_speech_prob': 0.00728547153994441}, {'id': 392, 'seek': 227656, 'start': 2283.32, 'end': 2289.12, 'text': ' and is going to put them together in one large instruction board. That the processor can', 'tokens': [50702, 293, 307, 516, 281, 829, 552, 1214, 294, 472, 2416, 10951, 3150, 13, 663, 264, 15321, 393, 50992], 'temperature': 0.0, 'avg_logprob': -0.1563280301216321, 'compression_ratio': 1.8911917098445596, 'no_speech_prob': 0.00728547153994441}, {'id': 393, 'seek': 227656, 'start': 2289.12, 'end': 2296.12, 'text': ' fetch, do the decode and simply execute. The processor can execute all of these instructions', 'tokens': [50992, 23673, 11, 360, 264, 979, 1429, 293, 2935, 14483, 13, 440, 15321, 393, 14483, 439, 295, 613, 9415, 51342], 'temperature': 0.0, 'avg_logprob': -0.1563280301216321, 'compression_ratio': 1.8911917098445596, 'no_speech_prob': 0.00728547153994441}, {'id': 394, 'seek': 227656, 'start': 2296.16, 'end': 2303.16, 'text': ' together because the compiler guarantees that they are independent, okay. That means that', 'tokens': [51344, 1214, 570, 264, 31958, 32567, 300, 436, 366, 6695, 11, 1392, 13, 663, 1355, 300, 51694], 'temperature': 0.0, 'avg_logprob': -0.1563280301216321, 'compression_ratio': 1.8911917098445596, 'no_speech_prob': 0.00728547153994441}, {'id': 395, 'seek': 230316, 'start': 2304.16, 'end': 2311.16, 'text': ' my hardware does not have to do any check, right. The hardware simply can say that if', 'tokens': [50414, 452, 8837, 775, 406, 362, 281, 360, 604, 1520, 11, 558, 13, 440, 8837, 2935, 393, 584, 300, 498, 50764], 'temperature': 0.0, 'avg_logprob': -0.14855125338532205, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.0033111474476754665}, {'id': 396, 'seek': 230316, 'start': 2311.2799999999997, 'end': 2316.0, 'text': ' these are the four operations that can be that are together in an instruction, I can', 'tokens': [50770, 613, 366, 264, 1451, 7705, 300, 393, 312, 300, 366, 1214, 294, 364, 10951, 11, 286, 393, 51006], 'temperature': 0.0, 'avg_logprob': -0.14855125338532205, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.0033111474476754665}, {'id': 397, 'seek': 230316, 'start': 2316.0, 'end': 2320.92, 'text': ' execute all of them in parallel, right. I do not really have to worry about checking', 'tokens': [51006, 14483, 439, 295, 552, 294, 8952, 11, 558, 13, 286, 360, 406, 534, 362, 281, 3292, 466, 8568, 51252], 'temperature': 0.0, 'avg_logprob': -0.14855125338532205, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.0033111474476754665}, {'id': 398, 'seek': 230316, 'start': 2320.92, 'end': 2327.56, 'text': ' their dependencies are in it, right. So, that is why in a VLIW processor the compiler does', 'tokens': [51252, 641, 36606, 366, 294, 309, 11, 558, 13, 407, 11, 300, 307, 983, 294, 257, 691, 48718, 54, 15321, 264, 31958, 775, 51584], 'temperature': 0.0, 'avg_logprob': -0.14855125338532205, 'compression_ratio': 1.6398104265402844, 'no_speech_prob': 0.0033111474476754665}, {'id': 399, 'seek': 232756, 'start': 2327.56, 'end': 2333.44, 'text': ' all the work and the hardware is simpler. Whereas, in a superscalar processor the hardware', 'tokens': [50364, 439, 264, 589, 293, 264, 8837, 307, 18587, 13, 13813, 11, 294, 257, 37906, 9895, 289, 15321, 264, 8837, 50658], 'temperature': 0.0, 'avg_logprob': -0.18200130024175534, 'compression_ratio': 1.8229166666666667, 'no_speech_prob': 0.019898273050785065}, {'id': 400, 'seek': 232756, 'start': 2333.44, 'end': 2338.92, 'text': ' does all the work and the compiler really does a little bit of reordering and nothing', 'tokens': [50658, 775, 439, 264, 589, 293, 264, 31958, 534, 775, 257, 707, 857, 295, 319, 765, 1794, 293, 1825, 50932], 'temperature': 0.0, 'avg_logprob': -0.18200130024175534, 'compression_ratio': 1.8229166666666667, 'no_speech_prob': 0.019898273050785065}, {'id': 401, 'seek': 232756, 'start': 2338.92, 'end': 2344.7599999999998, 'text': ' more. So, there the hardware is much more expensive, right. So, typically this is what', 'tokens': [50932, 544, 13, 407, 11, 456, 264, 8837, 307, 709, 544, 5124, 11, 558, 13, 407, 11, 5850, 341, 307, 437, 51224], 'temperature': 0.0, 'avg_logprob': -0.18200130024175534, 'compression_ratio': 1.8229166666666667, 'no_speech_prob': 0.019898273050785065}, {'id': 402, 'seek': 232756, 'start': 2344.7599999999998, 'end': 2351.7599999999998, 'text': ' we call as a smart compiler the one which does a lot of hard work and a dumb hardware,', 'tokens': [51224, 321, 818, 382, 257, 4069, 31958, 264, 472, 597, 775, 257, 688, 295, 1152, 589, 293, 257, 10316, 8837, 11, 51574], 'temperature': 0.0, 'avg_logprob': -0.18200130024175534, 'compression_ratio': 1.8229166666666667, 'no_speech_prob': 0.019898273050785065}, {'id': 403, 'seek': 235176, 'start': 2351.76, 'end': 2358.76, 'text': ' okay. So, this is how the VLIW processor looks like. It has an instruction memory from which', 'tokens': [50364, 1392, 13, 407, 11, 341, 307, 577, 264, 691, 48718, 54, 15321, 1542, 411, 13, 467, 575, 364, 10951, 4675, 490, 597, 50714], 'temperature': 0.0, 'avg_logprob': -0.16922809231665828, 'compression_ratio': 1.7450980392156863, 'no_speech_prob': 0.0013855091528967023}, {'id': 404, 'seek': 235176, 'start': 2358.88, 'end': 2363.6800000000003, 'text': ' the instructions are fetched every cycle. That instruction itself will have multiple', 'tokens': [50720, 264, 9415, 366, 23673, 292, 633, 6586, 13, 663, 10951, 2564, 486, 362, 3866, 50960], 'temperature': 0.0, 'avg_logprob': -0.16922809231665828, 'compression_ratio': 1.7450980392156863, 'no_speech_prob': 0.0013855091528967023}, {'id': 405, 'seek': 235176, 'start': 2363.6800000000003, 'end': 2369.8, 'text': ' operations and each of these operations because the compiler has compiled it this way we know', 'tokens': [50960, 7705, 293, 1184, 295, 613, 7705, 570, 264, 31958, 575, 36548, 309, 341, 636, 321, 458, 51266], 'temperature': 0.0, 'avg_logprob': -0.16922809231665828, 'compression_ratio': 1.7450980392156863, 'no_speech_prob': 0.0013855091528967023}, {'id': 406, 'seek': 235176, 'start': 2369.8, 'end': 2375.4, 'text': ' are independent and therefore, can be sent to the appropriate function unit and those', 'tokens': [51266, 366, 6695, 293, 4412, 11, 393, 312, 2279, 281, 264, 6854, 2445, 4985, 293, 729, 51546], 'temperature': 0.0, 'avg_logprob': -0.16922809231665828, 'compression_ratio': 1.7450980392156863, 'no_speech_prob': 0.0013855091528967023}, {'id': 407, 'seek': 235176, 'start': 2375.4, 'end': 2381.5, 'text': ' function units can execute them taking their operand from the respective register files', 'tokens': [51546, 2445, 6815, 393, 14483, 552, 1940, 641, 2208, 474, 490, 264, 23649, 7280, 7098, 51851], 'temperature': 0.0, 'avg_logprob': -0.16922809231665828, 'compression_ratio': 1.7450980392156863, 'no_speech_prob': 0.0013855091528967023}, {'id': 408, 'seek': 238150, 'start': 2381.7, 'end': 2386.9, 'text': ' and after finishing execution they will write the result back in the respective register', 'tokens': [50374, 293, 934, 12693, 15058, 436, 486, 2464, 264, 1874, 646, 294, 264, 23649, 7280, 50634], 'temperature': 0.0, 'avg_logprob': -0.18536784648895263, 'compression_ratio': 1.69377990430622, 'no_speech_prob': 0.004767529666423798}, {'id': 409, 'seek': 238150, 'start': 2386.9, 'end': 2392.5, 'text': ' file, right. If they need to do load store operations then they will access the data', 'tokens': [50634, 3991, 11, 558, 13, 759, 436, 643, 281, 360, 3677, 3531, 7705, 550, 436, 486, 2105, 264, 1412, 50914], 'temperature': 0.0, 'avg_logprob': -0.18536784648895263, 'compression_ratio': 1.69377990430622, 'no_speech_prob': 0.004767529666423798}, {'id': 410, 'seek': 238150, 'start': 2392.5, 'end': 2399.5, 'text': ' memory, right. So, this is a simple pipeline hardware is simple, right. No detecting of', 'tokens': [50914, 4675, 11, 558, 13, 407, 11, 341, 307, 257, 2199, 15517, 8837, 307, 2199, 11, 558, 13, 883, 40237, 295, 51264], 'temperature': 0.0, 'avg_logprob': -0.18536784648895263, 'compression_ratio': 1.69377990430622, 'no_speech_prob': 0.004767529666423798}, {'id': 411, 'seek': 238150, 'start': 2399.82, 'end': 2406.42, 'text': ' dependencies and other things. It can simply go through this cycle, right and it can execute', 'tokens': [51280, 36606, 293, 661, 721, 13, 467, 393, 2935, 352, 807, 341, 6586, 11, 558, 293, 309, 393, 14483, 51610], 'temperature': 0.0, 'avg_logprob': -0.18536784648895263, 'compression_ratio': 1.69377990430622, 'no_speech_prob': 0.004767529666423798}, {'id': 412, 'seek': 240642, 'start': 2406.42, 'end': 2411.66, 'text': ' parallel instructions every cycle. This is what that happens in the case of a VLIW processor.', 'tokens': [50364, 8952, 9415, 633, 6586, 13, 639, 307, 437, 300, 2314, 294, 264, 1389, 295, 257, 691, 48718, 54, 15321, 13, 50626], 'temperature': 0.0, 'avg_logprob': -0.1736596180842473, 'compression_ratio': 1.8, 'no_speech_prob': 0.012823973782360554}, {'id': 413, 'seek': 240642, 'start': 2411.66, 'end': 2417.26, 'text': ' So, the question is if you are writing the compiler for this VLIW processor what all', 'tokens': [50626, 407, 11, 264, 1168, 307, 498, 291, 366, 3579, 264, 31958, 337, 341, 691, 48718, 54, 15321, 437, 439, 50906], 'temperature': 0.0, 'avg_logprob': -0.1736596180842473, 'compression_ratio': 1.8, 'no_speech_prob': 0.012823973782360554}, {'id': 414, 'seek': 240642, 'start': 2417.26, 'end': 2422.46, 'text': ' do we need to do during the instruction scheduling stage? That is the problem that we will talk', 'tokens': [50906, 360, 321, 643, 281, 360, 1830, 264, 10951, 29055, 3233, 30, 663, 307, 264, 1154, 300, 321, 486, 751, 51166], 'temperature': 0.0, 'avg_logprob': -0.1736596180842473, 'compression_ratio': 1.8, 'no_speech_prob': 0.012823973782360554}, {'id': 415, 'seek': 240642, 'start': 2422.46, 'end': 2428.3, 'text': ' about, right. That is the reason why we are talking about VLIW processor. So, again we', 'tokens': [51166, 466, 11, 558, 13, 663, 307, 264, 1778, 983, 321, 366, 1417, 466, 691, 48718, 54, 15321, 13, 407, 11, 797, 321, 51458], 'temperature': 0.0, 'avg_logprob': -0.1736596180842473, 'compression_ratio': 1.8, 'no_speech_prob': 0.012823973782360554}, {'id': 416, 'seek': 240642, 'start': 2428.3, 'end': 2433.34, 'text': ' have the super scalar processor where the detecting of independence between instructions', 'tokens': [51458, 362, 264, 1687, 39684, 15321, 689, 264, 40237, 295, 14640, 1296, 9415, 51710], 'temperature': 0.0, 'avg_logprob': -0.1736596180842473, 'compression_ratio': 1.8, 'no_speech_prob': 0.012823973782360554}, {'id': 417, 'seek': 243334, 'start': 2433.34, 'end': 2439.34, 'text': ' is done by the hardware. We have a VLIW processor where this is done by the compiler, okay.', 'tokens': [50364, 307, 1096, 538, 264, 8837, 13, 492, 362, 257, 691, 48718, 54, 15321, 689, 341, 307, 1096, 538, 264, 31958, 11, 1392, 13, 50664], 'temperature': 0.0, 'avg_logprob': -0.16536553700764975, 'compression_ratio': 1.6590909090909092, 'no_speech_prob': 0.011672424152493477}, {'id': 418, 'seek': 243334, 'start': 2439.34, 'end': 2445.26, 'text': ' I think this is probably where we are going to stop. This is an example of a VLIW processor', 'tokens': [50664, 286, 519, 341, 307, 1391, 689, 321, 366, 516, 281, 1590, 13, 639, 307, 364, 1365, 295, 257, 691, 48718, 54, 15321, 50960], 'temperature': 0.0, 'avg_logprob': -0.16536553700764975, 'compression_ratio': 1.6590909090909092, 'no_speech_prob': 0.011672424152493477}, {'id': 419, 'seek': 243334, 'start': 2445.26, 'end': 2451.78, 'text': ' which has a 256 bit instruction and can hold up to 7 wide operations, okay. So, at this', 'tokens': [50960, 597, 575, 257, 38882, 857, 10951, 293, 393, 1797, 493, 281, 1614, 4874, 7705, 11, 1392, 13, 407, 11, 412, 341, 51286], 'temperature': 0.0, 'avg_logprob': -0.16536553700764975, 'compression_ratio': 1.6590909090909092, 'no_speech_prob': 0.011672424152493477}, {'id': 420, 'seek': 243334, 'start': 2451.78, 'end': 2457.94, 'text': ' point in time we probably have to switch and then stop here discussing about machine, machine', 'tokens': [51286, 935, 294, 565, 321, 1391, 362, 281, 3679, 293, 550, 1590, 510, 10850, 466, 3479, 11, 3479, 51594], 'temperature': 0.0, 'avg_logprob': -0.16536553700764975, 'compression_ratio': 1.6590909090909092, 'no_speech_prob': 0.011672424152493477}, {'id': 421, 'seek': 245794, 'start': 2457.94, 'end': 2463.86, 'text': ' architecture to a large extent, okay. We will come back and talk about memory hierarchy', 'tokens': [50364, 9482, 281, 257, 2416, 8396, 11, 1392, 13, 492, 486, 808, 646, 293, 751, 466, 4675, 22333, 50660], 'temperature': 0.0, 'avg_logprob': -0.15120891571044923, 'compression_ratio': 1.5071090047393365, 'no_speech_prob': 0.14724400639533997}, {'id': 422, 'seek': 245794, 'start': 2463.86, 'end': 2468.42, 'text': ' mostly on Friday and data parallelism also on Friday, okay.', 'tokens': [50660, 5240, 322, 6984, 293, 1412, 8952, 1434, 611, 322, 6984, 11, 1392, 13, 50888], 'temperature': 0.0, 'avg_logprob': -0.15120891571044923, 'compression_ratio': 1.5071090047393365, 'no_speech_prob': 0.14724400639533997}, {'id': 423, 'seek': 245794, 'start': 2468.42, 'end': 2475.42, 'text': ' Any questions before we switch the slides? So far things are good, right. Suppose to', 'tokens': [50888, 2639, 1651, 949, 321, 3679, 264, 9788, 30, 407, 1400, 721, 366, 665, 11, 558, 13, 21360, 281, 51238], 'temperature': 0.0, 'avg_logprob': -0.15120891571044923, 'compression_ratio': 1.5071090047393365, 'no_speech_prob': 0.14724400639533997}, {'id': 424, 'seek': 245794, 'start': 2475.5, 'end': 2481.7000000000003, 'text': ' give you a quick overview of architecture, right that is required for us to write the', 'tokens': [51242, 976, 291, 257, 1702, 12492, 295, 9482, 11, 558, 300, 307, 4739, 337, 505, 281, 2464, 264, 51552], 'temperature': 0.0, 'avg_logprob': -0.15120891571044923, 'compression_ratio': 1.5071090047393365, 'no_speech_prob': 0.14724400639533997}, {'id': 425, 'seek': 248170, 'start': 2481.7, 'end': 2488.7, 'text': ' compiler, right, okay. So, again so as I mentioned earlier we started off with machine architecture.', 'tokens': [50364, 31958, 11, 558, 11, 1392, 13, 407, 11, 797, 370, 382, 286, 2835, 3071, 321, 1409, 766, 365, 3479, 9482, 13, 50714], 'temperature': 0.0, 'avg_logprob': -0.21702281288478686, 'compression_ratio': 1.780373831775701, 'no_speech_prob': 0.028610240668058395}, {'id': 426, 'seek': 248170, 'start': 2489.4199999999996, 'end': 2496.4199999999996, 'text': ' We covered most of what we wanted to see immediately, okay. Now we are going to move on to code', 'tokens': [50750, 492, 5343, 881, 295, 437, 321, 1415, 281, 536, 4258, 11, 1392, 13, 823, 321, 366, 516, 281, 1286, 322, 281, 3089, 51100], 'temperature': 0.0, 'avg_logprob': -0.21702281288478686, 'compression_ratio': 1.780373831775701, 'no_speech_prob': 0.028610240668058395}, {'id': 427, 'seek': 248170, 'start': 2496.5, 'end': 2503.5, 'text': ' generation, right. So, that is basically what we are going to discuss for the rest of today,', 'tokens': [51104, 5125, 11, 558, 13, 407, 11, 300, 307, 1936, 437, 321, 366, 516, 281, 2248, 337, 264, 1472, 295, 965, 11, 51454], 'temperature': 0.0, 'avg_logprob': -0.21702281288478686, 'compression_ratio': 1.780373831775701, 'no_speech_prob': 0.028610240668058395}, {'id': 428, 'seek': 248170, 'start': 2503.5, 'end': 2510.2999999999997, 'text': ' okay. So, again we will have some introduction why code generation, what is code generation', 'tokens': [51454, 1392, 13, 407, 11, 797, 321, 486, 362, 512, 9339, 983, 3089, 5125, 11, 437, 307, 3089, 5125, 51794], 'temperature': 0.0, 'avg_logprob': -0.21702281288478686, 'compression_ratio': 1.780373831775701, 'no_speech_prob': 0.028610240668058395}, {'id': 429, 'seek': 251030, 'start': 2510.3, 'end': 2516.1400000000003, 'text': ' and you know how do we need to do that and so on. Then we will talk about a simple code', 'tokens': [50364, 293, 291, 458, 577, 360, 321, 643, 281, 360, 300, 293, 370, 322, 13, 1396, 321, 486, 751, 466, 257, 2199, 3089, 50656], 'temperature': 0.0, 'avg_logprob': -0.13693713206870883, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.007920054718852043}, {'id': 430, 'seek': 251030, 'start': 2516.1400000000003, 'end': 2523.1400000000003, 'text': ' generator which is just based on usage counts, okay, sorry not usage counts, simple code', 'tokens': [50656, 19265, 597, 307, 445, 2361, 322, 14924, 14893, 11, 1392, 11, 2597, 406, 14924, 14893, 11, 2199, 3089, 51006], 'temperature': 0.0, 'avg_logprob': -0.13693713206870883, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.007920054718852043}, {'id': 431, 'seek': 251030, 'start': 2523.1400000000003, 'end': 2529.1800000000003, 'text': ' generation, right. Then we will go to more sophisticated code generation mechanisms and', 'tokens': [51006, 5125, 11, 558, 13, 1396, 321, 486, 352, 281, 544, 16950, 3089, 5125, 15902, 293, 51308], 'temperature': 0.0, 'avg_logprob': -0.13693713206870883, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.007920054718852043}, {'id': 432, 'seek': 251030, 'start': 2529.1800000000003, 'end': 2535.02, 'text': ' specifically talk about the construction of a directed acyclic graph for basic blocks', 'tokens': [51308, 4682, 751, 466, 264, 6435, 295, 257, 12898, 696, 88, 66, 1050, 4295, 337, 3875, 8474, 51600], 'temperature': 0.0, 'avg_logprob': -0.13693713206870883, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.007920054718852043}, {'id': 433, 'seek': 251030, 'start': 2535.02, 'end': 2539.6200000000003, 'text': ' and then do code generation for that. And we will see that even in this case if you', 'tokens': [51600, 293, 550, 360, 3089, 5125, 337, 300, 13, 400, 321, 486, 536, 300, 754, 294, 341, 1389, 498, 291, 51830], 'temperature': 0.0, 'avg_logprob': -0.13693713206870883, 'compression_ratio': 1.8312236286919832, 'no_speech_prob': 0.007920054718852043}, {'id': 434, 'seek': 253962, 'start': 2539.62, 'end': 2546.7, 'text': ' want to generate what is called the optimal code that problem is an NP-hard problem, right.', 'tokens': [50364, 528, 281, 8460, 437, 307, 1219, 264, 16252, 3089, 300, 1154, 307, 364, 38611, 12, 21491, 1154, 11, 558, 13, 50718], 'temperature': 0.0, 'avg_logprob': -0.18842726218991163, 'compression_ratio': 1.5911111111111111, 'no_speech_prob': 0.0027334168553352356}, {'id': 435, 'seek': 253962, 'start': 2546.7, 'end': 2553.3399999999997, 'text': ' And therefore, we will resolve to some simpler mechanisms like using certain heuristics for', 'tokens': [50718, 400, 4412, 11, 321, 486, 14151, 281, 512, 18587, 15902, 411, 1228, 1629, 415, 374, 6006, 337, 51050], 'temperature': 0.0, 'avg_logprob': -0.18842726218991163, 'compression_ratio': 1.5911111111111111, 'no_speech_prob': 0.0027334168553352356}, {'id': 436, 'seek': 253962, 'start': 2553.3399999999997, 'end': 2559.94, 'text': ' generating code. But fortunately if you are talking about code generation for expressions', 'tokens': [51050, 17746, 3089, 13, 583, 25511, 498, 291, 366, 1417, 466, 3089, 5125, 337, 15277, 51380], 'temperature': 0.0, 'avg_logprob': -0.18842726218991163, 'compression_ratio': 1.5911111111111111, 'no_speech_prob': 0.0027334168553352356}, {'id': 437, 'seek': 253962, 'start': 2559.94, 'end': 2566.1, 'text': ' which are like trees, which is a specific case of a DAG, then in those cases you can', 'tokens': [51380, 597, 366, 411, 5852, 11, 597, 307, 257, 2685, 1389, 295, 257, 9578, 38, 11, 550, 294, 729, 3331, 291, 393, 51688], 'temperature': 0.0, 'avg_logprob': -0.18842726218991163, 'compression_ratio': 1.5911111111111111, 'no_speech_prob': 0.0027334168553352356}, {'id': 438, 'seek': 256610, 'start': 2566.5, 'end': 2571.98, 'text': ' generate optimal code either by using the Seti-Wilman algorithm or by doing what is', 'tokens': [50384, 8460, 16252, 3089, 2139, 538, 1228, 264, 8928, 72, 12, 54, 388, 1601, 9284, 420, 538, 884, 437, 307, 50658], 'temperature': 0.0, 'avg_logprob': -0.17244140836927627, 'compression_ratio': 1.8461538461538463, 'no_speech_prob': 0.11504489928483963}, {'id': 439, 'seek': 256610, 'start': 2571.98, 'end': 2577.94, 'text': ' called dynamic programming. So, we will talk about those approaches as well and then subsequently', 'tokens': [50658, 1219, 8546, 9410, 13, 407, 11, 321, 486, 751, 466, 729, 11587, 382, 731, 293, 550, 26514, 50956], 'temperature': 0.0, 'avg_logprob': -0.17244140836927627, 'compression_ratio': 1.8461538461538463, 'no_speech_prob': 0.11504489928483963}, {'id': 440, 'seek': 256610, 'start': 2577.94, 'end': 2582.66, 'text': ' we will talk about how do you do instruction selection using tree pattern matching, instruction', 'tokens': [50956, 321, 486, 751, 466, 577, 360, 291, 360, 10951, 9450, 1228, 4230, 5102, 14324, 11, 10951, 51192], 'temperature': 0.0, 'avg_logprob': -0.17244140836927627, 'compression_ratio': 1.8461538461538463, 'no_speech_prob': 0.11504489928483963}, {'id': 441, 'seek': 256610, 'start': 2582.66, 'end': 2586.9, 'text': ' selection and code generation using tree pattern matching, right.', 'tokens': [51192, 9450, 293, 3089, 5125, 1228, 4230, 5102, 14324, 11, 558, 13, 51404], 'temperature': 0.0, 'avg_logprob': -0.17244140836927627, 'compression_ratio': 1.8461538461538463, 'no_speech_prob': 0.11504489928483963}, {'id': 442, 'seek': 256610, 'start': 2586.9, 'end': 2591.66, 'text': ' And finally, we will also talk about little bit of machine dependent optimization called', 'tokens': [51404, 400, 2721, 11, 321, 486, 611, 751, 466, 707, 857, 295, 3479, 12334, 19618, 1219, 51642], 'temperature': 0.0, 'avg_logprob': -0.17244140836927627, 'compression_ratio': 1.8461538461538463, 'no_speech_prob': 0.11504489928483963}, {'id': 443, 'seek': 259166, 'start': 2591.7, 'end': 2595.98, 'text': ' peephole optimization. So, this is how we are going to cover, these are the things that', 'tokens': [50366, 520, 595, 14094, 19618, 13, 407, 11, 341, 307, 577, 321, 366, 516, 281, 2060, 11, 613, 366, 264, 721, 300, 50580], 'temperature': 0.0, 'avg_logprob': -0.1885038654455978, 'compression_ratio': 1.7, 'no_speech_prob': 0.051045406609773636}, {'id': 444, 'seek': 259166, 'start': 2595.98, 'end': 2602.98, 'text': ' we are going to cover in this module and we will kind of get to a shape by which we can', 'tokens': [50580, 321, 366, 516, 281, 2060, 294, 341, 10088, 293, 321, 486, 733, 295, 483, 281, 257, 3909, 538, 597, 321, 393, 50930], 'temperature': 0.0, 'avg_logprob': -0.1885038654455978, 'compression_ratio': 1.7, 'no_speech_prob': 0.051045406609773636}, {'id': 445, 'seek': 259166, 'start': 2603.14, 'end': 2610.14, 'text': ' do code generation, right. So, you might have seen that these are the different phases of', 'tokens': [50938, 360, 3089, 5125, 11, 558, 13, 407, 11, 291, 1062, 362, 1612, 300, 613, 366, 264, 819, 18764, 295, 51288], 'temperature': 0.0, 'avg_logprob': -0.1885038654455978, 'compression_ratio': 1.7, 'no_speech_prob': 0.051045406609773636}, {'id': 446, 'seek': 259166, 'start': 2610.14, 'end': 2617.14, 'text': ' the compiler, right. And obviously things on lexical analysis, syntax analysis and semantic', 'tokens': [51288, 264, 31958, 11, 558, 13, 400, 2745, 721, 322, 476, 87, 804, 5215, 11, 28431, 5215, 293, 47982, 51638], 'temperature': 0.0, 'avg_logprob': -0.1885038654455978, 'compression_ratio': 1.7, 'no_speech_prob': 0.051045406609773636}, {'id': 447, 'seek': 261714, 'start': 2617.14, 'end': 2624.14, 'text': ' analysis would have been covered. You would have also seen intermediate code generation,', 'tokens': [50364, 5215, 576, 362, 668, 5343, 13, 509, 576, 362, 611, 1612, 19376, 3089, 5125, 11, 50714], 'temperature': 0.0, 'avg_logprob': -0.2171459436416626, 'compression_ratio': 1.7990196078431373, 'no_speech_prob': 0.0027077114209532738}, {'id': 448, 'seek': 261714, 'start': 2624.14, 'end': 2631.14, 'text': ' correct. And you would have also seen machine independent optimization in the last two days,', 'tokens': [50714, 3006, 13, 400, 291, 576, 362, 611, 1612, 3479, 6695, 19618, 294, 264, 1036, 732, 1708, 11, 51064], 'temperature': 0.0, 'avg_logprob': -0.2171459436416626, 'compression_ratio': 1.7990196078431373, 'no_speech_prob': 0.0027077114209532738}, {'id': 449, 'seek': 261714, 'start': 2631.66, 'end': 2638.66, 'text': ' correct. So, all of this has been covered so far, right. So, what we are going to assume', 'tokens': [51090, 3006, 13, 407, 11, 439, 295, 341, 575, 668, 5343, 370, 1400, 11, 558, 13, 407, 11, 437, 321, 366, 516, 281, 6552, 51440], 'temperature': 0.0, 'avg_logprob': -0.2171459436416626, 'compression_ratio': 1.7990196078431373, 'no_speech_prob': 0.0027077114209532738}, {'id': 450, 'seek': 261714, 'start': 2638.74, 'end': 2644.7, 'text': ' is that you are given an optimized intermediate code. What kinds of intermediate representations', 'tokens': [51444, 307, 300, 291, 366, 2212, 364, 26941, 19376, 3089, 13, 708, 3685, 295, 19376, 33358, 51742], 'temperature': 0.0, 'avg_logprob': -0.2171459436416626, 'compression_ratio': 1.7990196078431373, 'no_speech_prob': 0.0027077114209532738}, {'id': 451, 'seek': 264470, 'start': 2644.7, 'end': 2651.7, 'text': ' did you people see? Three address code, anything else? AST, then. So, we are going to assume', 'tokens': [50364, 630, 291, 561, 536, 30, 6244, 2985, 3089, 11, 1340, 1646, 30, 316, 6840, 11, 550, 13, 407, 11, 321, 366, 516, 281, 6552, 50714], 'temperature': 0.0, 'avg_logprob': -0.19492956879851106, 'compression_ratio': 1.6267942583732058, 'no_speech_prob': 0.0066728368401527405}, {'id': 452, 'seek': 264470, 'start': 2655.58, 'end': 2660.22, 'text': ' that you are going to be given one of those things and we are going to assume that all', 'tokens': [50908, 300, 291, 366, 516, 281, 312, 2212, 472, 295, 729, 721, 293, 321, 366, 516, 281, 6552, 300, 439, 51140], 'temperature': 0.0, 'avg_logprob': -0.19492956879851106, 'compression_ratio': 1.6267942583732058, 'no_speech_prob': 0.0066728368401527405}, {'id': 453, 'seek': 264470, 'start': 2660.22, 'end': 2666.4199999999996, 'text': ' the machine independent optimization have already been performed, right.', 'tokens': [51140, 264, 3479, 6695, 19618, 362, 1217, 668, 10332, 11, 558, 13, 51450], 'temperature': 0.0, 'avg_logprob': -0.19492956879851106, 'compression_ratio': 1.6267942583732058, 'no_speech_prob': 0.0066728368401527405}, {'id': 454, 'seek': 264470, 'start': 2666.4199999999996, 'end': 2673.4199999999996, 'text': ' Now our objective is to take this optimized intermediate code and generate an efficient', 'tokens': [51450, 823, 527, 10024, 307, 281, 747, 341, 26941, 19376, 3089, 293, 8460, 364, 7148, 51800], 'temperature': 0.0, 'avg_logprob': -0.19492956879851106, 'compression_ratio': 1.6267942583732058, 'no_speech_prob': 0.0066728368401527405}, {'id': 455, 'seek': 267470, 'start': 2674.7, 'end': 2680.46, 'text': ' target code, right. And we are, as I mentioned earlier, we are only going to consider about', 'tokens': [50364, 3779, 3089, 11, 558, 13, 400, 321, 366, 11, 382, 286, 2835, 3071, 11, 321, 366, 787, 516, 281, 1949, 466, 50652], 'temperature': 0.0, 'avg_logprob': -0.14360377902076357, 'compression_ratio': 1.679245283018868, 'no_speech_prob': 0.0020901768002659082}, {'id': 456, 'seek': 267470, 'start': 2680.46, 'end': 2685.74, 'text': ' generating assembly code. From the assembly code going to the machine code is a part of', 'tokens': [50652, 17746, 12103, 3089, 13, 3358, 264, 12103, 3089, 516, 281, 264, 3479, 3089, 307, 257, 644, 295, 50916], 'temperature': 0.0, 'avg_logprob': -0.14360377902076357, 'compression_ratio': 1.679245283018868, 'no_speech_prob': 0.0020901768002659082}, {'id': 457, 'seek': 267470, 'start': 2685.74, 'end': 2692.74, 'text': ' the assembler which we will not discuss, okay. So, again as far as the machine dependent', 'tokens': [50916, 264, 8438, 1918, 597, 321, 486, 406, 2248, 11, 1392, 13, 407, 11, 797, 382, 1400, 382, 264, 3479, 12334, 51266], 'temperature': 0.0, 'avg_logprob': -0.14360377902076357, 'compression_ratio': 1.679245283018868, 'no_speech_prob': 0.0020901768002659082}, {'id': 458, 'seek': 267470, 'start': 2696.58, 'end': 2701.14, 'text': ' optimizations are concerned, these are the different phases. You do code generation and', 'tokens': [51458, 5028, 14455, 366, 5922, 11, 613, 366, 264, 819, 18764, 13, 509, 360, 3089, 5125, 293, 51686], 'temperature': 0.0, 'avg_logprob': -0.14360377902076357, 'compression_ratio': 1.679245283018868, 'no_speech_prob': 0.0020901768002659082}, {'id': 459, 'seek': 270114, 'start': 2701.14, 'end': 2707.62, 'text': ' as a part of the code generation you do instruction selection. Then you do a set of machine dependent', 'tokens': [50364, 382, 257, 644, 295, 264, 3089, 5125, 291, 360, 10951, 9450, 13, 1396, 291, 360, 257, 992, 295, 3479, 12334, 50688], 'temperature': 0.0, 'avg_logprob': -0.1493994930002949, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.004870275966823101}, {'id': 460, 'seek': 270114, 'start': 2707.62, 'end': 2712.7799999999997, 'text': ' optimizations which is what I call as the peephole optimization. And once you have finished', 'tokens': [50688, 5028, 14455, 597, 307, 437, 286, 818, 382, 264, 520, 595, 14094, 19618, 13, 400, 1564, 291, 362, 4335, 50946], 'temperature': 0.0, 'avg_logprob': -0.1493994930002949, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.004870275966823101}, {'id': 461, 'seek': 270114, 'start': 2712.7799999999997, 'end': 2719.5, 'text': ' all of these things you have a so called an efficient code, right. On that you may possibly', 'tokens': [50946, 439, 295, 613, 721, 291, 362, 257, 370, 1219, 364, 7148, 3089, 11, 558, 13, 1282, 300, 291, 815, 6264, 51282], 'temperature': 0.0, 'avg_logprob': -0.1493994930002949, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.004870275966823101}, {'id': 462, 'seek': 270114, 'start': 2719.5, 'end': 2725.18, 'text': ' do the register allocation. Then after that you do instruction scheduling', 'tokens': [51282, 360, 264, 7280, 27599, 13, 1396, 934, 300, 291, 360, 10951, 29055, 51566], 'temperature': 0.0, 'avg_logprob': -0.1493994930002949, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.004870275966823101}, {'id': 463, 'seek': 270114, 'start': 2725.18, 'end': 2730.3799999999997, 'text': ' in, it is not after that you actually do that before doing register allocation. But then', 'tokens': [51566, 294, 11, 309, 307, 406, 934, 300, 291, 767, 360, 300, 949, 884, 7280, 27599, 13, 583, 550, 51826], 'temperature': 0.0, 'avg_logprob': -0.1493994930002949, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.004870275966823101}, {'id': 464, 'seek': 273038, 'start': 2730.38, 'end': 2735.1800000000003, 'text': ' again it is possible to think of doing it in any order. So, these are two other components', 'tokens': [50364, 797, 309, 307, 1944, 281, 519, 295, 884, 309, 294, 604, 1668, 13, 407, 11, 613, 366, 732, 661, 6677, 50604], 'temperature': 0.0, 'avg_logprob': -0.16480174106834208, 'compression_ratio': 1.7054263565891472, 'no_speech_prob': 0.0028966667596250772}, {'id': 465, 'seek': 273038, 'start': 2735.1800000000003, 'end': 2741.58, 'text': ' that we are going to see. And the essential challenges here are that generating code,', 'tokens': [50604, 300, 321, 366, 516, 281, 536, 13, 400, 264, 7115, 4759, 510, 366, 300, 17746, 3089, 11, 50924], 'temperature': 0.0, 'avg_logprob': -0.16480174106834208, 'compression_ratio': 1.7054263565891472, 'no_speech_prob': 0.0028966667596250772}, {'id': 466, 'seek': 273038, 'start': 2741.58, 'end': 2748.06, 'text': ' right, is a non-trivial task, okay, given the intermediate code. Intermediate code is', 'tokens': [50924, 558, 11, 307, 257, 2107, 12, 83, 470, 22640, 5633, 11, 1392, 11, 2212, 264, 19376, 3089, 13, 5751, 3130, 473, 3089, 307, 51248], 'temperature': 0.0, 'avg_logprob': -0.16480174106834208, 'compression_ratio': 1.7054263565891472, 'no_speech_prob': 0.0028966667596250772}, {'id': 467, 'seek': 273038, 'start': 2748.06, 'end': 2753.02, 'text': ' in what form? Three address code form, right. But the three address code, how complex or', 'tokens': [51248, 294, 437, 1254, 30, 6244, 2985, 3089, 1254, 11, 558, 13, 583, 264, 1045, 2985, 3089, 11, 577, 3997, 420, 51496], 'temperature': 0.0, 'avg_logprob': -0.16480174106834208, 'compression_ratio': 1.7054263565891472, 'no_speech_prob': 0.0028966667596250772}, {'id': 468, 'seek': 273038, 'start': 2753.02, 'end': 2758.2200000000003, 'text': ' simple is it? Relatively simple, right. From the high level you have reduced it down to,', 'tokens': [51496, 2199, 307, 309, 30, 8738, 19020, 2199, 11, 558, 13, 3358, 264, 1090, 1496, 291, 362, 9212, 309, 760, 281, 11, 51756], 'temperature': 0.0, 'avg_logprob': -0.16480174106834208, 'compression_ratio': 1.7054263565891472, 'no_speech_prob': 0.0028966667596250772}, {'id': 469, 'seek': 275822, 'start': 2759.02, 'end': 2763.4199999999996, 'text': ' right, simple things. And if you look at it in some sense it is closer to the assembly', 'tokens': [50404, 558, 11, 2199, 721, 13, 400, 498, 291, 574, 412, 309, 294, 512, 2020, 309, 307, 4966, 281, 264, 12103, 50624], 'temperature': 0.0, 'avg_logprob': -0.16081828162783668, 'compression_ratio': 1.73828125, 'no_speech_prob': 0.018325289711356163}, {'id': 470, 'seek': 275822, 'start': 2763.4199999999996, 'end': 2769.7799999999997, 'text': ' code, correct. It is somewhat closer to the assembly code. But yet going from that intermediate', 'tokens': [50624, 3089, 11, 3006, 13, 467, 307, 8344, 4966, 281, 264, 12103, 3089, 13, 583, 1939, 516, 490, 300, 19376, 50942], 'temperature': 0.0, 'avg_logprob': -0.16081828162783668, 'compression_ratio': 1.73828125, 'no_speech_prob': 0.018325289711356163}, {'id': 471, 'seek': 275822, 'start': 2769.7799999999997, 'end': 2774.9399999999996, 'text': ' code to the assembly code is not that trivial. There are several ways by which you can do', 'tokens': [50942, 3089, 281, 264, 12103, 3089, 307, 406, 300, 26703, 13, 821, 366, 2940, 2098, 538, 597, 291, 393, 360, 51200], 'temperature': 0.0, 'avg_logprob': -0.16081828162783668, 'compression_ratio': 1.73828125, 'no_speech_prob': 0.018325289711356163}, {'id': 472, 'seek': 275822, 'start': 2774.9399999999996, 'end': 2781.2999999999997, 'text': ' this and each will have its own cost. And you may end up incurring unnecessary cost', 'tokens': [51200, 341, 293, 1184, 486, 362, 1080, 1065, 2063, 13, 400, 291, 815, 917, 493, 35774, 2937, 19350, 2063, 51518], 'temperature': 0.0, 'avg_logprob': -0.16081828162783668, 'compression_ratio': 1.73828125, 'no_speech_prob': 0.018325289711356163}, {'id': 473, 'seek': 275822, 'start': 2781.2999999999997, 'end': 2786.8999999999996, 'text': ' if you are not being efficient about it. The problem of generating the so called optimal', 'tokens': [51518, 498, 291, 366, 406, 885, 7148, 466, 309, 13, 440, 1154, 295, 17746, 264, 370, 1219, 16252, 51798], 'temperature': 0.0, 'avg_logprob': -0.16081828162783668, 'compression_ratio': 1.73828125, 'no_speech_prob': 0.018325289711356163}, {'id': 474, 'seek': 278690, 'start': 2786.9, 'end': 2794.02, 'text': ' code is an NP-hard problem. In fact several of these problems that you see here, right,', 'tokens': [50364, 3089, 307, 364, 38611, 12, 21491, 1154, 13, 682, 1186, 2940, 295, 613, 2740, 300, 291, 536, 510, 11, 558, 11, 50720], 'temperature': 0.0, 'avg_logprob': -0.16837094844072714, 'compression_ratio': 1.639269406392694, 'no_speech_prob': 0.02695845067501068}, {'id': 475, 'seek': 278690, 'start': 2794.02, 'end': 2801.5, 'text': ' fall in this NP class. And therefore getting the optimal solution for them will take a', 'tokens': [50720, 2100, 294, 341, 38611, 1508, 13, 400, 4412, 1242, 264, 16252, 3827, 337, 552, 486, 747, 257, 51094], 'temperature': 0.0, 'avg_logprob': -0.16837094844072714, 'compression_ratio': 1.639269406392694, 'no_speech_prob': 0.02695845067501068}, {'id': 476, 'seek': 278690, 'start': 2801.5, 'end': 2808.34, 'text': ' large amount of compile time, that is computation time, right. And therefore we may end up going', 'tokens': [51094, 2416, 2372, 295, 31413, 565, 11, 300, 307, 24903, 565, 11, 558, 13, 400, 4412, 321, 815, 917, 493, 516, 51436], 'temperature': 0.0, 'avg_logprob': -0.16837094844072714, 'compression_ratio': 1.639269406392694, 'no_speech_prob': 0.02695845067501068}, {'id': 477, 'seek': 278690, 'start': 2808.34, 'end': 2812.7000000000003, 'text': ' for certain heuristic solutions for these things. Again I will talk, when we talk about', 'tokens': [51436, 337, 1629, 415, 374, 3142, 6547, 337, 613, 721, 13, 3764, 286, 486, 751, 11, 562, 321, 751, 466, 51654], 'temperature': 0.0, 'avg_logprob': -0.16837094844072714, 'compression_ratio': 1.639269406392694, 'no_speech_prob': 0.02695845067501068}, {'id': 478, 'seek': 281270, 'start': 2812.7, 'end': 2817.2599999999998, 'text': ' code generation we will talk about which problem is NP-hard and why, what kind of solutions', 'tokens': [50364, 3089, 5125, 321, 486, 751, 466, 597, 1154, 307, 38611, 12, 21491, 293, 983, 11, 437, 733, 295, 6547, 50592], 'temperature': 0.0, 'avg_logprob': -0.16109533158559647, 'compression_ratio': 2.0866141732283463, 'no_speech_prob': 0.12555475533008575}, {'id': 479, 'seek': 281270, 'start': 2817.2599999999998, 'end': 2821.2999999999997, 'text': ' we go for that. Similarly when we talk about register allocation we will talk about why', 'tokens': [50592, 321, 352, 337, 300, 13, 13157, 562, 321, 751, 466, 7280, 27599, 321, 486, 751, 466, 983, 50794], 'temperature': 0.0, 'avg_logprob': -0.16109533158559647, 'compression_ratio': 2.0866141732283463, 'no_speech_prob': 0.12555475533008575}, {'id': 480, 'seek': 281270, 'start': 2821.2999999999997, 'end': 2825.7799999999997, 'text': ' register allocation problem is like that and so on and so on, right.', 'tokens': [50794, 7280, 27599, 1154, 307, 411, 300, 293, 370, 322, 293, 370, 322, 11, 558, 13, 51018], 'temperature': 0.0, 'avg_logprob': -0.16109533158559647, 'compression_ratio': 2.0866141732283463, 'no_speech_prob': 0.12555475533008575}, {'id': 481, 'seek': 281270, 'start': 2825.7799999999997, 'end': 2830.54, 'text': ' So optimal code generation, register allocation, instruction scheduling, all of these problems', 'tokens': [51018, 407, 16252, 3089, 5125, 11, 7280, 27599, 11, 10951, 29055, 11, 439, 295, 613, 2740, 51256], 'temperature': 0.0, 'avg_logprob': -0.16109533158559647, 'compression_ratio': 2.0866141732283463, 'no_speech_prob': 0.12555475533008575}, {'id': 482, 'seek': 281270, 'start': 2830.54, 'end': 2836.66, 'text': ' are NP-hard. So if you want to get the optimal solution you have to spend a lot of, the complexity', 'tokens': [51256, 366, 38611, 12, 21491, 13, 407, 498, 291, 528, 281, 483, 264, 16252, 3827, 291, 362, 281, 3496, 257, 688, 295, 11, 264, 14024, 51562], 'temperature': 0.0, 'avg_logprob': -0.16109533158559647, 'compression_ratio': 2.0866141732283463, 'no_speech_prob': 0.12555475533008575}, {'id': 483, 'seek': 281270, 'start': 2836.66, 'end': 2841.3799999999997, 'text': ' is high so you have to spend a lot of time for that. So we will not obviously get that.', 'tokens': [51562, 307, 1090, 370, 291, 362, 281, 3496, 257, 688, 295, 565, 337, 300, 13, 407, 321, 486, 406, 2745, 483, 300, 13, 51798], 'temperature': 0.0, 'avg_logprob': -0.16109533158559647, 'compression_ratio': 2.0866141732283463, 'no_speech_prob': 0.12555475533008575}, {'id': 484, 'seek': 284138, 'start': 2841.38, 'end': 2847.34, 'text': ' We will try to see efficient solutions for all of them. Okay, just to put things in perspective', 'tokens': [50364, 492, 486, 853, 281, 536, 7148, 6547, 337, 439, 295, 552, 13, 1033, 11, 445, 281, 829, 721, 294, 4585, 50662], 'temperature': 0.0, 'avg_logprob': -0.15516604979832968, 'compression_ratio': 1.7421875, 'no_speech_prob': 0.007611705455929041}, {'id': 485, 'seek': 284138, 'start': 2847.34, 'end': 2852.62, 'text': ' as I mentioned earlier we are going to take an optimized intermediate code and generate', 'tokens': [50662, 382, 286, 2835, 3071, 321, 366, 516, 281, 747, 364, 26941, 19376, 3089, 293, 8460, 50926], 'temperature': 0.0, 'avg_logprob': -0.15516604979832968, 'compression_ratio': 1.7421875, 'no_speech_prob': 0.007611705455929041}, {'id': 486, 'seek': 284138, 'start': 2852.62, 'end': 2857.82, 'text': ' an efficient target assembly code. So this consists of two parts which is basically the', 'tokens': [50926, 364, 7148, 3779, 12103, 3089, 13, 407, 341, 14689, 295, 732, 3166, 597, 307, 1936, 264, 51186], 'temperature': 0.0, 'avg_logprob': -0.15516604979832968, 'compression_ratio': 1.7421875, 'no_speech_prob': 0.007611705455929041}, {'id': 487, 'seek': 284138, 'start': 2857.82, 'end': 2863.38, 'text': ' target code generator and then certain code optimizations. And these code optimizations', 'tokens': [51186, 3779, 3089, 19265, 293, 550, 1629, 3089, 5028, 14455, 13, 400, 613, 3089, 5028, 14455, 51464], 'temperature': 0.0, 'avg_logprob': -0.15516604979832968, 'compression_ratio': 1.7421875, 'no_speech_prob': 0.007611705455929041}, {'id': 488, 'seek': 284138, 'start': 2863.38, 'end': 2869.7000000000003, 'text': ' are specific for the target machine that you are talking about. Okay, so what could be', 'tokens': [51464, 366, 2685, 337, 264, 3779, 3479, 300, 291, 366, 1417, 466, 13, 1033, 11, 370, 437, 727, 312, 51780], 'temperature': 0.0, 'avg_logprob': -0.15516604979832968, 'compression_ratio': 1.7421875, 'no_speech_prob': 0.007611705455929041}, {'id': 489, 'seek': 286970, 'start': 2869.7, 'end': 2875.48, 'text': ' the forms in which intermediate code can be? It can be a three address code, it can', 'tokens': [50364, 264, 6422, 294, 597, 19376, 3089, 393, 312, 30, 467, 393, 312, 257, 1045, 2985, 3089, 11, 309, 393, 50653], 'temperature': 0.0, 'avg_logprob': -0.1682889665876116, 'compression_ratio': 1.7950819672131149, 'no_speech_prob': 0.04702961444854736}, {'id': 490, 'seek': 286970, 'start': 2875.48, 'end': 2881.62, 'text': ' be some kind of a syntax tree, okay or it can be a linear representation, right.', 'tokens': [50653, 312, 512, 733, 295, 257, 28431, 4230, 11, 1392, 420, 309, 393, 312, 257, 8213, 10290, 11, 558, 13, 50960], 'temperature': 0.0, 'avg_logprob': -0.1682889665876116, 'compression_ratio': 1.7950819672131149, 'no_speech_prob': 0.04702961444854736}, {'id': 491, 'seek': 286970, 'start': 2881.62, 'end': 2887.18, 'text': ' When you talk about other kinds of compilation environments you also talk about what is called', 'tokens': [50960, 1133, 291, 751, 466, 661, 3685, 295, 40261, 12388, 291, 611, 751, 466, 437, 307, 1219, 51238], 'temperature': 0.0, 'avg_logprob': -0.1682889665876116, 'compression_ratio': 1.7950819672131149, 'no_speech_prob': 0.04702961444854736}, {'id': 492, 'seek': 286970, 'start': 2887.18, 'end': 2892.58, 'text': ' byte code, right. Many of you who are familiar with Java, Java generates, when you compile', 'tokens': [51238, 40846, 3089, 11, 558, 13, 5126, 295, 291, 567, 366, 4963, 365, 10745, 11, 10745, 23815, 11, 562, 291, 31413, 51508], 'temperature': 0.0, 'avg_logprob': -0.1682889665876116, 'compression_ratio': 1.7950819672131149, 'no_speech_prob': 0.04702961444854736}, {'id': 493, 'seek': 286970, 'start': 2892.58, 'end': 2898.3399999999997, 'text': ' a Java code it generates a byte code and the byte code is what is being executed by the', 'tokens': [51508, 257, 10745, 3089, 309, 23815, 257, 40846, 3089, 293, 264, 40846, 3089, 307, 437, 307, 885, 17577, 538, 264, 51796], 'temperature': 0.0, 'avg_logprob': -0.1682889665876116, 'compression_ratio': 1.7950819672131149, 'no_speech_prob': 0.04702961444854736}, {'id': 494, 'seek': 289834, 'start': 2898.34, 'end': 2905.34, 'text': ' Java virtual machine, correct. Typically the byte code is interpreted by the Java virtual', 'tokens': [50364, 10745, 6374, 3479, 11, 3006, 13, 23129, 264, 40846, 3089, 307, 26749, 538, 264, 10745, 6374, 50714], 'temperature': 0.0, 'avg_logprob': -0.19898113337430087, 'compression_ratio': 1.7843137254901962, 'no_speech_prob': 0.11045435070991516}, {'id': 495, 'seek': 289834, 'start': 2905.7000000000003, 'end': 2912.7000000000003, 'text': ' machine, right. But then in your Java virtual machine you can write a compiler which is', 'tokens': [50732, 3479, 11, 558, 13, 583, 550, 294, 428, 10745, 6374, 3479, 291, 393, 2464, 257, 31958, 597, 307, 51082], 'temperature': 0.0, 'avg_logprob': -0.19898113337430087, 'compression_ratio': 1.7843137254901962, 'no_speech_prob': 0.11045435070991516}, {'id': 496, 'seek': 289834, 'start': 2913.06, 'end': 2919.6600000000003, 'text': ' what they call as a just-in-time compiler that can take the byte code and generate executable', 'tokens': [51100, 437, 436, 818, 382, 257, 445, 12, 259, 12, 3766, 31958, 300, 393, 747, 264, 40846, 3089, 293, 8460, 7568, 712, 51430], 'temperature': 0.0, 'avg_logprob': -0.19898113337430087, 'compression_ratio': 1.7843137254901962, 'no_speech_prob': 0.11045435070991516}, {'id': 497, 'seek': 289834, 'start': 2919.6600000000003, 'end': 2926.02, 'text': ' code for that, correct. So in that case if you are considering of let us say a JIT compiler,', 'tokens': [51430, 3089, 337, 300, 11, 3006, 13, 407, 294, 300, 1389, 498, 291, 366, 8079, 295, 718, 505, 584, 257, 508, 3927, 31958, 11, 51748], 'temperature': 0.0, 'avg_logprob': -0.19898113337430087, 'compression_ratio': 1.7843137254901962, 'no_speech_prob': 0.11045435070991516}, {'id': 498, 'seek': 292602, 'start': 2926.02, 'end': 2930.06, 'text': ' that JIT compiler would have the byte code sequence as its intermediate representation,', 'tokens': [50364, 300, 508, 3927, 31958, 576, 362, 264, 40846, 3089, 8310, 382, 1080, 19376, 10290, 11, 50566], 'temperature': 0.0, 'avg_logprob': -0.2068737264265094, 'compression_ratio': 1.96484375, 'no_speech_prob': 0.0062637426890432835}, {'id': 499, 'seek': 292602, 'start': 2930.06, 'end': 2935.82, 'text': ' right. Or like any of the other intermediate representation that you are familiar with', 'tokens': [50566, 558, 13, 1610, 411, 604, 295, 264, 661, 19376, 10290, 300, 291, 366, 4963, 365, 50854], 'temperature': 0.0, 'avg_logprob': -0.2068737264265094, 'compression_ratio': 1.96484375, 'no_speech_prob': 0.0062637426890432835}, {'id': 500, 'seek': 292602, 'start': 2935.82, 'end': 2939.98, 'text': ' in the case of a normal, right, offline compilation kind of thing.', 'tokens': [50854, 294, 264, 1389, 295, 257, 2710, 11, 558, 11, 21857, 40261, 733, 295, 551, 13, 51062], 'temperature': 0.0, 'avg_logprob': -0.2068737264265094, 'compression_ratio': 1.96484375, 'no_speech_prob': 0.0062637426890432835}, {'id': 501, 'seek': 292602, 'start': 2939.98, 'end': 2945.2599999999998, 'text': ' The output that you generate is basically the target assembly code and depending on', 'tokens': [51062, 440, 5598, 300, 291, 8460, 307, 1936, 264, 3779, 12103, 3089, 293, 5413, 322, 51326], 'temperature': 0.0, 'avg_logprob': -0.2068737264265094, 'compression_ratio': 1.96484375, 'no_speech_prob': 0.0062637426890432835}, {'id': 502, 'seek': 292602, 'start': 2945.2599999999998, 'end': 2949.42, 'text': ' whether your processor is a RISC processor you generate a RISC code. If your processor', 'tokens': [51326, 1968, 428, 15321, 307, 257, 497, 2343, 34, 15321, 291, 8460, 257, 497, 2343, 34, 3089, 13, 759, 428, 15321, 51534], 'temperature': 0.0, 'avg_logprob': -0.2068737264265094, 'compression_ratio': 1.96484375, 'no_speech_prob': 0.0062637426890432835}, {'id': 503, 'seek': 292602, 'start': 2949.42, 'end': 2955.62, 'text': ' is a CISC processor you generate the appropriate RISC code. If you are generating code for', 'tokens': [51534, 307, 257, 383, 2343, 34, 15321, 291, 8460, 264, 6854, 497, 2343, 34, 3089, 13, 759, 291, 366, 17746, 3089, 337, 51844], 'temperature': 0.0, 'avg_logprob': -0.2068737264265094, 'compression_ratio': 1.96484375, 'no_speech_prob': 0.0062637426890432835}, {'id': 504, 'seek': 295562, 'start': 2955.62, 'end': 2960.5, 'text': ' let us say if you are generating byte code taking the Java as your input language, okay', 'tokens': [50364, 718, 505, 584, 498, 291, 366, 17746, 40846, 3089, 1940, 264, 10745, 382, 428, 4846, 2856, 11, 1392, 50608], 'temperature': 0.0, 'avg_logprob': -0.120804174891058, 'compression_ratio': 2.1333333333333333, 'no_speech_prob': 0.0019451770931482315}, {'id': 505, 'seek': 295562, 'start': 2960.5, 'end': 2966.2999999999997, 'text': ' and you are generating byte code, Java byte code then you are essentially generating that', 'tokens': [50608, 293, 291, 366, 17746, 40846, 3089, 11, 10745, 40846, 3089, 550, 291, 366, 4476, 17746, 300, 50898], 'temperature': 0.0, 'avg_logprob': -0.120804174891058, 'compression_ratio': 2.1333333333333333, 'no_speech_prob': 0.0019451770931482315}, {'id': 506, 'seek': 295562, 'start': 2966.2999999999997, 'end': 2972.8199999999997, 'text': ' byte code as your output code. So again this notion of what is input, what is output depends', 'tokens': [50898, 40846, 3089, 382, 428, 5598, 3089, 13, 407, 797, 341, 10710, 295, 437, 307, 4846, 11, 437, 307, 5598, 5946, 51224], 'temperature': 0.0, 'avg_logprob': -0.120804174891058, 'compression_ratio': 2.1333333333333333, 'no_speech_prob': 0.0019451770931482315}, {'id': 507, 'seek': 295562, 'start': 2972.8199999999997, 'end': 2977.62, 'text': ' on what is the context in which you are working on. If you are talking about a JIT compiler', 'tokens': [51224, 322, 437, 307, 264, 4319, 294, 597, 291, 366, 1364, 322, 13, 759, 291, 366, 1417, 466, 257, 508, 3927, 31958, 51464], 'temperature': 0.0, 'avg_logprob': -0.120804174891058, 'compression_ratio': 2.1333333333333333, 'no_speech_prob': 0.0019451770931482315}, {'id': 508, 'seek': 295562, 'start': 2977.62, 'end': 2981.98, 'text': ' your input is a byte code and your output is an object code. If you are talking about', 'tokens': [51464, 428, 4846, 307, 257, 40846, 3089, 293, 428, 5598, 307, 364, 2657, 3089, 13, 759, 291, 366, 1417, 466, 51682], 'temperature': 0.0, 'avg_logprob': -0.120804174891058, 'compression_ratio': 2.1333333333333333, 'no_speech_prob': 0.0019451770931482315}, {'id': 509, 'seek': 298198, 'start': 2981.98, 'end': 2988.22, 'text': ' a Java compiler your input might be a three address code or a syntax tree and your output', 'tokens': [50364, 257, 10745, 31958, 428, 4846, 1062, 312, 257, 1045, 2985, 3089, 420, 257, 28431, 4230, 293, 428, 5598, 50676], 'temperature': 0.0, 'avg_logprob': -0.10885708831077398, 'compression_ratio': 1.6990291262135921, 'no_speech_prob': 0.04570278525352478}, {'id': 510, 'seek': 298198, 'start': 2988.22, 'end': 2994.7, 'text': ' might be a byte code, correct. So all of this can be called as code generation', 'tokens': [50676, 1062, 312, 257, 40846, 3089, 11, 3006, 13, 407, 439, 295, 341, 393, 312, 1219, 382, 3089, 5125, 51000], 'temperature': 0.0, 'avg_logprob': -0.10885708831077398, 'compression_ratio': 1.6990291262135921, 'no_speech_prob': 0.04570278525352478}, {'id': 511, 'seek': 298198, 'start': 2994.7, 'end': 2999.82, 'text': ' in some sense. Of course we are going to focus more on taking a three address code and generating', 'tokens': [51000, 294, 512, 2020, 13, 2720, 1164, 321, 366, 516, 281, 1879, 544, 322, 1940, 257, 1045, 2985, 3089, 293, 17746, 51256], 'temperature': 0.0, 'avg_logprob': -0.10885708831077398, 'compression_ratio': 1.6990291262135921, 'no_speech_prob': 0.04570278525352478}, {'id': 512, 'seek': 298198, 'start': 2999.82, 'end': 3007.38, 'text': ' an assembly code and we are going to give all our examples for a CISC machine, okay', 'tokens': [51256, 364, 12103, 3089, 293, 321, 366, 516, 281, 976, 439, 527, 5110, 337, 257, 383, 2343, 34, 3479, 11, 1392, 51634], 'temperature': 0.0, 'avg_logprob': -0.10885708831077398, 'compression_ratio': 1.6990291262135921, 'no_speech_prob': 0.04570278525352478}, {'id': 513, 'seek': 300738, 'start': 3007.58, 'end': 3012.86, 'text': ' But the techniques are general enough that you can extend it to RISC machines as well,', 'tokens': [50374, 583, 264, 7512, 366, 2674, 1547, 300, 291, 393, 10101, 309, 281, 497, 2343, 34, 8379, 382, 731, 11, 50638], 'temperature': 0.0, 'avg_logprob': -0.21576794912648756, 'compression_ratio': 1.6759259259259258, 'no_speech_prob': 0.08295388519763947}, {'id': 514, 'seek': 300738, 'start': 3012.86, 'end': 3021.78, 'text': ' right. But examples are unfortunately going to be for a CISC machine, all right. Okay.', 'tokens': [50638, 558, 13, 583, 5110, 366, 7015, 516, 281, 312, 337, 257, 383, 2343, 34, 3479, 11, 439, 558, 13, 1033, 13, 51084], 'temperature': 0.0, 'avg_logprob': -0.21576794912648756, 'compression_ratio': 1.6759259259259258, 'no_speech_prob': 0.08295388519763947}, {'id': 515, 'seek': 300738, 'start': 3021.78, 'end': 3026.98, 'text': ' So again we have already answered this question what do we need to know about the target machine', 'tokens': [51084, 407, 797, 321, 362, 1217, 10103, 341, 1168, 437, 360, 321, 643, 281, 458, 466, 264, 3779, 3479, 51344], 'temperature': 0.0, 'avg_logprob': -0.21576794912648756, 'compression_ratio': 1.6759259259259258, 'no_speech_prob': 0.08295388519763947}, {'id': 516, 'seek': 300738, 'start': 3026.98, 'end': 3032.46, 'text': ' for code generation, okay. The simple answer is whatever you wanted to know we have already', 'tokens': [51344, 337, 3089, 5125, 11, 1392, 13, 440, 2199, 1867, 307, 2035, 291, 1415, 281, 458, 321, 362, 1217, 51618], 'temperature': 0.0, 'avg_logprob': -0.21576794912648756, 'compression_ratio': 1.6759259259259258, 'no_speech_prob': 0.08295388519763947}, {'id': 517, 'seek': 303246, 'start': 3032.46, 'end': 3039.3, 'text': ' covered in the last lecture, right. So what are the instructions in the target machine,', 'tokens': [50364, 5343, 294, 264, 1036, 7991, 11, 558, 13, 407, 437, 366, 264, 9415, 294, 264, 3779, 3479, 11, 50706], 'temperature': 0.0, 'avg_logprob': -0.18039316344029696, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.03943381831049919}, {'id': 518, 'seek': 303246, 'start': 3039.3, 'end': 3045.26, 'text': ' right. What are the addressing modes that are required, right. I mean that are supported', 'tokens': [50706, 558, 13, 708, 366, 264, 14329, 14068, 300, 366, 4739, 11, 558, 13, 286, 914, 300, 366, 8104, 51004], 'temperature': 0.0, 'avg_logprob': -0.18039316344029696, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.03943381831049919}, {'id': 519, 'seek': 303246, 'start': 3045.26, 'end': 3049.9, 'text': ' in the architecture. What is the cost of each instruction, right. There are many ways of', 'tokens': [51004, 294, 264, 9482, 13, 708, 307, 264, 2063, 295, 1184, 10951, 11, 558, 13, 821, 366, 867, 2098, 295, 51236], 'temperature': 0.0, 'avg_logprob': -0.18039316344029696, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.03943381831049919}, {'id': 520, 'seek': 303246, 'start': 3049.9, 'end': 3054.94, 'text': ' executing the same instruction or implementing the same instruction. They may have different', 'tokens': [51236, 32368, 264, 912, 10951, 420, 18114, 264, 912, 10951, 13, 814, 815, 362, 819, 51488], 'temperature': 0.0, 'avg_logprob': -0.18039316344029696, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.03943381831049919}, {'id': 521, 'seek': 303246, 'start': 3054.94, 'end': 3060.46, 'text': ' cost. I need to know the cost of this so that I will choose the one which is with the lower', 'tokens': [51488, 2063, 13, 286, 643, 281, 458, 264, 2063, 295, 341, 370, 300, 286, 486, 2826, 264, 472, 597, 307, 365, 264, 3126, 51764], 'temperature': 0.0, 'avg_logprob': -0.18039316344029696, 'compression_ratio': 1.948051948051948, 'no_speech_prob': 0.03943381831049919}, {'id': 522, 'seek': 306046, 'start': 3060.66, 'end': 3067.2200000000003, 'text': ' cost that is the idea. And of course I also need to know how the runtime storage management', 'tokens': [50374, 2063, 300, 307, 264, 1558, 13, 400, 295, 1164, 286, 611, 643, 281, 458, 577, 264, 34474, 6725, 4592, 50702], 'temperature': 0.0, 'avg_logprob': -0.22568895551893448, 'compression_ratio': 1.6561085972850678, 'no_speech_prob': 0.027058551087975502}, {'id': 523, 'seek': 306046, 'start': 3067.2200000000003, 'end': 3074.58, 'text': ' and other things are done, okay. So has runtime environment been covered as a part of this', 'tokens': [50702, 293, 661, 721, 366, 1096, 11, 1392, 13, 407, 575, 34474, 2823, 668, 5343, 382, 257, 644, 295, 341, 51070], 'temperature': 0.0, 'avg_logprob': -0.22568895551893448, 'compression_ratio': 1.6561085972850678, 'no_speech_prob': 0.027058551087975502}, {'id': 524, 'seek': 306046, 'start': 3074.58, 'end': 3083.58, 'text': ' workshop so far? Will be covered later, right. Next week it will be covered, okay. That is', 'tokens': [51070, 13541, 370, 1400, 30, 3099, 312, 5343, 1780, 11, 558, 13, 3087, 1243, 309, 486, 312, 5343, 11, 1392, 13, 663, 307, 51520], 'temperature': 0.0, 'avg_logprob': -0.22568895551893448, 'compression_ratio': 1.6561085972850678, 'no_speech_prob': 0.027058551087975502}, {'id': 525, 'seek': 306046, 'start': 3083.58, 'end': 3087.46, 'text': ' fine. The stack frames and other related things. I am not very sure whether that is going to', 'tokens': [51520, 2489, 13, 440, 8630, 12083, 293, 661, 4077, 721, 13, 286, 669, 406, 588, 988, 1968, 300, 307, 516, 281, 51714], 'temperature': 0.0, 'avg_logprob': -0.22568895551893448, 'compression_ratio': 1.6561085972850678, 'no_speech_prob': 0.027058551087975502}, {'id': 526, 'seek': 308746, 'start': 3087.46, 'end': 3095.34, 'text': ' be covered but okay. Unfortunately you will have to have that gap. I am not planning to', 'tokens': [50364, 312, 5343, 457, 1392, 13, 8590, 291, 486, 362, 281, 362, 300, 7417, 13, 286, 669, 406, 5038, 281, 50758], 'temperature': 0.0, 'avg_logprob': -0.2378134513968852, 'compression_ratio': 1.5056818181818181, 'no_speech_prob': 0.0879056453704834}, {'id': 527, 'seek': 308746, 'start': 3095.34, 'end': 3107.86, 'text': ' cover. We can, I can see whether I can give you a quick reading on that, okay. Sure, sure,', 'tokens': [50758, 2060, 13, 492, 393, 11, 286, 393, 536, 1968, 286, 393, 976, 291, 257, 1702, 3760, 322, 300, 11, 1392, 13, 4894, 11, 988, 11, 51384], 'temperature': 0.0, 'avg_logprob': -0.2378134513968852, 'compression_ratio': 1.5056818181818181, 'no_speech_prob': 0.0879056453704834}, {'id': 528, 'seek': 308746, 'start': 3107.86, 'end': 3114.26, 'text': ' sure, sure. Typically runtime environment how the stack frames are maintained and they', 'tokens': [51384, 988, 11, 988, 13, 23129, 34474, 2823, 577, 264, 8630, 12083, 366, 17578, 293, 436, 51704], 'temperature': 0.0, 'avg_logprob': -0.2378134513968852, 'compression_ratio': 1.5056818181818181, 'no_speech_prob': 0.0879056453704834}, {'id': 529, 'seek': 311426, 'start': 3114.3, 'end': 3120.1400000000003, 'text': ' need to know the parameters, parameter passing, local variables, that kind of a thing, right.', 'tokens': [50366, 643, 281, 458, 264, 9834, 11, 13075, 8437, 11, 2654, 9102, 11, 300, 733, 295, 257, 551, 11, 558, 13, 50658], 'temperature': 0.0, 'avg_logprob': -0.16599512100219727, 'compression_ratio': 1.6136363636363635, 'no_speech_prob': 0.03782515227794647}, {'id': 530, 'seek': 311426, 'start': 3120.1400000000003, 'end': 3131.46, 'text': ' Okay. I should have checked this before but unfortunately I forgot to, right. So this', 'tokens': [50658, 1033, 13, 286, 820, 362, 10033, 341, 949, 457, 7015, 286, 5298, 281, 11, 558, 13, 407, 341, 51224], 'temperature': 0.0, 'avg_logprob': -0.16599512100219727, 'compression_ratio': 1.6136363636363635, 'no_speech_prob': 0.03782515227794647}, {'id': 531, 'seek': 311426, 'start': 3131.46, 'end': 3136.78, 'text': ' part is something that I am sure that Shekhar will take care of coordinating and getting', 'tokens': [51224, 644, 307, 746, 300, 286, 669, 988, 300, 1240, 74, 5854, 486, 747, 1127, 295, 37824, 293, 1242, 51490], 'temperature': 0.0, 'avg_logprob': -0.16599512100219727, 'compression_ratio': 1.6136363636363635, 'no_speech_prob': 0.03782515227794647}, {'id': 532, 'seek': 311426, 'start': 3136.78, 'end': 3142.5800000000004, 'text': ' at least some part of it covered otherwise you can read it, right. Again remember when', 'tokens': [51490, 412, 1935, 512, 644, 295, 309, 5343, 5911, 291, 393, 1401, 309, 11, 558, 13, 3764, 1604, 562, 51780], 'temperature': 0.0, 'avg_logprob': -0.16599512100219727, 'compression_ratio': 1.6136363636363635, 'no_speech_prob': 0.03782515227794647}, {'id': 533, 'seek': 314258, 'start': 3142.58, 'end': 3148.42, 'text': ' we talked about local variables, local variables are allocated in the stack, correct. So you', 'tokens': [50364, 321, 2825, 466, 2654, 9102, 11, 2654, 9102, 366, 29772, 294, 264, 8630, 11, 3006, 13, 407, 291, 50656], 'temperature': 0.0, 'avg_logprob': -0.11187666289660396, 'compression_ratio': 2.059090909090909, 'no_speech_prob': 0.0920274406671524}, {'id': 534, 'seek': 314258, 'start': 3148.42, 'end': 3154.1, 'text': ' need to know how those variables are addressed. They are always addressed with reference to', 'tokens': [50656, 643, 281, 458, 577, 729, 9102, 366, 13847, 13, 814, 366, 1009, 13847, 365, 6408, 281, 50940], 'temperature': 0.0, 'avg_logprob': -0.11187666289660396, 'compression_ratio': 2.059090909090909, 'no_speech_prob': 0.0920274406671524}, {'id': 535, 'seek': 314258, 'start': 3154.1, 'end': 3158.94, 'text': ' either a stack pointer or a frame pointer, more like a frame pointer rather than a stack', 'tokens': [50940, 2139, 257, 8630, 23918, 420, 257, 3920, 23918, 11, 544, 411, 257, 3920, 23918, 2831, 813, 257, 8630, 51182], 'temperature': 0.0, 'avg_logprob': -0.11187666289660396, 'compression_ratio': 2.059090909090909, 'no_speech_prob': 0.0920274406671524}, {'id': 536, 'seek': 314258, 'start': 3158.94, 'end': 3163.9, 'text': ' pointer because that stack frame, right, both the stack pointer and the frame pointer will', 'tokens': [51182, 23918, 570, 300, 8630, 3920, 11, 558, 11, 1293, 264, 8630, 23918, 293, 264, 3920, 23918, 486, 51430], 'temperature': 0.0, 'avg_logprob': -0.11187666289660396, 'compression_ratio': 2.059090909090909, 'no_speech_prob': 0.0920274406671524}, {'id': 537, 'seek': 314258, 'start': 3163.9, 'end': 3169.1, 'text': ' be pointing to that. You typically use the frame pointer to address the local variables,', 'tokens': [51430, 312, 12166, 281, 300, 13, 509, 5850, 764, 264, 3920, 23918, 281, 2985, 264, 2654, 9102, 11, 51690], 'temperature': 0.0, 'avg_logprob': -0.11187666289660396, 'compression_ratio': 2.059090909090909, 'no_speech_prob': 0.0920274406671524}, {'id': 538, 'seek': 316910, 'start': 3169.1, 'end': 3173.7799999999997, 'text': ' right. Similarly for the parameters that you are passing to your function, they will be with', 'tokens': [50364, 558, 13, 13157, 337, 264, 9834, 300, 291, 366, 8437, 281, 428, 2445, 11, 436, 486, 312, 365, 50598], 'temperature': 0.0, 'avg_logprob': -0.13336723290600824, 'compression_ratio': 1.808, 'no_speech_prob': 0.013670114800333977}, {'id': 539, 'seek': 316910, 'start': 3173.7799999999997, 'end': 3179.7, 'text': ' reference to the stack, a frame pointer, right. And when you want to do return that is with', 'tokens': [50598, 6408, 281, 264, 8630, 11, 257, 3920, 23918, 11, 558, 13, 400, 562, 291, 528, 281, 360, 2736, 300, 307, 365, 50894], 'temperature': 0.0, 'avg_logprob': -0.13336723290600824, 'compression_ratio': 1.808, 'no_speech_prob': 0.013670114800333977}, {'id': 540, 'seek': 316910, 'start': 3179.7, 'end': 3185.38, 'text': ' reference to the stack pointer. So managing the stack frame is one aspect that you need to know', 'tokens': [50894, 6408, 281, 264, 8630, 23918, 13, 407, 11642, 264, 8630, 3920, 307, 472, 4171, 300, 291, 643, 281, 458, 51178], 'temperature': 0.0, 'avg_logprob': -0.13336723290600824, 'compression_ratio': 1.808, 'no_speech_prob': 0.013670114800333977}, {'id': 541, 'seek': 316910, 'start': 3185.38, 'end': 3189.8199999999997, 'text': ' in order for you to do the code generation and that part of it is typically covered in', 'tokens': [51178, 294, 1668, 337, 291, 281, 360, 264, 3089, 5125, 293, 300, 644, 295, 309, 307, 5850, 5343, 294, 51400], 'temperature': 0.0, 'avg_logprob': -0.13336723290600824, 'compression_ratio': 1.808, 'no_speech_prob': 0.013670114800333977}, {'id': 542, 'seek': 316910, 'start': 3189.8199999999997, 'end': 3195.5, 'text': ' runtime storage management, okay. Another thing is about call convention. So certain', 'tokens': [51400, 34474, 6725, 4592, 11, 1392, 13, 3996, 551, 307, 466, 818, 10286, 13, 407, 1629, 51684], 'temperature': 0.0, 'avg_logprob': -0.13336723290600824, 'compression_ratio': 1.808, 'no_speech_prob': 0.013670114800333977}, {'id': 543, 'seek': 319550, 'start': 3195.5, 'end': 3201.18, 'text': ' processors have this notion of caller saved register, callee saved registers and so on,', 'tokens': [50364, 27751, 362, 341, 10710, 295, 48324, 6624, 7280, 11, 818, 1653, 6624, 38351, 293, 370, 322, 11, 50648], 'temperature': 0.0, 'avg_logprob': -0.13072114899044945, 'compression_ratio': 2.1666666666666665, 'no_speech_prob': 0.11896071583032608}, {'id': 544, 'seek': 319550, 'start': 3201.18, 'end': 3207.1, 'text': ' right. In a caller saved register before you make the call, the caller will save some of these', 'tokens': [50648, 558, 13, 682, 257, 48324, 6624, 7280, 949, 291, 652, 264, 818, 11, 264, 48324, 486, 3155, 512, 295, 613, 50944], 'temperature': 0.0, 'avg_logprob': -0.13072114899044945, 'compression_ratio': 2.1666666666666665, 'no_speech_prob': 0.11896071583032608}, {'id': 545, 'seek': 319550, 'start': 3207.1, 'end': 3213.42, 'text': ' register contents in the stack before making the call. In the callee saved registers, the callee', 'tokens': [50944, 7280, 15768, 294, 264, 8630, 949, 1455, 264, 818, 13, 682, 264, 818, 1653, 6624, 38351, 11, 264, 818, 1653, 51260], 'temperature': 0.0, 'avg_logprob': -0.13072114899044945, 'compression_ratio': 2.1666666666666665, 'no_speech_prob': 0.11896071583032608}, {'id': 546, 'seek': 319550, 'start': 3213.42, 'end': 3220.02, 'text': ' will save those things in the stack frame before they modify those registers and then before they', 'tokens': [51260, 486, 3155, 729, 721, 294, 264, 8630, 3920, 949, 436, 16927, 729, 38351, 293, 550, 949, 436, 51590], 'temperature': 0.0, 'avg_logprob': -0.13072114899044945, 'compression_ratio': 2.1666666666666665, 'no_speech_prob': 0.11896071583032608}, {'id': 547, 'seek': 322002, 'start': 3220.02, 'end': 3224.9, 'text': ' return from the callee to the caller, they will actually restore those values. So these are', 'tokens': [50364, 2736, 490, 264, 818, 1653, 281, 264, 48324, 11, 436, 486, 767, 15227, 729, 4190, 13, 407, 613, 366, 50608], 'temperature': 0.0, 'avg_logprob': -0.09278467539194468, 'compression_ratio': 1.9007936507936507, 'no_speech_prob': 0.03297015279531479}, {'id': 548, 'seek': 322002, 'start': 3224.9, 'end': 3229.86, 'text': ' responsibilities that are, you know, given to these things. So as a compiler or as a compiler', 'tokens': [50608, 16190, 300, 366, 11, 291, 458, 11, 2212, 281, 613, 721, 13, 407, 382, 257, 31958, 420, 382, 257, 31958, 50856], 'temperature': 0.0, 'avg_logprob': -0.09278467539194468, 'compression_ratio': 1.9007936507936507, 'no_speech_prob': 0.03297015279531479}, {'id': 549, 'seek': 322002, 'start': 3229.86, 'end': 3235.18, 'text': ' writer, you need to know that so that when you generate code before you make a function call,', 'tokens': [50856, 9936, 11, 291, 643, 281, 458, 300, 370, 300, 562, 291, 8460, 3089, 949, 291, 652, 257, 2445, 818, 11, 51122], 'temperature': 0.0, 'avg_logprob': -0.09278467539194468, 'compression_ratio': 1.9007936507936507, 'no_speech_prob': 0.03297015279531479}, {'id': 550, 'seek': 322002, 'start': 3235.18, 'end': 3240.5, 'text': ' all the caller saved registers have to be saved in the stack frame. And in order for you to save', 'tokens': [51122, 439, 264, 48324, 6624, 38351, 362, 281, 312, 6624, 294, 264, 8630, 3920, 13, 400, 294, 1668, 337, 291, 281, 3155, 51388], 'temperature': 0.0, 'avg_logprob': -0.09278467539194468, 'compression_ratio': 1.9007936507936507, 'no_speech_prob': 0.03297015279531479}, {'id': 551, 'seek': 322002, 'start': 3240.5, 'end': 3246.14, 'text': ' them in the stack frame, the stack frame size has to be designed appropriately, decided appropriately.', 'tokens': [51388, 552, 294, 264, 8630, 3920, 11, 264, 8630, 3920, 2744, 575, 281, 312, 4761, 23505, 11, 3047, 23505, 13, 51670], 'temperature': 0.0, 'avg_logprob': -0.09278467539194468, 'compression_ratio': 1.9007936507936507, 'no_speech_prob': 0.03297015279531479}, {'id': 552, 'seek': 324614, 'start': 3246.14, 'end': 3251.1, 'text': ' So those are the things that the compiler writer has to take care of and for that purpose, they', 'tokens': [50364, 407, 729, 366, 264, 721, 300, 264, 31958, 9936, 575, 281, 747, 1127, 295, 293, 337, 300, 4334, 11, 436, 50612], 'temperature': 0.0, 'avg_logprob': -0.13078180272528467, 'compression_ratio': 1.6375, 'no_speech_prob': 0.012958972714841366}, {'id': 553, 'seek': 324614, 'start': 3251.1, 'end': 3257.94, 'text': ' need to know about the runtime storage management, okay. For now, we will assume that you have that', 'tokens': [50612, 643, 281, 458, 466, 264, 34474, 6725, 4592, 11, 1392, 13, 1171, 586, 11, 321, 486, 6552, 300, 291, 362, 300, 50954], 'temperature': 0.0, 'avg_logprob': -0.13078180272528467, 'compression_ratio': 1.6375, 'no_speech_prob': 0.012958972714841366}, {'id': 554, 'seek': 324614, 'start': 3257.94, 'end': 3263.54, 'text': ' knowledge, but wherever you require, I will kind of tell you what it is and maybe we can figure out', 'tokens': [50954, 3601, 11, 457, 8660, 291, 3651, 11, 286, 486, 733, 295, 980, 291, 437, 309, 307, 293, 1310, 321, 393, 2573, 484, 51234], 'temperature': 0.0, 'avg_logprob': -0.13078180272528467, 'compression_ratio': 1.6375, 'no_speech_prob': 0.012958972714841366}, {'id': 555, 'seek': 324614, 'start': 3263.54, 'end': 3272.3399999999997, 'text': ' how to implement that later on, okay. So why is efficient code generation kind of complex, right?', 'tokens': [51234, 577, 281, 4445, 300, 1780, 322, 11, 1392, 13, 407, 983, 307, 7148, 3089, 5125, 733, 295, 3997, 11, 558, 30, 51674], 'temperature': 0.0, 'avg_logprob': -0.13078180272528467, 'compression_ratio': 1.6375, 'no_speech_prob': 0.012958972714841366}, {'id': 556, 'seek': 327234, 'start': 3272.34, 'end': 3277.98, 'text': ' The answer is that there are many possible ways of implementing the same instruction or the same', 'tokens': [50364, 440, 1867, 307, 300, 456, 366, 867, 1944, 2098, 295, 18114, 264, 912, 10951, 420, 264, 912, 50646], 'temperature': 0.0, 'avg_logprob': -0.13786919620058952, 'compression_ratio': 1.7340425531914894, 'no_speech_prob': 0.06666053086519241}, {'id': 557, 'seek': 327234, 'start': 3277.98, 'end': 3284.3, 'text': ' three address code and you have to choose the one which is the most efficient one, right? And the', 'tokens': [50646, 1045, 2985, 3089, 293, 291, 362, 281, 2826, 264, 472, 597, 307, 264, 881, 7148, 472, 11, 558, 30, 400, 264, 50962], 'temperature': 0.0, 'avg_logprob': -0.13786919620058952, 'compression_ratio': 1.7340425531914894, 'no_speech_prob': 0.06666053086519241}, {'id': 558, 'seek': 327234, 'start': 3284.3, 'end': 3289.26, 'text': ' different sequences obviously will have different cost. So the one which is with the lower cost is', 'tokens': [50962, 819, 22978, 2745, 486, 362, 819, 2063, 13, 407, 264, 472, 597, 307, 365, 264, 3126, 2063, 307, 51210], 'temperature': 0.0, 'avg_logprob': -0.13786919620058952, 'compression_ratio': 1.7340425531914894, 'no_speech_prob': 0.06666053086519241}, {'id': 559, 'seek': 327234, 'start': 3289.26, 'end': 3295.3, 'text': ' what needs to be set. And then particularly when you talk about using registers, right, there are,', 'tokens': [51210, 437, 2203, 281, 312, 992, 13, 400, 550, 4098, 562, 291, 751, 466, 1228, 38351, 11, 558, 11, 456, 366, 11, 51512], 'temperature': 0.0, 'avg_logprob': -0.13786919620058952, 'compression_ratio': 1.7340425531914894, 'no_speech_prob': 0.06666053086519241}, {'id': 560, 'seek': 327234, 'start': 3295.3, 'end': 3300.42, 'text': " let's say, several program variables. You want to figure out which of these variables need to be", 'tokens': [51512, 718, 311, 584, 11, 2940, 1461, 9102, 13, 509, 528, 281, 2573, 484, 597, 295, 613, 9102, 643, 281, 312, 51768], 'temperature': 0.0, 'avg_logprob': -0.13786919620058952, 'compression_ratio': 1.7340425531914894, 'no_speech_prob': 0.06666053086519241}, {'id': 561, 'seek': 330042, 'start': 3300.42, 'end': 3305.58, 'text': ' stored in the register and which of them can be accessed from the memory directly. This is only', 'tokens': [50364, 12187, 294, 264, 7280, 293, 597, 295, 552, 393, 312, 34211, 490, 264, 4675, 3838, 13, 639, 307, 787, 50622], 'temperature': 0.0, 'avg_logprob': -0.11879695394764776, 'compression_ratio': 1.9958333333333333, 'no_speech_prob': 0.017835095524787903}, {'id': 562, 'seek': 330042, 'start': 3305.58, 'end': 3310.86, 'text': ' in Sysc architectures because in Sysc architectures, you can afford to have some operands in memory.', 'tokens': [50622, 294, 318, 749, 66, 6331, 1303, 570, 294, 318, 749, 66, 6331, 1303, 11, 291, 393, 6157, 281, 362, 512, 2208, 2967, 294, 4675, 13, 50886], 'temperature': 0.0, 'avg_logprob': -0.11879695394764776, 'compression_ratio': 1.9958333333333333, 'no_speech_prob': 0.017835095524787903}, {'id': 563, 'seek': 330042, 'start': 3310.86, 'end': 3316.14, 'text': ' And when you can afford to have some operands in memory, essentially the decision of what is', 'tokens': [50886, 400, 562, 291, 393, 6157, 281, 362, 512, 2208, 2967, 294, 4675, 11, 4476, 264, 3537, 295, 437, 307, 51150], 'temperature': 0.0, 'avg_logprob': -0.11879695394764776, 'compression_ratio': 1.9958333333333333, 'no_speech_prob': 0.017835095524787903}, {'id': 564, 'seek': 330042, 'start': 3316.14, 'end': 3322.38, 'text': ' in memory, what is in register or what should be loaded into register has to be, that decision has', 'tokens': [51150, 294, 4675, 11, 437, 307, 294, 7280, 420, 437, 820, 312, 13210, 666, 7280, 575, 281, 312, 11, 300, 3537, 575, 51462], 'temperature': 0.0, 'avg_logprob': -0.11879695394764776, 'compression_ratio': 1.9958333333333333, 'no_speech_prob': 0.017835095524787903}, {'id': 565, 'seek': 330042, 'start': 3322.38, 'end': 3329.54, 'text': ' to be made and again that decision influences the cost of your code, right? And therefore,', 'tokens': [51462, 281, 312, 1027, 293, 797, 300, 3537, 21222, 264, 2063, 295, 428, 3089, 11, 558, 30, 400, 4412, 11, 51820], 'temperature': 0.0, 'avg_logprob': -0.11879695394764776, 'compression_ratio': 1.9958333333333333, 'no_speech_prob': 0.017835095524787903}, {'id': 566, 'seek': 332954, 'start': 3329.54, 'end': 3334.38, 'text': ' again there are many choices and you have to choose the right one in order for you to generate', 'tokens': [50364, 797, 456, 366, 867, 7994, 293, 291, 362, 281, 2826, 264, 558, 472, 294, 1668, 337, 291, 281, 8460, 50606], 'temperature': 0.0, 'avg_logprob': -0.18251880944943896, 'compression_ratio': 1.6666666666666667, 'no_speech_prob': 0.0033011450432240963}, {'id': 567, 'seek': 332954, 'start': 3334.38, 'end': 3342.94, 'text': " the efficient code. Again my, okay, sorry about this animations coming out of order, but let's,", 'tokens': [50606, 264, 7148, 3089, 13, 3764, 452, 11, 1392, 11, 2597, 466, 341, 22868, 1348, 484, 295, 1668, 11, 457, 718, 311, 11, 51034], 'temperature': 0.0, 'avg_logprob': -0.18251880944943896, 'compression_ratio': 1.6666666666666667, 'no_speech_prob': 0.0033011450432240963}, {'id': 568, 'seek': 332954, 'start': 3342.94, 'end': 3350.1, 'text': " let's try to work this out, okay? So look at this simple instruction A is equal to B plus C. In this", 'tokens': [51034, 718, 311, 853, 281, 589, 341, 484, 11, 1392, 30, 407, 574, 412, 341, 2199, 10951, 316, 307, 2681, 281, 363, 1804, 383, 13, 682, 341, 51392], 'temperature': 0.0, 'avg_logprob': -0.18251880944943896, 'compression_ratio': 1.6666666666666667, 'no_speech_prob': 0.0033011450432240963}, {'id': 569, 'seek': 332954, 'start': 3350.1, 'end': 3355.58, 'text': ' case, what I am going to do is that I am going to load B into a register, C into another register.', 'tokens': [51392, 1389, 11, 437, 286, 669, 516, 281, 360, 307, 300, 286, 669, 516, 281, 3677, 363, 666, 257, 7280, 11, 383, 666, 1071, 7280, 13, 51666], 'temperature': 0.0, 'avg_logprob': -0.18251880944943896, 'compression_ratio': 1.6666666666666667, 'no_speech_prob': 0.0033011450432240963}, {'id': 570, 'seek': 335558, 'start': 3355.58, 'end': 3361.54, 'text': ' I can, I am sorry, I am not loading B into a register, I am loading the address of B, load', 'tokens': [50364, 286, 393, 11, 286, 669, 2597, 11, 286, 669, 406, 15114, 363, 666, 257, 7280, 11, 286, 669, 15114, 264, 2985, 295, 363, 11, 3677, 50662], 'temperature': 0.0, 'avg_logprob': -0.16552625383649552, 'compression_ratio': 1.964102564102564, 'no_speech_prob': 0.02235996350646019}, {'id': 571, 'seek': 335558, 'start': 3361.54, 'end': 3368.62, 'text': ' address of B into a register, load address of C into another register and I am moving the contents', 'tokens': [50662, 2985, 295, 363, 666, 257, 7280, 11, 3677, 2985, 295, 383, 666, 1071, 7280, 293, 286, 669, 2684, 264, 15768, 51016], 'temperature': 0.0, 'avg_logprob': -0.16552625383649552, 'compression_ratio': 1.964102564102564, 'no_speech_prob': 0.02235996350646019}, {'id': 572, 'seek': 335558, 'start': 3368.62, 'end': 3375.7, 'text': ' of the location pointed by R naught register into R2. Then I am adding the contents of the memory', 'tokens': [51016, 295, 264, 4914, 10932, 538, 497, 13138, 7280, 666, 497, 17, 13, 1396, 286, 669, 5127, 264, 15768, 295, 264, 4675, 51370], 'temperature': 0.0, 'avg_logprob': -0.16552625383649552, 'compression_ratio': 1.964102564102564, 'no_speech_prob': 0.02235996350646019}, {'id': 573, 'seek': 335558, 'start': 3375.7, 'end': 3384.7999999999997, 'text': " location pointed by R1 with R2, right? So this has A, sorry, yeah, let's look at it. So this is", 'tokens': [51370, 4914, 10932, 538, 497, 16, 365, 497, 17, 11, 558, 30, 407, 341, 575, 316, 11, 2597, 11, 1338, 11, 718, 311, 574, 412, 309, 13, 407, 341, 307, 51825], 'temperature': 0.0, 'avg_logprob': -0.16552625383649552, 'compression_ratio': 1.964102564102564, 'no_speech_prob': 0.02235996350646019}, {'id': 574, 'seek': 338480, 'start': 3384.8, 'end': 3392.1200000000003, 'text': ' basically moving the value of B into R2. This is the pointer to A. So I am adding the contents', 'tokens': [50364, 1936, 2684, 264, 2158, 295, 363, 666, 497, 17, 13, 639, 307, 264, 23918, 281, 316, 13, 407, 286, 669, 5127, 264, 15768, 50730], 'temperature': 0.0, 'avg_logprob': -0.11146637633606628, 'compression_ratio': 1.6991150442477876, 'no_speech_prob': 0.0035179886035621166}, {'id': 575, 'seek': 338480, 'start': 3392.1200000000003, 'end': 3399.5600000000004, 'text': ' of A now with the contents of B and I am then putting it back into that location, right? So', 'tokens': [50730, 295, 316, 586, 365, 264, 15768, 295, 363, 293, 286, 669, 550, 3372, 309, 646, 666, 300, 4914, 11, 558, 30, 407, 51102], 'temperature': 0.0, 'avg_logprob': -0.11146637633606628, 'compression_ratio': 1.6991150442477876, 'no_speech_prob': 0.0035179886035621166}, {'id': 576, 'seek': 338480, 'start': 3399.5600000000004, 'end': 3404.44, 'text': ' that is essentially what is happening. If you look at it, basically I have five instructions and', 'tokens': [51102, 300, 307, 4476, 437, 307, 2737, 13, 759, 291, 574, 412, 309, 11, 1936, 286, 362, 1732, 9415, 293, 51346], 'temperature': 0.0, 'avg_logprob': -0.11146637633606628, 'compression_ratio': 1.6991150442477876, 'no_speech_prob': 0.0035179886035621166}, {'id': 577, 'seek': 338480, 'start': 3404.44, 'end': 3410.1200000000003, 'text': ' then in couple of instructions I have this move address which is possibly using the absolute address', 'tokens': [51346, 550, 294, 1916, 295, 9415, 286, 362, 341, 1286, 2985, 597, 307, 6264, 1228, 264, 8236, 2985, 51630], 'temperature': 0.0, 'avg_logprob': -0.11146637633606628, 'compression_ratio': 1.6991150442477876, 'no_speech_prob': 0.0035179886035621166}, {'id': 578, 'seek': 341012, 'start': 3410.12, 'end': 3417.56, 'text': ' mode and that has an additional cost, right? So I add up those costs. Another way of generating', 'tokens': [50364, 4391, 293, 300, 575, 364, 4497, 2063, 11, 558, 30, 407, 286, 909, 493, 729, 5497, 13, 3996, 636, 295, 17746, 50736], 'temperature': 0.0, 'avg_logprob': -0.12945184500321097, 'compression_ratio': 1.6933333333333334, 'no_speech_prob': 0.3088679313659668}, {'id': 579, 'seek': 341012, 'start': 3417.56, 'end': 3425.6, 'text': ' code for this, again things are coming slightly out of order. Let me just get all of this and', 'tokens': [50736, 3089, 337, 341, 11, 797, 721, 366, 1348, 4748, 484, 295, 1668, 13, 961, 385, 445, 483, 439, 295, 341, 293, 51138], 'temperature': 0.0, 'avg_logprob': -0.12945184500321097, 'compression_ratio': 1.6933333333333334, 'no_speech_prob': 0.3088679313659668}, {'id': 580, 'seek': 341012, 'start': 3425.6, 'end': 3432.3599999999997, 'text': ' then work on it, right? So this is the second way of generating instruction for this in which I', 'tokens': [51138, 550, 589, 322, 309, 11, 558, 30, 407, 341, 307, 264, 1150, 636, 295, 17746, 10951, 337, 341, 294, 597, 286, 51476], 'temperature': 0.0, 'avg_logprob': -0.12945184500321097, 'compression_ratio': 1.6933333333333334, 'no_speech_prob': 0.3088679313659668}, {'id': 581, 'seek': 341012, 'start': 3432.3599999999997, 'end': 3438.64, 'text': " don't move any of these addresses into register or even the values into register. I simply move", 'tokens': [51476, 500, 380, 1286, 604, 295, 613, 16862, 666, 7280, 420, 754, 264, 4190, 666, 7280, 13, 286, 2935, 1286, 51790], 'temperature': 0.0, 'avg_logprob': -0.12945184500321097, 'compression_ratio': 1.6933333333333334, 'no_speech_prob': 0.3088679313659668}, {'id': 582, 'seek': 343864, 'start': 3438.64, 'end': 3444.96, 'text': ' the value of B using a move instruction into this R0 register. Similarly, move the value,', 'tokens': [50364, 264, 2158, 295, 363, 1228, 257, 1286, 10951, 666, 341, 497, 15, 7280, 13, 13157, 11, 1286, 264, 2158, 11, 50680], 'temperature': 0.0, 'avg_logprob': -0.1117807301607999, 'compression_ratio': 1.8917525773195876, 'no_speech_prob': 0.017731808125972748}, {'id': 583, 'seek': 343864, 'start': 3444.96, 'end': 3451.08, 'text': ' sorry, add the value of C which is in memory with the value of B which is in R0 register,', 'tokens': [50680, 2597, 11, 909, 264, 2158, 295, 383, 597, 307, 294, 4675, 365, 264, 2158, 295, 363, 597, 307, 294, 497, 15, 7280, 11, 50986], 'temperature': 0.0, 'avg_logprob': -0.1117807301607999, 'compression_ratio': 1.8917525773195876, 'no_speech_prob': 0.017731808125972748}, {'id': 584, 'seek': 343864, 'start': 3451.08, 'end': 3458.2799999999997, 'text': ' put the result in R0 register and subsequently move that value into A register. This takes', 'tokens': [50986, 829, 264, 1874, 294, 497, 15, 7280, 293, 26514, 1286, 300, 2158, 666, 316, 7280, 13, 639, 2516, 51346], 'temperature': 0.0, 'avg_logprob': -0.1117807301607999, 'compression_ratio': 1.8917525773195876, 'no_speech_prob': 0.017731808125972748}, {'id': 585, 'seek': 343864, 'start': 3458.2799999999997, 'end': 3463.8399999999997, 'text': ' only three instructions, right? But then some of these instructions are heavy duty instructions,', 'tokens': [51346, 787, 1045, 9415, 11, 558, 30, 583, 550, 512, 295, 613, 9415, 366, 4676, 9776, 9415, 11, 51624], 'temperature': 0.0, 'avg_logprob': -0.1117807301607999, 'compression_ratio': 1.8917525773195876, 'no_speech_prob': 0.017731808125972748}, {'id': 586, 'seek': 346384, 'start': 3463.84, 'end': 3469.6000000000004, 'text': ' right? As opposed to some of those instructions. So again the cost of this need to be estimated.', 'tokens': [50364, 558, 30, 1018, 8851, 281, 512, 295, 729, 9415, 13, 407, 797, 264, 2063, 295, 341, 643, 281, 312, 14109, 13, 50652], 'temperature': 0.0, 'avg_logprob': -0.16455983031879773, 'compression_ratio': 1.6954545454545455, 'no_speech_prob': 0.009977650828659534}, {'id': 587, 'seek': 346384, 'start': 3469.6000000000004, 'end': 3475.52, 'text': ' Here I have used a simple cost mechanism, one for each instruction plus one for any additional', 'tokens': [50652, 1692, 286, 362, 1143, 257, 2199, 2063, 7513, 11, 472, 337, 1184, 10951, 1804, 472, 337, 604, 4497, 50948], 'temperature': 0.0, 'avg_logprob': -0.16455983031879773, 'compression_ratio': 1.6954545454545455, 'no_speech_prob': 0.009977650828659534}, {'id': 588, 'seek': 346384, 'start': 3475.52, 'end': 3480.88, 'text': ' words that I am using. So this has a different cost. Again for each architecture this may be', 'tokens': [50948, 2283, 300, 286, 669, 1228, 13, 407, 341, 575, 257, 819, 2063, 13, 3764, 337, 1184, 9482, 341, 815, 312, 51216], 'temperature': 0.0, 'avg_logprob': -0.16455983031879773, 'compression_ratio': 1.6954545454545455, 'no_speech_prob': 0.009977650828659534}, {'id': 589, 'seek': 346384, 'start': 3480.88, 'end': 3486.56, 'text': ' different and you have to use the appropriate cost. If I have the facility to just move,', 'tokens': [51216, 819, 293, 291, 362, 281, 764, 264, 6854, 2063, 13, 759, 286, 362, 264, 8973, 281, 445, 1286, 11, 51500], 'temperature': 0.0, 'avg_logprob': -0.16455983031879773, 'compression_ratio': 1.6954545454545455, 'no_speech_prob': 0.009977650828659534}, {'id': 590, 'seek': 348656, 'start': 3487.52, 'end': 3500.0, 'text': ' so here is what happens. I first copy the contents of B into memory location A and then I add C to', 'tokens': [50412, 370, 510, 307, 437, 2314, 13, 286, 700, 5055, 264, 15768, 295, 363, 666, 4675, 4914, 316, 293, 550, 286, 909, 383, 281, 51036], 'temperature': 0.0, 'avg_logprob': -0.15778192351846135, 'compression_ratio': 1.574585635359116, 'no_speech_prob': 0.021493002772331238}, {'id': 591, 'seek': 348656, 'start': 3500.0, 'end': 3506.12, 'text': ' memory location A and put the value back in A. So provided my architecture supports and add', 'tokens': [51036, 4675, 4914, 316, 293, 829, 264, 2158, 646, 294, 316, 13, 407, 5649, 452, 9482, 9346, 293, 909, 51342], 'temperature': 0.0, 'avg_logprob': -0.15778192351846135, 'compression_ratio': 1.574585635359116, 'no_speech_prob': 0.021493002772331238}, {'id': 592, 'seek': 348656, 'start': 3506.12, 'end': 3512.32, 'text': ' instruction with two memory operators. If that is possible then I can do this. Whatever is the', 'tokens': [51342, 10951, 365, 732, 4675, 19077, 13, 759, 300, 307, 1944, 550, 286, 393, 360, 341, 13, 8541, 307, 264, 51652], 'temperature': 0.0, 'avg_logprob': -0.15778192351846135, 'compression_ratio': 1.574585635359116, 'no_speech_prob': 0.021493002772331238}, {'id': 593, 'seek': 351232, 'start': 3512.32, 'end': 3516.76, 'text': ' cost for that I have to pay for that. So this is another way of generating this instruction,', 'tokens': [50364, 2063, 337, 300, 286, 362, 281, 1689, 337, 300, 13, 407, 341, 307, 1071, 636, 295, 17746, 341, 10951, 11, 50586], 'temperature': 0.0, 'avg_logprob': -0.11457513099492983, 'compression_ratio': 1.7438423645320198, 'no_speech_prob': 0.06970292329788208}, {'id': 594, 'seek': 351232, 'start': 3516.76, 'end': 3523.92, 'text': ' right? So here is the third way where you basically, so here you are basically moving,', 'tokens': [50586, 558, 30, 407, 510, 307, 264, 2636, 636, 689, 291, 1936, 11, 370, 510, 291, 366, 1936, 2684, 11, 50944], 'temperature': 0.0, 'avg_logprob': -0.11457513099492983, 'compression_ratio': 1.7438423645320198, 'no_speech_prob': 0.06970292329788208}, {'id': 595, 'seek': 351232, 'start': 3523.92, 'end': 3529.2000000000003, 'text': ' you are assuming that the values of B and C are available in these two registers.', 'tokens': [50944, 291, 366, 11926, 300, 264, 4190, 295, 363, 293, 383, 366, 2435, 294, 613, 732, 38351, 13, 51208], 'temperature': 0.0, 'avg_logprob': -0.11457513099492983, 'compression_ratio': 1.7438423645320198, 'no_speech_prob': 0.06970292329788208}, {'id': 596, 'seek': 351232, 'start': 3529.2000000000003, 'end': 3536.6400000000003, 'text': ' I am first moving the value of B into again register A. I am adding register A with register', 'tokens': [51208, 286, 669, 700, 2684, 264, 2158, 295, 363, 666, 797, 7280, 316, 13, 286, 669, 5127, 7280, 316, 365, 7280, 51580], 'temperature': 0.0, 'avg_logprob': -0.11457513099492983, 'compression_ratio': 1.7438423645320198, 'no_speech_prob': 0.06970292329788208}, {'id': 597, 'seek': 353664, 'start': 3536.64, 'end': 3542.24, 'text': ' C and I am now writing the value into this, right? Again just to show that there are different', 'tokens': [50364, 383, 293, 286, 669, 586, 3579, 264, 2158, 666, 341, 11, 558, 30, 3764, 445, 281, 855, 300, 456, 366, 819, 50644], 'temperature': 0.0, 'avg_logprob': -0.13301399621096524, 'compression_ratio': 1.6652173913043478, 'no_speech_prob': 0.026486719027161598}, {'id': 598, 'seek': 353664, 'start': 3542.24, 'end': 3548.64, 'text': ' ways by which you can achieve the same instruction and each may have a different cost. So essentially', 'tokens': [50644, 2098, 538, 597, 291, 393, 4584, 264, 912, 10951, 293, 1184, 815, 362, 257, 819, 2063, 13, 407, 4476, 50964], 'temperature': 0.0, 'avg_logprob': -0.13301399621096524, 'compression_ratio': 1.6652173913043478, 'no_speech_prob': 0.026486719027161598}, {'id': 599, 'seek': 353664, 'start': 3548.64, 'end': 3556.7999999999997, 'text': ' in a code generation phase, yes? I have assumed some way by which each instruction has a cost', 'tokens': [50964, 294, 257, 3089, 5125, 5574, 11, 2086, 30, 286, 362, 15895, 512, 636, 538, 597, 1184, 10951, 575, 257, 2063, 51372], 'temperature': 0.0, 'avg_logprob': -0.13301399621096524, 'compression_ratio': 1.6652173913043478, 'no_speech_prob': 0.026486719027161598}, {'id': 600, 'seek': 353664, 'start': 3557.52, 'end': 3562.64, 'text': ' and then every instruction which use additional bytes. For example, here I have to store the', 'tokens': [51408, 293, 550, 633, 10951, 597, 764, 4497, 36088, 13, 1171, 1365, 11, 510, 286, 362, 281, 3531, 264, 51664], 'temperature': 0.0, 'avg_logprob': -0.13301399621096524, 'compression_ratio': 1.6652173913043478, 'no_speech_prob': 0.026486719027161598}, {'id': 601, 'seek': 356264, 'start': 3562.64, 'end': 3569.8399999999997, 'text': ' absolute address of B following that instruction as an additional cost, right? So the machine', 'tokens': [50364, 8236, 2985, 295, 363, 3480, 300, 10951, 382, 364, 4497, 2063, 11, 558, 30, 407, 264, 3479, 50724], 'temperature': 0.0, 'avg_logprob': -0.08858035886010458, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.03034300170838833}, {'id': 602, 'seek': 356264, 'start': 3569.8399999999997, 'end': 3576.16, 'text': ' architecture will tell you exactly what the cost is, right? And as a compiler writer one needs to', 'tokens': [50724, 9482, 486, 980, 291, 2293, 437, 264, 2063, 307, 11, 558, 30, 400, 382, 257, 31958, 9936, 472, 2203, 281, 51040], 'temperature': 0.0, 'avg_logprob': -0.08858035886010458, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.03034300170838833}, {'id': 603, 'seek': 356264, 'start': 3576.16, 'end': 3581.04, 'text': ' understand that cost and then incorporate that cost. That is really what it is. So in this', 'tokens': [51040, 1223, 300, 2063, 293, 550, 16091, 300, 2063, 13, 663, 307, 534, 437, 309, 307, 13, 407, 294, 341, 51284], 'temperature': 0.0, 'avg_logprob': -0.08858035886010458, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.03034300170838833}, {'id': 604, 'seek': 356264, 'start': 3581.04, 'end': 3586.7999999999997, 'text': ' particular example, see the address of B has to be following this instruction. So that has to be', 'tokens': [51284, 1729, 1365, 11, 536, 264, 2985, 295, 363, 575, 281, 312, 3480, 341, 10951, 13, 407, 300, 575, 281, 312, 51572], 'temperature': 0.0, 'avg_logprob': -0.08858035886010458, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.03034300170838833}, {'id': 605, 'seek': 358680, 'start': 3586.8, 'end': 3592.96, 'text': ' fetched and you know used. Therefore, I have added an additional cost for that. Similarly,', 'tokens': [50364, 23673, 292, 293, 291, 458, 1143, 13, 7504, 11, 286, 362, 3869, 364, 4497, 2063, 337, 300, 13, 13157, 11, 50672], 'temperature': 0.0, 'avg_logprob': -0.07212587765284947, 'compression_ratio': 1.8938775510204082, 'no_speech_prob': 0.041669443249702454}, {'id': 606, 'seek': 358680, 'start': 3592.96, 'end': 3599.2000000000003, 'text': ' the address of C. Similarly, the address of A. Here I am assuming that the value of B is already', 'tokens': [50672, 264, 2985, 295, 383, 13, 13157, 11, 264, 2985, 295, 316, 13, 1692, 286, 669, 11926, 300, 264, 2158, 295, 363, 307, 1217, 50984], 'temperature': 0.0, 'avg_logprob': -0.07212587765284947, 'compression_ratio': 1.8938775510204082, 'no_speech_prob': 0.041669443249702454}, {'id': 607, 'seek': 358680, 'start': 3599.2000000000003, 'end': 3605.2000000000003, 'text': ' available in a register, right? If that is available, then I can actually move that into', 'tokens': [50984, 2435, 294, 257, 7280, 11, 558, 30, 759, 300, 307, 2435, 11, 550, 286, 393, 767, 1286, 300, 666, 51284], 'temperature': 0.0, 'avg_logprob': -0.07212587765284947, 'compression_ratio': 1.8938775510204082, 'no_speech_prob': 0.041669443249702454}, {'id': 608, 'seek': 358680, 'start': 3605.2000000000003, 'end': 3610.48, 'text': ' another register. I can do the add with the memory location or with another register and then write', 'tokens': [51284, 1071, 7280, 13, 286, 393, 360, 264, 909, 365, 264, 4675, 4914, 420, 365, 1071, 7280, 293, 550, 2464, 51548], 'temperature': 0.0, 'avg_logprob': -0.07212587765284947, 'compression_ratio': 1.8938775510204082, 'no_speech_prob': 0.041669443249702454}, {'id': 609, 'seek': 358680, 'start': 3610.48, 'end': 3615.6000000000004, 'text': ' the value back. Here I am assuming that all of this is register operands and therefore,', 'tokens': [51548, 264, 2158, 646, 13, 1692, 286, 669, 11926, 300, 439, 295, 341, 307, 7280, 2208, 2967, 293, 4412, 11, 51804], 'temperature': 0.0, 'avg_logprob': -0.07212587765284947, 'compression_ratio': 1.8938775510204082, 'no_speech_prob': 0.041669443249702454}, {'id': 610, 'seek': 361560, 'start': 3615.6, 'end': 3621.2, 'text': ' they incur only one cost. I mean they only incur a cost for the instruction and only in this', 'tokens': [50364, 436, 35774, 787, 472, 2063, 13, 286, 914, 436, 787, 35774, 257, 2063, 337, 264, 10951, 293, 787, 294, 341, 50644], 'temperature': 0.0, 'avg_logprob': -0.09828650843989742, 'compression_ratio': 1.9133858267716535, 'no_speech_prob': 0.0005444964044727385}, {'id': 611, 'seek': 361560, 'start': 3621.2, 'end': 3627.52, 'text': ' instruction I have an additional memory address and therefore, I am assuming a cost of one, right?', 'tokens': [50644, 10951, 286, 362, 364, 4497, 4675, 2985, 293, 4412, 11, 286, 669, 11926, 257, 2063, 295, 472, 11, 558, 30, 50960], 'temperature': 0.0, 'avg_logprob': -0.09828650843989742, 'compression_ratio': 1.9133858267716535, 'no_speech_prob': 0.0005444964044727385}, {'id': 612, 'seek': 361560, 'start': 3627.52, 'end': 3633.04, 'text': ' So when you generate code for a target architecture, right, you say that each instruction has this kind', 'tokens': [50960, 407, 562, 291, 8460, 3089, 337, 257, 3779, 9482, 11, 558, 11, 291, 584, 300, 1184, 10951, 575, 341, 733, 51236], 'temperature': 0.0, 'avg_logprob': -0.09828650843989742, 'compression_ratio': 1.9133858267716535, 'no_speech_prob': 0.0005444964044727385}, {'id': 613, 'seek': 361560, 'start': 3633.04, 'end': 3638.3199999999997, 'text': ' of a cost and if the operand is like this, then there is an additional cost for that. So that', 'tokens': [51236, 295, 257, 2063, 293, 498, 264, 2208, 474, 307, 411, 341, 11, 550, 456, 307, 364, 4497, 2063, 337, 300, 13, 407, 300, 51500], 'temperature': 0.0, 'avg_logprob': -0.09828650843989742, 'compression_ratio': 1.9133858267716535, 'no_speech_prob': 0.0005444964044727385}, {'id': 614, 'seek': 361560, 'start': 3638.3199999999997, 'end': 3643.6, 'text': ' information is being specified to you or you can understand that from the instruction set manual', 'tokens': [51500, 1589, 307, 885, 22206, 281, 291, 420, 291, 393, 1223, 300, 490, 264, 10951, 992, 9688, 51764], 'temperature': 0.0, 'avg_logprob': -0.09828650843989742, 'compression_ratio': 1.9133858267716535, 'no_speech_prob': 0.0005444964044727385}, {'id': 615, 'seek': 364360, 'start': 3643.6, 'end': 3649.12, 'text': ' and based on that you will try to generate the code for that. That is really what happens, right?', 'tokens': [50364, 293, 2361, 322, 300, 291, 486, 853, 281, 8460, 264, 3089, 337, 300, 13, 663, 307, 534, 437, 2314, 11, 558, 30, 50640], 'temperature': 0.0, 'avg_logprob': -0.15656245671785796, 'compression_ratio': 1.7181818181818183, 'no_speech_prob': 0.0098496675491333}, {'id': 616, 'seek': 364360, 'start': 3649.12, 'end': 3654.88, 'text': ' Okay, if it is a Sysc machine, this is what you will do. If it is a Rysc machine, what can we do?', 'tokens': [50640, 1033, 11, 498, 309, 307, 257, 318, 749, 66, 3479, 11, 341, 307, 437, 291, 486, 360, 13, 759, 309, 307, 257, 497, 749, 66, 3479, 11, 437, 393, 321, 360, 30, 50928], 'temperature': 0.0, 'avg_logprob': -0.15656245671785796, 'compression_ratio': 1.7181818181818183, 'no_speech_prob': 0.0098496675491333}, {'id': 617, 'seek': 364360, 'start': 3654.88, 'end': 3662.64, 'text': ' You have to move the memory locations to registers, right, and then perform the operation', 'tokens': [50928, 509, 362, 281, 1286, 264, 4675, 9253, 281, 38351, 11, 558, 11, 293, 550, 2042, 264, 6916, 51316], 'temperature': 0.0, 'avg_logprob': -0.15656245671785796, 'compression_ratio': 1.7181818181818183, 'no_speech_prob': 0.0098496675491333}, {'id': 618, 'seek': 364360, 'start': 3662.64, 'end': 3672.7999999999997, 'text': ' and then store them back, right? Okay, so here is what you have, right? Load B into R naught', 'tokens': [51316, 293, 550, 3531, 552, 646, 11, 558, 30, 1033, 11, 370, 510, 307, 437, 291, 362, 11, 558, 30, 48408, 363, 666, 497, 13138, 51824], 'temperature': 0.0, 'avg_logprob': -0.15656245671785796, 'compression_ratio': 1.7181818181818183, 'no_speech_prob': 0.0098496675491333}, {'id': 619, 'seek': 367360, 'start': 3673.92, 'end': 3683.36, 'text': ' load C into R1, add R1 and R2, put the result in R naught and store it back into A, right?', 'tokens': [50380, 3677, 383, 666, 497, 16, 11, 909, 497, 16, 293, 497, 17, 11, 829, 264, 1874, 294, 497, 13138, 293, 3531, 309, 646, 666, 316, 11, 558, 30, 50852], 'temperature': 0.0, 'avg_logprob': -0.15054279037668736, 'compression_ratio': 1.559782608695652, 'no_speech_prob': 0.0007445850642398}, {'id': 620, 'seek': 367360, 'start': 3683.36, 'end': 3689.2799999999997, 'text': ' So if you assume that each instruction is one word, there are four instructions, there is nothing', 'tokens': [50852, 407, 498, 291, 6552, 300, 1184, 10951, 307, 472, 1349, 11, 456, 366, 1451, 9415, 11, 456, 307, 1825, 51148], 'temperature': 0.0, 'avg_logprob': -0.15054279037668736, 'compression_ratio': 1.559782608695652, 'no_speech_prob': 0.0007445850642398}, {'id': 621, 'seek': 367360, 'start': 3689.2799999999997, 'end': 3700.08, 'text': ' additional in here, so you will have a cost of, right? Here is again I am assuming that this B and', 'tokens': [51148, 4497, 294, 510, 11, 370, 291, 486, 362, 257, 2063, 295, 11, 558, 30, 1692, 307, 797, 286, 669, 11926, 300, 341, 363, 293, 51688], 'temperature': 0.0, 'avg_logprob': -0.15054279037668736, 'compression_ratio': 1.559782608695652, 'no_speech_prob': 0.0007445850642398}, {'id': 622, 'seek': 370008, 'start': 3700.08, 'end': 3708.24, 'text': ' C can be specified simply, I mean simply meaning like using some kind of displacement addressing', 'tokens': [50364, 383, 393, 312, 22206, 2935, 11, 286, 914, 2935, 3620, 411, 1228, 512, 733, 295, 21899, 14329, 50772], 'temperature': 0.0, 'avg_logprob': -0.09505428664985745, 'compression_ratio': 1.7616822429906542, 'no_speech_prob': 0.08235034346580505}, {'id': 623, 'seek': 370008, 'start': 3708.24, 'end': 3713.6, 'text': ' mode with a small offset. That is what I mean, that is why I said that these could be four bytes.', 'tokens': [50772, 4391, 365, 257, 1359, 18687, 13, 663, 307, 437, 286, 914, 11, 300, 307, 983, 286, 848, 300, 613, 727, 312, 1451, 36088, 13, 51040], 'temperature': 0.0, 'avg_logprob': -0.09505428664985745, 'compression_ratio': 1.7616822429906542, 'no_speech_prob': 0.08235034346580505}, {'id': 624, 'seek': 370008, 'start': 3714.88, 'end': 3720.88, 'text': ' Whereas if these addresses are not there, I mean that can typically happen if these are', 'tokens': [51104, 13813, 498, 613, 16862, 366, 406, 456, 11, 286, 914, 300, 393, 5850, 1051, 498, 613, 366, 51404], 'temperature': 0.0, 'avg_logprob': -0.09505428664985745, 'compression_ratio': 1.7616822429906542, 'no_speech_prob': 0.08235034346580505}, {'id': 625, 'seek': 370008, 'start': 3720.88, 'end': 3727.04, 'text': ' local variables are available in the stack frame. If this is not available in the stack frame,', 'tokens': [51404, 2654, 9102, 366, 2435, 294, 264, 8630, 3920, 13, 759, 341, 307, 406, 2435, 294, 264, 8630, 3920, 11, 51712], 'temperature': 0.0, 'avg_logprob': -0.09505428664985745, 'compression_ratio': 1.7616822429906542, 'no_speech_prob': 0.08235034346580505}, {'id': 626, 'seek': 372704, 'start': 3727.04, 'end': 3731.68, 'text': ' but if these are variables which are global variables, then their addresses first need to', 'tokens': [50364, 457, 498, 613, 366, 9102, 597, 366, 4338, 9102, 11, 550, 641, 16862, 700, 643, 281, 50596], 'temperature': 0.0, 'avg_logprob': -0.12477273526399033, 'compression_ratio': 1.6343612334801763, 'no_speech_prob': 0.014804491773247719}, {'id': 627, 'seek': 372704, 'start': 3731.68, 'end': 3737.36, 'text': ' be moved into some locations from there it can be do. For example, in order for me to move A,', 'tokens': [50596, 312, 4259, 666, 512, 9253, 490, 456, 309, 393, 312, 360, 13, 1171, 1365, 11, 294, 1668, 337, 385, 281, 1286, 316, 11, 50880], 'temperature': 0.0, 'avg_logprob': -0.12477273526399033, 'compression_ratio': 1.6343612334801763, 'no_speech_prob': 0.014804491773247719}, {'id': 628, 'seek': 372704, 'start': 3737.92, 'end': 3744.32, 'text': ' or sorry move B, first I need to store the most significant word of the address of B,', 'tokens': [50908, 420, 2597, 1286, 363, 11, 700, 286, 643, 281, 3531, 264, 881, 4776, 1349, 295, 264, 2985, 295, 363, 11, 51228], 'temperature': 0.0, 'avg_logprob': -0.12477273526399033, 'compression_ratio': 1.6343612334801763, 'no_speech_prob': 0.014804491773247719}, {'id': 629, 'seek': 372704, 'start': 3745.52, 'end': 3754.72, 'text': ' right? That is the upper 16 bits into one register. Then I have to add the least significant 16 bits,', 'tokens': [51288, 558, 30, 663, 307, 264, 6597, 3165, 9239, 666, 472, 7280, 13, 1396, 286, 362, 281, 909, 264, 1935, 4776, 3165, 9239, 11, 51748], 'temperature': 0.0, 'avg_logprob': -0.12477273526399033, 'compression_ratio': 1.6343612334801763, 'no_speech_prob': 0.014804491773247719}, {'id': 630, 'seek': 375472, 'start': 3755.52, 'end': 3760.8799999999997, 'text': ' okay, with that in another. See, remember my immediate constant can only be 16 bits long', 'tokens': [50404, 1392, 11, 365, 300, 294, 1071, 13, 3008, 11, 1604, 452, 11629, 5754, 393, 787, 312, 3165, 9239, 938, 50672], 'temperature': 0.0, 'avg_logprob': -0.1099494400844779, 'compression_ratio': 1.7605633802816902, 'no_speech_prob': 0.0014962120912969112}, {'id': 631, 'seek': 375472, 'start': 3762.0, 'end': 3767.04, 'text': ' in the MIPS architecture. So in that MIPS architecture, the immediate constant can be', 'tokens': [50728, 294, 264, 13696, 6273, 9482, 13, 407, 294, 300, 13696, 6273, 9482, 11, 264, 11629, 5754, 393, 312, 50980], 'temperature': 0.0, 'avg_logprob': -0.1099494400844779, 'compression_ratio': 1.7605633802816902, 'no_speech_prob': 0.0014962120912969112}, {'id': 632, 'seek': 375472, 'start': 3767.04, 'end': 3773.9199999999996, 'text': ' at most 16 bits, whereas the addresses are supposed to be 32 bits, right? So I have to do it in two', 'tokens': [50980, 412, 881, 3165, 9239, 11, 9735, 264, 16862, 366, 3442, 281, 312, 8858, 9239, 11, 558, 30, 407, 286, 362, 281, 360, 309, 294, 732, 51324], 'temperature': 0.0, 'avg_logprob': -0.1099494400844779, 'compression_ratio': 1.7605633802816902, 'no_speech_prob': 0.0014962120912969112}, {'id': 633, 'seek': 375472, 'start': 3773.9199999999996, 'end': 3780.24, 'text': ' steps. First get the most significant bit, then add the least significant bit to it, get the address', 'tokens': [51324, 4439, 13, 2386, 483, 264, 881, 4776, 857, 11, 550, 909, 264, 1935, 4776, 857, 281, 309, 11, 483, 264, 2985, 51640], 'temperature': 0.0, 'avg_logprob': -0.1099494400844779, 'compression_ratio': 1.7605633802816902, 'no_speech_prob': 0.0014962120912969112}, {'id': 634, 'seek': 378024, 'start': 3780.24, 'end': 3790.0, 'text': ' in R naught, then use that address, load it, put it into R. Similarly for the C, right? And then', 'tokens': [50364, 294, 497, 13138, 11, 550, 764, 300, 2985, 11, 3677, 309, 11, 829, 309, 666, 497, 13, 13157, 337, 264, 383, 11, 558, 30, 400, 550, 50852], 'temperature': 0.0, 'avg_logprob': -0.1244424682065665, 'compression_ratio': 1.515625, 'no_speech_prob': 0.010553997941315174}, {'id': 635, 'seek': 378024, 'start': 3790.0, 'end': 3798.24, 'text': ' I perform the addition, I again get the address of A in register R phi and then I store the value.', 'tokens': [50852, 286, 2042, 264, 4500, 11, 286, 797, 483, 264, 2985, 295, 316, 294, 7280, 497, 13107, 293, 550, 286, 3531, 264, 2158, 13, 51264], 'temperature': 0.0, 'avg_logprob': -0.1244424682065665, 'compression_ratio': 1.515625, 'no_speech_prob': 0.010553997941315174}, {'id': 636, 'seek': 378024, 'start': 3799.2, 'end': 3805.6, 'text': ' In fact, this is what I have to do if A, B and C happen to be global variables, right? Or their', 'tokens': [51312, 682, 1186, 11, 341, 307, 437, 286, 362, 281, 360, 498, 316, 11, 363, 293, 383, 1051, 281, 312, 4338, 9102, 11, 558, 30, 1610, 641, 51632], 'temperature': 0.0, 'avg_logprob': -0.1244424682065665, 'compression_ratio': 1.515625, 'no_speech_prob': 0.010553997941315174}, {'id': 637, 'seek': 380560, 'start': 3805.6, 'end': 3811.52, 'text': ' addresses are truly 32 bits and they are not available in any registers, right? If I know A', 'tokens': [50364, 16862, 366, 4908, 8858, 9239, 293, 436, 366, 406, 2435, 294, 604, 38351, 11, 558, 30, 759, 286, 458, 316, 50660], 'temperature': 0.0, 'avg_logprob': -0.08610380365607444, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.012510686181485653}, {'id': 638, 'seek': 380560, 'start': 3811.52, 'end': 3817.68, 'text': ' and B are offset by four locations, right? I could have used that in some efficient way,', 'tokens': [50660, 293, 363, 366, 18687, 538, 1451, 9253, 11, 558, 30, 286, 727, 362, 1143, 300, 294, 512, 7148, 636, 11, 50968], 'temperature': 0.0, 'avg_logprob': -0.08610380365607444, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.012510686181485653}, {'id': 639, 'seek': 380560, 'start': 3818.4, 'end': 3825.04, 'text': ' right? You understand that, right? For example, if A and B happen to be part of', 'tokens': [51004, 558, 30, 509, 1223, 300, 11, 558, 30, 1171, 1365, 11, 498, 316, 293, 363, 1051, 281, 312, 644, 295, 51336], 'temperature': 0.0, 'avg_logprob': -0.08610380365607444, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.012510686181485653}, {'id': 640, 'seek': 380560, 'start': 3826.24, 'end': 3832.64, 'text': ' a structure fields, correct? A happens first and then B happens next. The compiler allocates', 'tokens': [51396, 257, 3877, 7909, 11, 3006, 30, 316, 2314, 700, 293, 550, 363, 2314, 958, 13, 440, 31958, 12660, 1024, 51716], 'temperature': 0.0, 'avg_logprob': -0.08610380365607444, 'compression_ratio': 1.5972850678733033, 'no_speech_prob': 0.012510686181485653}, {'id': 641, 'seek': 383264, 'start': 3832.64, 'end': 3836.96, 'text': ' saying that the first one is going to take four bytes, the next one is four bytes off from that.', 'tokens': [50364, 1566, 300, 264, 700, 472, 307, 516, 281, 747, 1451, 36088, 11, 264, 958, 472, 307, 1451, 36088, 766, 490, 300, 13, 50580], 'temperature': 0.0, 'avg_logprob': -0.07732495615037821, 'compression_ratio': 1.7773722627737227, 'no_speech_prob': 0.009638498537242413}, {'id': 642, 'seek': 383264, 'start': 3837.68, 'end': 3844.96, 'text': " Then once I have loaded B's address, A's address is only four bytes offset from that. I do not need", 'tokens': [50616, 1396, 1564, 286, 362, 13210, 363, 311, 2985, 11, 316, 311, 2985, 307, 787, 1451, 36088, 18687, 490, 300, 13, 286, 360, 406, 643, 50980], 'temperature': 0.0, 'avg_logprob': -0.07732495615037821, 'compression_ratio': 1.7773722627737227, 'no_speech_prob': 0.009638498537242413}, {'id': 643, 'seek': 383264, 'start': 3844.96, 'end': 3851.68, 'text': ' any of these things. I could have simply used 4 minus 4 or 0. I could have done that, correct?', 'tokens': [50980, 604, 295, 613, 721, 13, 286, 727, 362, 2935, 1143, 1017, 3175, 1017, 420, 1958, 13, 286, 727, 362, 1096, 300, 11, 3006, 30, 51316], 'temperature': 0.0, 'avg_logprob': -0.07732495615037821, 'compression_ratio': 1.7773722627737227, 'no_speech_prob': 0.009638498537242413}, {'id': 644, 'seek': 383264, 'start': 3851.68, 'end': 3856.64, 'text': ' So similarly some intelligent decisions could have been done. So depending on where the variables', 'tokens': [51316, 407, 14138, 512, 13232, 5327, 727, 362, 668, 1096, 13, 407, 5413, 322, 689, 264, 9102, 51564], 'temperature': 0.0, 'avg_logprob': -0.07732495615037821, 'compression_ratio': 1.7773722627737227, 'no_speech_prob': 0.009638498537242413}, {'id': 645, 'seek': 383264, 'start': 3856.64, 'end': 3862.16, 'text': ' are and how they are relative to each other, when the compiler generates code, it has to generate', 'tokens': [51564, 366, 293, 577, 436, 366, 4972, 281, 1184, 661, 11, 562, 264, 31958, 23815, 3089, 11, 309, 575, 281, 8460, 51840], 'temperature': 0.0, 'avg_logprob': -0.07732495615037821, 'compression_ratio': 1.7773722627737227, 'no_speech_prob': 0.009638498537242413}, {'id': 646, 'seek': 386216, 'start': 3862.16, 'end': 3867.3599999999997, 'text': ' the complete code so that it can load that information. In this case, if these are local', 'tokens': [50364, 264, 3566, 3089, 370, 300, 309, 393, 3677, 300, 1589, 13, 682, 341, 1389, 11, 498, 613, 366, 2654, 50624], 'temperature': 0.0, 'avg_logprob': -0.0770965628667709, 'compression_ratio': 1.9707112970711298, 'no_speech_prob': 0.0002077121171168983}, {'id': 647, 'seek': 386216, 'start': 3867.3599999999997, 'end': 3872.48, 'text': ' variables, they are available in the frame pointer, right? And offset within the frame', 'tokens': [50624, 9102, 11, 436, 366, 2435, 294, 264, 3920, 23918, 11, 558, 30, 400, 18687, 1951, 264, 3920, 50880], 'temperature': 0.0, 'avg_logprob': -0.0770965628667709, 'compression_ratio': 1.9707112970711298, 'no_speech_prob': 0.0002077121171168983}, {'id': 648, 'seek': 386216, 'start': 3872.48, 'end': 3878.7999999999997, 'text': ' pointer is a short offset. So that can be a part of the immediate concept, right? So I can specify', 'tokens': [50880, 23918, 307, 257, 2099, 18687, 13, 407, 300, 393, 312, 257, 644, 295, 264, 11629, 3410, 11, 558, 30, 407, 286, 393, 16500, 51196], 'temperature': 0.0, 'avg_logprob': -0.0770965628667709, 'compression_ratio': 1.9707112970711298, 'no_speech_prob': 0.0002077121171168983}, {'id': 649, 'seek': 386216, 'start': 3878.7999999999997, 'end': 3884.3199999999997, 'text': ' it within the same instruction, right? For local variables, local variables are always stored in the', 'tokens': [51196, 309, 1951, 264, 912, 10951, 11, 558, 30, 1171, 2654, 9102, 11, 2654, 9102, 366, 1009, 12187, 294, 264, 51472], 'temperature': 0.0, 'avg_logprob': -0.0770965628667709, 'compression_ratio': 1.9707112970711298, 'no_speech_prob': 0.0002077121171168983}, {'id': 650, 'seek': 386216, 'start': 3884.3199999999997, 'end': 3889.68, 'text': ' stack frame and they are always referenced with regard to the frame pointer. So there will be a', 'tokens': [51472, 8630, 3920, 293, 436, 366, 1009, 32734, 365, 3843, 281, 264, 3920, 23918, 13, 407, 456, 486, 312, 257, 51740], 'temperature': 0.0, 'avg_logprob': -0.0770965628667709, 'compression_ratio': 1.9707112970711298, 'no_speech_prob': 0.0002077121171168983}, {'id': 651, 'seek': 388968, 'start': 3889.68, 'end': 3895.04, 'text': ' small offset from the frame pointer so that can be specified. So that is where these instructions', 'tokens': [50364, 1359, 18687, 490, 264, 3920, 23918, 370, 300, 393, 312, 22206, 13, 407, 300, 307, 689, 613, 9415, 50632], 'temperature': 0.0, 'avg_logprob': -0.13976771036783855, 'compression_ratio': 1.8310502283105023, 'no_speech_prob': 0.0038675798568874598}, {'id': 652, 'seek': 388968, 'start': 3895.04, 'end': 3901.44, 'text': ' are simpler and has a lower cost. Whereas these instructions, they require more instructions and', 'tokens': [50632, 366, 18587, 293, 575, 257, 3126, 2063, 13, 13813, 613, 9415, 11, 436, 3651, 544, 9415, 293, 50952], 'temperature': 0.0, 'avg_logprob': -0.13976771036783855, 'compression_ratio': 1.8310502283105023, 'no_speech_prob': 0.0038675798568874598}, {'id': 653, 'seek': 388968, 'start': 3901.44, 'end': 3909.7599999999998, 'text': ' their cost is correct and therefore the total cost is, okay? So depending on whether you are generating', 'tokens': [50952, 641, 2063, 307, 3006, 293, 4412, 264, 3217, 2063, 307, 11, 1392, 30, 407, 5413, 322, 1968, 291, 366, 17746, 51368], 'temperature': 0.0, 'avg_logprob': -0.13976771036783855, 'compression_ratio': 1.8310502283105023, 'no_speech_prob': 0.0038675798568874598}, {'id': 654, 'seek': 388968, 'start': 3909.7599999999998, 'end': 3915.3599999999997, 'text': ' code for a Sysc machine or for a Rysc machine, what types of instructions are supported, what types of', 'tokens': [51368, 3089, 337, 257, 318, 749, 66, 3479, 420, 337, 257, 497, 749, 66, 3479, 11, 437, 3467, 295, 9415, 366, 8104, 11, 437, 3467, 295, 51648], 'temperature': 0.0, 'avg_logprob': -0.13976771036783855, 'compression_ratio': 1.8310502283105023, 'no_speech_prob': 0.0038675798568874598}, {'id': 655, 'seek': 391536, 'start': 3915.36, 'end': 3920.1600000000003, 'text': ' addressing modes are supported, right? You have to generate code appropriately and you have to', 'tokens': [50364, 14329, 14068, 366, 8104, 11, 558, 30, 509, 362, 281, 8460, 3089, 23505, 293, 291, 362, 281, 50604], 'temperature': 0.0, 'avg_logprob': -0.10411843167075628, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.02616264298558235}, {'id': 656, 'seek': 391536, 'start': 3920.1600000000003, 'end': 3926.1600000000003, 'text': ' generate a code which is supposedly more efficient, right? And there are several possibilities. The', 'tokens': [50604, 8460, 257, 3089, 597, 307, 20581, 544, 7148, 11, 558, 30, 400, 456, 366, 2940, 12178, 13, 440, 50904], 'temperature': 0.0, 'avg_logprob': -0.10411843167075628, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.02616264298558235}, {'id': 657, 'seek': 391536, 'start': 3926.1600000000003, 'end': 3932.4, 'text': ' idea here is to just show that there are several possibilities, okay? All right. So let us just', 'tokens': [50904, 1558, 510, 307, 281, 445, 855, 300, 456, 366, 2940, 12178, 11, 1392, 30, 1057, 558, 13, 407, 718, 505, 445, 51216], 'temperature': 0.0, 'avg_logprob': -0.10411843167075628, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.02616264298558235}, {'id': 658, 'seek': 391536, 'start': 3932.4, 'end': 3935.84, 'text': ' first start off with a simple code generation. Yes, question.', 'tokens': [51216, 700, 722, 766, 365, 257, 2199, 3089, 5125, 13, 1079, 11, 1168, 13, 51388], 'temperature': 0.0, 'avg_logprob': -0.10411843167075628, 'compression_ratio': 1.7339901477832513, 'no_speech_prob': 0.02616264298558235}, {'id': 659, 'seek': 393584, 'start': 3935.84, 'end': 3950.56, 'text': ' Right. So for every global variable, right, there is something like, okay, so for every global', 'tokens': [50364, 1779, 13, 407, 337, 633, 4338, 7006, 11, 558, 11, 456, 307, 746, 411, 11, 1392, 11, 370, 337, 633, 4338, 51100], 'temperature': 0.0, 'avg_logprob': -0.12955887637921235, 'compression_ratio': 1.8269230769230769, 'no_speech_prob': 0.02403409779071808}, {'id': 660, 'seek': 393584, 'start': 3950.56, 'end': 3955.44, 'text': ' variable it is going to associate a location, right, saying that it is going to be in that', 'tokens': [51100, 7006, 309, 307, 516, 281, 14644, 257, 4914, 11, 558, 11, 1566, 300, 309, 307, 516, 281, 312, 294, 300, 51344], 'temperature': 0.0, 'avg_logprob': -0.12955887637921235, 'compression_ratio': 1.8269230769230769, 'no_speech_prob': 0.02403409779071808}, {'id': 661, 'seek': 393584, 'start': 3955.44, 'end': 3962.7200000000003, 'text': ' particular location starting from the data segment. So the data segment starts off from some place.', 'tokens': [51344, 1729, 4914, 2891, 490, 264, 1412, 9469, 13, 407, 264, 1412, 9469, 3719, 766, 490, 512, 1081, 13, 51708], 'temperature': 0.0, 'avg_logprob': -0.12955887637921235, 'compression_ratio': 1.8269230769230769, 'no_speech_prob': 0.02403409779071808}, {'id': 662, 'seek': 396272, 'start': 3962.72, 'end': 3968.56, 'text': ' So everything is offset from that, right? So all the global variables are going to keep allocating', 'tokens': [50364, 407, 1203, 307, 18687, 490, 300, 11, 558, 30, 407, 439, 264, 4338, 9102, 366, 516, 281, 1066, 12660, 990, 50656], 'temperature': 0.0, 'avg_logprob': -0.08406775450903523, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.012469504959881306}, {'id': 663, 'seek': 396272, 'start': 3968.56, 'end': 3974.72, 'text': ' from that, right? It is a little bit, so if you think of your entire C program as a single C file,', 'tokens': [50656, 490, 300, 11, 558, 30, 467, 307, 257, 707, 857, 11, 370, 498, 291, 519, 295, 428, 2302, 383, 1461, 382, 257, 2167, 383, 3991, 11, 50964], 'temperature': 0.0, 'avg_logprob': -0.08406775450903523, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.012469504959881306}, {'id': 664, 'seek': 396272, 'start': 3975.3599999999997, 'end': 3980.8799999999997, 'text': ' right, that picture is kind of easier to look at than thinking of it as multiple C files.', 'tokens': [50996, 558, 11, 300, 3036, 307, 733, 295, 3571, 281, 574, 412, 813, 1953, 295, 309, 382, 3866, 383, 7098, 13, 51272], 'temperature': 0.0, 'avg_logprob': -0.08406775450903523, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.012469504959881306}, {'id': 665, 'seek': 396272, 'start': 3980.8799999999997, 'end': 3986.3999999999996, 'text': ' Even multiple C files can be done. So if I have a single C file and let us say I have three global', 'tokens': [51272, 2754, 3866, 383, 7098, 393, 312, 1096, 13, 407, 498, 286, 362, 257, 2167, 383, 3991, 293, 718, 505, 584, 286, 362, 1045, 4338, 51548], 'temperature': 0.0, 'avg_logprob': -0.08406775450903523, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.012469504959881306}, {'id': 666, 'seek': 396272, 'start': 3986.3999999999996, 'end': 3992.0, 'text': ' variables A, B and C, the compiler can understand that there are only three global variables,', 'tokens': [51548, 9102, 316, 11, 363, 293, 383, 11, 264, 31958, 393, 1223, 300, 456, 366, 787, 1045, 4338, 9102, 11, 51828], 'temperature': 0.0, 'avg_logprob': -0.08406775450903523, 'compression_ratio': 1.8823529411764706, 'no_speech_prob': 0.012469504959881306}, {'id': 667, 'seek': 399200, 'start': 3992.0, 'end': 3996.64, 'text': ' all of them have to be in the data segment. The first variable is an integer variable,', 'tokens': [50364, 439, 295, 552, 362, 281, 312, 294, 264, 1412, 9469, 13, 440, 700, 7006, 307, 364, 24922, 7006, 11, 50596], 'temperature': 0.0, 'avg_logprob': -0.08797177547166328, 'compression_ratio': 2.02991452991453, 'no_speech_prob': 0.003176429308950901}, {'id': 668, 'seek': 399200, 'start': 3996.64, 'end': 4003.2, 'text': ' so it will be at an offset 0. The second variable let us say is a double precision variable,', 'tokens': [50596, 370, 309, 486, 312, 412, 364, 18687, 1958, 13, 440, 1150, 7006, 718, 505, 584, 307, 257, 3834, 18356, 7006, 11, 50924], 'temperature': 0.0, 'avg_logprob': -0.08797177547166328, 'compression_ratio': 2.02991452991453, 'no_speech_prob': 0.003176429308950901}, {'id': 669, 'seek': 399200, 'start': 4003.2, 'end': 4008.72, 'text': ' so it will be from the first variable which is 4 bytes, the next variable will be at an offset of 4.', 'tokens': [50924, 370, 309, 486, 312, 490, 264, 700, 7006, 597, 307, 1017, 36088, 11, 264, 958, 7006, 486, 312, 412, 364, 18687, 295, 1017, 13, 51200], 'temperature': 0.0, 'avg_logprob': -0.08797177547166328, 'compression_ratio': 2.02991452991453, 'no_speech_prob': 0.003176429308950901}, {'id': 670, 'seek': 399200, 'start': 4008.72, 'end': 4015.04, 'text': ' The third variable let us say is another integer because the previous one is a double and then the', 'tokens': [51200, 440, 2636, 7006, 718, 505, 584, 307, 1071, 24922, 570, 264, 3894, 472, 307, 257, 3834, 293, 550, 264, 51516], 'temperature': 0.0, 'avg_logprob': -0.08797177547166328, 'compression_ratio': 2.02991452991453, 'no_speech_prob': 0.003176429308950901}, {'id': 671, 'seek': 399200, 'start': 4015.04, 'end': 4021.12, 'text': ' one before that is an integer, so it is 4 plus 8, 12 bytes offset. It can actually work out all', 'tokens': [51516, 472, 949, 300, 307, 364, 24922, 11, 370, 309, 307, 1017, 1804, 1649, 11, 2272, 36088, 18687, 13, 467, 393, 767, 589, 484, 439, 51820], 'temperature': 0.0, 'avg_logprob': -0.08797177547166328, 'compression_ratio': 2.02991452991453, 'no_speech_prob': 0.003176429308950901}, {'id': 672, 'seek': 402112, 'start': 4021.12, 'end': 4026.96, 'text': ' of these details. So it can say that global variable A will be at offset 0, global variable', 'tokens': [50364, 295, 613, 4365, 13, 407, 309, 393, 584, 300, 4338, 7006, 316, 486, 312, 412, 18687, 1958, 11, 4338, 7006, 50656], 'temperature': 0.0, 'avg_logprob': -0.06988395724380225, 'compression_ratio': 1.8629032258064515, 'no_speech_prob': 0.0021273186430335045}, {'id': 673, 'seek': 402112, 'start': 4026.96, 'end': 4032.96, 'text': ' B will be at offset 4, global variable C will be at offset 12. It can fix that thing, right,', 'tokens': [50656, 363, 486, 312, 412, 18687, 1017, 11, 4338, 7006, 383, 486, 312, 412, 18687, 2272, 13, 467, 393, 3191, 300, 551, 11, 558, 11, 50956], 'temperature': 0.0, 'avg_logprob': -0.06988395724380225, 'compression_ratio': 1.8629032258064515, 'no_speech_prob': 0.0021273186430335045}, {'id': 674, 'seek': 402112, 'start': 4032.96, 'end': 4039.12, 'text': ' and it can use that. Now when you have multiple such files which you are linking together,', 'tokens': [50956, 293, 309, 393, 764, 300, 13, 823, 562, 291, 362, 3866, 1270, 7098, 597, 291, 366, 25775, 1214, 11, 51264], 'temperature': 0.0, 'avg_logprob': -0.06988395724380225, 'compression_ratio': 1.8629032258064515, 'no_speech_prob': 0.0021273186430335045}, {'id': 675, 'seek': 402112, 'start': 4039.12, 'end': 4044.3199999999997, 'text': ' then something has to be above, something has to be below, but then again they are relative,', 'tokens': [51264, 550, 746, 575, 281, 312, 3673, 11, 746, 575, 281, 312, 2507, 11, 457, 550, 797, 436, 366, 4972, 11, 51524], 'temperature': 0.0, 'avg_logprob': -0.06988395724380225, 'compression_ratio': 1.8629032258064515, 'no_speech_prob': 0.0021273186430335045}, {'id': 676, 'seek': 402112, 'start': 4044.3199999999997, 'end': 4050.0, 'text': ' right, and the compiler can work those things out. Compiler and then subsequently the linkers', 'tokens': [51524, 558, 11, 293, 264, 31958, 393, 589, 729, 721, 484, 13, 6620, 5441, 293, 550, 26514, 264, 2113, 433, 51808], 'temperature': 0.0, 'avg_logprob': -0.06988395724380225, 'compression_ratio': 1.8629032258064515, 'no_speech_prob': 0.0021273186430335045}, {'id': 677, 'seek': 405000, 'start': 4050.0, 'end': 4055.04, 'text': ' and loaders, not just the compiler, it is also the linkers and loaders because each file is compiled', 'tokens': [50364, 293, 3677, 433, 11, 406, 445, 264, 31958, 11, 309, 307, 611, 264, 2113, 433, 293, 3677, 433, 570, 1184, 3991, 307, 36548, 50616], 'temperature': 0.0, 'avg_logprob': -0.12911333589472324, 'compression_ratio': 1.7695167286245352, 'no_speech_prob': 0.004731698427349329}, {'id': 678, 'seek': 405000, 'start': 4055.04, 'end': 4060.08, 'text': ' separately, you remember that, right. So as far as that single C file is concerned,', 'tokens': [50616, 14759, 11, 291, 1604, 300, 11, 558, 13, 407, 382, 1400, 382, 300, 2167, 383, 3991, 307, 5922, 11, 50868], 'temperature': 0.0, 'avg_logprob': -0.12911333589472324, 'compression_ratio': 1.7695167286245352, 'no_speech_prob': 0.004731698427349329}, {'id': 679, 'seek': 405000, 'start': 4060.08, 'end': 4066.64, 'text': ' there are only these global variables, right. Again, unfortunately I may not be able to provide', 'tokens': [50868, 456, 366, 787, 613, 4338, 9102, 11, 558, 13, 3764, 11, 7015, 286, 815, 406, 312, 1075, 281, 2893, 51196], 'temperature': 0.0, 'avg_logprob': -0.12911333589472324, 'compression_ratio': 1.7695167286245352, 'no_speech_prob': 0.004731698427349329}, {'id': 680, 'seek': 405000, 'start': 4066.64, 'end': 4071.36, 'text': ' a complete answer because there are several other things also, but it gives you an idea, right.', 'tokens': [51196, 257, 3566, 1867, 570, 456, 366, 2940, 661, 721, 611, 11, 457, 309, 2709, 291, 364, 1558, 11, 558, 13, 51432], 'temperature': 0.0, 'avg_logprob': -0.12911333589472324, 'compression_ratio': 1.7695167286245352, 'no_speech_prob': 0.004731698427349329}, {'id': 681, 'seek': 405000, 'start': 4072.32, 'end': 4079.52, 'text': ' If it is a stack frame, it is simple. Local variable is simple, right. Good. Shall we move forward?', 'tokens': [51480, 759, 309, 307, 257, 8630, 3920, 11, 309, 307, 2199, 13, 22755, 7006, 307, 2199, 11, 558, 13, 2205, 13, 12128, 321, 1286, 2128, 30, 51840], 'temperature': 0.0, 'avg_logprob': -0.12911333589472324, 'compression_ratio': 1.7695167286245352, 'no_speech_prob': 0.004731698427349329}, {'id': 682, 'seek': 408000, 'start': 4080.32, 'end': 4087.36, 'text': ' Okay, so let us look at a very simple code generation scheme, right. So this is going', 'tokens': [50380, 1033, 11, 370, 718, 505, 574, 412, 257, 588, 2199, 3089, 5125, 12232, 11, 558, 13, 407, 341, 307, 516, 50732], 'temperature': 0.0, 'avg_logprob': -0.0948614270499583, 'compression_ratio': 1.7209302325581395, 'no_speech_prob': 0.0004988855798728764}, {'id': 683, 'seek': 408000, 'start': 4087.36, 'end': 4093.44, 'text': ' to essentially go and then do the following thing. It will read one, right, intermediate', 'tokens': [50732, 281, 4476, 352, 293, 550, 360, 264, 3480, 551, 13, 467, 486, 1401, 472, 11, 558, 11, 19376, 51036], 'temperature': 0.0, 'avg_logprob': -0.0948614270499583, 'compression_ratio': 1.7209302325581395, 'no_speech_prob': 0.0004988855798728764}, {'id': 684, 'seek': 408000, 'start': 4093.44, 'end': 4102.24, 'text': ' statement and it will generate the code for that, right. That is essentially what it is going to do,', 'tokens': [51036, 5629, 293, 309, 486, 8460, 264, 3089, 337, 300, 11, 558, 13, 663, 307, 4476, 437, 309, 307, 516, 281, 360, 11, 51476], 'temperature': 0.0, 'avg_logprob': -0.0948614270499583, 'compression_ratio': 1.7209302325581395, 'no_speech_prob': 0.0004988855798728764}, {'id': 685, 'seek': 408000, 'start': 4102.96, 'end': 4108.32, 'text': ' but then when it generates a code depending on what the architecture allows, it has to decide,', 'tokens': [51512, 457, 550, 562, 309, 23815, 257, 3089, 5413, 322, 437, 264, 9482, 4045, 11, 309, 575, 281, 4536, 11, 51780], 'temperature': 0.0, 'avg_logprob': -0.0948614270499583, 'compression_ratio': 1.7209302325581395, 'no_speech_prob': 0.0004988855798728764}, {'id': 686, 'seek': 410832, 'start': 4108.32, 'end': 4113.599999999999, 'text': ' you know, what stays in the register and what stays in the memory and so on and so forth, right.', 'tokens': [50364, 291, 458, 11, 437, 10834, 294, 264, 7280, 293, 437, 10834, 294, 264, 4675, 293, 370, 322, 293, 370, 5220, 11, 558, 13, 50628], 'temperature': 0.0, 'avg_logprob': -0.07987303960890997, 'compression_ratio': 1.776190476190476, 'no_speech_prob': 0.0010233074426651}, {'id': 687, 'seek': 410832, 'start': 4114.639999999999, 'end': 4118.799999999999, 'text': ' So it is going to essentially maintain two data structures, one called register', 'tokens': [50680, 407, 309, 307, 516, 281, 4476, 6909, 732, 1412, 9227, 11, 472, 1219, 7280, 50888], 'temperature': 0.0, 'avg_logprob': -0.07987303960890997, 'compression_ratio': 1.776190476190476, 'no_speech_prob': 0.0010233074426651}, {'id': 688, 'seek': 410832, 'start': 4118.799999999999, 'end': 4125.84, 'text': ' and another called address descriptor, right. The register descriptor essentially keeps track of', 'tokens': [50888, 293, 1071, 1219, 2985, 31280, 284, 11, 558, 13, 440, 7280, 31280, 284, 4476, 5965, 2837, 295, 51240], 'temperature': 0.0, 'avg_logprob': -0.07987303960890997, 'compression_ratio': 1.776190476190476, 'no_speech_prob': 0.0010233074426651}, {'id': 689, 'seek': 410832, 'start': 4125.84, 'end': 4131.84, 'text': ' which register holds what variable names, right. For example, let us say if you have moved contents', 'tokens': [51240, 597, 7280, 9190, 437, 7006, 5288, 11, 558, 13, 1171, 1365, 11, 718, 505, 584, 498, 291, 362, 4259, 15768, 51540], 'temperature': 0.0, 'avg_logprob': -0.07987303960890997, 'compression_ratio': 1.776190476190476, 'no_speech_prob': 0.0010233074426651}, {'id': 690, 'seek': 413184, 'start': 4131.84, 'end': 4139.04, 'text': ' of A into register R1, then you have to remember that R1 contains variable A. So that subsequently', 'tokens': [50364, 295, 316, 666, 7280, 497, 16, 11, 550, 291, 362, 281, 1604, 300, 497, 16, 8306, 7006, 316, 13, 407, 300, 26514, 50724], 'temperature': 0.0, 'avg_logprob': -0.07300311138755397, 'compression_ratio': 1.7219730941704037, 'no_speech_prob': 0.04259771108627319}, {'id': 691, 'seek': 413184, 'start': 4139.04, 'end': 4144.24, 'text': ' if there is any instruction which is making use of variable A, instead of again loading it into', 'tokens': [50724, 498, 456, 307, 604, 10951, 597, 307, 1455, 764, 295, 7006, 316, 11, 2602, 295, 797, 15114, 309, 666, 50984], 'temperature': 0.0, 'avg_logprob': -0.07300311138755397, 'compression_ratio': 1.7219730941704037, 'no_speech_prob': 0.04259771108627319}, {'id': 692, 'seek': 413184, 'start': 4144.24, 'end': 4150.56, 'text': ' one more register, you might as well use this R1 because you save cost, correct. Once you have', 'tokens': [50984, 472, 544, 7280, 11, 291, 1062, 382, 731, 764, 341, 497, 16, 570, 291, 3155, 2063, 11, 3006, 13, 3443, 291, 362, 51300], 'temperature': 0.0, 'avg_logprob': -0.07300311138755397, 'compression_ratio': 1.7219730941704037, 'no_speech_prob': 0.04259771108627319}, {'id': 693, 'seek': 413184, 'start': 4150.56, 'end': 4155.68, 'text': ' already moved it into a register R1, it will be good to remember that, right. So that whenever', 'tokens': [51300, 1217, 4259, 309, 666, 257, 7280, 497, 16, 11, 309, 486, 312, 665, 281, 1604, 300, 11, 558, 13, 407, 300, 5699, 51556], 'temperature': 0.0, 'avg_logprob': -0.07300311138755397, 'compression_ratio': 1.7219730941704037, 'no_speech_prob': 0.04259771108627319}, {'id': 694, 'seek': 415568, 'start': 4155.68, 'end': 4163.12, 'text': ' A is being used, instead you can use R1 to do that, right. The other data structure which', 'tokens': [50364, 316, 307, 885, 1143, 11, 2602, 291, 393, 764, 497, 16, 281, 360, 300, 11, 558, 13, 440, 661, 1412, 3877, 597, 50736], 'temperature': 0.0, 'avg_logprob': -0.05425191962200662, 'compression_ratio': 1.7536945812807883, 'no_speech_prob': 0.048920586705207825}, {'id': 695, 'seek': 415568, 'start': 4163.12, 'end': 4168.16, 'text': ' is the address descriptor essentially kind of holds the other kind of the map.', 'tokens': [50736, 307, 264, 2985, 31280, 284, 4476, 733, 295, 9190, 264, 661, 733, 295, 264, 4471, 13, 50988], 'temperature': 0.0, 'avg_logprob': -0.05425191962200662, 'compression_ratio': 1.7536945812807883, 'no_speech_prob': 0.048920586705207825}, {'id': 696, 'seek': 415568, 'start': 4168.16, 'end': 4175.52, 'text': ' For every variable name, it says where all it is being held, right. For example, variable A,', 'tokens': [50988, 1171, 633, 7006, 1315, 11, 309, 1619, 689, 439, 309, 307, 885, 5167, 11, 558, 13, 1171, 1365, 11, 7006, 316, 11, 51356], 'temperature': 0.0, 'avg_logprob': -0.05425191962200662, 'compression_ratio': 1.7536945812807883, 'no_speech_prob': 0.048920586705207825}, {'id': 697, 'seek': 415568, 'start': 4175.52, 'end': 4182.64, 'text': ' you say whether it is in memory or you say whether it is in memory and register, you say that,', 'tokens': [51356, 291, 584, 1968, 309, 307, 294, 4675, 420, 291, 584, 1968, 309, 307, 294, 4675, 293, 7280, 11, 291, 584, 300, 11, 51712], 'temperature': 0.0, 'avg_logprob': -0.05425191962200662, 'compression_ratio': 1.7536945812807883, 'no_speech_prob': 0.048920586705207825}, {'id': 698, 'seek': 418264, 'start': 4183.52, 'end': 4192.08, 'text': ' okay. Because it is possible that you could have it in both places, right. And similarly,', 'tokens': [50408, 1392, 13, 1436, 309, 307, 1944, 300, 291, 727, 362, 309, 294, 1293, 3190, 11, 558, 13, 400, 14138, 11, 50836], 'temperature': 0.0, 'avg_logprob': -0.12281668364112057, 'compression_ratio': 1.5898876404494382, 'no_speech_prob': 0.001959490589797497}, {'id': 699, 'seek': 418264, 'start': 4192.08, 'end': 4199.92, 'text': ' when a variable is being copied into another variable, right, the register descriptor can', 'tokens': [50836, 562, 257, 7006, 307, 885, 25365, 666, 1071, 7006, 11, 558, 11, 264, 7280, 31280, 284, 393, 51228], 'temperature': 0.0, 'avg_logprob': -0.12281668364112057, 'compression_ratio': 1.5898876404494382, 'no_speech_prob': 0.001959490589797497}, {'id': 700, 'seek': 418264, 'start': 4199.92, 'end': 4207.280000000001, 'text': ' have for the same register multiple variable names. Say for example, A is copied into B and then I have', 'tokens': [51228, 362, 337, 264, 912, 7280, 3866, 7006, 5288, 13, 6463, 337, 1365, 11, 316, 307, 25365, 666, 363, 293, 550, 286, 362, 51596], 'temperature': 0.0, 'avg_logprob': -0.12281668364112057, 'compression_ratio': 1.5898876404494382, 'no_speech_prob': 0.001959490589797497}, {'id': 701, 'seek': 420728, 'start': 4207.28, 'end': 4213.84, 'text': ' loaded A, sorry A is copied into B, then I have loaded B into R1 register, right. If I have the', 'tokens': [50364, 13210, 316, 11, 2597, 316, 307, 25365, 666, 363, 11, 550, 286, 362, 13210, 363, 666, 497, 16, 7280, 11, 558, 13, 759, 286, 362, 264, 50692], 'temperature': 0.0, 'avg_logprob': -0.0981224605015346, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.0078637870028615}, {'id': 702, 'seek': 420728, 'start': 4213.84, 'end': 4220.5599999999995, 'text': ' sequence of statement A equal to B and then move B to R1, then R1 essentially holds B,', 'tokens': [50692, 8310, 295, 5629, 316, 2681, 281, 363, 293, 550, 1286, 363, 281, 497, 16, 11, 550, 497, 16, 4476, 9190, 363, 11, 51028], 'temperature': 0.0, 'avg_logprob': -0.0981224605015346, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.0078637870028615}, {'id': 703, 'seek': 420728, 'start': 4221.44, 'end': 4227.92, 'text': ' but R1 also holds A. To remembering this would be helpful because if I am going to do something with', 'tokens': [51072, 457, 497, 16, 611, 9190, 316, 13, 1407, 20719, 341, 576, 312, 4961, 570, 498, 286, 669, 516, 281, 360, 746, 365, 51396], 'temperature': 0.0, 'avg_logprob': -0.0981224605015346, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.0078637870028615}, {'id': 704, 'seek': 420728, 'start': 4227.92, 'end': 4236.0, 'text': ' A, I might as well use R1. However, I have to be careful not to overwrite something, right.', 'tokens': [51396, 316, 11, 286, 1062, 382, 731, 764, 497, 16, 13, 2908, 11, 286, 362, 281, 312, 5026, 406, 281, 670, 21561, 746, 11, 558, 13, 51800], 'temperature': 0.0, 'avg_logprob': -0.0981224605015346, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.0078637870028615}, {'id': 705, 'seek': 423600, 'start': 4236.0, 'end': 4242.72, 'text': ' Because if B is going to write onto itself some value or let us say the register which is holding', 'tokens': [50364, 1436, 498, 363, 307, 516, 281, 2464, 3911, 2564, 512, 2158, 420, 718, 505, 584, 264, 7280, 597, 307, 5061, 50700], 'temperature': 0.0, 'avg_logprob': -0.06495740288182308, 'compression_ratio': 1.5957446808510638, 'no_speech_prob': 0.006857036612927914}, {'id': 706, 'seek': 423600, 'start': 4242.72, 'end': 4248.8, 'text': ' B is going to be modified, then at that point in time I have to go and say that A no longer', 'tokens': [50700, 363, 307, 516, 281, 312, 15873, 11, 550, 412, 300, 935, 294, 565, 286, 362, 281, 352, 293, 584, 300, 316, 572, 2854, 51004], 'temperature': 0.0, 'avg_logprob': -0.06495740288182308, 'compression_ratio': 1.5957446808510638, 'no_speech_prob': 0.006857036612927914}, {'id': 707, 'seek': 423600, 'start': 4248.8, 'end': 4254.96, 'text': ' resides in register, A is only in the memory, correct. Otherwise, I will be using the wrong', 'tokens': [51004, 47157, 294, 7280, 11, 316, 307, 787, 294, 264, 4675, 11, 3006, 13, 10328, 11, 286, 486, 312, 1228, 264, 2085, 51312], 'temperature': 0.0, 'avg_logprob': -0.06495740288182308, 'compression_ratio': 1.5957446808510638, 'no_speech_prob': 0.006857036612927914}, {'id': 708, 'seek': 423600, 'start': 4254.96, 'end': 4261.84, 'text': ' location. So, this kind of a mapping is what needs to be maintained by these two descriptors.', 'tokens': [51312, 4914, 13, 407, 11, 341, 733, 295, 257, 18350, 307, 437, 2203, 281, 312, 17578, 538, 613, 732, 31280, 830, 13, 51656], 'temperature': 0.0, 'avg_logprob': -0.06495740288182308, 'compression_ratio': 1.5957446808510638, 'no_speech_prob': 0.006857036612927914}, {'id': 709, 'seek': 426184, 'start': 4261.84, 'end': 4268.4800000000005, 'text': ' That means the current up to date value for every variable, where is it available or in what all', 'tokens': [50364, 663, 1355, 264, 2190, 493, 281, 4002, 2158, 337, 633, 7006, 11, 689, 307, 309, 2435, 420, 294, 437, 439, 50696], 'temperature': 0.0, 'avg_logprob': -0.08117688030277917, 'compression_ratio': 1.73992673992674, 'no_speech_prob': 0.10513293743133545}, {'id': 710, 'seek': 426184, 'start': 4268.4800000000005, 'end': 4274.16, 'text': ' locations is it available. Similarly, each register what are all the variables that it is', 'tokens': [50696, 9253, 307, 309, 2435, 13, 13157, 11, 1184, 7280, 437, 366, 439, 264, 9102, 300, 309, 307, 50980], 'temperature': 0.0, 'avg_logprob': -0.08117688030277917, 'compression_ratio': 1.73992673992674, 'no_speech_prob': 0.10513293743133545}, {'id': 711, 'seek': 426184, 'start': 4274.16, 'end': 4279.28, 'text': ' currently holding. You need to kind of remember this in order for you to do this code generation.', 'tokens': [50980, 4362, 5061, 13, 509, 643, 281, 733, 295, 1604, 341, 294, 1668, 337, 291, 281, 360, 341, 3089, 5125, 13, 51236], 'temperature': 0.0, 'avg_logprob': -0.08117688030277917, 'compression_ratio': 1.73992673992674, 'no_speech_prob': 0.10513293743133545}, {'id': 712, 'seek': 426184, 'start': 4279.28, 'end': 4284.56, 'text': ' I will show you a simple scheme and also a simple example. We will not really bother too much about', 'tokens': [51236, 286, 486, 855, 291, 257, 2199, 12232, 293, 611, 257, 2199, 1365, 13, 492, 486, 406, 534, 8677, 886, 709, 466, 51500], 'temperature': 0.0, 'avg_logprob': -0.08117688030277917, 'compression_ratio': 1.73992673992674, 'no_speech_prob': 0.10513293743133545}, {'id': 713, 'seek': 426184, 'start': 4284.56, 'end': 4289.68, 'text': ' it because nobody is going to write a code generator using this method. I mean it is going', 'tokens': [51500, 309, 570, 5079, 307, 516, 281, 2464, 257, 3089, 19265, 1228, 341, 3170, 13, 286, 914, 309, 307, 516, 51756], 'temperature': 0.0, 'avg_logprob': -0.08117688030277917, 'compression_ratio': 1.73992673992674, 'no_speech_prob': 0.10513293743133545}, {'id': 714, 'seek': 428968, 'start': 4289.68, 'end': 4294.56, 'text': ' to produce a very very inefficient code if you use this method. So, there is no need to', 'tokens': [50364, 281, 5258, 257, 588, 588, 43495, 3089, 498, 291, 764, 341, 3170, 13, 407, 11, 456, 307, 572, 643, 281, 50608], 'temperature': 0.0, 'avg_logprob': -0.09426420302618117, 'compression_ratio': 1.8612244897959183, 'no_speech_prob': 0.00702257826924324}, {'id': 715, 'seek': 428968, 'start': 4295.92, 'end': 4300.72, 'text': ' learn this completely and then generate code using that because you are not ever', 'tokens': [50676, 1466, 341, 2584, 293, 550, 8460, 3089, 1228, 300, 570, 291, 366, 406, 1562, 50916], 'temperature': 0.0, 'avg_logprob': -0.09426420302618117, 'compression_ratio': 1.8612244897959183, 'no_speech_prob': 0.00702257826924324}, {'id': 716, 'seek': 428968, 'start': 4300.72, 'end': 4306.08, 'text': ' whenever ever going to use this thing. But just to have a quick idea of what it is, right.', 'tokens': [50916, 5699, 1562, 516, 281, 764, 341, 551, 13, 583, 445, 281, 362, 257, 1702, 1558, 295, 437, 309, 307, 11, 558, 13, 51184], 'temperature': 0.0, 'avg_logprob': -0.09426420302618117, 'compression_ratio': 1.8612244897959183, 'no_speech_prob': 0.00702257826924324}, {'id': 717, 'seek': 428968, 'start': 4306.88, 'end': 4311.4400000000005, 'text': ' So, in this code generation scheme what we want to do is that we want to use the register location', 'tokens': [51224, 407, 11, 294, 341, 3089, 5125, 12232, 437, 321, 528, 281, 360, 307, 300, 321, 528, 281, 764, 264, 7280, 4914, 51452], 'temperature': 0.0, 'avg_logprob': -0.09426420302618117, 'compression_ratio': 1.8612244897959183, 'no_speech_prob': 0.00702257826924324}, {'id': 718, 'seek': 428968, 'start': 4312.0, 'end': 4317.6, 'text': ' whenever the operand is available both in the memory and register because using register location', 'tokens': [51480, 5699, 264, 2208, 474, 307, 2435, 1293, 294, 264, 4675, 293, 7280, 570, 1228, 7280, 4914, 51760], 'temperature': 0.0, 'avg_logprob': -0.09426420302618117, 'compression_ratio': 1.8612244897959183, 'no_speech_prob': 0.00702257826924324}, {'id': 719, 'seek': 431760, 'start': 4317.6, 'end': 4326.72, 'text': ' saves cost, right. That is simply what it is, okay. And for every destination operand you try to', 'tokens': [50364, 19155, 2063, 11, 558, 13, 663, 307, 2935, 437, 309, 307, 11, 1392, 13, 400, 337, 633, 12236, 2208, 474, 291, 853, 281, 50820], 'temperature': 0.0, 'avg_logprob': -0.13697940047069262, 'compression_ratio': 1.7074235807860263, 'no_speech_prob': 0.004509336315095425}, {'id': 720, 'seek': 431760, 'start': 4326.72, 'end': 4333.92, 'text': ' allocate a register whenever it is possible and hold that value in that register as long as possible.', 'tokens': [50820, 35713, 257, 7280, 5699, 309, 307, 1944, 293, 1797, 300, 2158, 294, 300, 7280, 382, 938, 382, 1944, 13, 51180], 'temperature': 0.0, 'avg_logprob': -0.13697940047069262, 'compression_ratio': 1.7074235807860263, 'no_speech_prob': 0.004509336315095425}, {'id': 721, 'seek': 431760, 'start': 4334.72, 'end': 4340.72, 'text': ' But if no free registers are available you can also use memory. That means that you are going', 'tokens': [51220, 583, 498, 572, 1737, 38351, 366, 2435, 291, 393, 611, 764, 4675, 13, 663, 1355, 300, 291, 366, 516, 51520], 'temperature': 0.0, 'avg_logprob': -0.13697940047069262, 'compression_ratio': 1.7074235807860263, 'no_speech_prob': 0.004509336315095425}, {'id': 722, 'seek': 431760, 'start': 4340.72, 'end': 4345.92, 'text': ' to incur more cost. That is the only difference, right. If they are if the see particularly in the', 'tokens': [51520, 281, 35774, 544, 2063, 13, 663, 307, 264, 787, 2649, 11, 558, 13, 759, 436, 366, 498, 264, 536, 4098, 294, 264, 51780], 'temperature': 0.0, 'avg_logprob': -0.13697940047069262, 'compression_ratio': 1.7074235807860263, 'no_speech_prob': 0.004509336315095425}, {'id': 723, 'seek': 434592, 'start': 4345.92, 'end': 4351.4400000000005, 'text': ' case of a Sysc machine which allows your operand to be in memory or register you could have used', 'tokens': [50364, 1389, 295, 257, 318, 749, 66, 3479, 597, 4045, 428, 2208, 474, 281, 312, 294, 4675, 420, 7280, 291, 727, 362, 1143, 50640], 'temperature': 0.0, 'avg_logprob': -0.06199421260667884, 'compression_ratio': 1.872, 'no_speech_prob': 0.001902329153381288}, {'id': 724, 'seek': 434592, 'start': 4351.4400000000005, 'end': 4356.8, 'text': ' either one of them, right. Again it depends whether that particular Sysc architecture allows', 'tokens': [50640, 2139, 472, 295, 552, 11, 558, 13, 3764, 309, 5946, 1968, 300, 1729, 318, 749, 66, 9482, 4045, 50908], 'temperature': 0.0, 'avg_logprob': -0.06199421260667884, 'compression_ratio': 1.872, 'no_speech_prob': 0.001902329153381288}, {'id': 725, 'seek': 434592, 'start': 4356.8, 'end': 4362.32, 'text': ' your destination operand to be in memory. If it allows it to be in memory then you can use it.', 'tokens': [50908, 428, 12236, 2208, 474, 281, 312, 294, 4675, 13, 759, 309, 4045, 309, 281, 312, 294, 4675, 550, 291, 393, 764, 309, 13, 51184], 'temperature': 0.0, 'avg_logprob': -0.06199421260667884, 'compression_ratio': 1.872, 'no_speech_prob': 0.001902329153381288}, {'id': 726, 'seek': 434592, 'start': 4362.32, 'end': 4366.72, 'text': ' If it does not then necessarily you have to allocate a register for that. So, you have to', 'tokens': [51184, 759, 309, 775, 406, 550, 4725, 291, 362, 281, 35713, 257, 7280, 337, 300, 13, 407, 11, 291, 362, 281, 51404], 'temperature': 0.0, 'avg_logprob': -0.06199421260667884, 'compression_ratio': 1.872, 'no_speech_prob': 0.001902329153381288}, {'id': 727, 'seek': 434592, 'start': 4366.72, 'end': 4372.72, 'text': ' find a register and so on. So, essentially this algorithm is going to go in the following way', 'tokens': [51404, 915, 257, 7280, 293, 370, 322, 13, 407, 11, 4476, 341, 9284, 307, 516, 281, 352, 294, 264, 3480, 636, 51704], 'temperature': 0.0, 'avg_logprob': -0.06199421260667884, 'compression_ratio': 1.872, 'no_speech_prob': 0.001902329153381288}, {'id': 728, 'seek': 437272, 'start': 4373.2, 'end': 4378.56, 'text': ' but it is very I mean it is going to generate a very inefficient code. Let us see how it works,', 'tokens': [50388, 457, 309, 307, 588, 286, 914, 309, 307, 516, 281, 8460, 257, 588, 43495, 3089, 13, 961, 505, 536, 577, 309, 1985, 11, 50656], 'temperature': 0.0, 'avg_logprob': -0.10985399061633695, 'compression_ratio': 1.704225352112676, 'no_speech_prob': 0.01298683974891901}, {'id': 729, 'seek': 437272, 'start': 4379.12, 'end': 4385.4400000000005, 'text': ' right. For each three address code which is of this form x is equal to y operation z,', 'tokens': [50684, 558, 13, 1171, 1184, 1045, 2985, 3089, 597, 307, 295, 341, 1254, 2031, 307, 2681, 281, 288, 6916, 710, 11, 51000], 'temperature': 0.0, 'avg_logprob': -0.10985399061633695, 'compression_ratio': 1.704225352112676, 'no_speech_prob': 0.01298683974891901}, {'id': 730, 'seek': 437272, 'start': 4386.240000000001, 'end': 4393.360000000001, 'text': ' right. It first finds out, okay. It first gets a register for the destination location,', 'tokens': [51040, 558, 13, 467, 700, 10704, 484, 11, 1392, 13, 467, 700, 2170, 257, 7280, 337, 264, 12236, 4914, 11, 51396], 'temperature': 0.0, 'avg_logprob': -0.10985399061633695, 'compression_ratio': 1.704225352112676, 'no_speech_prob': 0.01298683974891901}, {'id': 731, 'seek': 437272, 'start': 4394.320000000001, 'end': 4400.08, 'text': ' right. So, we will find out how get register works but the idea is that get register is going', 'tokens': [51444, 558, 13, 407, 11, 321, 486, 915, 484, 577, 483, 7280, 1985, 457, 264, 1558, 307, 300, 483, 7280, 307, 516, 51732], 'temperature': 0.0, 'avg_logprob': -0.10985399061633695, 'compression_ratio': 1.704225352112676, 'no_speech_prob': 0.01298683974891901}, {'id': 732, 'seek': 440008, 'start': 4400.08, 'end': 4407.44, 'text': ' to identify a location L which could either be a register or a memory location, right for the', 'tokens': [50364, 281, 5876, 257, 4914, 441, 597, 727, 2139, 312, 257, 7280, 420, 257, 4675, 4914, 11, 558, 337, 264, 50732], 'temperature': 0.0, 'avg_logprob': -0.08921497746517784, 'compression_ratio': 2.0, 'no_speech_prob': 0.0010196990333497524}, {'id': 733, 'seek': 440008, 'start': 4407.44, 'end': 4417.04, 'text': ' destination operand, right. And then next it determines where y is available. So, it finds out', 'tokens': [50732, 12236, 2208, 474, 11, 558, 13, 400, 550, 958, 309, 24799, 689, 288, 307, 2435, 13, 407, 11, 309, 10704, 484, 51212], 'temperature': 0.0, 'avg_logprob': -0.08921497746517784, 'compression_ratio': 2.0, 'no_speech_prob': 0.0010196990333497524}, {'id': 734, 'seek': 440008, 'start': 4417.04, 'end': 4423.76, 'text': ' the location y prime where y is available, okay. It could y prime could either be a register or a', 'tokens': [51212, 264, 4914, 288, 5835, 689, 288, 307, 2435, 11, 1392, 13, 467, 727, 288, 5835, 727, 2139, 312, 257, 7280, 420, 257, 51548], 'temperature': 0.0, 'avg_logprob': -0.08921497746517784, 'compression_ratio': 2.0, 'no_speech_prob': 0.0010196990333497524}, {'id': 735, 'seek': 440008, 'start': 4423.76, 'end': 4429.92, 'text': ' memory, okay. The location where it is available. Then what it is going to do is that it is going', 'tokens': [51548, 4675, 11, 1392, 13, 440, 4914, 689, 309, 307, 2435, 13, 1396, 437, 309, 307, 516, 281, 360, 307, 300, 309, 307, 516, 51856], 'temperature': 0.0, 'avg_logprob': -0.08921497746517784, 'compression_ratio': 2.0, 'no_speech_prob': 0.0010196990333497524}, {'id': 736, 'seek': 442992, 'start': 4429.92, 'end': 4436.88, 'text': ' to copy this y into this location L, right. Remember we are going to talk about generating', 'tokens': [50364, 281, 5055, 341, 288, 666, 341, 4914, 441, 11, 558, 13, 5459, 321, 366, 516, 281, 751, 466, 17746, 50712], 'temperature': 0.0, 'avg_logprob': -0.08220934045725856, 'compression_ratio': 1.7391304347826086, 'no_speech_prob': 0.0002383566607022658}, {'id': 737, 'seek': 442992, 'start': 4436.88, 'end': 4443.04, 'text': ' address for CISC machines and in this CISC machines typically it is a two address,', 'tokens': [50712, 2985, 337, 383, 2343, 34, 8379, 293, 294, 341, 383, 2343, 34, 8379, 5850, 309, 307, 257, 732, 2985, 11, 51020], 'temperature': 0.0, 'avg_logprob': -0.08220934045725856, 'compression_ratio': 1.7391304347826086, 'no_speech_prob': 0.0002383566607022658}, {'id': 738, 'seek': 442992, 'start': 4443.04, 'end': 4449.36, 'text': ' two operand instruction address format, okay. And one of the operands is also the destination', 'tokens': [51020, 732, 2208, 474, 10951, 2985, 7877, 11, 1392, 13, 400, 472, 295, 264, 2208, 2967, 307, 611, 264, 12236, 51336], 'temperature': 0.0, 'avg_logprob': -0.08220934045725856, 'compression_ratio': 1.7391304347826086, 'no_speech_prob': 0.0002383566607022658}, {'id': 739, 'seek': 442992, 'start': 4449.36, 'end': 4456.4800000000005, 'text': ' location. That is why we are taking the first operand and then putting it in the destination', 'tokens': [51336, 4914, 13, 663, 307, 983, 321, 366, 1940, 264, 700, 2208, 474, 293, 550, 3372, 309, 294, 264, 12236, 51692], 'temperature': 0.0, 'avg_logprob': -0.08220934045725856, 'compression_ratio': 1.7391304347826086, 'no_speech_prob': 0.0002383566607022658}, {'id': 740, 'seek': 445648, 'start': 4456.48, 'end': 4463.04, 'text': ' location, right. So, remember earlier itself we figured out that L should be the location where', 'tokens': [50364, 4914, 11, 558, 13, 407, 11, 1604, 3071, 2564, 321, 8932, 484, 300, 441, 820, 312, 264, 4914, 689, 50692], 'temperature': 0.0, 'avg_logprob': -0.07956208785374959, 'compression_ratio': 1.6566265060240963, 'no_speech_prob': 0.007272589020431042}, {'id': 741, 'seek': 445648, 'start': 4463.04, 'end': 4470.24, 'text': ' the destination is going to be, right. So, we have said that x is going to be available in L', 'tokens': [50692, 264, 12236, 307, 516, 281, 312, 11, 558, 13, 407, 11, 321, 362, 848, 300, 2031, 307, 516, 281, 312, 2435, 294, 441, 51052], 'temperature': 0.0, 'avg_logprob': -0.07956208785374959, 'compression_ratio': 1.6566265060240963, 'no_speech_prob': 0.007272589020431042}, {'id': 742, 'seek': 445648, 'start': 4471.12, 'end': 4477.2, 'text': ' and in that location I have now moved the value of y. Now I find out where z would be,', 'tokens': [51096, 293, 294, 300, 4914, 286, 362, 586, 4259, 264, 2158, 295, 288, 13, 823, 286, 915, 484, 689, 710, 576, 312, 11, 51400], 'temperature': 0.0, 'avg_logprob': -0.07956208785374959, 'compression_ratio': 1.6566265060240963, 'no_speech_prob': 0.007272589020431042}, {'id': 743, 'seek': 447720, 'start': 4477.2, 'end': 4487.36, 'text': ' right. Find out the location where z is, okay. And then generate code operation z prime, L.', 'tokens': [50364, 558, 13, 11809, 484, 264, 4914, 689, 710, 307, 11, 1392, 13, 400, 550, 8460, 3089, 6916, 710, 5835, 11, 441, 13, 50872], 'temperature': 0.0, 'avg_logprob': -0.12860235008033546, 'compression_ratio': 1.7579617834394905, 'no_speech_prob': 0.002320425119251013}, {'id': 744, 'seek': 447720, 'start': 4488.16, 'end': 4496.24, 'text': ' If z prime is a register, then it is a register, register. If z prime is a memory, then it is', 'tokens': [50912, 759, 710, 5835, 307, 257, 7280, 11, 550, 309, 307, 257, 7280, 11, 7280, 13, 759, 710, 5835, 307, 257, 4675, 11, 550, 309, 307, 51316], 'temperature': 0.0, 'avg_logprob': -0.12860235008033546, 'compression_ratio': 1.7579617834394905, 'no_speech_prob': 0.002320425119251013}, {'id': 745, 'seek': 447720, 'start': 4496.88, 'end': 4502.639999999999, 'text': ' memory register, right. Assuming this machine supports one operand to be in the memory and', 'tokens': [51348, 4675, 7280, 11, 558, 13, 6281, 24919, 341, 3479, 9346, 472, 2208, 474, 281, 312, 294, 264, 4675, 293, 51636], 'temperature': 0.0, 'avg_logprob': -0.12860235008033546, 'compression_ratio': 1.7579617834394905, 'no_speech_prob': 0.002320425119251013}, {'id': 746, 'seek': 450264, 'start': 4502.64, 'end': 4509.68, 'text': ' the other to be in the register, right. This kind of works. So, that is the reason why we have', 'tokens': [50364, 264, 661, 281, 312, 294, 264, 7280, 11, 558, 13, 639, 733, 295, 1985, 13, 407, 11, 300, 307, 264, 1778, 983, 321, 362, 50716], 'temperature': 0.0, 'avg_logprob': -0.07567833671885088, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.009468691423535347}, {'id': 747, 'seek': 450264, 'start': 4509.68, 'end': 4514.88, 'text': ' done this, okay. Actually, I am sorry, I will take that back a little bit because I do not know', 'tokens': [50716, 1096, 341, 11, 1392, 13, 5135, 11, 286, 669, 2597, 11, 286, 486, 747, 300, 646, 257, 707, 857, 570, 286, 360, 406, 458, 50976], 'temperature': 0.0, 'avg_logprob': -0.07567833671885088, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.009468691423535347}, {'id': 748, 'seek': 450264, 'start': 4514.88, 'end': 4520.8, 'text': ' whether L is a register, right. We only know that L is the location where the destination has to be.', 'tokens': [50976, 1968, 441, 307, 257, 7280, 11, 558, 13, 492, 787, 458, 300, 441, 307, 264, 4914, 689, 264, 12236, 575, 281, 312, 13, 51272], 'temperature': 0.0, 'avg_logprob': -0.07567833671885088, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.009468691423535347}, {'id': 749, 'seek': 450264, 'start': 4520.8, 'end': 4525.84, 'text': ' This could even be a memory, memory operation. All that I know is that I have moved the value of', 'tokens': [51272, 639, 727, 754, 312, 257, 4675, 11, 4675, 6916, 13, 1057, 300, 286, 458, 307, 300, 286, 362, 4259, 264, 2158, 295, 51524], 'temperature': 0.0, 'avg_logprob': -0.07567833671885088, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.009468691423535347}, {'id': 750, 'seek': 450264, 'start': 4526.4800000000005, 'end': 4532.320000000001, 'text': ' the first source operand into the destination location. Then I have performed the operation', 'tokens': [51556, 264, 700, 4009, 2208, 474, 666, 264, 12236, 4914, 13, 1396, 286, 362, 10332, 264, 6916, 51848], 'temperature': 0.0, 'avg_logprob': -0.07567833671885088, 'compression_ratio': 1.8181818181818181, 'no_speech_prob': 0.009468691423535347}, {'id': 751, 'seek': 453232, 'start': 4532.32, 'end': 4538.16, 'text': ' of performed the operation with regard to the second source operand and the first source operand', 'tokens': [50364, 295, 10332, 264, 6916, 365, 3843, 281, 264, 1150, 4009, 2208, 474, 293, 264, 700, 4009, 2208, 474, 50656], 'temperature': 0.0, 'avg_logprob': -0.10460251310597295, 'compression_ratio': 1.9746192893401016, 'no_speech_prob': 0.0005911206244491041}, {'id': 752, 'seek': 453232, 'start': 4538.16, 'end': 4543.12, 'text': ' which is already available in my destination location and the result is also available in my', 'tokens': [50656, 597, 307, 1217, 2435, 294, 452, 12236, 4914, 293, 264, 1874, 307, 611, 2435, 294, 452, 50904], 'temperature': 0.0, 'avg_logprob': -0.10460251310597295, 'compression_ratio': 1.9746192893401016, 'no_speech_prob': 0.0005911206244491041}, {'id': 753, 'seek': 453232, 'start': 4543.12, 'end': 4550.48, 'text': ' destination location, right. After I have done that, now I have to say that x is now available in L,', 'tokens': [50904, 12236, 4914, 11, 558, 13, 2381, 286, 362, 1096, 300, 11, 586, 286, 362, 281, 584, 300, 2031, 307, 586, 2435, 294, 441, 11, 51272], 'temperature': 0.0, 'avg_logprob': -0.10460251310597295, 'compression_ratio': 1.9746192893401016, 'no_speech_prob': 0.0005911206244491041}, {'id': 754, 'seek': 453232, 'start': 4551.44, 'end': 4558.719999999999, 'text': ' right. x is available in L. I cannot say anything about y prime. I am sorry, I cannot say anything', 'tokens': [51320, 558, 13, 2031, 307, 2435, 294, 441, 13, 286, 2644, 584, 1340, 466, 288, 5835, 13, 286, 669, 2597, 11, 286, 2644, 584, 1340, 51684], 'temperature': 0.0, 'avg_logprob': -0.10460251310597295, 'compression_ratio': 1.9746192893401016, 'no_speech_prob': 0.0005911206244491041}, {'id': 755, 'seek': 455872, 'start': 4558.72, 'end': 4564.64, 'text': ' about y except that y is available in y prime which is where it was available earlier. So,', 'tokens': [50364, 466, 288, 3993, 300, 288, 307, 2435, 294, 288, 5835, 597, 307, 689, 309, 390, 2435, 3071, 13, 407, 11, 50660], 'temperature': 0.0, 'avg_logprob': -0.043625268825264865, 'compression_ratio': 1.733009708737864, 'no_speech_prob': 0.005615367088466883}, {'id': 756, 'seek': 455872, 'start': 4564.64, 'end': 4569.76, 'text': ' I do not have to necessarily do any update on that. He said also I am not moving anywhere,', 'tokens': [50660, 286, 360, 406, 362, 281, 4725, 360, 604, 5623, 322, 300, 13, 634, 848, 611, 286, 669, 406, 2684, 4992, 11, 50916], 'temperature': 0.0, 'avg_logprob': -0.043625268825264865, 'compression_ratio': 1.733009708737864, 'no_speech_prob': 0.005615367088466883}, {'id': 757, 'seek': 455872, 'start': 4571.280000000001, 'end': 4577.4400000000005, 'text': ' right. You understand that prior to this instruction, y was available in the location', 'tokens': [50992, 558, 13, 509, 1223, 300, 4059, 281, 341, 10951, 11, 288, 390, 2435, 294, 264, 4914, 51300], 'temperature': 0.0, 'avg_logprob': -0.043625268825264865, 'compression_ratio': 1.733009708737864, 'no_speech_prob': 0.005615367088466883}, {'id': 758, 'seek': 455872, 'start': 4577.4400000000005, 'end': 4583.52, 'text': ' y prime and z was available in the location z prime. Neither of them have been disturbed,', 'tokens': [51300, 288, 5835, 293, 710, 390, 2435, 294, 264, 4914, 710, 5835, 13, 23956, 295, 552, 362, 668, 30558, 11, 51604], 'temperature': 0.0, 'avg_logprob': -0.043625268825264865, 'compression_ratio': 1.733009708737864, 'no_speech_prob': 0.005615367088466883}, {'id': 759, 'seek': 458352, 'start': 4583.52, 'end': 4590.080000000001, 'text': ' right. They have not been modified. So, both y and y prime continue to stay wherever they were', 'tokens': [50364, 558, 13, 814, 362, 406, 668, 15873, 13, 407, 11, 1293, 288, 293, 288, 5835, 2354, 281, 1754, 8660, 436, 645, 50692], 'temperature': 0.0, 'avg_logprob': -0.06858792555959602, 'compression_ratio': 1.7887323943661972, 'no_speech_prob': 0.003256371710449457}, {'id': 760, 'seek': 458352, 'start': 4590.080000000001, 'end': 4598.320000000001, 'text': ' before. Only thing is that x is now available in L. If L happens to be a register, then we know', 'tokens': [50692, 949, 13, 5686, 551, 307, 300, 2031, 307, 586, 2435, 294, 441, 13, 759, 441, 2314, 281, 312, 257, 7280, 11, 550, 321, 458, 51104], 'temperature': 0.0, 'avg_logprob': -0.06858792555959602, 'compression_ratio': 1.7887323943661972, 'no_speech_prob': 0.003256371710449457}, {'id': 761, 'seek': 458352, 'start': 4598.320000000001, 'end': 4603.360000000001, 'text': ' that it is a register. If L happens to be a memory location, then it is a memory location.', 'tokens': [51104, 300, 309, 307, 257, 7280, 13, 759, 441, 2314, 281, 312, 257, 4675, 4914, 11, 550, 309, 307, 257, 4675, 4914, 13, 51356], 'temperature': 0.0, 'avg_logprob': -0.06858792555959602, 'compression_ratio': 1.7887323943661972, 'no_speech_prob': 0.003256371710449457}, {'id': 762, 'seek': 458352, 'start': 4603.360000000001, 'end': 4609.84, 'text': ' So, the address registers, address descriptor and the register descriptors have to be appropriately', 'tokens': [51356, 407, 11, 264, 2985, 38351, 11, 2985, 31280, 284, 293, 264, 7280, 31280, 830, 362, 281, 312, 23505, 51680], 'temperature': 0.0, 'avg_logprob': -0.06858792555959602, 'compression_ratio': 1.7887323943661972, 'no_speech_prob': 0.003256371710449457}, {'id': 763, 'seek': 460984, 'start': 4610.72, 'end': 4617.6, 'text': ' updated, ok. x was not already available in L.', 'tokens': [50408, 10588, 11, 3133, 13, 2031, 390, 406, 1217, 2435, 294, 441, 13, 50752], 'temperature': 0.0, 'avg_logprob': -0.18576166364881727, 'compression_ratio': 1.5723684210526316, 'no_speech_prob': 0.0077303750440478325}, {'id': 764, 'seek': 460984, 'start': 4617.6, 'end': 4624.88, 'text': ' x was not already available in L. We have to use this getreg function to find out a location for', 'tokens': [50752, 2031, 390, 406, 1217, 2435, 294, 441, 13, 492, 362, 281, 764, 341, 483, 3375, 2445, 281, 915, 484, 257, 4914, 337, 51116], 'temperature': 0.0, 'avg_logprob': -0.18576166364881727, 'compression_ratio': 1.5723684210526316, 'no_speech_prob': 0.0077303750440478325}, {'id': 765, 'seek': 460984, 'start': 4624.88, 'end': 4630.96, 'text': ' L and if that happens to be a register, it is something different. Otherwise, it will be memory', 'tokens': [51116, 441, 293, 498, 300, 2314, 281, 312, 257, 7280, 11, 309, 307, 746, 819, 13, 10328, 11, 309, 486, 312, 4675, 51420], 'temperature': 0.0, 'avg_logprob': -0.18576166364881727, 'compression_ratio': 1.5723684210526316, 'no_speech_prob': 0.0077303750440478325}, {'id': 766, 'seek': 463096, 'start': 4630.96, 'end': 4640.0, 'text': ' location x, ok. Let us see what the getreg function is doing, right. So, getreg function', 'tokens': [50364, 4914, 2031, 11, 3133, 13, 961, 505, 536, 437, 264, 483, 3375, 2445, 307, 884, 11, 558, 13, 407, 11, 483, 3375, 2445, 50816], 'temperature': 0.0, 'avg_logprob': -0.0619448979695638, 'compression_ratio': 1.6896551724137931, 'no_speech_prob': 0.03483939170837402}, {'id': 767, 'seek': 463096, 'start': 4640.0, 'end': 4646.24, 'text': ' is essentially supposed to find a location L for x for computing this operation. So,', 'tokens': [50816, 307, 4476, 3442, 281, 915, 257, 4914, 441, 337, 2031, 337, 15866, 341, 6916, 13, 407, 11, 51128], 'temperature': 0.0, 'avg_logprob': -0.0619448979695638, 'compression_ratio': 1.6896551724137931, 'no_speech_prob': 0.03483939170837402}, {'id': 768, 'seek': 463096, 'start': 4647.52, 'end': 4652.4800000000005, 'text': ' it is actually going to do something very interesting. It first finds out whether y is', 'tokens': [51192, 309, 307, 767, 516, 281, 360, 746, 588, 1880, 13, 467, 700, 10704, 484, 1968, 288, 307, 51440], 'temperature': 0.0, 'avg_logprob': -0.0619448979695638, 'compression_ratio': 1.6896551724137931, 'no_speech_prob': 0.03483939170837402}, {'id': 769, 'seek': 463096, 'start': 4652.4800000000005, 'end': 4658.96, 'text': ' in a register R, ok. If y is already in a register, y is the first source operand,', 'tokens': [51440, 294, 257, 7280, 497, 11, 3133, 13, 759, 288, 307, 1217, 294, 257, 7280, 11, 288, 307, 264, 700, 4009, 2208, 474, 11, 51764], 'temperature': 0.0, 'avg_logprob': -0.0619448979695638, 'compression_ratio': 1.6896551724137931, 'no_speech_prob': 0.03483939170837402}, {'id': 770, 'seek': 465896, 'start': 4659.84, 'end': 4669.36, 'text': ' ok. And that register is not holding any other location. That means that only y and R has only', 'tokens': [50408, 3133, 13, 400, 300, 7280, 307, 406, 5061, 604, 661, 4914, 13, 663, 1355, 300, 787, 288, 293, 497, 575, 787, 50884], 'temperature': 0.0, 'avg_logprob': -0.10359613011392314, 'compression_ratio': 1.7538461538461538, 'no_speech_prob': 0.002268315525725484}, {'id': 771, 'seek': 465896, 'start': 4669.36, 'end': 4675.92, 'text': ' y, nothing else, right. And of course, y is not needed anymore, y is not live anymore,', 'tokens': [50884, 288, 11, 1825, 1646, 11, 558, 13, 400, 295, 1164, 11, 288, 307, 406, 2978, 3602, 11, 288, 307, 406, 1621, 3602, 11, 51212], 'temperature': 0.0, 'avg_logprob': -0.10359613011392314, 'compression_ratio': 1.7538461538461538, 'no_speech_prob': 0.002268315525725484}, {'id': 772, 'seek': 465896, 'start': 4677.12, 'end': 4681.52, 'text': ' right. That is that value which is available in the R register is not needed anymore.', 'tokens': [51272, 558, 13, 663, 307, 300, 2158, 597, 307, 2435, 294, 264, 497, 7280, 307, 406, 2978, 3602, 13, 51492], 'temperature': 0.0, 'avg_logprob': -0.10359613011392314, 'compression_ratio': 1.7538461538461538, 'no_speech_prob': 0.002268315525725484}, {'id': 773, 'seek': 465896, 'start': 4682.16, 'end': 4686.32, 'text': ' Then I can use that itself. See, it is possible that you have computations', 'tokens': [51524, 1396, 286, 393, 764, 300, 2564, 13, 3008, 11, 309, 307, 1944, 300, 291, 362, 2807, 763, 51732], 'temperature': 0.0, 'avg_logprob': -0.10359613011392314, 'compression_ratio': 1.7538461538461538, 'no_speech_prob': 0.002268315525725484}, {'id': 774, 'seek': 468632, 'start': 4686.88, 'end': 4693.12, 'text': ' where certain value is in a location. You use it once or you use it a few times and after that,', 'tokens': [50392, 689, 1629, 2158, 307, 294, 257, 4914, 13, 509, 764, 309, 1564, 420, 291, 764, 309, 257, 1326, 1413, 293, 934, 300, 11, 50704], 'temperature': 0.0, 'avg_logprob': -0.09852938785731236, 'compression_ratio': 1.6978723404255318, 'no_speech_prob': 0.004873562604188919}, {'id': 775, 'seek': 468632, 'start': 4693.12, 'end': 4698.88, 'text': ' you do not again need it for a long time. In which case, I can actually overwrite onto that location,', 'tokens': [50704, 291, 360, 406, 797, 643, 309, 337, 257, 938, 565, 13, 682, 597, 1389, 11, 286, 393, 767, 670, 21561, 3911, 300, 4914, 11, 50992], 'temperature': 0.0, 'avg_logprob': -0.09852938785731236, 'compression_ratio': 1.6978723404255318, 'no_speech_prob': 0.004873562604188919}, {'id': 776, 'seek': 468632, 'start': 4698.88, 'end': 4707.759999999999, 'text': ' right. That is what it says. So, if y is available in a register R and R does not hold anything other', 'tokens': [50992, 558, 13, 663, 307, 437, 309, 1619, 13, 407, 11, 498, 288, 307, 2435, 294, 257, 7280, 497, 293, 497, 775, 406, 1797, 1340, 661, 51436], 'temperature': 0.0, 'avg_logprob': -0.09852938785731236, 'compression_ratio': 1.6978723404255318, 'no_speech_prob': 0.004873562604188919}, {'id': 777, 'seek': 468632, 'start': 4707.759999999999, 'end': 4714.24, 'text': ' than y, then I can and of course, y is not needed anymore and I can go and modify that itself. That', 'tokens': [51436, 813, 288, 11, 550, 286, 393, 293, 295, 1164, 11, 288, 307, 406, 2978, 3602, 293, 286, 393, 352, 293, 16927, 300, 2564, 13, 663, 51760], 'temperature': 0.0, 'avg_logprob': -0.09852938785731236, 'compression_ratio': 1.6978723404255318, 'no_speech_prob': 0.004873562604188919}, {'id': 778, 'seek': 471424, 'start': 4714.24, 'end': 4721.04, 'text': ' register itself I can reuse. That is essentially what it is saying. So, allocate that register to', 'tokens': [50364, 7280, 2564, 286, 393, 26225, 13, 663, 307, 4476, 437, 309, 307, 1566, 13, 407, 11, 35713, 300, 7280, 281, 50704], 'temperature': 0.0, 'avg_logprob': -0.08028933766124012, 'compression_ratio': 1.7609756097560976, 'no_speech_prob': 0.001100810244679451}, {'id': 779, 'seek': 471424, 'start': 4721.04, 'end': 4724.96, 'text': ' x and say that that is the location where your destination is going to be.', 'tokens': [50704, 2031, 293, 584, 300, 300, 307, 264, 4914, 689, 428, 12236, 307, 516, 281, 312, 13, 50900], 'temperature': 0.0, 'avg_logprob': -0.08028933766124012, 'compression_ratio': 1.7609756097560976, 'no_speech_prob': 0.001100810244679451}, {'id': 780, 'seek': 471424, 'start': 4725.679999999999, 'end': 4732.48, 'text': ' And if you do that, you remember that your y is already in R, ok, in your destination location.', 'tokens': [50936, 400, 498, 291, 360, 300, 11, 291, 1604, 300, 428, 288, 307, 1217, 294, 497, 11, 3133, 11, 294, 428, 12236, 4914, 13, 51276], 'temperature': 0.0, 'avg_logprob': -0.08028933766124012, 'compression_ratio': 1.7609756097560976, 'no_speech_prob': 0.001100810244679451}, {'id': 781, 'seek': 471424, 'start': 4733.679999999999, 'end': 4740.24, 'text': ' Else, if there is an empty register R prime, you can allocate that, right. If no register is', 'tokens': [51336, 45472, 11, 498, 456, 307, 364, 6707, 7280, 497, 5835, 11, 291, 393, 35713, 300, 11, 558, 13, 759, 572, 7280, 307, 51664], 'temperature': 0.0, 'avg_logprob': -0.08028933766124012, 'compression_ratio': 1.7609756097560976, 'no_speech_prob': 0.001100810244679451}, {'id': 782, 'seek': 474024, 'start': 4740.24, 'end': 4747.76, 'text': ' available, ok, and if the operand requires the destination to be in a register, then you have to', 'tokens': [50364, 2435, 11, 3133, 11, 293, 498, 264, 2208, 474, 7029, 264, 12236, 281, 312, 294, 257, 7280, 11, 550, 291, 362, 281, 50740], 'temperature': 0.0, 'avg_logprob': -0.07783014723595152, 'compression_ratio': 1.7410714285714286, 'no_speech_prob': 0.005404097493737936}, {'id': 783, 'seek': 474024, 'start': 4747.76, 'end': 4752.639999999999, 'text': ' spill one of those existing variables which is already holding all your registers, throw that', 'tokens': [50740, 22044, 472, 295, 729, 6741, 9102, 597, 307, 1217, 5061, 439, 428, 38351, 11, 3507, 300, 50984], 'temperature': 0.0, 'avg_logprob': -0.07783014723595152, 'compression_ratio': 1.7410714285714286, 'no_speech_prob': 0.005404097493737936}, {'id': 784, 'seek': 474024, 'start': 4752.639999999999, 'end': 4757.76, 'text': ' out and give that register to this location, right. So, that is essentially what you are going to do.', 'tokens': [50984, 484, 293, 976, 300, 7280, 281, 341, 4914, 11, 558, 13, 407, 11, 300, 307, 4476, 437, 291, 366, 516, 281, 360, 13, 51240], 'temperature': 0.0, 'avg_logprob': -0.07783014723595152, 'compression_ratio': 1.7410714285714286, 'no_speech_prob': 0.005404097493737936}, {'id': 785, 'seek': 474024, 'start': 4758.32, 'end': 4765.92, 'text': ' So, spill a register into memory and give that, ok. If none of this is true, then this particular', 'tokens': [51268, 407, 11, 22044, 257, 7280, 666, 4675, 293, 976, 300, 11, 3133, 13, 759, 6022, 295, 341, 307, 2074, 11, 550, 341, 1729, 51648], 'temperature': 0.0, 'avg_logprob': -0.07783014723595152, 'compression_ratio': 1.7410714285714286, 'no_speech_prob': 0.005404097493737936}, {'id': 786, 'seek': 476592, 'start': 4765.92, 'end': 4772.24, 'text': ' instruction can have a memory operand. So, you say that x is in memory, right. So, again let me', 'tokens': [50364, 10951, 393, 362, 257, 4675, 2208, 474, 13, 407, 11, 291, 584, 300, 2031, 307, 294, 4675, 11, 558, 13, 407, 11, 797, 718, 385, 50680], 'temperature': 0.0, 'avg_logprob': -0.052155827482541404, 'compression_ratio': 1.7333333333333334, 'no_speech_prob': 0.010148677974939346}, {'id': 787, 'seek': 476592, 'start': 4772.24, 'end': 4779.04, 'text': ' go through this one more time. So, you either find out if the first source operand is a register', 'tokens': [50680, 352, 807, 341, 472, 544, 565, 13, 407, 11, 291, 2139, 915, 484, 498, 264, 700, 4009, 2208, 474, 307, 257, 7280, 51020], 'temperature': 0.0, 'avg_logprob': -0.052155827482541404, 'compression_ratio': 1.7333333333333334, 'no_speech_prob': 0.010148677974939346}, {'id': 788, 'seek': 476592, 'start': 4779.84, 'end': 4787.04, 'text': ' and that register is no longer required for y, then you can use that itself as the location for', 'tokens': [51060, 293, 300, 7280, 307, 572, 2854, 4739, 337, 288, 11, 550, 291, 393, 764, 300, 2564, 382, 264, 4914, 337, 51420], 'temperature': 0.0, 'avg_logprob': -0.052155827482541404, 'compression_ratio': 1.7333333333333334, 'no_speech_prob': 0.010148677974939346}, {'id': 789, 'seek': 476592, 'start': 4787.04, 'end': 4792.24, 'text': ' x. If that is not the case, if there is a free register which is available,', 'tokens': [51420, 2031, 13, 759, 300, 307, 406, 264, 1389, 11, 498, 456, 307, 257, 1737, 7280, 597, 307, 2435, 11, 51680], 'temperature': 0.0, 'avg_logprob': -0.052155827482541404, 'compression_ratio': 1.7333333333333334, 'no_speech_prob': 0.010148677974939346}, {'id': 790, 'seek': 479224, 'start': 4792.8, 'end': 4797.92, 'text': ' then you can say that free register will hold that. If that is also not the case,', 'tokens': [50392, 550, 291, 393, 584, 300, 1737, 7280, 486, 1797, 300, 13, 759, 300, 307, 611, 406, 264, 1389, 11, 50648], 'temperature': 0.0, 'avg_logprob': -0.06978531593972064, 'compression_ratio': 1.8172588832487309, 'no_speech_prob': 0.011097163893282413}, {'id': 791, 'seek': 479224, 'start': 4798.8, 'end': 4805.04, 'text': ' but if your operand can be in memory, sorry, if your operand has to be in a register, then', 'tokens': [50692, 457, 498, 428, 2208, 474, 393, 312, 294, 4675, 11, 2597, 11, 498, 428, 2208, 474, 575, 281, 312, 294, 257, 7280, 11, 550, 51004], 'temperature': 0.0, 'avg_logprob': -0.06978531593972064, 'compression_ratio': 1.8172588832487309, 'no_speech_prob': 0.011097163893282413}, {'id': 792, 'seek': 479224, 'start': 4805.599999999999, 'end': 4810.719999999999, 'text': ' spill one of the existing variables which is in one of those registers and then give that register', 'tokens': [51032, 22044, 472, 295, 264, 6741, 9102, 597, 307, 294, 472, 295, 729, 38351, 293, 550, 976, 300, 7280, 51288], 'temperature': 0.0, 'avg_logprob': -0.06978531593972064, 'compression_ratio': 1.8172588832487309, 'no_speech_prob': 0.011097163893282413}, {'id': 793, 'seek': 479224, 'start': 4810.719999999999, 'end': 4818.8, 'text': ' to x. If none of this is the case, then you simply use a memory location for x, right.', 'tokens': [51288, 281, 2031, 13, 759, 6022, 295, 341, 307, 264, 1389, 11, 550, 291, 2935, 764, 257, 4675, 4914, 337, 2031, 11, 558, 13, 51692], 'temperature': 0.0, 'avg_logprob': -0.06978531593972064, 'compression_ratio': 1.8172588832487309, 'no_speech_prob': 0.011097163893282413}, {'id': 794, 'seek': 481880, 'start': 4818.8, 'end': 4830.08, 'text': ' Questions? The third one, ok. So, let us say that I have four registers and they are storing y, z,', 'tokens': [50364, 27738, 30, 440, 2636, 472, 11, 3133, 13, 407, 11, 718, 505, 584, 300, 286, 362, 1451, 38351, 293, 436, 366, 26085, 288, 11, 710, 11, 50928], 'temperature': 0.0, 'avg_logprob': -0.16825475190815173, 'compression_ratio': 1.5368421052631578, 'no_speech_prob': 0.004358705133199692}, {'id': 795, 'seek': 481880, 'start': 4830.72, 'end': 4841.12, 'text': ' w and v, right. But now this particular operation, right, the target machine specification says that', 'tokens': [50960, 261, 293, 371, 11, 558, 13, 583, 586, 341, 1729, 6916, 11, 558, 11, 264, 3779, 3479, 31256, 1619, 300, 51480], 'temperature': 0.0, 'avg_logprob': -0.16825475190815173, 'compression_ratio': 1.5368421052631578, 'no_speech_prob': 0.004358705133199692}, {'id': 796, 'seek': 481880, 'start': 4841.12, 'end': 4847.28, 'text': ' the destination has to be a register operand. It cannot be a memory operand, correct. Then I', 'tokens': [51480, 264, 12236, 575, 281, 312, 257, 7280, 2208, 474, 13, 467, 2644, 312, 257, 4675, 2208, 474, 11, 3006, 13, 1396, 286, 51788], 'temperature': 0.0, 'avg_logprob': -0.16825475190815173, 'compression_ratio': 1.5368421052631578, 'no_speech_prob': 0.004358705133199692}, {'id': 797, 'seek': 484728, 'start': 4847.28, 'end': 4853.84, 'text': ' cannot say that x can be in memory, x has to be in a register, right, as far as this operation is', 'tokens': [50364, 2644, 584, 300, 2031, 393, 312, 294, 4675, 11, 2031, 575, 281, 312, 294, 257, 7280, 11, 558, 11, 382, 1400, 382, 341, 6916, 307, 50692], 'temperature': 0.0, 'avg_logprob': -0.07571151677299948, 'compression_ratio': 1.7897196261682242, 'no_speech_prob': 0.0008715314324945211}, {'id': 798, 'seek': 484728, 'start': 4853.84, 'end': 4859.36, 'text': ' concerned. Let us say that this is some multiply operation or something like that, just as an', 'tokens': [50692, 5922, 13, 961, 505, 584, 300, 341, 307, 512, 12972, 6916, 420, 746, 411, 300, 11, 445, 382, 364, 50968], 'temperature': 0.0, 'avg_logprob': -0.07571151677299948, 'compression_ratio': 1.7897196261682242, 'no_speech_prob': 0.0008715314324945211}, {'id': 799, 'seek': 484728, 'start': 4859.36, 'end': 4865.36, 'text': ' example. So, multiply the destination has to be a register, it cannot be a memory operand, right.', 'tokens': [50968, 1365, 13, 407, 11, 12972, 264, 12236, 575, 281, 312, 257, 7280, 11, 309, 2644, 312, 257, 4675, 2208, 474, 11, 558, 13, 51268], 'temperature': 0.0, 'avg_logprob': -0.07571151677299948, 'compression_ratio': 1.7897196261682242, 'no_speech_prob': 0.0008715314324945211}, {'id': 800, 'seek': 484728, 'start': 4865.36, 'end': 4872.4, 'text': ' Then what I need to do is that, right, this x which is a temporary, I will say that it has to', 'tokens': [51268, 1396, 437, 286, 643, 281, 360, 307, 300, 11, 558, 11, 341, 2031, 597, 307, 257, 13413, 11, 286, 486, 584, 300, 309, 575, 281, 51620], 'temperature': 0.0, 'avg_logprob': -0.07571151677299948, 'compression_ratio': 1.7897196261682242, 'no_speech_prob': 0.0008715314324945211}, {'id': 801, 'seek': 487240, 'start': 4872.4, 'end': 4877.759999999999, 'text': ' be in one of the registers. I have only four registers and these four registers are being', 'tokens': [50364, 312, 294, 472, 295, 264, 38351, 13, 286, 362, 787, 1451, 38351, 293, 613, 1451, 38351, 366, 885, 50632], 'temperature': 0.0, 'avg_logprob': -0.06371750702729097, 'compression_ratio': 1.7302325581395348, 'no_speech_prob': 0.02889477089047432}, {'id': 802, 'seek': 487240, 'start': 4877.759999999999, 'end': 4887.44, 'text': ' taken by y, z, w and v. I do not have a place for x. What do you do? You ask one of these people,', 'tokens': [50632, 2726, 538, 288, 11, 710, 11, 261, 293, 371, 13, 286, 360, 406, 362, 257, 1081, 337, 2031, 13, 708, 360, 291, 360, 30, 509, 1029, 472, 295, 613, 561, 11, 51116], 'temperature': 0.0, 'avg_logprob': -0.06371750702729097, 'compression_ratio': 1.7302325581395348, 'no_speech_prob': 0.02889477089047432}, {'id': 803, 'seek': 487240, 'start': 4887.44, 'end': 4894.4, 'text': ' y, z or w, right, to get out and then give that register. That is what is called as spill.', 'tokens': [51116, 288, 11, 710, 420, 261, 11, 558, 11, 281, 483, 484, 293, 550, 976, 300, 7280, 13, 663, 307, 437, 307, 1219, 382, 22044, 13, 51464], 'temperature': 0.0, 'avg_logprob': -0.06371750702729097, 'compression_ratio': 1.7302325581395348, 'no_speech_prob': 0.02889477089047432}, {'id': 804, 'seek': 487240, 'start': 4894.96, 'end': 4902.16, 'text': ' So, let us say that we are going to say that, ok, w is the victim. So, I will spill the value', 'tokens': [51492, 407, 11, 718, 505, 584, 300, 321, 366, 516, 281, 584, 300, 11, 3133, 11, 261, 307, 264, 6760, 13, 407, 11, 286, 486, 22044, 264, 2158, 51852], 'temperature': 0.0, 'avg_logprob': -0.06371750702729097, 'compression_ratio': 1.7302325581395348, 'no_speech_prob': 0.02889477089047432}, {'id': 805, 'seek': 490216, 'start': 4902.16, 'end': 4909.04, 'text': ' of w into the memory location and whichever register w was holding, I will assign that to x,', 'tokens': [50364, 295, 261, 666, 264, 4675, 4914, 293, 24123, 7280, 261, 390, 5061, 11, 286, 486, 6269, 300, 281, 2031, 11, 50708], 'temperature': 0.0, 'avg_logprob': -0.20006887302842252, 'compression_ratio': 1.2936507936507937, 'no_speech_prob': 0.01896568387746811}, {'id': 806, 'seek': 490216, 'start': 4910.5599999999995, 'end': 4912.0, 'text': ' right. That is really what happens.', 'tokens': [50784, 558, 13, 663, 307, 534, 437, 2314, 13, 50856], 'temperature': 0.0, 'avg_logprob': -0.20006887302842252, 'compression_ratio': 1.2936507936507937, 'no_speech_prob': 0.01896568387746811}, {'id': 807, 'seek': 490216, 'start': 4917.04, 'end': 4920.0, 'text': ' There is no use of y subsequently.', 'tokens': [51108, 821, 307, 572, 764, 295, 288, 26514, 13, 51256], 'temperature': 0.0, 'avg_logprob': -0.20006887302842252, 'compression_ratio': 1.2936507936507937, 'no_speech_prob': 0.01896568387746811}, {'id': 808, 'seek': 493216, 'start': 4932.16, 'end': 4936.32, 'text': ' After this instruction, it is going to hold the value of x.', 'tokens': [50364, 2381, 341, 10951, 11, 309, 307, 516, 281, 1797, 264, 2158, 295, 2031, 13, 50572], 'temperature': 0.0, 'avg_logprob': -0.22184470604205953, 'compression_ratio': 1.525925925925926, 'no_speech_prob': 0.0734415277838707}, {'id': 809, 'seek': 493216, 'start': 4938.88, 'end': 4945.44, 'text': ' Absolutely. It is not holding the address, it is holding the value of y, value of y, ok.', 'tokens': [50700, 7021, 13, 467, 307, 406, 5061, 264, 2985, 11, 309, 307, 5061, 264, 2158, 295, 288, 11, 2158, 295, 288, 11, 3133, 13, 51028], 'temperature': 0.0, 'avg_logprob': -0.22184470604205953, 'compression_ratio': 1.525925925925926, 'no_speech_prob': 0.0734415277838707}, {'id': 810, 'seek': 493216, 'start': 4953.92, 'end': 4958.639999999999, 'text': ' All the four registers might be, will be used later also.', 'tokens': [51452, 1057, 264, 1451, 38351, 1062, 312, 11, 486, 312, 1143, 1780, 611, 13, 51688], 'temperature': 0.0, 'avg_logprob': -0.22184470604205953, 'compression_ratio': 1.525925925925926, 'no_speech_prob': 0.0734415277838707}, {'id': 811, 'seek': 495864, 'start': 4958.64, 'end': 4964.96, 'text': ' So, let us say that here I have spilled w and give that register to.', 'tokens': [50364, 407, 11, 718, 505, 584, 300, 510, 286, 362, 37833, 261, 293, 976, 300, 7280, 281, 13, 50680], 'temperature': 0.0, 'avg_logprob': -0.20355963706970215, 'compression_ratio': 1.6476683937823835, 'no_speech_prob': 0.004233029671013355}, {'id': 812, 'seek': 495864, 'start': 4969.68, 'end': 4976.88, 'text': ' No, in this instruction there are going to be only two operands, correct. Remember,', 'tokens': [50916, 883, 11, 294, 341, 10951, 456, 366, 516, 281, 312, 787, 732, 2208, 2967, 11, 3006, 13, 5459, 11, 51276], 'temperature': 0.0, 'avg_logprob': -0.20355963706970215, 'compression_ratio': 1.6476683937823835, 'no_speech_prob': 0.004233029671013355}, {'id': 813, 'seek': 495864, 'start': 4976.88, 'end': 4980.320000000001, 'text': ' this simple code, this, remember, remember this is a simple code generation.', 'tokens': [51276, 341, 2199, 3089, 11, 341, 11, 1604, 11, 1604, 341, 307, 257, 2199, 3089, 5125, 13, 51448], 'temperature': 0.0, 'avg_logprob': -0.20355963706970215, 'compression_ratio': 1.6476683937823835, 'no_speech_prob': 0.004233029671013355}, {'id': 814, 'seek': 495864, 'start': 4981.200000000001, 'end': 4987.6, 'text': ' We do code generation for one intermediate statement at a point in time. It has only two', 'tokens': [51492, 492, 360, 3089, 5125, 337, 472, 19376, 5629, 412, 257, 935, 294, 565, 13, 467, 575, 787, 732, 51812], 'temperature': 0.0, 'avg_logprob': -0.20355963706970215, 'compression_ratio': 1.6476683937823835, 'no_speech_prob': 0.004233029671013355}, {'id': 815, 'seek': 498760, 'start': 4987.6, 'end': 4993.52, 'text': ' operands. I have to have y definitely in the register or I have to, means I have to have x', 'tokens': [50364, 2208, 2967, 13, 286, 362, 281, 362, 288, 2138, 294, 264, 7280, 420, 286, 362, 281, 11, 1355, 286, 362, 281, 362, 2031, 50660], 'temperature': 0.0, 'avg_logprob': -0.08366221005154639, 'compression_ratio': 1.8151658767772512, 'no_speech_prob': 0.0028445071075111628}, {'id': 816, 'seek': 498760, 'start': 4993.52, 'end': 4998.88, 'text': ' in the register. So, eventually I am going to move y into that register and do something, correct.', 'tokens': [50660, 294, 264, 7280, 13, 407, 11, 4728, 286, 669, 516, 281, 1286, 288, 666, 300, 7280, 293, 360, 746, 11, 3006, 13, 50928], 'temperature': 0.0, 'avg_logprob': -0.08366221005154639, 'compression_ratio': 1.8151658767772512, 'no_speech_prob': 0.0028445071075111628}, {'id': 817, 'seek': 498760, 'start': 4998.88, 'end': 5004.400000000001, 'text': ' But that is ok. Other than that, right, if there is a variable w which is holding a register,', 'tokens': [50928, 583, 300, 307, 3133, 13, 5358, 813, 300, 11, 558, 11, 498, 456, 307, 257, 7006, 261, 597, 307, 5061, 257, 7280, 11, 51204], 'temperature': 0.0, 'avg_logprob': -0.08366221005154639, 'compression_ratio': 1.8151658767772512, 'no_speech_prob': 0.0028445071075111628}, {'id': 818, 'seek': 498760, 'start': 5005.04, 'end': 5011.52, 'text': ' which is not needed for this instruction, right, my immediate point is to get this instruction done', 'tokens': [51236, 597, 307, 406, 2978, 337, 341, 10951, 11, 558, 11, 452, 11629, 935, 307, 281, 483, 341, 10951, 1096, 51560], 'temperature': 0.0, 'avg_logprob': -0.08366221005154639, 'compression_ratio': 1.8151658767772512, 'no_speech_prob': 0.0028445071075111628}, {'id': 819, 'seek': 501152, 'start': 5012.240000000001, 'end': 5018.4800000000005, 'text': ' and in order for me to do that, I will spill w. It may so be the case that the next instruction', 'tokens': [50400, 293, 294, 1668, 337, 385, 281, 360, 300, 11, 286, 486, 22044, 261, 13, 467, 815, 370, 312, 264, 1389, 300, 264, 958, 10951, 50712], 'temperature': 0.0, 'avg_logprob': -0.07430373367510344, 'compression_ratio': 1.598901098901099, 'no_speech_prob': 0.01524968072772026}, {'id': 820, 'seek': 501152, 'start': 5018.4800000000005, 'end': 5028.320000000001, 'text': ' is w, correct, and I want to reload it into the register. I will incur the cost. That is why this', 'tokens': [50712, 307, 261, 11, 3006, 11, 293, 286, 528, 281, 25628, 309, 666, 264, 7280, 13, 286, 486, 35774, 264, 2063, 13, 663, 307, 983, 341, 51204], 'temperature': 0.0, 'avg_logprob': -0.07430373367510344, 'compression_ratio': 1.598901098901099, 'no_speech_prob': 0.01524968072772026}, {'id': 821, 'seek': 501152, 'start': 5028.320000000001, 'end': 5035.68, 'text': ' is called a simple code generator and that is why it generates inefficient code. It does not look', 'tokens': [51204, 307, 1219, 257, 2199, 3089, 19265, 293, 300, 307, 983, 309, 23815, 43495, 3089, 13, 467, 775, 406, 574, 51572], 'temperature': 0.0, 'avg_logprob': -0.07430373367510344, 'compression_ratio': 1.598901098901099, 'no_speech_prob': 0.01524968072772026}, {'id': 822, 'seek': 503568, 'start': 5035.68, 'end': 5043.6, 'text': ' beyond how it takes a decision of what to spill, right. We have not really said it could spill any', 'tokens': [50364, 4399, 577, 309, 2516, 257, 3537, 295, 437, 281, 22044, 11, 558, 13, 492, 362, 406, 534, 848, 309, 727, 22044, 604, 50760], 'temperature': 0.0, 'avg_logprob': -0.11878441120016164, 'compression_ratio': 1.596244131455399, 'no_speech_prob': 0.025573786348104477}, {'id': 823, 'seek': 503568, 'start': 5043.6, 'end': 5049.200000000001, 'text': ' one of those things arbitrarily and that might be required immediately after that, right. So,', 'tokens': [50760, 472, 295, 729, 721, 19071, 3289, 293, 300, 1062, 312, 4739, 4258, 934, 300, 11, 558, 13, 407, 11, 51040], 'temperature': 0.0, 'avg_logprob': -0.11878441120016164, 'compression_ratio': 1.596244131455399, 'no_speech_prob': 0.025573786348104477}, {'id': 824, 'seek': 503568, 'start': 5049.200000000001, 'end': 5056.0, 'text': ' you will incur a cost for that, no doubt, but you can generate code. Functionally,', 'tokens': [51040, 291, 486, 35774, 257, 2063, 337, 300, 11, 572, 6385, 11, 457, 291, 393, 8460, 3089, 13, 11166, 882, 379, 11, 51380], 'temperature': 0.0, 'avg_logprob': -0.11878441120016164, 'compression_ratio': 1.596244131455399, 'no_speech_prob': 0.025573786348104477}, {'id': 825, 'seek': 503568, 'start': 5056.0, 'end': 5059.52, 'text': ' correct code, it will execute, but it may be inefficient, right.', 'tokens': [51380, 3006, 3089, 11, 309, 486, 14483, 11, 457, 309, 815, 312, 43495, 11, 558, 13, 51556], 'temperature': 0.0, 'avg_logprob': -0.11878441120016164, 'compression_ratio': 1.596244131455399, 'no_speech_prob': 0.025573786348104477}, {'id': 826, 'seek': 505952, 'start': 5059.52, 'end': 5072.160000000001, 'text': ' Yes, yes, if I have only two registers, what will I do? That is an architecture which may not be', 'tokens': [50364, 1079, 11, 2086, 11, 498, 286, 362, 787, 732, 38351, 11, 437, 486, 286, 360, 30, 663, 307, 364, 9482, 597, 815, 406, 312, 50996], 'temperature': 0.0, 'avg_logprob': -0.09347354888916015, 'compression_ratio': 1.7079646017699115, 'no_speech_prob': 0.029308302327990532}, {'id': 827, 'seek': 505952, 'start': 5072.160000000001, 'end': 5077.92, 'text': ' a useful architecture, right. So, you will have enough registers to work with, but all of them may', 'tokens': [50996, 257, 4420, 9482, 11, 558, 13, 407, 11, 291, 486, 362, 1547, 38351, 281, 589, 365, 11, 457, 439, 295, 552, 815, 51284], 'temperature': 0.0, 'avg_logprob': -0.09347354888916015, 'compression_ratio': 1.7079646017699115, 'no_speech_prob': 0.029308302327990532}, {'id': 828, 'seek': 505952, 'start': 5077.92, 'end': 5083.84, 'text': ' have some values. Then you have to take a decision of which one to spill. It may so happen that the', 'tokens': [51284, 362, 512, 4190, 13, 1396, 291, 362, 281, 747, 257, 3537, 295, 597, 472, 281, 22044, 13, 467, 815, 370, 1051, 300, 264, 51580], 'temperature': 0.0, 'avg_logprob': -0.09347354888916015, 'compression_ratio': 1.7079646017699115, 'no_speech_prob': 0.029308302327990532}, {'id': 829, 'seek': 505952, 'start': 5083.84, 'end': 5088.320000000001, 'text': ' one that you have spilled may have to be reloaded again. There is a cost that you pay for.', 'tokens': [51580, 472, 300, 291, 362, 37833, 815, 362, 281, 312, 25628, 292, 797, 13, 821, 307, 257, 2063, 300, 291, 1689, 337, 13, 51804], 'temperature': 0.0, 'avg_logprob': -0.09347354888916015, 'compression_ratio': 1.7079646017699115, 'no_speech_prob': 0.029308302327990532}, {'id': 830, 'seek': 508952, 'start': 5089.6, 'end': 5092.56, 'text': ' Right. That is really what happened. Any more questions? Yeah.', 'tokens': [50368, 1779, 13, 663, 307, 534, 437, 2011, 13, 2639, 544, 1651, 30, 865, 13, 50516], 'temperature': 0.0, 'avg_logprob': -0.12902185776654412, 'compression_ratio': 1.5534883720930233, 'no_speech_prob': 0.009735019877552986}, {'id': 831, 'seek': 508952, 'start': 5098.96, 'end': 5105.040000000001, 'text': ' Okay. So, this has to go a little bit more into the details of how this intermediate code is,', 'tokens': [50836, 1033, 13, 407, 11, 341, 575, 281, 352, 257, 707, 857, 544, 666, 264, 4365, 295, 577, 341, 19376, 3089, 307, 11, 51140], 'temperature': 0.0, 'avg_logprob': -0.12902185776654412, 'compression_ratio': 1.5534883720930233, 'no_speech_prob': 0.009735019877552986}, {'id': 832, 'seek': 508952, 'start': 5105.040000000001, 'end': 5110.8, 'text': ' what these temporaries are. The assumption here is that this is a new temporary which is being', 'tokens': [51140, 437, 613, 8219, 4889, 366, 13, 440, 15302, 510, 307, 300, 341, 307, 257, 777, 13413, 597, 307, 885, 51428], 'temperature': 0.0, 'avg_logprob': -0.12902185776654412, 'compression_ratio': 1.5534883720930233, 'no_speech_prob': 0.009735019877552986}, {'id': 833, 'seek': 508952, 'start': 5110.8, 'end': 5115.280000000001, 'text': ' generated. That is why you try to find a location. If it is already in a register,', 'tokens': [51428, 10833, 13, 663, 307, 983, 291, 853, 281, 915, 257, 4914, 13, 759, 309, 307, 1217, 294, 257, 7280, 11, 51652], 'temperature': 0.0, 'avg_logprob': -0.12902185776654412, 'compression_ratio': 1.5534883720930233, 'no_speech_prob': 0.009735019877552986}, {'id': 834, 'seek': 511528, 'start': 5115.28, 'end': 5120.639999999999, 'text': ' you can definitely use that. Okay. You just modify this slightly so that that is taken into', 'tokens': [50364, 291, 393, 2138, 764, 300, 13, 1033, 13, 509, 445, 16927, 341, 4748, 370, 300, 300, 307, 2726, 666, 50632], 'temperature': 0.0, 'avg_logprob': -0.18197267055511473, 'compression_ratio': 1.5660377358490567, 'no_speech_prob': 0.02586355060338974}, {'id': 835, 'seek': 511528, 'start': 5120.639999999999, 'end': 5124.48, 'text': ' account. This is assuming that this is a newly generated value, right.', 'tokens': [50632, 2696, 13, 639, 307, 11926, 300, 341, 307, 257, 15109, 10833, 2158, 11, 558, 13, 50824], 'temperature': 0.0, 'avg_logprob': -0.18197267055511473, 'compression_ratio': 1.5660377358490567, 'no_speech_prob': 0.02586355060338974}, {'id': 836, 'seek': 511528, 'start': 5124.48, 'end': 5136.639999999999, 'text': ' Which register to spill is it? Okay. We are going to talk about separate,', 'tokens': [50824, 3013, 7280, 281, 22044, 307, 309, 30, 1033, 13, 492, 366, 516, 281, 751, 466, 4994, 11, 51432], 'temperature': 0.0, 'avg_logprob': -0.18197267055511473, 'compression_ratio': 1.5660377358490567, 'no_speech_prob': 0.02586355060338974}, {'id': 837, 'seek': 511528, 'start': 5137.36, 'end': 5142.32, 'text': ' as far as this simple code generation scheme is concerned, nobody is using it or nobody will be', 'tokens': [51468, 382, 1400, 382, 341, 2199, 3089, 5125, 12232, 307, 5922, 11, 5079, 307, 1228, 309, 420, 5079, 486, 312, 51716], 'temperature': 0.0, 'avg_logprob': -0.18197267055511473, 'compression_ratio': 1.5660377358490567, 'no_speech_prob': 0.02586355060338974}, {'id': 838, 'seek': 514232, 'start': 5142.32, 'end': 5148.96, 'text': ' using it. So, the answer is very simple. Use anything that you want, okay, randomly. But,', 'tokens': [50364, 1228, 309, 13, 407, 11, 264, 1867, 307, 588, 2199, 13, 8278, 1340, 300, 291, 528, 11, 1392, 11, 16979, 13, 583, 11, 50696], 'temperature': 0.0, 'avg_logprob': -0.12245659992612641, 'compression_ratio': 1.749063670411985, 'no_speech_prob': 0.012055877596139908}, {'id': 839, 'seek': 514232, 'start': 5150.0, 'end': 5154.639999999999, 'text': ' yeah, it is going to be inefficient. You could do something smarter. Like you could look ahead', 'tokens': [50748, 1338, 11, 309, 307, 516, 281, 312, 43495, 13, 509, 727, 360, 746, 20294, 13, 1743, 291, 727, 574, 2286, 50980], 'temperature': 0.0, 'avg_logprob': -0.12245659992612641, 'compression_ratio': 1.749063670411985, 'no_speech_prob': 0.012055877596139908}, {'id': 840, 'seek': 514232, 'start': 5154.639999999999, 'end': 5158.799999999999, 'text': ' and then see which variable you are not going to use for a longer time, etcetera, etcetera,', 'tokens': [50980, 293, 550, 536, 597, 7006, 291, 366, 406, 516, 281, 764, 337, 257, 2854, 565, 11, 22066, 11, 22066, 11, 51188], 'temperature': 0.0, 'avg_logprob': -0.12245659992612641, 'compression_ratio': 1.749063670411985, 'no_speech_prob': 0.012055877596139908}, {'id': 841, 'seek': 514232, 'start': 5158.799999999999, 'end': 5163.92, 'text': ' and you can make your decision smarter. But then this mechanism itself, this way of generating', 'tokens': [51188, 293, 291, 393, 652, 428, 3537, 20294, 13, 583, 550, 341, 7513, 2564, 11, 341, 636, 295, 17746, 51444], 'temperature': 0.0, 'avg_logprob': -0.12245659992612641, 'compression_ratio': 1.749063670411985, 'no_speech_prob': 0.012055877596139908}, {'id': 842, 'seek': 514232, 'start': 5163.92, 'end': 5169.44, 'text': ' code itself is so inefficient that you do not want to fix some part of it. So, let us not worry', 'tokens': [51444, 3089, 2564, 307, 370, 43495, 300, 291, 360, 406, 528, 281, 3191, 512, 644, 295, 309, 13, 407, 11, 718, 505, 406, 3292, 51720], 'temperature': 0.0, 'avg_logprob': -0.12245659992612641, 'compression_ratio': 1.749063670411985, 'no_speech_prob': 0.012055877596139908}, {'id': 843, 'seek': 516944, 'start': 5169.44, 'end': 5174.32, 'text': ' about it, right. Let it do something very, very inefficient. It is okay. It only adds to our', 'tokens': [50364, 466, 309, 11, 558, 13, 961, 309, 360, 746, 588, 11, 588, 43495, 13, 467, 307, 1392, 13, 467, 787, 10860, 281, 527, 50608], 'temperature': 0.0, 'avg_logprob': -0.08246702111285666, 'compression_ratio': 1.7116788321167884, 'no_speech_prob': 0.06654789298772812}, {'id': 844, 'seek': 516944, 'start': 5174.32, 'end': 5180.4, 'text': ' motivation that we have to build a more efficient code generator, right. Good. But I think the', 'tokens': [50608, 12335, 300, 321, 362, 281, 1322, 257, 544, 7148, 3089, 19265, 11, 558, 13, 2205, 13, 583, 286, 519, 264, 50912], 'temperature': 0.0, 'avg_logprob': -0.08246702111285666, 'compression_ratio': 1.7116788321167884, 'no_speech_prob': 0.06654789298772812}, {'id': 845, 'seek': 516944, 'start': 5180.4, 'end': 5184.879999999999, 'text': ' points are very well taken and your answers and as well as questions are indeed in the right', 'tokens': [50912, 2793, 366, 588, 731, 2726, 293, 428, 6338, 293, 382, 731, 382, 1651, 366, 6451, 294, 264, 558, 51136], 'temperature': 0.0, 'avg_logprob': -0.08246702111285666, 'compression_ratio': 1.7116788321167884, 'no_speech_prob': 0.06654789298772812}, {'id': 846, 'seek': 516944, 'start': 5184.879999999999, 'end': 5189.2, 'text': ' direction. That tells you how to think about writing a good code generator. That is really', 'tokens': [51136, 3513, 13, 663, 5112, 291, 577, 281, 519, 466, 3579, 257, 665, 3089, 19265, 13, 663, 307, 534, 51352], 'temperature': 0.0, 'avg_logprob': -0.08246702111285666, 'compression_ratio': 1.7116788321167884, 'no_speech_prob': 0.06654789298772812}, {'id': 847, 'seek': 516944, 'start': 5189.2, 'end': 5194.24, 'text': ' what is important, right. If I ask you, okay, can you make it better? You would obviously make it', 'tokens': [51352, 437, 307, 1021, 11, 558, 13, 759, 286, 1029, 291, 11, 1392, 11, 393, 291, 652, 309, 1101, 30, 509, 576, 2745, 652, 309, 51604], 'temperature': 0.0, 'avg_logprob': -0.08246702111285666, 'compression_ratio': 1.7116788321167884, 'no_speech_prob': 0.06654789298772812}, {'id': 848, 'seek': 519424, 'start': 5194.24, 'end': 5200.48, 'text': ' better. But then for what purpose, I do not know, right, because this whole process itself is very', 'tokens': [50364, 1101, 13, 583, 550, 337, 437, 4334, 11, 286, 360, 406, 458, 11, 558, 11, 570, 341, 1379, 1399, 2564, 307, 588, 50676], 'temperature': 0.0, 'avg_logprob': -0.10348828364226778, 'compression_ratio': 1.6736842105263159, 'no_speech_prob': 0.040482036769390106}, {'id': 849, 'seek': 519424, 'start': 5200.48, 'end': 5204.8, 'text': ' inefficient. We are going to see something significantly better than this. Please stay', 'tokens': [50676, 43495, 13, 492, 366, 516, 281, 536, 746, 10591, 1101, 813, 341, 13, 2555, 1754, 50892], 'temperature': 0.0, 'avg_logprob': -0.10348828364226778, 'compression_ratio': 1.6736842105263159, 'no_speech_prob': 0.040482036769390106}, {'id': 850, 'seek': 519424, 'start': 5204.8, 'end': 5208.4, 'text': ' with me for some time. Just wanted to get the concepts through. That is why I am just saying', 'tokens': [50892, 365, 385, 337, 512, 565, 13, 1449, 1415, 281, 483, 264, 10392, 807, 13, 663, 307, 983, 286, 669, 445, 1566, 51072], 'temperature': 0.0, 'avg_logprob': -0.10348828364226778, 'compression_ratio': 1.6736842105263159, 'no_speech_prob': 0.040482036769390106}, {'id': 851, 'seek': 519424, 'start': 5209.04, 'end': 5214.24, 'text': ' this, okay. So, here is an example that we are going to see, right. So, we have these variables', 'tokens': [51104, 341, 11, 1392, 13, 407, 11, 510, 307, 364, 1365, 300, 321, 366, 516, 281, 536, 11, 558, 13, 407, 11, 321, 362, 613, 9102, 51364], 'temperature': 0.0, 'avg_logprob': -0.10348828364226778, 'compression_ratio': 1.6736842105263159, 'no_speech_prob': 0.040482036769390106}, {'id': 852, 'seek': 519424, 'start': 5214.24, 'end': 5222.4, 'text': ' t, u, v and w which are being generated and they are basically these things, right, these expressions.', 'tokens': [51364, 256, 11, 344, 11, 371, 293, 261, 597, 366, 885, 10833, 293, 436, 366, 1936, 613, 721, 11, 558, 11, 613, 15277, 13, 51772], 'temperature': 0.0, 'avg_logprob': -0.10348828364226778, 'compression_ratio': 1.6736842105263159, 'no_speech_prob': 0.040482036769390106}, {'id': 853, 'seek': 522240, 'start': 5223.28, 'end': 5228.879999999999, 'text': ' So, what I do is that I take each statement and try to generate code for that statement.', 'tokens': [50408, 407, 11, 437, 286, 360, 307, 300, 286, 747, 1184, 5629, 293, 853, 281, 8460, 3089, 337, 300, 5629, 13, 50688], 'temperature': 0.0, 'avg_logprob': -0.09158128240834111, 'compression_ratio': 1.8383838383838385, 'no_speech_prob': 0.00317579647526145}, {'id': 854, 'seek': 522240, 'start': 5229.679999999999, 'end': 5234.32, 'text': ' Taking into account whatever is the current registered descriptor and address descriptor', 'tokens': [50728, 17837, 666, 2696, 2035, 307, 264, 2190, 13968, 31280, 284, 293, 2985, 31280, 284, 50960], 'temperature': 0.0, 'avg_logprob': -0.09158128240834111, 'compression_ratio': 1.8383838383838385, 'no_speech_prob': 0.00317579647526145}, {'id': 855, 'seek': 522240, 'start': 5234.32, 'end': 5241.12, 'text': ' at that point in time, right. So, let us say that at this point in time r naught has t,', 'tokens': [50960, 412, 300, 935, 294, 565, 11, 558, 13, 407, 11, 718, 505, 584, 300, 412, 341, 935, 294, 565, 367, 13138, 575, 256, 11, 51300], 'temperature': 0.0, 'avg_logprob': -0.09158128240834111, 'compression_ratio': 1.8383838383838385, 'no_speech_prob': 0.00317579647526145}, {'id': 856, 'seek': 522240, 'start': 5242.16, 'end': 5248.4, 'text': ' right. So, let us say initially nothing was there in my data structures. So, now what I do is that', 'tokens': [51352, 558, 13, 407, 11, 718, 505, 584, 9105, 1825, 390, 456, 294, 452, 1412, 9227, 13, 407, 11, 586, 437, 286, 360, 307, 300, 51664], 'temperature': 0.0, 'avg_logprob': -0.09158128240834111, 'compression_ratio': 1.8383838383838385, 'no_speech_prob': 0.00317579647526145}, {'id': 857, 'seek': 524840, 'start': 5248.4, 'end': 5256.4, 'text': ' I move first a to r naught and I subtract b from r naught and therefore, r naught will contain the', 'tokens': [50364, 286, 1286, 700, 257, 281, 367, 13138, 293, 286, 16390, 272, 490, 367, 13138, 293, 4412, 11, 367, 13138, 486, 5304, 264, 50764], 'temperature': 0.0, 'avg_logprob': -0.08986391740686753, 'compression_ratio': 1.8990384615384615, 'no_speech_prob': 0.0030366976279765368}, {'id': 858, 'seek': 524840, 'start': 5256.4, 'end': 5262.799999999999, 'text': ' value of a minus b which is my t. So, in this instruction, when I am generating code for this', 'tokens': [50764, 2158, 295, 257, 3175, 272, 597, 307, 452, 256, 13, 407, 11, 294, 341, 10951, 11, 562, 286, 669, 17746, 3089, 337, 341, 51084], 'temperature': 0.0, 'avg_logprob': -0.08986391740686753, 'compression_ratio': 1.8990384615384615, 'no_speech_prob': 0.0030366976279765368}, {'id': 859, 'seek': 524840, 'start': 5262.799999999999, 'end': 5270.32, 'text': ' instruction, for this destination location t, when I ask to get register, I assume that it gave me', 'tokens': [51084, 10951, 11, 337, 341, 12236, 4914, 256, 11, 562, 286, 1029, 281, 483, 7280, 11, 286, 6552, 300, 309, 2729, 385, 51460], 'temperature': 0.0, 'avg_logprob': -0.08986391740686753, 'compression_ratio': 1.8990384615384615, 'no_speech_prob': 0.0030366976279765368}, {'id': 860, 'seek': 524840, 'start': 5270.32, 'end': 5277.44, 'text': ' r naught, right. Therefore, my first code is move b to r naught and then subtract, I move a to r naught', 'tokens': [51460, 367, 13138, 11, 558, 13, 7504, 11, 452, 700, 3089, 307, 1286, 272, 281, 367, 13138, 293, 550, 16390, 11, 286, 1286, 257, 281, 367, 13138, 51816], 'temperature': 0.0, 'avg_logprob': -0.08986391740686753, 'compression_ratio': 1.8990384615384615, 'no_speech_prob': 0.0030366976279765368}, {'id': 861, 'seek': 527744, 'start': 5277.44, 'end': 5283.04, 'text': ' and then subtract b from r naught and then store it into, I mean that essentially puts the value', 'tokens': [50364, 293, 550, 16390, 272, 490, 367, 13138, 293, 550, 3531, 309, 666, 11, 286, 914, 300, 4476, 8137, 264, 2158, 50644], 'temperature': 0.0, 'avg_logprob': -0.11136492942143413, 'compression_ratio': 1.7685185185185186, 'no_speech_prob': 0.0007669822662137449}, {'id': 862, 'seek': 527744, 'start': 5283.599999999999, 'end': 5291.28, 'text': ' a minus b in r naught, ok. So, after this instruction is over, I know that r naught has', 'tokens': [50672, 257, 3175, 272, 294, 367, 13138, 11, 3133, 13, 407, 11, 934, 341, 10951, 307, 670, 11, 286, 458, 300, 367, 13138, 575, 51056], 'temperature': 0.0, 'avg_logprob': -0.11136492942143413, 'compression_ratio': 1.7685185185185186, 'no_speech_prob': 0.0007669822662137449}, {'id': 863, 'seek': 527744, 'start': 5291.28, 'end': 5298.799999999999, 'text': ' t, right and that is of course, the same thing t is in r naught, right. Now, when I go to the next', 'tokens': [51056, 256, 11, 558, 293, 300, 307, 295, 1164, 11, 264, 912, 551, 256, 307, 294, 367, 13138, 11, 558, 13, 823, 11, 562, 286, 352, 281, 264, 958, 51432], 'temperature': 0.0, 'avg_logprob': -0.11136492942143413, 'compression_ratio': 1.7685185185185186, 'no_speech_prob': 0.0007669822662137449}, {'id': 864, 'seek': 527744, 'start': 5298.799999999999, 'end': 5305.919999999999, 'text': ' instruction u, I am again asking the question give me a location for u, right and this time let us', 'tokens': [51432, 10951, 344, 11, 286, 669, 797, 3365, 264, 1168, 976, 385, 257, 4914, 337, 344, 11, 558, 293, 341, 565, 718, 505, 51788], 'temperature': 0.0, 'avg_logprob': -0.11136492942143413, 'compression_ratio': 1.7685185185185186, 'no_speech_prob': 0.0007669822662137449}, {'id': 865, 'seek': 530592, 'start': 5305.92, 'end': 5316.0, 'text': ' say it gave r 1, right. Now, I generate the code move a to r 1, subtract c from r 1, the result is', 'tokens': [50364, 584, 309, 2729, 367, 502, 11, 558, 13, 823, 11, 286, 8460, 264, 3089, 1286, 257, 281, 367, 502, 11, 16390, 269, 490, 367, 502, 11, 264, 1874, 307, 50868], 'temperature': 0.0, 'avg_logprob': -0.06920228465910881, 'compression_ratio': 1.6179775280898876, 'no_speech_prob': 0.0010716186370700598}, {'id': 866, 'seek': 530592, 'start': 5316.0, 'end': 5323.4400000000005, 'text': ' in r 1. Now, we can say that r naught has t and r 1 has u, the same thing in the address descriptor,', 'tokens': [50868, 294, 367, 502, 13, 823, 11, 321, 393, 584, 300, 367, 13138, 575, 256, 293, 367, 502, 575, 344, 11, 264, 912, 551, 294, 264, 2985, 31280, 284, 11, 51240], 'temperature': 0.0, 'avg_logprob': -0.06920228465910881, 'compression_ratio': 1.6179775280898876, 'no_speech_prob': 0.0010716186370700598}, {'id': 867, 'seek': 530592, 'start': 5323.4400000000005, 'end': 5329.52, 'text': ' put the other way around, right, t in r 1 and this one. Now, let us say v is equal to u,', 'tokens': [51240, 829, 264, 661, 636, 926, 11, 558, 11, 256, 294, 367, 502, 293, 341, 472, 13, 823, 11, 718, 505, 584, 371, 307, 2681, 281, 344, 11, 51544], 'temperature': 0.0, 'avg_logprob': -0.06920228465910881, 'compression_ratio': 1.6179775280898876, 'no_speech_prob': 0.0010716186370700598}, {'id': 868, 'seek': 532952, 'start': 5330.320000000001, 'end': 5337.200000000001, 'text': ' this is a copy operation, right. Now, in this case, I do not necessarily need to generate any code for', 'tokens': [50404, 341, 307, 257, 5055, 6916, 11, 558, 13, 823, 11, 294, 341, 1389, 11, 286, 360, 406, 4725, 643, 281, 8460, 604, 3089, 337, 50748], 'temperature': 0.0, 'avg_logprob': -0.10160777080489929, 'compression_ratio': 1.72, 'no_speech_prob': 0.004609546158462763}, {'id': 869, 'seek': 532952, 'start': 5337.200000000001, 'end': 5346.88, 'text': ' this, right. I find out what is u, u is in r 1, correct, it is a copy operation and for the copy', 'tokens': [50748, 341, 11, 558, 13, 286, 915, 484, 437, 307, 344, 11, 344, 307, 294, 367, 502, 11, 3006, 11, 309, 307, 257, 5055, 6916, 293, 337, 264, 5055, 51232], 'temperature': 0.0, 'avg_logprob': -0.10160777080489929, 'compression_ratio': 1.72, 'no_speech_prob': 0.004609546158462763}, {'id': 870, 'seek': 532952, 'start': 5346.88, 'end': 5353.040000000001, 'text': ' operation, I can simply say if this is already in a location, this will also be in the same location,', 'tokens': [51232, 6916, 11, 286, 393, 2935, 584, 498, 341, 307, 1217, 294, 257, 4914, 11, 341, 486, 611, 312, 294, 264, 912, 4914, 11, 51540], 'temperature': 0.0, 'avg_logprob': -0.10160777080489929, 'compression_ratio': 1.72, 'no_speech_prob': 0.004609546158462763}, {'id': 871, 'seek': 535304, 'start': 5353.04, 'end': 5361.84, 'text': ' right. So, after this we say that r naught has t and r 1 has both u and v, same thing over here.', 'tokens': [50364, 558, 13, 407, 11, 934, 341, 321, 584, 300, 367, 13138, 575, 256, 293, 367, 502, 575, 1293, 344, 293, 371, 11, 912, 551, 670, 510, 13, 50804], 'temperature': 0.0, 'avg_logprob': -0.091447205013699, 'compression_ratio': 1.6089385474860336, 'no_speech_prob': 0.006447736639529467}, {'id': 872, 'seek': 535304, 'start': 5361.84, 'end': 5368.48, 'text': ' Now, let us see here, here I am going to do t plus v, right and I am going to write it into w,', 'tokens': [50804, 823, 11, 718, 505, 536, 510, 11, 510, 286, 669, 516, 281, 360, 256, 1804, 371, 11, 558, 293, 286, 669, 516, 281, 2464, 309, 666, 261, 11, 51136], 'temperature': 0.0, 'avg_logprob': -0.091447205013699, 'compression_ratio': 1.6089385474860336, 'no_speech_prob': 0.006447736639529467}, {'id': 873, 'seek': 535304, 'start': 5369.44, 'end': 5376.8, 'text': ' right. Again, when I try to say get register for w, it gave me r 2, right and I find out where t', 'tokens': [51184, 558, 13, 3764, 11, 562, 286, 853, 281, 584, 483, 7280, 337, 261, 11, 309, 2729, 385, 367, 568, 11, 558, 293, 286, 915, 484, 689, 256, 51552], 'temperature': 0.0, 'avg_logprob': -0.091447205013699, 'compression_ratio': 1.6089385474860336, 'no_speech_prob': 0.006447736639529467}, {'id': 874, 'seek': 537680, 'start': 5376.8, 'end': 5384.8, 'text': ' is in r naught. So, I move r naught to r 2 and then of course, find out where v is, v is in r 1.', 'tokens': [50364, 307, 294, 367, 13138, 13, 407, 11, 286, 1286, 367, 13138, 281, 367, 568, 293, 550, 295, 1164, 11, 915, 484, 689, 371, 307, 11, 371, 307, 294, 367, 502, 13, 50764], 'temperature': 0.0, 'avg_logprob': -0.11052330771645347, 'compression_ratio': 1.6470588235294117, 'no_speech_prob': 0.011878502555191517}, {'id': 875, 'seek': 537680, 'start': 5384.8, 'end': 5392.64, 'text': ' So, I add r 1 to r 2, right. So, at the end of this r naught has t, r 1 has both u, v', 'tokens': [50764, 407, 11, 286, 909, 367, 502, 281, 367, 568, 11, 558, 13, 407, 11, 412, 264, 917, 295, 341, 367, 13138, 575, 256, 11, 367, 502, 575, 1293, 344, 11, 371, 51156], 'temperature': 0.0, 'avg_logprob': -0.11052330771645347, 'compression_ratio': 1.6470588235294117, 'no_speech_prob': 0.011878502555191517}, {'id': 876, 'seek': 537680, 'start': 5393.360000000001, 'end': 5401.4400000000005, 'text': ' and r 2 has w, same information mapping in the reverse direction. So, I keep updating my register', 'tokens': [51192, 293, 367, 568, 575, 261, 11, 912, 1589, 18350, 294, 264, 9943, 3513, 13, 407, 11, 286, 1066, 25113, 452, 7280, 51596], 'temperature': 0.0, 'avg_logprob': -0.11052330771645347, 'compression_ratio': 1.6470588235294117, 'no_speech_prob': 0.011878502555191517}, {'id': 877, 'seek': 540144, 'start': 5401.44, 'end': 5407.12, 'text': ' descriptor and address descriptor and I keep working on these things, every statement one', 'tokens': [50364, 31280, 284, 293, 2985, 31280, 284, 293, 286, 1066, 1364, 322, 613, 721, 11, 633, 5629, 472, 50648], 'temperature': 0.0, 'avg_logprob': -0.08241513467604114, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.04233716428279877}, {'id': 878, 'seek': 540144, 'start': 5407.12, 'end': 5412.4, 'text': ' after another and I keep updating it. I keep generating the code for this, right.', 'tokens': [50648, 934, 1071, 293, 286, 1066, 25113, 309, 13, 286, 1066, 17746, 264, 3089, 337, 341, 11, 558, 13, 50912], 'temperature': 0.0, 'avg_logprob': -0.08241513467604114, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.04233716428279877}, {'id': 879, 'seek': 540144, 'start': 5412.96, 'end': 5418.799999999999, 'text': ' You can see that in this particular case, right, I first move a to r naught, then again I move a to', 'tokens': [50940, 509, 393, 536, 300, 294, 341, 1729, 1389, 11, 558, 11, 286, 700, 1286, 257, 281, 367, 13138, 11, 550, 797, 286, 1286, 257, 281, 51232], 'temperature': 0.0, 'avg_logprob': -0.08241513467604114, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.04233716428279877}, {'id': 880, 'seek': 540144, 'start': 5418.799999999999, 'end': 5426.24, 'text': ' r 1, right. I could have avoided this by giving a register for this and keeping a in that register,', 'tokens': [51232, 367, 502, 11, 558, 13, 286, 727, 362, 24890, 341, 538, 2902, 257, 7280, 337, 341, 293, 5145, 257, 294, 300, 7280, 11, 51604], 'temperature': 0.0, 'avg_logprob': -0.08241513467604114, 'compression_ratio': 1.7922705314009661, 'no_speech_prob': 0.04233716428279877}, {'id': 881, 'seek': 542624, 'start': 5426.88, 'end': 5432.24, 'text': ' but I do not do those intelligent decisions in this simple code generator. All I do is that', 'tokens': [50396, 457, 286, 360, 406, 360, 729, 13232, 5327, 294, 341, 2199, 3089, 19265, 13, 1057, 286, 360, 307, 300, 50664], 'temperature': 0.0, 'avg_logprob': -0.09402740880062706, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.0040317499078810215}, {'id': 882, 'seek': 542624, 'start': 5432.24, 'end': 5437.12, 'text': ' for this instruction, what is that I need to do? For that instruction, what is that I need to do?', 'tokens': [50664, 337, 341, 10951, 11, 437, 307, 300, 286, 643, 281, 360, 30, 1171, 300, 10951, 11, 437, 307, 300, 286, 643, 281, 360, 30, 50908], 'temperature': 0.0, 'avg_logprob': -0.09402740880062706, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.0040317499078810215}, {'id': 883, 'seek': 542624, 'start': 5437.12, 'end': 5443.12, 'text': ' And based on that, I generate code and therefore, I may end up moving the same operand into', 'tokens': [50908, 400, 2361, 322, 300, 11, 286, 8460, 3089, 293, 4412, 11, 286, 815, 917, 493, 2684, 264, 912, 2208, 474, 666, 51208], 'temperature': 0.0, 'avg_logprob': -0.09402740880062706, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.0040317499078810215}, {'id': 884, 'seek': 542624, 'start': 5443.679999999999, 'end': 5450.16, 'text': ' different registers at different points in time, right. See, if I have moved a into r naught,', 'tokens': [51236, 819, 38351, 412, 819, 2793, 294, 565, 11, 558, 13, 3008, 11, 498, 286, 362, 4259, 257, 666, 367, 13138, 11, 51560], 'temperature': 0.0, 'avg_logprob': -0.09402740880062706, 'compression_ratio': 1.7857142857142858, 'no_speech_prob': 0.0040317499078810215}, {'id': 885, 'seek': 545016, 'start': 5450.8, 'end': 5456.4, 'text': ' b into r 1 and subtracted a minus b as r naught minus r 1 or something like that,', 'tokens': [50396, 272, 666, 367, 502, 293, 16390, 292, 257, 3175, 272, 382, 367, 13138, 3175, 367, 502, 420, 746, 411, 300, 11, 50676], 'temperature': 0.0, 'avg_logprob': -0.07070459871210603, 'compression_ratio': 1.724264705882353, 'no_speech_prob': 0.01134751457720995}, {'id': 886, 'seek': 545016, 'start': 5456.4, 'end': 5461.36, 'text': ' my a would have been saved and I could have used it later, but I did not do that, right. So,', 'tokens': [50676, 452, 257, 576, 362, 668, 6624, 293, 286, 727, 362, 1143, 309, 1780, 11, 457, 286, 630, 406, 360, 300, 11, 558, 13, 407, 11, 50924], 'temperature': 0.0, 'avg_logprob': -0.07070459871210603, 'compression_ratio': 1.724264705882353, 'no_speech_prob': 0.01134751457720995}, {'id': 887, 'seek': 545016, 'start': 5461.36, 'end': 5467.44, 'text': ' that is why this kind of generates inefficient code, okay. Essentially, the point is that we', 'tokens': [50924, 300, 307, 983, 341, 733, 295, 23815, 43495, 3089, 11, 1392, 13, 23596, 11, 264, 935, 307, 300, 321, 51228], 'temperature': 0.0, 'avg_logprob': -0.07070459871210603, 'compression_ratio': 1.724264705882353, 'no_speech_prob': 0.01134751457720995}, {'id': 888, 'seek': 545016, 'start': 5467.44, 'end': 5472.639999999999, 'text': ' are not looking ahead, we are just concerned about that particular statement and generating code for', 'tokens': [51228, 366, 406, 1237, 2286, 11, 321, 366, 445, 5922, 466, 300, 1729, 5629, 293, 17746, 3089, 337, 51488], 'temperature': 0.0, 'avg_logprob': -0.07070459871210603, 'compression_ratio': 1.724264705882353, 'no_speech_prob': 0.01134751457720995}, {'id': 889, 'seek': 545016, 'start': 5472.639999999999, 'end': 5478.0, 'text': ' that. So, if you want to generate more efficient code, obviously, you have to have a global picture.', 'tokens': [51488, 300, 13, 407, 11, 498, 291, 528, 281, 8460, 544, 7148, 3089, 11, 2745, 11, 291, 362, 281, 362, 257, 4338, 3036, 13, 51756], 'temperature': 0.0, 'avg_logprob': -0.07070459871210603, 'compression_ratio': 1.724264705882353, 'no_speech_prob': 0.01134751457720995}, {'id': 890, 'seek': 547800, 'start': 5478.0, 'end': 5481.84, 'text': ' Well, let us not call it as a global picture, let us first let us call it as a big picture,', 'tokens': [50364, 1042, 11, 718, 505, 406, 818, 309, 382, 257, 4338, 3036, 11, 718, 505, 700, 718, 505, 818, 309, 382, 257, 955, 3036, 11, 50556], 'temperature': 0.0, 'avg_logprob': -0.10416355289396692, 'compression_ratio': 1.8764940239043826, 'no_speech_prob': 0.008018886670470238}, {'id': 891, 'seek': 547800, 'start': 5481.84, 'end': 5488.24, 'text': ' because the word global is going to be used in compiler in a very specific way, right. So,', 'tokens': [50556, 570, 264, 1349, 4338, 307, 516, 281, 312, 1143, 294, 31958, 294, 257, 588, 2685, 636, 11, 558, 13, 407, 11, 50876], 'temperature': 0.0, 'avg_logprob': -0.10416355289396692, 'compression_ratio': 1.8764940239043826, 'no_speech_prob': 0.008018886670470238}, {'id': 892, 'seek': 547800, 'start': 5488.24, 'end': 5493.84, 'text': ' we need to have a slightly bigger picture of the whole thing, right. Obviously, the bigger picture', 'tokens': [50876, 321, 643, 281, 362, 257, 4748, 3801, 3036, 295, 264, 1379, 551, 11, 558, 13, 7580, 11, 264, 3801, 3036, 51156], 'temperature': 0.0, 'avg_logprob': -0.10416355289396692, 'compression_ratio': 1.8764940239043826, 'no_speech_prob': 0.008018886670470238}, {'id': 893, 'seek': 547800, 'start': 5493.84, 'end': 5499.36, 'text': ' cannot be too big, then we will be there may be too many details and we may not be able to see.', 'tokens': [51156, 2644, 312, 886, 955, 11, 550, 321, 486, 312, 456, 815, 312, 886, 867, 4365, 293, 321, 815, 406, 312, 1075, 281, 536, 13, 51432], 'temperature': 0.0, 'avg_logprob': -0.10416355289396692, 'compression_ratio': 1.8764940239043826, 'no_speech_prob': 0.008018886670470238}, {'id': 894, 'seek': 547800, 'start': 5499.36, 'end': 5504.64, 'text': ' So, we are going to focus on a small region of code for which we can generate and this region', 'tokens': [51432, 407, 11, 321, 366, 516, 281, 1879, 322, 257, 1359, 4458, 295, 3089, 337, 597, 321, 393, 8460, 293, 341, 4458, 51696], 'temperature': 0.0, 'avg_logprob': -0.10416355289396692, 'compression_ratio': 1.8764940239043826, 'no_speech_prob': 0.008018886670470238}, {'id': 895, 'seek': 550464, 'start': 5504.64, 'end': 5511.280000000001, 'text': ' of code is what we are going to call as the basic block, right. So, in control flow analysis,', 'tokens': [50364, 295, 3089, 307, 437, 321, 366, 516, 281, 818, 382, 264, 3875, 3461, 11, 558, 13, 407, 11, 294, 1969, 3095, 5215, 11, 50696], 'temperature': 0.0, 'avg_logprob': -0.11772391625813075, 'compression_ratio': 1.892116182572614, 'no_speech_prob': 0.019182808697223663}, {'id': 896, 'seek': 550464, 'start': 5511.280000000001, 'end': 5515.200000000001, 'text': ' right you would have seen data flow, sorry in data flow analysis you would have talked about', 'tokens': [50696, 558, 291, 576, 362, 1612, 1412, 3095, 11, 2597, 294, 1412, 3095, 5215, 291, 576, 362, 2825, 466, 50892], 'temperature': 0.0, 'avg_logprob': -0.11772391625813075, 'compression_ratio': 1.892116182572614, 'no_speech_prob': 0.019182808697223663}, {'id': 897, 'seek': 550464, 'start': 5515.200000000001, 'end': 5520.160000000001, 'text': ' basic blocks and other things. So, what is a basic block? Sequence of instructions.', 'tokens': [50892, 3875, 8474, 293, 661, 721, 13, 407, 11, 437, 307, 257, 3875, 3461, 30, 46859, 655, 295, 9415, 13, 51140], 'temperature': 0.0, 'avg_logprob': -0.11772391625813075, 'compression_ratio': 1.892116182572614, 'no_speech_prob': 0.019182808697223663}, {'id': 898, 'seek': 550464, 'start': 5522.08, 'end': 5526.88, 'text': ' One follows the other and if one instruction is executed, then all of them are executed,', 'tokens': [51236, 1485, 10002, 264, 661, 293, 498, 472, 10951, 307, 17577, 11, 550, 439, 295, 552, 366, 17577, 11, 51476], 'temperature': 0.0, 'avg_logprob': -0.11772391625813075, 'compression_ratio': 1.892116182572614, 'no_speech_prob': 0.019182808697223663}, {'id': 899, 'seek': 550464, 'start': 5527.6, 'end': 5534.08, 'text': ' correct. Let us say that is what is called a basic block, single entrance, single exit, correct.', 'tokens': [51512, 3006, 13, 961, 505, 584, 300, 307, 437, 307, 1219, 257, 3875, 3461, 11, 2167, 12014, 11, 2167, 11043, 11, 3006, 13, 51836], 'temperature': 0.0, 'avg_logprob': -0.11772391625813075, 'compression_ratio': 1.892116182572614, 'no_speech_prob': 0.019182808697223663}, {'id': 900, 'seek': 553408, 'start': 5534.08, 'end': 5539.28, 'text': ' So, essentially if I ask the question, can you come up with a code generation scheme which looks', 'tokens': [50364, 407, 11, 4476, 498, 286, 1029, 264, 1168, 11, 393, 291, 808, 493, 365, 257, 3089, 5125, 12232, 597, 1542, 50624], 'temperature': 0.0, 'avg_logprob': -0.0773846862512991, 'compression_ratio': 1.8911290322580645, 'no_speech_prob': 0.0003795824304688722}, {'id': 901, 'seek': 553408, 'start': 5539.28, 'end': 5546.0, 'text': ' at a basic block and generates efficient code for that, right. And then of course, you have', 'tokens': [50624, 412, 257, 3875, 3461, 293, 23815, 7148, 3089, 337, 300, 11, 558, 13, 400, 550, 295, 1164, 11, 291, 362, 50960], 'temperature': 0.0, 'avg_logprob': -0.0773846862512991, 'compression_ratio': 1.8911290322580645, 'no_speech_prob': 0.0003795824304688722}, {'id': 902, 'seek': 553408, 'start': 5546.0, 'end': 5551.44, 'text': ' different basic blocks which are combined by means of control flow, you can generate code for that', 'tokens': [50960, 819, 3875, 8474, 597, 366, 9354, 538, 1355, 295, 1969, 3095, 11, 291, 393, 8460, 3089, 337, 300, 51232], 'temperature': 0.0, 'avg_logprob': -0.0773846862512991, 'compression_ratio': 1.8911290322580645, 'no_speech_prob': 0.0003795824304688722}, {'id': 903, 'seek': 553408, 'start': 5551.44, 'end': 5556.0, 'text': ' and so on and so forth. So, the code generation problem we are essentially going to look at', 'tokens': [51232, 293, 370, 322, 293, 370, 5220, 13, 407, 11, 264, 3089, 5125, 1154, 321, 366, 4476, 516, 281, 574, 412, 51460], 'temperature': 0.0, 'avg_logprob': -0.0773846862512991, 'compression_ratio': 1.8911290322580645, 'no_speech_prob': 0.0003795824304688722}, {'id': 904, 'seek': 553408, 'start': 5556.0, 'end': 5561.36, 'text': ' at a basic block level to start with, right. Anything which is beyond basic block is what', 'tokens': [51460, 412, 257, 3875, 3461, 1496, 281, 722, 365, 11, 558, 13, 11998, 597, 307, 4399, 3875, 3461, 307, 437, 51728], 'temperature': 0.0, 'avg_logprob': -0.0773846862512991, 'compression_ratio': 1.8911290322580645, 'no_speech_prob': 0.0003795824304688722}, {'id': 905, 'seek': 556136, 'start': 5561.36, 'end': 5565.679999999999, 'text': ' is called the global in the compiler terminology. So, that is why we did not want to say we want to', 'tokens': [50364, 307, 1219, 264, 4338, 294, 264, 31958, 27575, 13, 407, 11, 300, 307, 983, 321, 630, 406, 528, 281, 584, 321, 528, 281, 50580], 'temperature': 0.0, 'avg_logprob': -0.11281393444727338, 'compression_ratio': 1.8111111111111111, 'no_speech_prob': 0.005924500524997711}, {'id': 906, 'seek': 556136, 'start': 5565.679999999999, 'end': 5571.839999999999, 'text': ' have a global picture. We want to have well a big picture, okay, which is at the level of a', 'tokens': [50580, 362, 257, 4338, 3036, 13, 492, 528, 281, 362, 731, 257, 955, 3036, 11, 1392, 11, 597, 307, 412, 264, 1496, 295, 257, 50888], 'temperature': 0.0, 'avg_logprob': -0.11281393444727338, 'compression_ratio': 1.8111111111111111, 'no_speech_prob': 0.005924500524997711}, {'id': 907, 'seek': 556136, 'start': 5571.839999999999, 'end': 5576.799999999999, 'text': ' basic block to start with, okay. Then of course, we will look at how this basic block are connected', 'tokens': [50888, 3875, 3461, 281, 722, 365, 11, 1392, 13, 1396, 295, 1164, 11, 321, 486, 574, 412, 577, 341, 3875, 3461, 366, 4582, 51136], 'temperature': 0.0, 'avg_logprob': -0.11281393444727338, 'compression_ratio': 1.8111111111111111, 'no_speech_prob': 0.005924500524997711}, {'id': 908, 'seek': 556136, 'start': 5576.799999999999, 'end': 5582.24, 'text': ' by means of these control flow graphs and so on and so forth, right. So, that is the next step,', 'tokens': [51136, 538, 1355, 295, 613, 1969, 3095, 24877, 293, 370, 322, 293, 370, 5220, 11, 558, 13, 407, 11, 300, 307, 264, 958, 1823, 11, 51408], 'temperature': 0.0, 'avg_logprob': -0.11281393444727338, 'compression_ratio': 1.8111111111111111, 'no_speech_prob': 0.005924500524997711}, {'id': 909, 'seek': 556136, 'start': 5583.5199999999995, 'end': 5589.04, 'text': ' right. And when you talk about basic blocks, right, the way to kind of capture the information in the', 'tokens': [51472, 558, 13, 400, 562, 291, 751, 466, 3875, 8474, 11, 558, 11, 264, 636, 281, 733, 295, 7983, 264, 1589, 294, 264, 51748], 'temperature': 0.0, 'avg_logprob': -0.11281393444727338, 'compression_ratio': 1.8111111111111111, 'no_speech_prob': 0.005924500524997711}, {'id': 910, 'seek': 558904, 'start': 5589.04, 'end': 5596.24, 'text': ' basic block and what variables are being repeatedly used, etcetera, is can be captured by means of a', 'tokens': [50364, 3875, 3461, 293, 437, 9102, 366, 885, 18227, 1143, 11, 22066, 11, 307, 393, 312, 11828, 538, 1355, 295, 257, 50724], 'temperature': 0.0, 'avg_logprob': -0.12612942915696365, 'compression_ratio': 1.4011299435028248, 'no_speech_prob': 0.012026157230138779}, {'id': 911, 'seek': 558904, 'start': 5596.24, 'end': 5602.24, 'text': ' DAG which is a directed acyclic graph. So, we will talk about constructing a DAG', 'tokens': [50724, 9578, 38, 597, 307, 257, 12898, 696, 88, 66, 1050, 4295, 13, 407, 11, 321, 486, 751, 466, 39969, 257, 9578, 38, 51024], 'temperature': 0.0, 'avg_logprob': -0.12612942915696365, 'compression_ratio': 1.4011299435028248, 'no_speech_prob': 0.012026157230138779}, {'id': 912, 'seek': 558904, 'start': 5602.24, 'end': 5606.48, 'text': ' and then doing code generation for the DAG. That is our next step.', 'tokens': [51024, 293, 550, 884, 3089, 5125, 337, 264, 9578, 38, 13, 663, 307, 527, 958, 1823, 13, 51236], 'temperature': 0.0, 'avg_logprob': -0.12612942915696365, 'compression_ratio': 1.4011299435028248, 'no_speech_prob': 0.012026157230138779}]