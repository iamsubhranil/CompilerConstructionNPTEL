[{'id': 0, 'seek': 0, 'start': 0.0, 'end': 12.8, 'text': ' Okay, so the last session I was sort of indecisive whether I should do it or not or how much', 'tokens': [50364, 1033, 11, 370, 264, 1036, 5481, 286, 390, 1333, 295, 1016, 3045, 271, 488, 1968, 286, 820, 360, 309, 420, 406, 420, 577, 709, 51004], 'temperature': 0.0, 'avg_logprob': -0.21424441551094625, 'compression_ratio': 1.4408602150537635, 'no_speech_prob': 0.40520355105400085}, {'id': 1, 'seek': 0, 'start': 12.8, 'end': 20.6, 'text': " but I think it's a good idea to talk a bit about pointer analysis. The reason is that", 'tokens': [51004, 457, 286, 519, 309, 311, 257, 665, 1558, 281, 751, 257, 857, 466, 23918, 5215, 13, 440, 1778, 307, 300, 51394], 'temperature': 0.0, 'avg_logprob': -0.21424441551094625, 'compression_ratio': 1.4408602150537635, 'no_speech_prob': 0.40520355105400085}, {'id': 2, 'seek': 0, 'start': 20.6, 'end': 27.68, 'text': ' Monday whenever you start looking at machine independent optimizations, he might want you', 'tokens': [51394, 8138, 5699, 291, 722, 1237, 412, 3479, 6695, 5028, 14455, 11, 415, 1062, 528, 291, 51748], 'temperature': 0.0, 'avg_logprob': -0.21424441551094625, 'compression_ratio': 1.4408602150537635, 'no_speech_prob': 0.40520355105400085}, {'id': 3, 'seek': 2768, 'start': 27.68, 'end': 34.88, 'text': ' to know about pointer analysis. So at least a little bit idea of it is important. So now', 'tokens': [50364, 281, 458, 466, 23918, 5215, 13, 407, 412, 1935, 257, 707, 857, 1558, 295, 309, 307, 1021, 13, 407, 586, 50724], 'temperature': 0.0, 'avg_logprob': -0.25805809248739214, 'compression_ratio': 1.5952380952380953, 'no_speech_prob': 0.10599280148744583}, {'id': 4, 'seek': 2768, 'start': 34.88, 'end': 40.44, 'text': ' pointer analysis exactly what is the data for problem? What are we trying to solve?', 'tokens': [50724, 23918, 5215, 2293, 437, 307, 264, 1412, 337, 1154, 30, 708, 366, 321, 1382, 281, 5039, 30, 51002], 'temperature': 0.0, 'avg_logprob': -0.25805809248739214, 'compression_ratio': 1.5952380952380953, 'no_speech_prob': 0.10599280148744583}, {'id': 5, 'seek': 2768, 'start': 40.44, 'end': 52.58, 'text': ' So we are trying to figure out that given a set of variables, rather I would say given a set of', 'tokens': [51002, 407, 321, 366, 1382, 281, 2573, 484, 300, 2212, 257, 992, 295, 9102, 11, 2831, 286, 576, 584, 2212, 257, 992, 295, 51609], 'temperature': 0.0, 'avg_logprob': -0.25805809248739214, 'compression_ratio': 1.5952380952380953, 'no_speech_prob': 0.10599280148744583}, {'id': 6, 'seek': 5258, 'start': 52.58, 'end': 70.22, 'text': ' pointer variables and a set of memory locations, we want to find out that what for a given variable', 'tokens': [50364, 23918, 9102, 293, 257, 992, 295, 4675, 9253, 11, 321, 528, 281, 915, 484, 300, 437, 337, 257, 2212, 7006, 51246], 'temperature': 0.0, 'avg_logprob': -0.16106515345366104, 'compression_ratio': 1.6120689655172413, 'no_speech_prob': 0.13601849973201752}, {'id': 7, 'seek': 5258, 'start': 70.22, 'end': 75.53999999999999, 'text': ' says a given variable B, what are the set of memory locations it may be able to access,', 'tokens': [51246, 1619, 257, 2212, 7006, 363, 11, 437, 366, 264, 992, 295, 4675, 9253, 309, 815, 312, 1075, 281, 2105, 11, 51512], 'temperature': 0.0, 'avg_logprob': -0.16106515345366104, 'compression_ratio': 1.6120689655172413, 'no_speech_prob': 0.13601849973201752}, {'id': 8, 'seek': 7554, 'start': 75.54, 'end': 92.26, 'text': ' which it might be pointing to. This is points to. So for any given variable, I want to find out', 'tokens': [50364, 597, 309, 1062, 312, 12166, 281, 13, 639, 307, 2793, 281, 13, 407, 337, 604, 2212, 7006, 11, 286, 528, 281, 915, 484, 51200], 'temperature': 0.0, 'avg_logprob': -0.22392173983016103, 'compression_ratio': 1.4, 'no_speech_prob': 0.08555427938699722}, {'id': 9, 'seek': 7554, 'start': 92.26, 'end': 105.42, 'text': ' that what does it point to? So that is the next question. So let us say that we have a set of', 'tokens': [51200, 300, 437, 775, 309, 935, 281, 30, 407, 300, 307, 264, 958, 1168, 13, 407, 718, 505, 584, 300, 321, 362, 257, 992, 295, 51858], 'temperature': 0.0, 'avg_logprob': -0.22392173983016103, 'compression_ratio': 1.4, 'no_speech_prob': 0.08555427938699722}, {'id': 10, 'seek': 10542, 'start': 105.42, 'end': 118.02, 'text': ' statements. I have x equals ampersand A, y equals ampersand B and say y equals ampersand C, x equals', 'tokens': [50364, 12363, 13, 286, 362, 2031, 6915, 18648, 433, 474, 316, 11, 288, 6915, 18648, 433, 474, 363, 293, 584, 288, 6915, 18648, 433, 474, 383, 11, 2031, 6915, 50994], 'temperature': 0.0, 'avg_logprob': -0.19669104785453984, 'compression_ratio': 1.7439024390243902, 'no_speech_prob': 0.008836359716951847}, {'id': 11, 'seek': 10542, 'start': 118.02, 'end': 125.46000000000001, 'text': " y. So let's say how will we go about doing pointer analysis? So essentially for, so what is the,", 'tokens': [50994, 288, 13, 407, 718, 311, 584, 577, 486, 321, 352, 466, 884, 23918, 5215, 30, 407, 4476, 337, 11, 370, 437, 307, 264, 11, 51366], 'temperature': 0.0, 'avg_logprob': -0.19669104785453984, 'compression_ratio': 1.7439024390243902, 'no_speech_prob': 0.008836359716951847}, {'id': 12, 'seek': 10542, 'start': 125.46000000000001, 'end': 130.02, 'text': ' what will it look like? What is the data for problem? What is the data flow set? What is', 'tokens': [51366, 437, 486, 309, 574, 411, 30, 708, 307, 264, 1412, 337, 1154, 30, 708, 307, 264, 1412, 3095, 992, 30, 708, 307, 51594], 'temperature': 0.0, 'avg_logprob': -0.19669104785453984, 'compression_ratio': 1.7439024390243902, 'no_speech_prob': 0.008836359716951847}, {'id': 13, 'seek': 13002, 'start': 130.02, 'end': 136.94, 'text': ' the solution set look like? So for every variable, I will have to say what is the points to set.', 'tokens': [50364, 264, 3827, 992, 574, 411, 30, 407, 337, 633, 7006, 11, 286, 486, 362, 281, 584, 437, 307, 264, 2793, 281, 992, 13, 50710], 'temperature': 0.0, 'avg_logprob': -0.14472877618038293, 'compression_ratio': 1.9183673469387754, 'no_speech_prob': 0.34699031710624695}, {'id': 14, 'seek': 13002, 'start': 136.94, 'end': 142.70000000000002, 'text': ' So there are how many variables? There are variables like there is x, y, these are the', 'tokens': [50710, 407, 456, 366, 577, 867, 9102, 30, 821, 366, 9102, 411, 456, 307, 2031, 11, 288, 11, 613, 366, 264, 50998], 'temperature': 0.0, 'avg_logprob': -0.14472877618038293, 'compression_ratio': 1.9183673469387754, 'no_speech_prob': 0.34699031710624695}, {'id': 15, 'seek': 13002, 'start': 142.70000000000002, 'end': 147.5, 'text': ' two variables. For each of them, I would like to need, I need to say that x can point to what all', 'tokens': [50998, 732, 9102, 13, 1171, 1184, 295, 552, 11, 286, 576, 411, 281, 643, 11, 286, 643, 281, 584, 300, 2031, 393, 935, 281, 437, 439, 51238], 'temperature': 0.0, 'avg_logprob': -0.14472877618038293, 'compression_ratio': 1.9183673469387754, 'no_speech_prob': 0.34699031710624695}, {'id': 16, 'seek': 13002, 'start': 147.5, 'end': 153.02, 'text': ' things and y can point to what all things. This is my solution. This is what my solution would', 'tokens': [51238, 721, 293, 288, 393, 935, 281, 437, 439, 721, 13, 639, 307, 452, 3827, 13, 639, 307, 437, 452, 3827, 576, 51514], 'temperature': 0.0, 'avg_logprob': -0.14472877618038293, 'compression_ratio': 1.9183673469387754, 'no_speech_prob': 0.34699031710624695}, {'id': 17, 'seek': 15302, 'start': 153.02, 'end': 163.22, 'text': ' look like. So now to begin with, I will assume that the pointy sets are empty. They are not', 'tokens': [50364, 574, 411, 13, 407, 586, 281, 1841, 365, 11, 286, 486, 6552, 300, 264, 935, 88, 6352, 366, 6707, 13, 814, 366, 406, 50874], 'temperature': 0.0, 'avg_logprob': -0.09722980554553046, 'compression_ratio': 1.8223684210526316, 'no_speech_prob': 0.22662900388240814}, {'id': 18, 'seek': 15302, 'start': 163.22, 'end': 174.18, 'text': " pointing to anything. So let's say I start doing a flow sensitive analysis. I start doing a flow", 'tokens': [50874, 12166, 281, 1340, 13, 407, 718, 311, 584, 286, 722, 884, 257, 3095, 9477, 5215, 13, 286, 722, 884, 257, 3095, 51422], 'temperature': 0.0, 'avg_logprob': -0.09722980554553046, 'compression_ratio': 1.8223684210526316, 'no_speech_prob': 0.22662900388240814}, {'id': 19, 'seek': 15302, 'start': 174.18, 'end': 179.5, 'text': ' sensitive analysis. So in a flow sensitive analysis, I will need to maintain the pointer', 'tokens': [51422, 9477, 5215, 13, 407, 294, 257, 3095, 9477, 5215, 11, 286, 486, 643, 281, 6909, 264, 23918, 51688], 'temperature': 0.0, 'avg_logprob': -0.09722980554553046, 'compression_ratio': 1.8223684210526316, 'no_speech_prob': 0.22662900388240814}, {'id': 20, 'seek': 17950, 'start': 179.5, 'end': 184.38, 'text': " sets at each program point or at end of each basic block the way we were doing. So let's for", 'tokens': [50364, 6352, 412, 1184, 1461, 935, 420, 412, 917, 295, 1184, 3875, 3461, 264, 636, 321, 645, 884, 13, 407, 718, 311, 337, 50608], 'temperature': 0.0, 'avg_logprob': -0.17312051190270317, 'compression_ratio': 1.6235955056179776, 'no_speech_prob': 0.4137500524520874}, {'id': 21, 'seek': 17950, 'start': 184.38, 'end': 188.98, 'text': ' this particular set of instructions, how would you go about doing it? So after the first statement,', 'tokens': [50608, 341, 1729, 992, 295, 9415, 11, 577, 576, 291, 352, 466, 884, 309, 30, 407, 934, 264, 700, 5629, 11, 50838], 'temperature': 0.0, 'avg_logprob': -0.17312051190270317, 'compression_ratio': 1.6235955056179776, 'no_speech_prob': 0.4137500524520874}, {'id': 22, 'seek': 17950, 'start': 188.98, 'end': 198.54, 'text': ' how will it change? So x will now start pointing to A and y will start pointing to still the set', 'tokens': [50838, 577, 486, 309, 1319, 30, 407, 2031, 486, 586, 722, 12166, 281, 316, 293, 288, 486, 722, 12166, 281, 920, 264, 992, 51316], 'temperature': 0.0, 'avg_logprob': -0.17312051190270317, 'compression_ratio': 1.6235955056179776, 'no_speech_prob': 0.4137500524520874}, {'id': 23, 'seek': 19854, 'start': 198.54, 'end': 208.45999999999998, 'text': ' is empty. At this point, x starts pointing to still A, y points to B. At this point,', 'tokens': [50364, 307, 6707, 13, 1711, 341, 935, 11, 2031, 3719, 12166, 281, 920, 316, 11, 288, 2793, 281, 363, 13, 1711, 341, 935, 11, 50860], 'temperature': 0.0, 'avg_logprob': -0.17477438584813532, 'compression_ratio': 1.7755102040816326, 'no_speech_prob': 0.34705644845962524}, {'id': 24, 'seek': 19854, 'start': 208.45999999999998, 'end': 223.1, 'text': ' x points to A and y points to C and at this point, both points to, yeah, so x also starts', 'tokens': [50860, 2031, 2793, 281, 316, 293, 288, 2793, 281, 383, 293, 412, 341, 935, 11, 1293, 2793, 281, 11, 1338, 11, 370, 2031, 611, 3719, 51592], 'temperature': 0.0, 'avg_logprob': -0.17477438584813532, 'compression_ratio': 1.7755102040816326, 'no_speech_prob': 0.34705644845962524}, {'id': 25, 'seek': 22310, 'start': 223.1, 'end': 237.9, 'text': ' pointing to C and y also keeps on pointing to C. So this is all pointer analysis is all about.', 'tokens': [50364, 12166, 281, 383, 293, 288, 611, 5965, 322, 12166, 281, 383, 13, 407, 341, 307, 439, 23918, 5215, 307, 439, 466, 13, 51104], 'temperature': 0.0, 'avg_logprob': -0.15878293991088868, 'compression_ratio': 1.4, 'no_speech_prob': 0.020917076617479324}, {'id': 26, 'seek': 22310, 'start': 237.9, 'end': 244.85999999999999, 'text': ' Now what about if we have, what are my meet and join operators? Like if I wanted to across two', 'tokens': [51104, 823, 437, 466, 498, 321, 362, 11, 437, 366, 452, 1677, 293, 3917, 19077, 30, 1743, 498, 286, 1415, 281, 2108, 732, 51452], 'temperature': 0.0, 'avg_logprob': -0.15878293991088868, 'compression_ratio': 1.4, 'no_speech_prob': 0.020917076617479324}, {'id': 27, 'seek': 24486, 'start': 244.86, 'end': 253.86, 'text': ' basic blocks, if I want to say that what should be the pointer set here? Union, variable, per variable.', 'tokens': [50364, 3875, 8474, 11, 498, 286, 528, 281, 584, 300, 437, 820, 312, 264, 23918, 992, 510, 30, 8133, 11, 7006, 11, 680, 7006, 13, 50814], 'temperature': 0.0, 'avg_logprob': -0.22079030398664803, 'compression_ratio': 1.4817518248175183, 'no_speech_prob': 0.37777650356292725}, {'id': 28, 'seek': 24486, 'start': 253.86, 'end': 262.98, 'text': ' Per variable. For like x, you will unify the set of variables on x. For y, you will do it for y and', 'tokens': [50814, 3026, 7006, 13, 1171, 411, 2031, 11, 291, 486, 517, 2505, 264, 992, 295, 9102, 322, 2031, 13, 1171, 288, 11, 291, 486, 360, 309, 337, 288, 293, 51270], 'temperature': 0.0, 'avg_logprob': -0.22079030398664803, 'compression_ratio': 1.4817518248175183, 'no_speech_prob': 0.37777650356292725}, {'id': 29, 'seek': 26298, 'start': 262.98, 'end': 274.46000000000004, 'text': ' so on. And what are my, how will I compute my transfer function for each basic block?', 'tokens': [50364, 370, 322, 13, 400, 437, 366, 452, 11, 577, 486, 286, 14722, 452, 5003, 2445, 337, 1184, 3875, 3461, 30, 50938], 'temperature': 0.0, 'avg_logprob': -0.14700184171161954, 'compression_ratio': 1.7905405405405406, 'no_speech_prob': 0.15529011189937592}, {'id': 30, 'seek': 26298, 'start': 274.46000000000004, 'end': 283.58000000000004, 'text': ' So to come up with the transfer function, you have to come up with what are the important', 'tokens': [50938, 407, 281, 808, 493, 365, 264, 5003, 2445, 11, 291, 362, 281, 808, 493, 365, 437, 366, 264, 1021, 51394], 'temperature': 0.0, 'avg_logprob': -0.14700184171161954, 'compression_ratio': 1.7905405405405406, 'no_speech_prob': 0.15529011189937592}, {'id': 31, 'seek': 26298, 'start': 283.58000000000004, 'end': 287.02000000000004, 'text': ' statements I have to model. So what are the different important statements that are there', 'tokens': [51394, 12363, 286, 362, 281, 2316, 13, 407, 437, 366, 264, 819, 1021, 12363, 300, 366, 456, 51566], 'temperature': 0.0, 'avg_logprob': -0.14700184171161954, 'compression_ratio': 1.7905405405405406, 'no_speech_prob': 0.15529011189937592}, {'id': 32, 'seek': 28702, 'start': 287.02, 'end': 296.06, 'text': ' for pointer analysis? The first is the assignment of the referencing operator. So essentially y', 'tokens': [50364, 337, 23918, 5215, 30, 440, 700, 307, 264, 15187, 295, 264, 40582, 12973, 13, 407, 4476, 288, 50816], 'temperature': 0.0, 'avg_logprob': -0.19879690317007212, 'compression_ratio': 1.5480225988700564, 'no_speech_prob': 0.7037515640258789}, {'id': 33, 'seek': 28702, 'start': 296.06, 'end': 303.9, 'text': ' equals ampersand A sort of operation. So here what will happen? So what is the transfer function', 'tokens': [50816, 6915, 18648, 433, 474, 316, 1333, 295, 6916, 13, 407, 510, 437, 486, 1051, 30, 407, 437, 307, 264, 5003, 2445, 51208], 'temperature': 0.0, 'avg_logprob': -0.19879690317007212, 'compression_ratio': 1.5480225988700564, 'no_speech_prob': 0.7037515640258789}, {'id': 34, 'seek': 28702, 'start': 303.9, 'end': 316.46, 'text': ' for such a statement? So kill whatever is the pointer set of y, throw it away and', 'tokens': [51208, 337, 1270, 257, 5629, 30, 407, 1961, 2035, 307, 264, 23918, 992, 295, 288, 11, 3507, 309, 1314, 293, 51836], 'temperature': 0.0, 'avg_logprob': -0.19879690317007212, 'compression_ratio': 1.5480225988700564, 'no_speech_prob': 0.7037515640258789}, {'id': 35, 'seek': 31646, 'start': 316.7, 'end': 324.82, 'text': ' add A as the singleton element in that set. The second important operation is star y equals A.', 'tokens': [50376, 909, 316, 382, 264, 1522, 14806, 4478, 294, 300, 992, 13, 440, 1150, 1021, 6916, 307, 3543, 288, 6915, 316, 13, 50782], 'temperature': 0.0, 'avg_logprob': -0.2937209164654767, 'compression_ratio': 1.4225352112676057, 'no_speech_prob': 0.006090946961194277}, {'id': 36, 'seek': 31646, 'start': 324.82, 'end': 342.38, 'text': ' Point a dereferencing operator. Oh sorry, the other way round. So A y equals this. So that is not required.', 'tokens': [50782, 12387, 257, 15969, 612, 13644, 12973, 13, 876, 2597, 11, 264, 661, 636, 3098, 13, 407, 316, 288, 6915, 341, 13, 407, 300, 307, 406, 4739, 13, 51660], 'temperature': 0.0, 'avg_logprob': -0.2937209164654767, 'compression_ratio': 1.4225352112676057, 'no_speech_prob': 0.006090946961194277}, {'id': 37, 'seek': 34238, 'start': 342.38, 'end': 353.46, 'text': ' So I can do, what about y equals, assignment statement, y equals x. Replace the set of,', 'tokens': [50364, 407, 286, 393, 360, 11, 437, 466, 288, 6915, 11, 15187, 5629, 11, 288, 6915, 2031, 13, 1300, 6742, 264, 992, 295, 11, 50918], 'temperature': 0.0, 'avg_logprob': -0.2417941006747159, 'compression_ratio': 1.4318181818181819, 'no_speech_prob': 0.18159042298793793}, {'id': 38, 'seek': 34238, 'start': 353.46, 'end': 364.5, 'text': ' whatever is the set of y, throw it and put the set of x here. And then you have, these are important,', 'tokens': [50918, 2035, 307, 264, 992, 295, 288, 11, 3507, 309, 293, 829, 264, 992, 295, 2031, 510, 13, 400, 550, 291, 362, 11, 613, 366, 1021, 11, 51470], 'temperature': 0.0, 'avg_logprob': -0.2417941006747159, 'compression_ratio': 1.4318181818181819, 'no_speech_prob': 0.18159042298793793}, {'id': 39, 'seek': 36450, 'start': 364.5, 'end': 374.26, 'text': " but you can also have y equals star of x. Why is that? It's a pointer to pointer. So then what", 'tokens': [50364, 457, 291, 393, 611, 362, 288, 6915, 3543, 295, 2031, 13, 1545, 307, 300, 30, 467, 311, 257, 23918, 281, 23918, 13, 407, 550, 437, 50852], 'temperature': 0.0, 'avg_logprob': -0.1379405925800274, 'compression_ratio': 1.7, 'no_speech_prob': 0.15144260227680206}, {'id': 40, 'seek': 36450, 'start': 374.26, 'end': 385.62, 'text': ' will we do? So we will find out what is the set of location that x points to. Then figure out for', 'tokens': [50852, 486, 321, 360, 30, 407, 321, 486, 915, 484, 437, 307, 264, 992, 295, 4914, 300, 2031, 2793, 281, 13, 1396, 2573, 484, 337, 51420], 'temperature': 0.0, 'avg_logprob': -0.1379405925800274, 'compression_ratio': 1.7, 'no_speech_prob': 0.15144260227680206}, {'id': 41, 'seek': 36450, 'start': 385.62, 'end': 392.26, 'text': ' all of these locations, what is the location that those locations can point to. And the union of', 'tokens': [51420, 439, 295, 613, 9253, 11, 437, 307, 264, 4914, 300, 729, 9253, 393, 935, 281, 13, 400, 264, 11671, 295, 51752], 'temperature': 0.0, 'avg_logprob': -0.1379405925800274, 'compression_ratio': 1.7, 'no_speech_prob': 0.15144260227680206}, {'id': 42, 'seek': 39226, 'start': 392.26, 'end': 399.46, 'text': ' that will finally get assigned as the points to set of y. And now the last thing is that if you', 'tokens': [50364, 300, 486, 2721, 483, 13279, 382, 264, 2793, 281, 992, 295, 288, 13, 400, 586, 264, 1036, 551, 307, 300, 498, 291, 50724], 'temperature': 0.0, 'avg_logprob': -0.10478552650002872, 'compression_ratio': 1.4029850746268657, 'no_speech_prob': 0.18642348051071167}, {'id': 43, 'seek': 39226, 'start': 399.46, 'end': 407.26, 'text': ' have the other type of operation, star of y is equal to x. It can still be a double pointer.', 'tokens': [50724, 362, 264, 661, 2010, 295, 6916, 11, 3543, 295, 288, 307, 2681, 281, 2031, 13, 467, 393, 920, 312, 257, 3834, 23918, 13, 51114], 'temperature': 0.0, 'avg_logprob': -0.10478552650002872, 'compression_ratio': 1.4029850746268657, 'no_speech_prob': 0.18642348051071167}, {'id': 44, 'seek': 40726, 'start': 407.26, 'end': 430.86, 'text': ' So then what will you do? Okay, so this is a little sensitive operation. How, what does it mean? So,', 'tokens': [50364, 407, 550, 437, 486, 291, 360, 30, 1033, 11, 370, 341, 307, 257, 707, 9477, 6916, 13, 1012, 11, 437, 775, 309, 914, 30, 407, 11, 51544], 'temperature': 0.0, 'avg_logprob': -0.22868425051371258, 'compression_ratio': 1.098901098901099, 'no_speech_prob': 0.111394502222538}, {'id': 45, 'seek': 43086, 'start': 431.66, 'end': 440.38, 'text': ' so whenever I say, whenever I tell you this points to set, A points to A or B, what exactly does it mean?', 'tokens': [50404, 370, 5699, 286, 584, 11, 5699, 286, 980, 291, 341, 2793, 281, 992, 11, 316, 2793, 281, 316, 420, 363, 11, 437, 2293, 775, 309, 914, 30, 50840], 'temperature': 0.0, 'avg_logprob': -0.2596569384558726, 'compression_ratio': 1.4852941176470589, 'no_speech_prob': 0.18366459012031555}, {'id': 46, 'seek': 43086, 'start': 440.38, 'end': 458.14, 'text': " What is every element? Y is a variable. No, no, I'm saying what does this fact mean? What does A", 'tokens': [50840, 708, 307, 633, 4478, 30, 398, 307, 257, 7006, 13, 883, 11, 572, 11, 286, 478, 1566, 437, 775, 341, 1186, 914, 30, 708, 775, 316, 51728], 'temperature': 0.0, 'avg_logprob': -0.2596569384558726, 'compression_ratio': 1.4852941176470589, 'no_speech_prob': 0.18366459012031555}, {'id': 47, 'seek': 45814, 'start': 458.14, 'end': 466.86, 'text': ' points to A and B mean? A may be pointing to A or B. You do not know which one does it point to', 'tokens': [50364, 2793, 281, 316, 293, 363, 914, 30, 316, 815, 312, 12166, 281, 316, 420, 363, 13, 509, 360, 406, 458, 597, 472, 775, 309, 935, 281, 50800], 'temperature': 0.0, 'avg_logprob': -0.12451319694519043, 'compression_ratio': 1.144578313253012, 'no_speech_prob': 0.6456101536750793}, {'id': 48, 'seek': 46686, 'start': 466.86, 'end': 493.86, 'text': ' at this point in time. Sorry, y points to. After n B. Yes, yes, yes, of course it will. So that is', 'tokens': [50364, 412, 341, 935, 294, 565, 13, 4919, 11, 288, 2793, 281, 13, 2381, 297, 363, 13, 1079, 11, 2086, 11, 2086, 11, 295, 1164, 309, 486, 13, 407, 300, 307, 51714], 'temperature': 0.0, 'avg_logprob': -0.3802627675673541, 'compression_ratio': 1.1264367816091954, 'no_speech_prob': 0.45134732127189636}, {'id': 49, 'seek': 49386, 'start': 493.86, 'end': 500.66, 'text': ' what you have to modulate properly. So what does then star y of equals x should do? Yeah,', 'tokens': [50364, 437, 291, 362, 281, 1072, 5256, 6108, 13, 407, 437, 775, 550, 3543, 288, 295, 6915, 2031, 820, 360, 30, 865, 11, 50704], 'temperature': 0.0, 'avg_logprob': -0.22207548068119928, 'compression_ratio': 1.3161764705882353, 'no_speech_prob': 0.6967686414718628}, {'id': 50, 'seek': 49386, 'start': 500.66, 'end': 510.82, 'text': " yeah. So types are matching. So don't worry about it. So then let's say y is pointing to,", 'tokens': [50704, 1338, 13, 407, 3467, 366, 14324, 13, 407, 500, 380, 3292, 466, 309, 13, 407, 550, 718, 311, 584, 288, 307, 12166, 281, 11, 51212], 'temperature': 0.0, 'avg_logprob': -0.22207548068119928, 'compression_ratio': 1.3161764705882353, 'no_speech_prob': 0.6967686414718628}, {'id': 51, 'seek': 51082, 'start': 510.82, 'end': 539.74, 'text': " I don't know, let's say u and v. No, v, okay, u and w. So then. Can I kill the set? Yes,", 'tokens': [50364, 286, 500, 380, 458, 11, 718, 311, 584, 344, 293, 371, 13, 883, 11, 371, 11, 1392, 11, 344, 293, 261, 13, 407, 550, 13, 1664, 286, 1961, 264, 992, 30, 1079, 11, 51810], 'temperature': 0.0, 'avg_logprob': -0.25253772735595703, 'compression_ratio': 1.0476190476190477, 'no_speech_prob': 0.8490205407142639}, {'id': 52, 'seek': 53974, 'start': 540.38, 'end': 546.78, 'text': ' yes. So that is a very tricky thing, right? So had this been a simple set u, then I know that', 'tokens': [50396, 2086, 13, 407, 300, 307, 257, 588, 12414, 551, 11, 558, 30, 407, 632, 341, 668, 257, 2199, 992, 344, 11, 550, 286, 458, 300, 50716], 'temperature': 0.0, 'avg_logprob': -0.1192930675688244, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.004363936837762594}, {'id': 53, 'seek': 53974, 'start': 546.78, 'end': 554.3, 'text': " y is surely pointing to u. That's an easy case. In that case, I can kill whatever was point,", 'tokens': [50716, 288, 307, 11468, 12166, 281, 344, 13, 663, 311, 364, 1858, 1389, 13, 682, 300, 1389, 11, 286, 393, 1961, 2035, 390, 935, 11, 51092], 'temperature': 0.0, 'avg_logprob': -0.1192930675688244, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.004363936837762594}, {'id': 54, 'seek': 53974, 'start': 554.3, 'end': 559.9, 'text': ' whatever u was pointing to. And I can now say whatever x is pointing to, u also points to that.', 'tokens': [51092, 2035, 344, 390, 12166, 281, 13, 400, 286, 393, 586, 584, 2035, 2031, 307, 12166, 281, 11, 344, 611, 2793, 281, 300, 13, 51372], 'temperature': 0.0, 'avg_logprob': -0.1192930675688244, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.004363936837762594}, {'id': 55, 'seek': 53974, 'start': 560.94, 'end': 568.3, 'text': ' But if I have a situation where y was pointing to two things or more, then I do not know at this', 'tokens': [51424, 583, 498, 286, 362, 257, 2590, 689, 288, 390, 12166, 281, 732, 721, 420, 544, 11, 550, 286, 360, 406, 458, 412, 341, 51792], 'temperature': 0.0, 'avg_logprob': -0.1192930675688244, 'compression_ratio': 1.738532110091743, 'no_speech_prob': 0.004363936837762594}, {'id': 56, 'seek': 56830, 'start': 568.3, 'end': 577.0999999999999, 'text': ' point what it might be pointing to. So I have to be safe. I cannot be unsafe. So if I throw away', 'tokens': [50364, 935, 437, 309, 1062, 312, 12166, 281, 13, 407, 286, 362, 281, 312, 3273, 13, 286, 2644, 312, 35948, 13, 407, 498, 286, 3507, 1314, 50804], 'temperature': 0.0, 'avg_logprob': -0.11886509486607143, 'compression_ratio': 1.7720930232558139, 'no_speech_prob': 0.009663700126111507}, {'id': 57, 'seek': 56830, 'start': 577.0999999999999, 'end': 582.6999999999999, 'text': " the contents in u, maybe u was not even changed, maybe w was changed. I don't know because it's a", 'tokens': [50804, 264, 15768, 294, 344, 11, 1310, 344, 390, 406, 754, 3105, 11, 1310, 261, 390, 3105, 13, 286, 500, 380, 458, 570, 309, 311, 257, 51084], 'temperature': 0.0, 'avg_logprob': -0.11886509486607143, 'compression_ratio': 1.7720930232558139, 'no_speech_prob': 0.009663700126111507}, {'id': 58, 'seek': 56830, 'start': 582.6999999999999, 'end': 588.8599999999999, 'text': " made point relation. It may be pointing to any of them. I don't know which one is currently", 'tokens': [51084, 1027, 935, 9721, 13, 467, 815, 312, 12166, 281, 604, 295, 552, 13, 286, 500, 380, 458, 597, 472, 307, 4362, 51392], 'temperature': 0.0, 'avg_logprob': -0.11886509486607143, 'compression_ratio': 1.7720930232558139, 'no_speech_prob': 0.009663700126111507}, {'id': 59, 'seek': 56830, 'start': 588.8599999999999, 'end': 596.3, 'text': ' pointing to. So in that case, I cannot, so this is what is known as a strong update and a weak', 'tokens': [51392, 12166, 281, 13, 407, 294, 300, 1389, 11, 286, 2644, 11, 370, 341, 307, 437, 307, 2570, 382, 257, 2068, 5623, 293, 257, 5336, 51764], 'temperature': 0.0, 'avg_logprob': -0.11886509486607143, 'compression_ratio': 1.7720930232558139, 'no_speech_prob': 0.009663700126111507}, {'id': 60, 'seek': 59630, 'start': 596.3, 'end': 601.74, 'text': ' update. So if you do a strong update, means you throw away whatever that variable is currently', 'tokens': [50364, 5623, 13, 407, 498, 291, 360, 257, 2068, 5623, 11, 1355, 291, 3507, 1314, 2035, 300, 7006, 307, 4362, 50636], 'temperature': 0.0, 'avg_logprob': -0.06810385704040528, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.01852722093462944}, {'id': 61, 'seek': 59630, 'start': 601.74, 'end': 610.3, 'text': ' having and put the new fact. Instead, you can do a weak update when you know that I do not know', 'tokens': [50636, 1419, 293, 829, 264, 777, 1186, 13, 7156, 11, 291, 393, 360, 257, 5336, 5623, 562, 291, 458, 300, 286, 360, 406, 458, 51064], 'temperature': 0.0, 'avg_logprob': -0.06810385704040528, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.01852722093462944}, {'id': 62, 'seek': 59630, 'start': 611.0999999999999, 'end': 615.3399999999999, 'text': ' which of them is the right guy. So let me just add it to both the data flow facts.', 'tokens': [51104, 597, 295, 552, 307, 264, 558, 2146, 13, 407, 718, 385, 445, 909, 309, 281, 1293, 264, 1412, 3095, 9130, 13, 51316], 'temperature': 0.0, 'avg_logprob': -0.06810385704040528, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.01852722093462944}, {'id': 63, 'seek': 59630, 'start': 616.54, 'end': 624.62, 'text': ' So in this particular case, if it is pointing to u and w, I will not throw away the facts of u and w.', 'tokens': [51376, 407, 294, 341, 1729, 1389, 11, 498, 309, 307, 12166, 281, 344, 293, 261, 11, 286, 486, 406, 3507, 1314, 264, 9130, 295, 344, 293, 261, 13, 51780], 'temperature': 0.0, 'avg_logprob': -0.06810385704040528, 'compression_ratio': 1.6816143497757847, 'no_speech_prob': 0.01852722093462944}, {'id': 64, 'seek': 62462, 'start': 624.62, 'end': 631.26, 'text': " I will simply add the points to set of x into the points to set of both u and w. I'll just union them.", 'tokens': [50364, 286, 486, 2935, 909, 264, 2793, 281, 992, 295, 2031, 666, 264, 2793, 281, 992, 295, 1293, 344, 293, 261, 13, 286, 603, 445, 11671, 552, 13, 50696], 'temperature': 0.0, 'avg_logprob': -0.1039544117601612, 'compression_ratio': 1.5824175824175823, 'no_speech_prob': 0.000823871698230505}, {'id': 65, 'seek': 62462, 'start': 635.98, 'end': 641.74, 'text': ' This is a weak update. And strong update is whenever, if it had been a singleton set,', 'tokens': [50932, 639, 307, 257, 5336, 5623, 13, 400, 2068, 5623, 307, 5699, 11, 498, 309, 632, 668, 257, 1522, 14806, 992, 11, 51220], 'temperature': 0.0, 'avg_logprob': -0.1039544117601612, 'compression_ratio': 1.5824175824175823, 'no_speech_prob': 0.000823871698230505}, {'id': 66, 'seek': 62462, 'start': 642.3, 'end': 649.98, 'text': ' then I know that y is surely pointing to u. Then I can simply throw away that set and put the whole', 'tokens': [51248, 550, 286, 458, 300, 288, 307, 11468, 12166, 281, 344, 13, 1396, 286, 393, 2935, 3507, 1314, 300, 992, 293, 829, 264, 1379, 51632], 'temperature': 0.0, 'avg_logprob': -0.1039544117601612, 'compression_ratio': 1.5824175824175823, 'no_speech_prob': 0.000823871698230505}, {'id': 67, 'seek': 64998, 'start': 649.98, 'end': 660.0600000000001, 'text': ' set of x as the set of, so the set of u. So this is how I design my transfer function.', 'tokens': [50364, 992, 295, 2031, 382, 264, 992, 295, 11, 370, 264, 992, 295, 344, 13, 407, 341, 307, 577, 286, 1715, 452, 5003, 2445, 13, 50868], 'temperature': 0.0, 'avg_logprob': -0.17031613025036488, 'compression_ratio': 1.7073170731707317, 'no_speech_prob': 0.002049787901341915}, {'id': 68, 'seek': 64998, 'start': 660.7, 'end': 666.0600000000001, 'text': ' The meet operation you already know. So this is exactly what my points to analysis is.', 'tokens': [50900, 440, 1677, 6916, 291, 1217, 458, 13, 407, 341, 307, 2293, 437, 452, 2793, 281, 5215, 307, 13, 51168], 'temperature': 0.0, 'avg_logprob': -0.17031613025036488, 'compression_ratio': 1.7073170731707317, 'no_speech_prob': 0.002049787901341915}, {'id': 69, 'seek': 64998, 'start': 668.14, 'end': 673.4200000000001, 'text': ' So we have this points to set, where variables points to values, and this is the business. So', 'tokens': [51272, 407, 321, 362, 341, 2793, 281, 992, 11, 689, 9102, 2793, 281, 4190, 11, 293, 341, 307, 264, 1606, 13, 407, 51536], 'temperature': 0.0, 'avg_logprob': -0.17031613025036488, 'compression_ratio': 1.7073170731707317, 'no_speech_prob': 0.002049787901341915}, {'id': 70, 'seek': 64998, 'start': 673.4200000000001, 'end': 677.34, 'text': ' what is my, what does my lattice look like? What is the ordering relation on that?', 'tokens': [51536, 437, 307, 452, 11, 437, 775, 452, 34011, 574, 411, 30, 708, 307, 264, 21739, 9721, 322, 300, 30, 51732], 'temperature': 0.0, 'avg_logprob': -0.17031613025036488, 'compression_ratio': 1.7073170731707317, 'no_speech_prob': 0.002049787901341915}, {'id': 71, 'seek': 67998, 'start': 680.46, 'end': 704.46, 'text': ' So it is set, right? So it is a set of locations.', 'tokens': [50388, 407, 309, 307, 992, 11, 558, 30, 407, 309, 307, 257, 992, 295, 9253, 13, 51588], 'temperature': 0.0, 'avg_logprob': -0.30292375464188426, 'compression_ratio': 1.0208333333333333, 'no_speech_prob': 0.13894778490066528}, {'id': 72, 'seek': 70446, 'start': 704.46, 'end': 709.26, 'text': ' So the ordering relation can is generally.', 'tokens': [50364, 407, 264, 21739, 9721, 393, 307, 5101, 13, 50604], 'temperature': 0.0, 'avg_logprob': -0.34877076696177, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.02738078683614731}, {'id': 73, 'seek': 70446, 'start': 715.26, 'end': 717.82, 'text': ' So for one variable, what does the ordering relation look like?', 'tokens': [50904, 407, 337, 472, 7006, 11, 437, 775, 264, 21739, 9721, 574, 411, 30, 51032], 'temperature': 0.0, 'avg_logprob': -0.34877076696177, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.02738078683614731}, {'id': 74, 'seek': 70446, 'start': 722.62, 'end': 724.14, 'text': ' MT and then it is a?', 'tokens': [51272, 37333, 293, 550, 309, 307, 257, 30, 51348], 'temperature': 0.0, 'avg_logprob': -0.34877076696177, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.02738078683614731}, {'id': 75, 'seek': 70446, 'start': 726.86, 'end': 731.02, 'text': ' Right, right. But what is the ordering on? How do I do an ordering? What is the ordering relation', 'tokens': [51484, 1779, 11, 558, 13, 583, 437, 307, 264, 21739, 322, 30, 1012, 360, 286, 360, 364, 21739, 30, 708, 307, 264, 21739, 9721, 51692], 'temperature': 0.0, 'avg_logprob': -0.34877076696177, 'compression_ratio': 1.6304347826086956, 'no_speech_prob': 0.02738078683614731}, {'id': 76, 'seek': 73102, 'start': 731.02, 'end': 742.14, 'text': ' for this lattice? Yeah, subset equal to, right? So that is for every variable. And then the whole', 'tokens': [50364, 337, 341, 34011, 30, 865, 11, 25993, 2681, 281, 11, 558, 30, 407, 300, 307, 337, 633, 7006, 13, 400, 550, 264, 1379, 50920], 'temperature': 0.0, 'avg_logprob': -0.1676926749093192, 'compression_ratio': 1.6264367816091954, 'no_speech_prob': 0.005179951898753643}, {'id': 77, 'seek': 73102, 'start': 742.14, 'end': 746.54, 'text': ' lattice is going to be the product of that, the product lattice, just the way we did it for', 'tokens': [50920, 34011, 307, 516, 281, 312, 264, 1674, 295, 300, 11, 264, 1674, 34011, 11, 445, 264, 636, 321, 630, 309, 337, 51140], 'temperature': 0.0, 'avg_logprob': -0.1676926749093192, 'compression_ratio': 1.6264367816091954, 'no_speech_prob': 0.005179951898753643}, {'id': 78, 'seek': 73102, 'start': 746.54, 'end': 756.9399999999999, 'text': ' constant propagation. And then the ordering is this huge humongous ordering among each of the', 'tokens': [51140, 5754, 38377, 13, 400, 550, 264, 21739, 307, 341, 2603, 1484, 556, 563, 21739, 3654, 1184, 295, 264, 51660], 'temperature': 0.0, 'avg_logprob': -0.1676926749093192, 'compression_ratio': 1.6264367816091954, 'no_speech_prob': 0.005179951898753643}, {'id': 79, 'seek': 75694, 'start': 756.94, 'end': 761.1, 'text': ' component lattices. And then you figure out if something is bigger than that or not. Exactly', 'tokens': [50364, 6542, 29025, 1473, 13, 400, 550, 291, 2573, 484, 498, 746, 307, 3801, 813, 300, 420, 406, 13, 7587, 50572], 'temperature': 0.0, 'avg_logprob': -0.1405019892586602, 'compression_ratio': 1.427807486631016, 'no_speech_prob': 0.0015374288195744157}, {'id': 80, 'seek': 75694, 'start': 761.1, 'end': 774.7, 'text': ' the way we did for constant propagation. Right? Are you lost? Who is lost? Why ordering?', 'tokens': [50572, 264, 636, 321, 630, 337, 5754, 38377, 13, 1779, 30, 2014, 291, 2731, 30, 2102, 307, 2731, 30, 1545, 21739, 30, 51252], 'temperature': 0.0, 'avg_logprob': -0.1405019892586602, 'compression_ratio': 1.427807486631016, 'no_speech_prob': 0.0015374288195744157}, {'id': 81, 'seek': 75694, 'start': 777.6600000000001, 'end': 783.6600000000001, 'text': ' You tell me. So if you have a set which is pointing to only A and B, and I have a set', 'tokens': [51400, 509, 980, 385, 13, 407, 498, 291, 362, 257, 992, 597, 307, 12166, 281, 787, 316, 293, 363, 11, 293, 286, 362, 257, 992, 51700], 'temperature': 0.0, 'avg_logprob': -0.1405019892586602, 'compression_ratio': 1.427807486631016, 'no_speech_prob': 0.0015374288195744157}, {'id': 82, 'seek': 78366, 'start': 783.66, 'end': 789.42, 'text': ' which is pointing to A, B and C, the same variable. So X pointing to this and X pointing to this,', 'tokens': [50364, 597, 307, 12166, 281, 316, 11, 363, 293, 383, 11, 264, 912, 7006, 13, 407, 1783, 12166, 281, 341, 293, 1783, 12166, 281, 341, 11, 50652], 'temperature': 0.0, 'avg_logprob': -0.2102455670320535, 'compression_ratio': 1.7043010752688172, 'no_speech_prob': 0.003971715457737446}, {'id': 83, 'seek': 78366, 'start': 789.42, 'end': 791.42, 'text': ' which is more approximate, which is over approximate?', 'tokens': [50652, 597, 307, 544, 30874, 11, 597, 307, 670, 30874, 30, 50752], 'temperature': 0.0, 'avg_logprob': -0.2102455670320535, 'compression_ratio': 1.7043010752688172, 'no_speech_prob': 0.003971715457737446}, {'id': 84, 'seek': 78366, 'start': 797.3399999999999, 'end': 801.9, 'text': " Later, later, later doesn't work guys. Please understand across program points,", 'tokens': [51048, 11965, 11, 1780, 11, 1780, 1177, 380, 589, 1074, 13, 2555, 1223, 2108, 1461, 2793, 11, 51276], 'temperature': 0.0, 'avg_logprob': -0.2102455670320535, 'compression_ratio': 1.7043010752688172, 'no_speech_prob': 0.003971715457737446}, {'id': 85, 'seek': 78366, 'start': 801.9, 'end': 808.14, 'text': ' it does not, there is no comparison. This everything is working at one program point.', 'tokens': [51276, 309, 775, 406, 11, 456, 307, 572, 9660, 13, 639, 1203, 307, 1364, 412, 472, 1461, 935, 13, 51588], 'temperature': 0.0, 'avg_logprob': -0.2102455670320535, 'compression_ratio': 1.7043010752688172, 'no_speech_prob': 0.003971715457737446}, {'id': 86, 'seek': 80814, 'start': 809.1, 'end': 815.18, 'text': " Right? So I'm saying what, how do the updates move at the same program point? So every of", 'tokens': [50412, 1779, 30, 407, 286, 478, 1566, 437, 11, 577, 360, 264, 9205, 1286, 412, 264, 912, 1461, 935, 30, 407, 633, 295, 50716], 'temperature': 0.0, 'avg_logprob': -0.15044760236553117, 'compression_ratio': 1.7346938775510203, 'no_speech_prob': 0.06715541332960129}, {'id': 87, 'seek': 80814, 'start': 815.18, 'end': 819.18, 'text': ' these lattices are actually think about them, they are duplicated at each program point,', 'tokens': [50716, 613, 29025, 1473, 366, 767, 519, 466, 552, 11, 436, 366, 1581, 564, 3587, 412, 1184, 1461, 935, 11, 50916], 'temperature': 0.0, 'avg_logprob': -0.15044760236553117, 'compression_ratio': 1.7346938775510203, 'no_speech_prob': 0.06715541332960129}, {'id': 88, 'seek': 80814, 'start': 819.18, 'end': 824.22, 'text': " and they're moving on their own independently. So across the program points, there is absolutely", 'tokens': [50916, 293, 436, 434, 2684, 322, 641, 1065, 21761, 13, 407, 2108, 264, 1461, 2793, 11, 456, 307, 3122, 51168], 'temperature': 0.0, 'avg_logprob': -0.15044760236553117, 'compression_ratio': 1.7346938775510203, 'no_speech_prob': 0.06715541332960129}, {'id': 89, 'seek': 80814, 'start': 824.22, 'end': 828.14, 'text': ' no relation. I can put any statement in between and arbitrarily change the,', 'tokens': [51168, 572, 9721, 13, 286, 393, 829, 604, 5629, 294, 1296, 293, 19071, 3289, 1319, 264, 11, 51364], 'temperature': 0.0, 'avg_logprob': -0.15044760236553117, 'compression_ratio': 1.7346938775510203, 'no_speech_prob': 0.06715541332960129}, {'id': 90, 'seek': 80814, 'start': 829.74, 'end': 833.42, 'text': ' whatever happens at another program point. I can produce any state I can.', 'tokens': [51444, 2035, 2314, 412, 1071, 1461, 935, 13, 286, 393, 5258, 604, 1785, 286, 393, 13, 51628], 'temperature': 0.0, 'avg_logprob': -0.15044760236553117, 'compression_ratio': 1.7346938775510203, 'no_speech_prob': 0.06715541332960129}, {'id': 91, 'seek': 83342, 'start': 833.5, 'end': 838.6999999999999, 'text': ' So all these beautiful mathematics that we saw today was all telling you things about the same', 'tokens': [50368, 407, 439, 613, 2238, 18666, 300, 321, 1866, 965, 390, 439, 3585, 291, 721, 466, 264, 912, 50628], 'temperature': 0.0, 'avg_logprob': -0.14333459942839866, 'compression_ratio': 1.7547169811320755, 'no_speech_prob': 0.044803112745285034}, {'id': 92, 'seek': 83342, 'start': 838.6999999999999, 'end': 843.74, 'text': ' program point. Along the same program point, it should form that ascending chain and then', 'tokens': [50628, 1461, 935, 13, 17457, 264, 912, 1461, 935, 11, 309, 820, 1254, 300, 15526, 2029, 5021, 293, 550, 50880], 'temperature': 0.0, 'avg_logprob': -0.14333459942839866, 'compression_ratio': 1.7547169811320755, 'no_speech_prob': 0.044803112745285034}, {'id': 93, 'seek': 83342, 'start': 843.74, 'end': 851.5, 'text': ' eventually stabilize and all this business. So across program points, things do not make', 'tokens': [50880, 4728, 31870, 293, 439, 341, 1606, 13, 407, 2108, 1461, 2793, 11, 721, 360, 406, 652, 51268], 'temperature': 0.0, 'avg_logprob': -0.14333459942839866, 'compression_ratio': 1.7547169811320755, 'no_speech_prob': 0.044803112745285034}, {'id': 94, 'seek': 83342, 'start': 851.5, 'end': 856.3, 'text': ' that mistake again. I mean, I know this is a very, I mean, it happens again and again and again to', 'tokens': [51268, 300, 6146, 797, 13, 286, 914, 11, 286, 458, 341, 307, 257, 588, 11, 286, 914, 11, 309, 2314, 797, 293, 797, 293, 797, 281, 51508], 'temperature': 0.0, 'avg_logprob': -0.14333459942839866, 'compression_ratio': 1.7547169811320755, 'no_speech_prob': 0.044803112745285034}, {'id': 95, 'seek': 85630, 'start': 856.3, 'end': 861.8199999999999, 'text': " people, but don't like, don't get into that trap. That will be very misleading.", 'tokens': [50364, 561, 11, 457, 500, 380, 411, 11, 500, 380, 483, 666, 300, 11487, 13, 663, 486, 312, 588, 36429, 13, 50640], 'temperature': 0.0, 'avg_logprob': -0.18798203346056816, 'compression_ratio': 1.233644859813084, 'no_speech_prob': 0.06900907307863235}, {'id': 96, 'seek': 85630, 'start': 869.26, 'end': 872.3, 'text': ' So now the thing is that is it a separable analysis?', 'tokens': [51012, 407, 586, 264, 551, 307, 300, 307, 309, 257, 3128, 712, 5215, 30, 51164], 'temperature': 0.0, 'avg_logprob': -0.18798203346056816, 'compression_ratio': 1.233644859813084, 'no_speech_prob': 0.06900907307863235}, {'id': 97, 'seek': 87230, 'start': 872.3, 'end': 888.06, 'text': ' Yes. Yes. So this is also not a separable analysis, right? Because if I change the', 'tokens': [50364, 1079, 13, 1079, 13, 407, 341, 307, 611, 406, 257, 3128, 712, 5215, 11, 558, 30, 1436, 498, 286, 1319, 264, 51152], 'temperature': 0.0, 'avg_logprob': -0.19544351273688718, 'compression_ratio': 1.6918238993710693, 'no_speech_prob': 0.010969993658363819}, {'id': 98, 'seek': 87230, 'start': 888.06, 'end': 894.4599999999999, 'text': ' points to set of one relation for this double, that pointer dereferences that may cause an update', 'tokens': [51152, 2793, 281, 992, 295, 472, 9721, 337, 341, 3834, 11, 300, 23918, 15969, 612, 2667, 300, 815, 3082, 364, 5623, 51472], 'temperature': 0.0, 'avg_logprob': -0.19544351273688718, 'compression_ratio': 1.6918238993710693, 'no_speech_prob': 0.010969993658363819}, {'id': 99, 'seek': 87230, 'start': 894.4599999999999, 'end': 900.2199999999999, 'text': " to the another guy's points to relation. So this is also not a separable relation. Yeah?", 'tokens': [51472, 281, 264, 1071, 2146, 311, 2793, 281, 9721, 13, 407, 341, 307, 611, 406, 257, 3128, 712, 9721, 13, 865, 30, 51760], 'temperature': 0.0, 'avg_logprob': -0.19544351273688718, 'compression_ratio': 1.6918238993710693, 'no_speech_prob': 0.010969993658363819}, {'id': 100, 'seek': 90230, 'start': 902.6999999999999, 'end': 912.4599999999999, 'text': ' So pointer increment does not change the point to set of anything. You just get to a new location,', 'tokens': [50384, 407, 23918, 26200, 775, 406, 1319, 264, 935, 281, 992, 295, 1340, 13, 509, 445, 483, 281, 257, 777, 4914, 11, 50872], 'temperature': 0.0, 'avg_logprob': -0.14613891259217873, 'compression_ratio': 1.6045197740112995, 'no_speech_prob': 0.0017528629396110773}, {'id': 101, 'seek': 90230, 'start': 912.4599999999999, 'end': 918.14, 'text': ' right? So pointer increment means what? So you are, this was pointing to, so think about my', 'tokens': [50872, 558, 30, 407, 23918, 26200, 1355, 437, 30, 407, 291, 366, 11, 341, 390, 12166, 281, 11, 370, 519, 466, 452, 51156], 'temperature': 0.0, 'avg_logprob': -0.14613891259217873, 'compression_ratio': 1.6045197740112995, 'no_speech_prob': 0.0017528629396110773}, {'id': 102, 'seek': 90230, 'start': 918.14, 'end': 927.74, 'text': ' locations as L1, L2 and so on, right? So if I say pointer P is P plus 1, essentially now P is', 'tokens': [51156, 9253, 382, 441, 16, 11, 441, 17, 293, 370, 322, 11, 558, 30, 407, 498, 286, 584, 23918, 430, 307, 430, 1804, 502, 11, 4476, 586, 430, 307, 51636], 'temperature': 0.0, 'avg_logprob': -0.14613891259217873, 'compression_ratio': 1.6045197740112995, 'no_speech_prob': 0.0017528629396110773}, {'id': 103, 'seek': 92774, 'start': 927.74, 'end': 934.54, 'text': ' pointing to the location L2. That is all that is. So earlier it was like, so the other problem is', 'tokens': [50364, 12166, 281, 264, 4914, 441, 17, 13, 663, 307, 439, 300, 307, 13, 407, 3071, 309, 390, 411, 11, 370, 264, 661, 1154, 307, 50704], 'temperature': 0.0, 'avg_logprob': -0.11761063116568106, 'compression_ratio': 1.7269372693726937, 'no_speech_prob': 0.015388723462820053}, {'id': 104, 'seek': 92774, 'start': 934.54, 'end': 941.26, 'text': ' that there are these, these increment statement happen on things like aggregate data structures', 'tokens': [50704, 300, 456, 366, 613, 11, 613, 26200, 5629, 1051, 322, 721, 411, 26118, 1412, 9227, 51040], 'temperature': 0.0, 'avg_logprob': -0.11761063116568106, 'compression_ratio': 1.7269372693726937, 'no_speech_prob': 0.015388723462820053}, {'id': 105, 'seek': 92774, 'start': 941.26, 'end': 946.86, 'text': ' like arrays, right? So the problem is even modeling arrays is hard because whenever we', 'tokens': [51040, 411, 41011, 11, 558, 30, 407, 264, 1154, 307, 754, 15983, 41011, 307, 1152, 570, 5699, 321, 51320], 'temperature': 0.0, 'avg_logprob': -0.11761063116568106, 'compression_ratio': 1.7269372693726937, 'no_speech_prob': 0.015388723462820053}, {'id': 106, 'seek': 92774, 'start': 946.86, 'end': 951.5, 'text': ' are modeling something, we would like a finite representation, but arrays can be of unbounded', 'tokens': [51320, 366, 15983, 746, 11, 321, 576, 411, 257, 19362, 10290, 11, 457, 41011, 393, 312, 295, 517, 18767, 292, 51552], 'temperature': 0.0, 'avg_logprob': -0.11761063116568106, 'compression_ratio': 1.7269372693726937, 'no_speech_prob': 0.015388723462820053}, {'id': 107, 'seek': 92774, 'start': 951.5, 'end': 957.1, 'text': ' sizes. You do not know what size the programmer want the array for, right? Like for instance,', 'tokens': [51552, 11602, 13, 509, 360, 406, 458, 437, 2744, 264, 32116, 528, 264, 10225, 337, 11, 558, 30, 1743, 337, 5197, 11, 51832], 'temperature': 0.0, 'avg_logprob': -0.11761063116568106, 'compression_ratio': 1.7269372693726937, 'no_speech_prob': 0.015388723462820053}, {'id': 108, 'seek': 95710, 'start': 957.1, 'end': 961.98, 'text': ' let us say even allocate the array dynamically using a malloc statement. So at runtime, what is', 'tokens': [50364, 718, 505, 584, 754, 35713, 264, 10225, 43492, 1228, 257, 16026, 905, 5629, 13, 407, 412, 34474, 11, 437, 307, 50608], 'temperature': 0.0, 'avg_logprob': -0.1125891595824152, 'compression_ratio': 1.7238805970149254, 'no_speech_prob': 0.00029123848071321845}, {'id': 109, 'seek': 95710, 'start': 961.98, 'end': 967.4200000000001, 'text': ' the value of that, the size of the malloc? Nobody knows, right? So I will not be able to do a', 'tokens': [50608, 264, 2158, 295, 300, 11, 264, 2744, 295, 264, 16026, 905, 30, 9297, 3255, 11, 558, 30, 407, 286, 486, 406, 312, 1075, 281, 360, 257, 50880], 'temperature': 0.0, 'avg_logprob': -0.1125891595824152, 'compression_ratio': 1.7238805970149254, 'no_speech_prob': 0.00029123848071321845}, {'id': 110, 'seek': 95710, 'start': 967.4200000000001, 'end': 971.5, 'text': ' analysis at compile time because I do not know how big the array is going to be at runtime.', 'tokens': [50880, 5215, 412, 31413, 565, 570, 286, 360, 406, 458, 577, 955, 264, 10225, 307, 516, 281, 312, 412, 34474, 13, 51084], 'temperature': 0.0, 'avg_logprob': -0.1125891595824152, 'compression_ratio': 1.7238805970149254, 'no_speech_prob': 0.00029123848071321845}, {'id': 111, 'seek': 95710, 'start': 972.38, 'end': 976.94, 'text': ' So what people do is, like I was saying yesterday, instead of these multiple locations,', 'tokens': [51128, 407, 437, 561, 360, 307, 11, 411, 286, 390, 1566, 5186, 11, 2602, 295, 613, 3866, 9253, 11, 51356], 'temperature': 0.0, 'avg_logprob': -0.1125891595824152, 'compression_ratio': 1.7238805970149254, 'no_speech_prob': 0.00029123848071321845}, {'id': 112, 'seek': 95710, 'start': 977.5, 'end': 987.02, 'text': ' they assume that the whole array is just one location L1, right? And like if you say pointer', 'tokens': [51384, 436, 6552, 300, 264, 1379, 10225, 307, 445, 472, 4914, 441, 16, 11, 558, 30, 400, 411, 498, 291, 584, 23918, 51860], 'temperature': 0.0, 'avg_logprob': -0.1125891595824152, 'compression_ratio': 1.7238805970149254, 'no_speech_prob': 0.00029123848071321845}, {'id': 113, 'seek': 98702, 'start': 987.5, 'end': 1001.98, 'text': ' the array A goes to, like let us say P goes to A and A0 and later you say P goes to ampersand', 'tokens': [50388, 264, 10225, 316, 1709, 281, 11, 411, 718, 505, 584, 430, 1709, 281, 316, 293, 316, 15, 293, 1780, 291, 584, 430, 1709, 281, 18648, 433, 474, 51112], 'temperature': 0.0, 'avg_logprob': -0.11279499530792236, 'compression_ratio': 1.7777777777777777, 'no_speech_prob': 0.00048659974709153175}, {'id': 114, 'seek': 98702, 'start': 1001.98, 'end': 1007.34, 'text': ' A0, P goes to ampersand A1, what the compiler will simply do is because it is the same location,', 'tokens': [51112, 316, 15, 11, 430, 1709, 281, 18648, 433, 474, 316, 16, 11, 437, 264, 31958, 486, 2935, 360, 307, 570, 309, 307, 264, 912, 4914, 11, 51380], 'temperature': 0.0, 'avg_logprob': -0.11279499530792236, 'compression_ratio': 1.7777777777777777, 'no_speech_prob': 0.00048659974709153175}, {'id': 115, 'seek': 98702, 'start': 1007.34, 'end': 1013.5, 'text': ' here also it will say P goes to L1. Here also it will say that, okay, I still see the same array.', 'tokens': [51380, 510, 611, 309, 486, 584, 430, 1709, 281, 441, 16, 13, 1692, 611, 309, 486, 584, 300, 11, 1392, 11, 286, 920, 536, 264, 912, 10225, 13, 51688], 'temperature': 0.0, 'avg_logprob': -0.11279499530792236, 'compression_ratio': 1.7777777777777777, 'no_speech_prob': 0.00048659974709153175}, {'id': 116, 'seek': 101350, 'start': 1013.5, 'end': 1016.7, 'text': ' It is not a different array. So it will still keep it as P goes to L1.', 'tokens': [50364, 467, 307, 406, 257, 819, 10225, 13, 407, 309, 486, 920, 1066, 309, 382, 430, 1709, 281, 441, 16, 13, 50524], 'temperature': 0.0, 'avg_logprob': -0.08030966165903453, 'compression_ratio': 1.8023715415019763, 'no_speech_prob': 0.009691528044641018}, {'id': 117, 'seek': 101350, 'start': 1018.38, 'end': 1026.62, 'text': ' So it completely disregards your array accesses for the different elements. It does not bother', 'tokens': [50608, 407, 309, 2584, 36405, 2287, 428, 10225, 2105, 279, 337, 264, 819, 4959, 13, 467, 775, 406, 8677, 51020], 'temperature': 0.0, 'avg_logprob': -0.08030966165903453, 'compression_ratio': 1.8023715415019763, 'no_speech_prob': 0.009691528044641018}, {'id': 118, 'seek': 101350, 'start': 1026.62, 'end': 1030.94, 'text': ' because it does not know how many memory locations to model. So the one way is to like completely', 'tokens': [51020, 570, 309, 775, 406, 458, 577, 867, 4675, 9253, 281, 2316, 13, 407, 264, 472, 636, 307, 281, 411, 2584, 51236], 'temperature': 0.0, 'avg_logprob': -0.08030966165903453, 'compression_ratio': 1.8023715415019763, 'no_speech_prob': 0.009691528044641018}, {'id': 119, 'seek': 101350, 'start': 1031.74, 'end': 1037.58, 'text': ' squish the array into one location and then say I will only keep track of does it point to this', 'tokens': [51276, 31379, 264, 10225, 666, 472, 4914, 293, 550, 584, 286, 486, 787, 1066, 2837, 295, 775, 309, 935, 281, 341, 51568], 'temperature': 0.0, 'avg_logprob': -0.08030966165903453, 'compression_ratio': 1.8023715415019763, 'no_speech_prob': 0.009691528044641018}, {'id': 120, 'seek': 101350, 'start': 1037.58, 'end': 1041.98, 'text': ' array or this other array. But I will not keep track of which index in the array it is currently', 'tokens': [51568, 10225, 420, 341, 661, 10225, 13, 583, 286, 486, 406, 1066, 2837, 295, 597, 8186, 294, 264, 10225, 309, 307, 4362, 51788], 'temperature': 0.0, 'avg_logprob': -0.08030966165903453, 'compression_ratio': 1.8023715415019763, 'no_speech_prob': 0.009691528044641018}, {'id': 121, 'seek': 104198, 'start': 1041.98, 'end': 1046.54, 'text': ' pointing to, right? Excellent question. So this is an important point, but yeah,', 'tokens': [50364, 12166, 281, 11, 558, 30, 16723, 1168, 13, 407, 341, 307, 364, 1021, 935, 11, 457, 1338, 11, 50592], 'temperature': 0.0, 'avg_logprob': -0.14613982609340123, 'compression_ratio': 1.7045454545454546, 'no_speech_prob': 0.0007907021790742874}, {'id': 122, 'seek': 104198, 'start': 1046.54, 'end': 1051.74, 'text': ' generally, right? So that is one way to handle arrays. Of course, there are other abstractions.', 'tokens': [50592, 5101, 11, 558, 30, 407, 300, 307, 472, 636, 281, 4813, 41011, 13, 2720, 1164, 11, 456, 366, 661, 12649, 626, 13, 50852], 'temperature': 0.0, 'avg_logprob': -0.14613982609340123, 'compression_ratio': 1.7045454545454546, 'no_speech_prob': 0.0007907021790742874}, {'id': 123, 'seek': 104198, 'start': 1051.74, 'end': 1055.82, 'text': ' We will have come up with more sophisticated abstractions, but let us not get into this.', 'tokens': [50852, 492, 486, 362, 808, 493, 365, 544, 16950, 12649, 626, 11, 457, 718, 505, 406, 483, 666, 341, 13, 51056], 'temperature': 0.0, 'avg_logprob': -0.14613982609340123, 'compression_ratio': 1.7045454545454546, 'no_speech_prob': 0.0007907021790742874}, {'id': 124, 'seek': 104198, 'start': 1058.22, 'end': 1062.8600000000001, 'text': ' So again, like I said, people have this recency abstraction where what they do is they think that', 'tokens': [51176, 407, 797, 11, 411, 286, 848, 11, 561, 362, 341, 850, 3020, 37765, 689, 437, 436, 360, 307, 436, 519, 300, 51408], 'temperature': 0.0, 'avg_logprob': -0.14613982609340123, 'compression_ratio': 1.7045454545454546, 'no_speech_prob': 0.0007907021790742874}, {'id': 125, 'seek': 104198, 'start': 1062.8600000000001, 'end': 1068.06, 'text': ' my array is two parts. One part is the rest of the array is squished into one location', 'tokens': [51408, 452, 10225, 307, 732, 3166, 13, 1485, 644, 307, 264, 1472, 295, 264, 10225, 307, 2339, 4729, 666, 472, 4914, 51668], 'temperature': 0.0, 'avg_logprob': -0.14613982609340123, 'compression_ratio': 1.7045454545454546, 'no_speech_prob': 0.0007907021790742874}, {'id': 126, 'seek': 106806, 'start': 1068.7, 'end': 1074.86, 'text': ' and the first element like A0 and the rest. And I will only keep track of these two, nothing else.', 'tokens': [50396, 293, 264, 700, 4478, 411, 316, 15, 293, 264, 1472, 13, 400, 286, 486, 787, 1066, 2837, 295, 613, 732, 11, 1825, 1646, 13, 50704], 'temperature': 0.0, 'avg_logprob': -0.17122287977309453, 'compression_ratio': 1.662037037037037, 'no_speech_prob': 0.008046367205679417}, {'id': 127, 'seek': 106806, 'start': 1076.3799999999999, 'end': 1082.62, 'text': ' So because people think that the most recently accessed location you will going to access again', 'tokens': [50780, 407, 570, 561, 519, 300, 264, 881, 3938, 34211, 4914, 291, 486, 516, 281, 2105, 797, 51092], 'temperature': 0.0, 'avg_logprob': -0.17122287977309453, 'compression_ratio': 1.662037037037037, 'no_speech_prob': 0.008046367205679417}, {'id': 128, 'seek': 106806, 'start': 1082.62, 'end': 1087.74, 'text': ' or something like that. So again, it depends on your domain, looks at depends on your problems.', 'tokens': [51092, 420, 746, 411, 300, 13, 407, 797, 11, 309, 5946, 322, 428, 9274, 11, 1542, 412, 5946, 322, 428, 2740, 13, 51348], 'temperature': 0.0, 'avg_logprob': -0.17122287977309453, 'compression_ratio': 1.662037037037037, 'no_speech_prob': 0.008046367205679417}, {'id': 129, 'seek': 106806, 'start': 1089.02, 'end': 1092.1399999999999, 'text': ' So are we good with this transfer function for all these statements?', 'tokens': [51412, 407, 366, 321, 665, 365, 341, 5003, 2445, 337, 439, 613, 12363, 30, 51568], 'temperature': 0.0, 'avg_logprob': -0.17122287977309453, 'compression_ratio': 1.662037037037037, 'no_speech_prob': 0.008046367205679417}, {'id': 130, 'seek': 109214, 'start': 1092.38, 'end': 1095.98, 'text': ' Any question with understanding point analysis? Probably this is the fastest point analysis,', 'tokens': [50376, 2639, 1168, 365, 3701, 935, 5215, 30, 9210, 341, 307, 264, 14573, 935, 5215, 11, 50556], 'temperature': 0.0, 'avg_logprob': -0.260469212251551, 'compression_ratio': 1.7366412213740459, 'no_speech_prob': 0.004606213886290789}, {'id': 131, 'seek': 109214, 'start': 1096.8600000000001, 'end': 1101.74, 'text': ' but it is very similar to constant propagation. That is the, so everything remains very similar.', 'tokens': [50600, 457, 309, 307, 588, 2531, 281, 5754, 38377, 13, 663, 307, 264, 11, 370, 1203, 7023, 588, 2531, 13, 50844], 'temperature': 0.0, 'avg_logprob': -0.260469212251551, 'compression_ratio': 1.7366412213740459, 'no_speech_prob': 0.004606213886290789}, {'id': 132, 'seek': 109214, 'start': 1101.74, 'end': 1107.42, 'text': ' Any questions with this? Again, very quickly, so we have these points to sets. So for every', 'tokens': [50844, 2639, 1651, 365, 341, 30, 3764, 11, 588, 2661, 11, 370, 321, 362, 613, 2793, 281, 6352, 13, 407, 337, 633, 51128], 'temperature': 0.0, 'avg_logprob': -0.260469212251551, 'compression_ratio': 1.7366412213740459, 'no_speech_prob': 0.004606213886290789}, {'id': 133, 'seek': 109214, 'start': 1107.42, 'end': 1112.3000000000002, 'text': ' variable we need to figure out what are the locations, memory locations it can point to,', 'tokens': [51128, 7006, 321, 643, 281, 2573, 484, 437, 366, 264, 9253, 11, 4675, 9253, 309, 393, 935, 281, 11, 51372], 'temperature': 0.0, 'avg_logprob': -0.260469212251551, 'compression_ratio': 1.7366412213740459, 'no_speech_prob': 0.004606213886290789}, {'id': 134, 'seek': 109214, 'start': 1113.8200000000002, 'end': 1118.22, 'text': ' right? So the updates for these different statements are as follows. If you have one', 'tokens': [51448, 558, 30, 407, 264, 9205, 337, 613, 819, 12363, 366, 382, 10002, 13, 759, 291, 362, 472, 51668], 'temperature': 0.0, 'avg_logprob': -0.260469212251551, 'compression_ratio': 1.7366412213740459, 'no_speech_prob': 0.004606213886290789}, {'id': 135, 'seek': 111822, 'start': 1118.3, 'end': 1123.98, 'text': ' goes to Y is equal to ampersand A, then you will kill the set Y. You will throw away whatever is', 'tokens': [50368, 1709, 281, 398, 307, 2681, 281, 18648, 433, 474, 316, 11, 550, 291, 486, 1961, 264, 992, 398, 13, 509, 486, 3507, 1314, 2035, 307, 50652], 'temperature': 0.0, 'avg_logprob': -0.24647538058729057, 'compression_ratio': 1.7777777777777777, 'no_speech_prob': 0.010081137530505657}, {'id': 136, 'seek': 111822, 'start': 1123.98, 'end': 1131.74, 'text': " in Y and put A in that location. If Y equals X, then you'll throw away whatever is there in Y", 'tokens': [50652, 294, 398, 293, 829, 316, 294, 300, 4914, 13, 759, 398, 6915, 1783, 11, 550, 291, 603, 3507, 1314, 2035, 307, 456, 294, 398, 51040], 'temperature': 0.0, 'avg_logprob': -0.24647538058729057, 'compression_ratio': 1.7777777777777777, 'no_speech_prob': 0.010081137530505657}, {'id': 137, 'seek': 111822, 'start': 1131.74, 'end': 1138.6200000000001, 'text': ' and copy the whole set of Y into the points to set of X, points to set of Y. If you have Y equals', 'tokens': [51040, 293, 5055, 264, 1379, 992, 295, 398, 666, 264, 2793, 281, 992, 295, 1783, 11, 2793, 281, 992, 295, 398, 13, 759, 291, 362, 398, 6915, 51384], 'temperature': 0.0, 'avg_logprob': -0.24647538058729057, 'compression_ratio': 1.7777777777777777, 'no_speech_prob': 0.010081137530505657}, {'id': 138, 'seek': 113862, 'start': 1138.62, 'end': 1144.3799999999999, 'text': ' star of X, then what do you do? Then you will find out what are the locations that does that', 'tokens': [50364, 3543, 295, 1783, 11, 550, 437, 360, 291, 360, 30, 1396, 291, 486, 915, 484, 437, 366, 264, 9253, 300, 775, 300, 50652], 'temperature': 0.0, 'avg_logprob': -0.26289668148511075, 'compression_ratio': 1.6258503401360545, 'no_speech_prob': 0.01685187593102455}, {'id': 139, 'seek': 113862, 'start': 1144.3799999999999, 'end': 1151.7399999999998, 'text': " X point to. So let's say X points to location L1 and L2 and L1, L2 themselves points to,", 'tokens': [50652, 1783, 935, 281, 13, 407, 718, 311, 584, 1783, 2793, 281, 4914, 441, 16, 293, 441, 17, 293, 441, 16, 11, 441, 17, 2969, 2793, 281, 11, 51020], 'temperature': 0.0, 'avg_logprob': -0.26289668148511075, 'compression_ratio': 1.6258503401360545, 'no_speech_prob': 0.01685187593102455}, {'id': 140, 'seek': 113862, 'start': 1151.7399999999998, 'end': 1157.26, 'text': " let's say AB and this points to C. Then what will you do?", 'tokens': [51020, 718, 311, 584, 13838, 293, 341, 2793, 281, 383, 13, 1396, 437, 486, 291, 360, 30, 51296], 'temperature': 0.0, 'avg_logprob': -0.26289668148511075, 'compression_ratio': 1.6258503401360545, 'no_speech_prob': 0.01685187593102455}, {'id': 141, 'seek': 115726, 'start': 1157.26, 'end': 1162.54, 'text': " Yeah, so I'll take the union over all the locations that these guys could point to. So this will become,", 'tokens': [50364, 865, 11, 370, 286, 603, 747, 264, 11671, 670, 439, 264, 9253, 300, 613, 1074, 727, 935, 281, 13, 407, 341, 486, 1813, 11, 50628], 'temperature': 0.0, 'avg_logprob': -0.3357319215528008, 'compression_ratio': 1.7652582159624413, 'no_speech_prob': 0.08699099719524384}, {'id': 142, 'seek': 115726, 'start': 1162.54, 'end': 1171.82, 'text': ' so X will start pointing to A, B, C, all them because it does not know where to go. And finally,', 'tokens': [50628, 370, 1783, 486, 722, 12166, 281, 316, 11, 363, 11, 383, 11, 439, 552, 570, 309, 775, 406, 458, 689, 281, 352, 13, 400, 2721, 11, 51092], 'temperature': 0.0, 'avg_logprob': -0.3357319215528008, 'compression_ratio': 1.7652582159624413, 'no_speech_prob': 0.08699099719524384}, {'id': 143, 'seek': 115726, 'start': 1171.82, 'end': 1176.7, 'text': ' if you have the most tricky situation is if you have a set of X points to location L1,', 'tokens': [51092, 498, 291, 362, 264, 881, 12414, 2590, 307, 498, 291, 362, 257, 992, 295, 1783, 2793, 281, 4914, 441, 16, 11, 51336], 'temperature': 0.0, 'avg_logprob': -0.3357319215528008, 'compression_ratio': 1.7652582159624413, 'no_speech_prob': 0.08699099719524384}, {'id': 144, 'seek': 115726, 'start': 1176.7, 'end': 1183.9, 'text': ' L2, L3, L4, L5, L6, L7, L8, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9,', 'tokens': [51336, 441, 17, 11, 441, 18, 11, 441, 19, 11, 441, 20, 11, 441, 21, 11, 441, 22, 11, 441, 23, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 441, 24, 11, 51696], 'temperature': 0.0, 'avg_logprob': -0.3357319215528008, 'compression_ratio': 1.7652582159624413, 'no_speech_prob': 0.08699099719524384}, {'id': 145, 'seek': 118390, 'start': 1183.9, 'end': 1190.22, 'text': ' finally if you have the most tricky situation is if you have star of Y equals X, then what can happen?', 'tokens': [50364, 2721, 498, 291, 362, 264, 881, 12414, 2590, 307, 498, 291, 362, 3543, 295, 398, 6915, 1783, 11, 550, 437, 393, 1051, 30, 50680], 'temperature': 0.0, 'avg_logprob': -0.10700883467992146, 'compression_ratio': 1.5780346820809248, 'no_speech_prob': 0.02671038918197155}, {'id': 146, 'seek': 118390, 'start': 1194.7, 'end': 1199.3400000000001, 'text': ' Yes, so if it is a singleton set, then I can actually do a strong update', 'tokens': [50904, 1079, 11, 370, 498, 309, 307, 257, 1522, 14806, 992, 11, 550, 286, 393, 767, 360, 257, 2068, 5623, 51136], 'temperature': 0.0, 'avg_logprob': -0.10700883467992146, 'compression_ratio': 1.5780346820809248, 'no_speech_prob': 0.02671038918197155}, {'id': 147, 'seek': 118390, 'start': 1200.38, 'end': 1208.14, 'text': ' by replacing that particular location by the set contained in X. Or if it is not a singleton set,', 'tokens': [51188, 538, 19139, 300, 1729, 4914, 538, 264, 992, 16212, 294, 1783, 13, 1610, 498, 309, 307, 406, 257, 1522, 14806, 992, 11, 51576], 'temperature': 0.0, 'avg_logprob': -0.10700883467992146, 'compression_ratio': 1.5780346820809248, 'no_speech_prob': 0.02671038918197155}, {'id': 148, 'seek': 120814, 'start': 1208.14, 'end': 1215.3400000000001, 'text': ' then I do a weak update by adding that set to all the sets pointed to Y.', 'tokens': [50364, 550, 286, 360, 257, 5336, 5623, 538, 5127, 300, 992, 281, 439, 264, 6352, 10932, 281, 398, 13, 50724], 'temperature': 0.0, 'avg_logprob': -0.20795377095540366, 'compression_ratio': 1.5294117647058822, 'no_speech_prob': 0.00756464246660471}, {'id': 149, 'seek': 120814, 'start': 1217.42, 'end': 1228.14, 'text': ' Clean? Awesome. Now, pointer analysis is one analysis which is also done in a flow insensitive', 'tokens': [50828, 18463, 30, 10391, 13, 823, 11, 23918, 5215, 307, 472, 5215, 597, 307, 611, 1096, 294, 257, 3095, 1028, 34465, 51364], 'temperature': 0.0, 'avg_logprob': -0.20795377095540366, 'compression_ratio': 1.5294117647058822, 'no_speech_prob': 0.00756464246660471}, {'id': 150, 'seek': 120814, 'start': 1228.14, 'end': 1235.66, 'text': ' manner. So it is a good candidate for flow insensitive analysis also. Did I lose everything?', 'tokens': [51364, 9060, 13, 407, 309, 307, 257, 665, 11532, 337, 3095, 1028, 34465, 5215, 611, 13, 2589, 286, 3624, 1203, 30, 51740], 'temperature': 0.0, 'avg_logprob': -0.20795377095540366, 'compression_ratio': 1.5294117647058822, 'no_speech_prob': 0.00756464246660471}, {'id': 151, 'seek': 123566, 'start': 1236.6200000000001, 'end': 1244.7, 'text': ' Okay, so one interesting data structure or interesting visualization people used to', 'tokens': [50412, 1033, 11, 370, 472, 1880, 1412, 3877, 420, 1880, 25801, 561, 1143, 281, 50816], 'temperature': 0.0, 'avg_logprob': -0.2510540158140893, 'compression_ratio': 1.4901960784313726, 'no_speech_prob': 0.0005491816555149853}, {'id': 152, 'seek': 123566, 'start': 1244.7, 'end': 1249.26, 'text': ' track about point analysis is referred to as a points to graph.', 'tokens': [50816, 2837, 466, 935, 5215, 307, 10839, 281, 382, 257, 2793, 281, 4295, 13, 51044], 'temperature': 0.0, 'avg_logprob': -0.2510540158140893, 'compression_ratio': 1.4901960784313726, 'no_speech_prob': 0.0005491816555149853}, {'id': 153, 'seek': 123566, 'start': 1258.46, 'end': 1264.0600000000002, 'text': ' So what is this graph? This graph is all the variables and the memory locations.', 'tokens': [51504, 407, 437, 307, 341, 4295, 30, 639, 4295, 307, 439, 264, 9102, 293, 264, 4675, 9253, 13, 51784], 'temperature': 0.0, 'avg_logprob': -0.2510540158140893, 'compression_ratio': 1.4901960784313726, 'no_speech_prob': 0.0005491816555149853}, {'id': 154, 'seek': 126406, 'start': 1264.22, 'end': 1277.58, 'text': ' A, B, X, Y, so on. Let us say array something like that. And there is a directed edge from', 'tokens': [50372, 316, 11, 363, 11, 1783, 11, 398, 11, 370, 322, 13, 961, 505, 584, 10225, 746, 411, 300, 13, 400, 456, 307, 257, 12898, 4691, 490, 51040], 'temperature': 0.0, 'avg_logprob': -0.19202016434579525, 'compression_ratio': 1.3475177304964538, 'no_speech_prob': 0.0030252959113568068}, {'id': 155, 'seek': 126406, 'start': 1277.58, 'end': 1286.3799999999999, 'text': ' one location to the other if A can point to that location. So here essentially what does this show?', 'tokens': [51040, 472, 4914, 281, 264, 661, 498, 316, 393, 935, 281, 300, 4914, 13, 407, 510, 4476, 437, 775, 341, 855, 30, 51480], 'temperature': 0.0, 'avg_logprob': -0.19202016434579525, 'compression_ratio': 1.3475177304964538, 'no_speech_prob': 0.0030252959113568068}, {'id': 156, 'seek': 128638, 'start': 1287.0200000000002, 'end': 1297.18, 'text': ' So this captures the points to relation that A can point to X and Y, B can point to Y, and', 'tokens': [50396, 407, 341, 27986, 264, 2793, 281, 9721, 300, 316, 393, 935, 281, 1783, 293, 398, 11, 363, 393, 935, 281, 398, 11, 293, 50904], 'temperature': 0.0, 'avg_logprob': -0.2269961986135929, 'compression_ratio': 1.6346153846153846, 'no_speech_prob': 0.0035350657999515533}, {'id': 157, 'seek': 128638, 'start': 1297.18, 'end': 1306.94, 'text': ' X can point to the array. So this relation is captured by this points to graph.', 'tokens': [50904, 1783, 393, 935, 281, 264, 10225, 13, 407, 341, 9721, 307, 11828, 538, 341, 2793, 281, 4295, 13, 51392], 'temperature': 0.0, 'avg_logprob': -0.2269961986135929, 'compression_ratio': 1.6346153846153846, 'no_speech_prob': 0.0035350657999515533}, {'id': 158, 'seek': 130694, 'start': 1307.42, 'end': 1322.14, 'text': ' Okay, so now there is a very interesting flow insensitive analysis called the steam.', 'tokens': [50388, 1033, 11, 370, 586, 456, 307, 257, 588, 1880, 3095, 1028, 34465, 5215, 1219, 264, 11952, 13, 51124], 'temperature': 0.0, 'avg_logprob': -0.47949449477657197, 'compression_ratio': 1.2233009708737863, 'no_speech_prob': 0.028996936976909637}, {'id': 159, 'seek': 130694, 'start': 1330.7, 'end': 1335.18, 'text': ' I keep on forgetting where is the beacon.', 'tokens': [51552, 286, 1066, 322, 25428, 689, 307, 264, 41669, 13, 51776], 'temperature': 0.0, 'avg_logprob': -0.47949449477657197, 'compression_ratio': 1.2233009708737863, 'no_speech_prob': 0.028996936976909637}, {'id': 160, 'seek': 133694, 'start': 1337.66, 'end': 1345.5, 'text': " So, so Stinger's analysis essentially these are flow insensitive analysis.", 'tokens': [50400, 407, 11, 370, 745, 6911, 311, 5215, 4476, 613, 366, 3095, 1028, 34465, 5215, 13, 50792], 'temperature': 0.0, 'avg_logprob': -0.28170731067657473, 'compression_ratio': 1.3333333333333333, 'no_speech_prob': 0.0007174397469498217}, {'id': 161, 'seek': 133694, 'start': 1355.74, 'end': 1362.22, 'text': ' So what it means is it does not look at the order in which I traverse the statements.', 'tokens': [51304, 407, 437, 309, 1355, 307, 309, 775, 406, 574, 412, 264, 1668, 294, 597, 286, 45674, 264, 12363, 13, 51628], 'temperature': 0.0, 'avg_logprob': -0.28170731067657473, 'compression_ratio': 1.3333333333333333, 'no_speech_prob': 0.0007174397469498217}, {'id': 162, 'seek': 136222, 'start': 1362.22, 'end': 1363.74, 'text': ' The statements appear in the program.', 'tokens': [50364, 440, 12363, 4204, 294, 264, 1461, 13, 50440], 'temperature': 0.0, 'avg_logprob': -0.17163178160950376, 'compression_ratio': 1.6567796610169492, 'no_speech_prob': 0.0040326835587620735}, {'id': 163, 'seek': 136222, 'start': 1367.18, 'end': 1372.46, 'text': ' It is something known as a equality based analysis and I will tell you why it is called so.', 'tokens': [50612, 467, 307, 746, 2570, 382, 257, 14949, 2361, 5215, 293, 286, 486, 980, 291, 983, 309, 307, 1219, 370, 13, 50876], 'temperature': 0.0, 'avg_logprob': -0.17163178160950376, 'compression_ratio': 1.6567796610169492, 'no_speech_prob': 0.0040326835587620735}, {'id': 164, 'seek': 136222, 'start': 1375.1000000000001, 'end': 1381.58, 'text': ' And this is probably the fastest point analysis available, but it is not very precise.', 'tokens': [51008, 400, 341, 307, 1391, 264, 14573, 935, 5215, 2435, 11, 457, 309, 307, 406, 588, 13600, 13, 51332], 'temperature': 0.0, 'avg_logprob': -0.17163178160950376, 'compression_ratio': 1.6567796610169492, 'no_speech_prob': 0.0040326835587620735}, {'id': 165, 'seek': 136222, 'start': 1382.3, 'end': 1386.7, 'text': ' So it is really meant for really large pieces of code where you cannot afford to run a', 'tokens': [51368, 407, 309, 307, 534, 4140, 337, 534, 2416, 3755, 295, 3089, 689, 291, 2644, 6157, 281, 1190, 257, 51588], 'temperature': 0.0, 'avg_logprob': -0.17163178160950376, 'compression_ratio': 1.6567796610169492, 'no_speech_prob': 0.0040326835587620735}, {'id': 166, 'seek': 136222, 'start': 1387.58, 'end': 1391.98, 'text': ' like a very expensive analysis. But point analysis as you can understand is a precursor', 'tokens': [51632, 411, 257, 588, 5124, 5215, 13, 583, 935, 5215, 382, 291, 393, 1223, 307, 257, 41736, 284, 51852], 'temperature': 0.0, 'avg_logprob': -0.17163178160950376, 'compression_ratio': 1.6567796610169492, 'no_speech_prob': 0.0040326835587620735}, {'id': 167, 'seek': 139198, 'start': 1391.98, 'end': 1395.66, 'text': ' to almost every analysis because if they are pointers everything can go haywire.', 'tokens': [50364, 281, 1920, 633, 5215, 570, 498, 436, 366, 44548, 1203, 393, 352, 4842, 42689, 13, 50548], 'temperature': 0.0, 'avg_logprob': -0.16560919307967992, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.00041452597361057997}, {'id': 168, 'seek': 139198, 'start': 1395.66, 'end': 1401.42, 'text': ' We do not know what they point to. So at least you need some point analysis to go any for any', 'tokens': [50548, 492, 360, 406, 458, 437, 436, 935, 281, 13, 407, 412, 1935, 291, 643, 512, 935, 5215, 281, 352, 604, 337, 604, 50836], 'temperature': 0.0, 'avg_logprob': -0.16560919307967992, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.00041452597361057997}, {'id': 169, 'seek': 139198, 'start': 1401.42, 'end': 1407.02, 'text': ' analysis to run. So even for large code bases where you cannot afford to run a very expensive', 'tokens': [50836, 5215, 281, 1190, 13, 407, 754, 337, 2416, 3089, 17949, 689, 291, 2644, 6157, 281, 1190, 257, 588, 5124, 51116], 'temperature': 0.0, 'avg_logprob': -0.16560919307967992, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.00041452597361057997}, {'id': 170, 'seek': 139198, 'start': 1407.02, 'end': 1411.5, 'text': ' point analysis you can still run steam guys analysis because it is extremely fast.', 'tokens': [51116, 935, 5215, 291, 393, 920, 1190, 11952, 1074, 5215, 570, 309, 307, 4664, 2370, 13, 51340], 'temperature': 0.0, 'avg_logprob': -0.16560919307967992, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.00041452597361057997}, {'id': 171, 'seek': 139198, 'start': 1413.34, 'end': 1419.42, 'text': ' Okay, so let us think about how does steam guys analysis work. So let us say I have', 'tokens': [51432, 1033, 11, 370, 718, 505, 519, 466, 577, 775, 11952, 1074, 5215, 589, 13, 407, 718, 505, 584, 286, 362, 51736], 'temperature': 0.0, 'avg_logprob': -0.16560919307967992, 'compression_ratio': 1.8277310924369747, 'no_speech_prob': 0.00041452597361057997}, {'id': 172, 'seek': 141942, 'start': 1419.5800000000002, 'end': 1431.5800000000002, 'text': ' A equals ampersand x, B equals ampersand y, B equals ampersand z, A equals b.', 'tokens': [50372, 316, 6915, 18648, 433, 474, 2031, 11, 363, 6915, 18648, 433, 474, 288, 11, 363, 6915, 18648, 433, 474, 710, 11, 316, 6915, 272, 13, 50972], 'temperature': 0.0, 'avg_logprob': -0.18872532779223297, 'compression_ratio': 1.6265822784810127, 'no_speech_prob': 0.0018619147595018148}, {'id': 173, 'seek': 141942, 'start': 1434.46, 'end': 1440.0600000000002, 'text': ' Let us say I have this piece of code. So the way steam guys analysis work it is very similar', 'tokens': [51116, 961, 505, 584, 286, 362, 341, 2522, 295, 3089, 13, 407, 264, 636, 11952, 1074, 5215, 589, 309, 307, 588, 2531, 51396], 'temperature': 0.0, 'avg_logprob': -0.18872532779223297, 'compression_ratio': 1.6265822784810127, 'no_speech_prob': 0.0018619147595018148}, {'id': 174, 'seek': 141942, 'start': 1440.0600000000002, 'end': 1446.22, 'text': ' to the updates that we have seen so far. But because it is a flow insensitive analysis', 'tokens': [51396, 281, 264, 9205, 300, 321, 362, 1612, 370, 1400, 13, 583, 570, 309, 307, 257, 3095, 1028, 34465, 5215, 51704], 'temperature': 0.0, 'avg_logprob': -0.18872532779223297, 'compression_ratio': 1.6265822784810127, 'no_speech_prob': 0.0018619147595018148}, {'id': 175, 'seek': 144622, 'start': 1446.94, 'end': 1450.94, 'text': ' it cannot do strong updates because it does not know which order the statements appear.', 'tokens': [50400, 309, 2644, 360, 2068, 9205, 570, 309, 775, 406, 458, 597, 1668, 264, 12363, 4204, 13, 50600], 'temperature': 0.0, 'avg_logprob': -0.10611061877514942, 'compression_ratio': 1.7194570135746607, 'no_speech_prob': 0.003583507379516959}, {'id': 176, 'seek': 144622, 'start': 1451.5, 'end': 1458.38, 'text': ' So it can only do weak updates. That is one problem. The second problem with flow insensitive', 'tokens': [50628, 407, 309, 393, 787, 360, 5336, 9205, 13, 663, 307, 472, 1154, 13, 440, 1150, 1154, 365, 3095, 1028, 34465, 50972], 'temperature': 0.0, 'avg_logprob': -0.10611061877514942, 'compression_ratio': 1.7194570135746607, 'no_speech_prob': 0.003583507379516959}, {'id': 177, 'seek': 144622, 'start': 1458.38, 'end': 1466.3, 'text': ' analysis is that think about that you have taken the statements in this order. And after some time', 'tokens': [50972, 5215, 307, 300, 519, 466, 300, 291, 362, 2726, 264, 12363, 294, 341, 1668, 13, 400, 934, 512, 565, 51368], 'temperature': 0.0, 'avg_logprob': -0.10611061877514942, 'compression_ratio': 1.7194570135746607, 'no_speech_prob': 0.003583507379516959}, {'id': 178, 'seek': 144622, 'start': 1467.42, 'end': 1474.14, 'text': ' there is a statement which assumes the previous statement like okay let us see how this works here.', 'tokens': [51424, 456, 307, 257, 5629, 597, 37808, 264, 3894, 5629, 411, 1392, 718, 505, 536, 577, 341, 1985, 510, 13, 51760], 'temperature': 0.0, 'avg_logprob': -0.10611061877514942, 'compression_ratio': 1.7194570135746607, 'no_speech_prob': 0.003583507379516959}, {'id': 179, 'seek': 147622, 'start': 1476.22, 'end': 1480.06, 'text': ' So how should I put it?', 'tokens': [50364, 407, 577, 820, 286, 829, 309, 30, 50556], 'temperature': 0.0, 'avg_logprob': -0.3089135659707559, 'compression_ratio': 1.1505376344086022, 'no_speech_prob': 0.0043050930835306644}, {'id': 180, 'seek': 147622, 'start': 1486.3, 'end': 1490.3, 'text': ' So let us put some updates to these guys also. P equals', 'tokens': [50868, 407, 718, 505, 829, 512, 9205, 281, 613, 1074, 611, 13, 430, 6915, 51068], 'temperature': 0.0, 'avg_logprob': -0.3089135659707559, 'compression_ratio': 1.1505376344086022, 'no_speech_prob': 0.0043050930835306644}, {'id': 181, 'seek': 147622, 'start': 1493.58, 'end': 1494.7, 'text': ' maybe ampersand a', 'tokens': [51232, 1310, 18648, 433, 474, 257, 51288], 'temperature': 0.0, 'avg_logprob': -0.3089135659707559, 'compression_ratio': 1.1505376344086022, 'no_speech_prob': 0.0043050930835306644}, {'id': 182, 'seek': 147622, 'start': 1497.5, 'end': 1498.22, 'text': ' right and', 'tokens': [51428, 558, 293, 51464], 'temperature': 0.0, 'avg_logprob': -0.3089135659707559, 'compression_ratio': 1.1505376344086022, 'no_speech_prob': 0.0043050930835306644}, {'id': 183, 'seek': 149822, 'start': 1498.3, 'end': 1498.94, 'text': ' and', 'tokens': [50368, 293, 50400], 'temperature': 0.0, 'avg_logprob': -0.33054840087890625, 'compression_ratio': 1.3513513513513513, 'no_speech_prob': 0.002708137035369873}, {'id': 184, 'seek': 149822, 'start': 1506.54, 'end': 1514.38, 'text': ' star P equals ampersand z. No ampersand z cannot happen. So type wise what can happen here?', 'tokens': [50780, 3543, 430, 6915, 18648, 433, 474, 710, 13, 883, 18648, 433, 474, 710, 2644, 1051, 13, 407, 2010, 10829, 437, 393, 1051, 510, 30, 51172], 'temperature': 0.0, 'avg_logprob': -0.33054840087890625, 'compression_ratio': 1.3513513513513513, 'no_speech_prob': 0.002708137035369873}, {'id': 185, 'seek': 149822, 'start': 1515.66, 'end': 1521.5, 'text': ' Star P can be ampersand B let us say. No sorry only B.', 'tokens': [51236, 5705, 430, 393, 312, 18648, 433, 474, 363, 718, 505, 584, 13, 883, 2597, 787, 363, 13, 51528], 'temperature': 0.0, 'avg_logprob': -0.33054840087890625, 'compression_ratio': 1.3513513513513513, 'no_speech_prob': 0.002708137035369873}, {'id': 186, 'seek': 152150, 'start': 1522.14, 'end': 1531.26, 'text': ' So now essentially the problem is that when I let us say because I am doing a flow insensitive', 'tokens': [50396, 407, 586, 4476, 264, 1154, 307, 300, 562, 286, 718, 505, 584, 570, 286, 669, 884, 257, 3095, 1028, 34465, 50852], 'temperature': 0.0, 'avg_logprob': -0.12873513963487412, 'compression_ratio': 1.6431718061674008, 'no_speech_prob': 0.001132402801886201}, {'id': 187, 'seek': 152150, 'start': 1531.26, 'end': 1537.9, 'text': ' analysis the order in which I am seeing these statements just does not matter. So it can happen', 'tokens': [50852, 5215, 264, 1668, 294, 597, 286, 669, 2577, 613, 12363, 445, 775, 406, 1871, 13, 407, 309, 393, 1051, 51184], 'temperature': 0.0, 'avg_logprob': -0.12873513963487412, 'compression_ratio': 1.6431718061674008, 'no_speech_prob': 0.001132402801886201}, {'id': 188, 'seek': 152150, 'start': 1537.9, 'end': 1542.86, 'text': ' that I end up seeing this particular statement first. I start seeing star P equals B first.', 'tokens': [51184, 300, 286, 917, 493, 2577, 341, 1729, 5629, 700, 13, 286, 722, 2577, 3543, 430, 6915, 363, 700, 13, 51432], 'temperature': 0.0, 'avg_logprob': -0.12873513963487412, 'compression_ratio': 1.6431718061674008, 'no_speech_prob': 0.001132402801886201}, {'id': 189, 'seek': 152150, 'start': 1544.38, 'end': 1550.14, 'text': ' So at this point I do not even know what does P point to. Later down the line I discover P', 'tokens': [51508, 407, 412, 341, 935, 286, 360, 406, 754, 458, 437, 775, 430, 935, 281, 13, 11965, 760, 264, 1622, 286, 4411, 430, 51796], 'temperature': 0.0, 'avg_logprob': -0.12873513963487412, 'compression_ratio': 1.6431718061674008, 'no_speech_prob': 0.001132402801886201}, {'id': 190, 'seek': 155014, 'start': 1550.14, 'end': 1555.74, 'text': ' points to A. So now I have to figure out I have to go to the previous statement again', 'tokens': [50364, 2793, 281, 316, 13, 407, 586, 286, 362, 281, 2573, 484, 286, 362, 281, 352, 281, 264, 3894, 5629, 797, 50644], 'temperature': 0.0, 'avg_logprob': -0.08970307181863224, 'compression_ratio': 1.774869109947644, 'no_speech_prob': 0.0008244371856562793}, {'id': 191, 'seek': 155014, 'start': 1556.6200000000001, 'end': 1561.66, 'text': ' and I will have to update all the locations where P was pointing to by this new information', 'tokens': [50688, 293, 286, 486, 362, 281, 5623, 439, 264, 9253, 689, 430, 390, 12166, 281, 538, 341, 777, 1589, 50940], 'temperature': 0.0, 'avg_logprob': -0.08970307181863224, 'compression_ratio': 1.774869109947644, 'no_speech_prob': 0.0008244371856562793}, {'id': 192, 'seek': 155014, 'start': 1561.66, 'end': 1566.3000000000002, 'text': ' that I have got. What if later I also realize that P can point to C also?', 'tokens': [50940, 300, 286, 362, 658, 13, 708, 498, 1780, 286, 611, 4325, 300, 430, 393, 935, 281, 383, 611, 30, 51172], 'temperature': 0.0, 'avg_logprob': -0.08970307181863224, 'compression_ratio': 1.774869109947644, 'no_speech_prob': 0.0008244371856562793}, {'id': 193, 'seek': 155014, 'start': 1567.9, 'end': 1574.14, 'text': ' So then again I will have to go to this state revisit this statement again and put this', 'tokens': [51252, 407, 550, 797, 286, 486, 362, 281, 352, 281, 341, 1785, 32676, 341, 5629, 797, 293, 829, 341, 51564], 'temperature': 0.0, 'avg_logprob': -0.08970307181863224, 'compression_ratio': 1.774869109947644, 'no_speech_prob': 0.0008244371856562793}, {'id': 194, 'seek': 157414, 'start': 1574.14, 'end': 1582.7, 'text': ' particular information in C also. So you do not want a statement to be executed multiple times.', 'tokens': [50364, 1729, 1589, 294, 383, 611, 13, 407, 291, 360, 406, 528, 257, 5629, 281, 312, 17577, 3866, 1413, 13, 50792], 'temperature': 0.0, 'avg_logprob': -0.07506107442519244, 'compression_ratio': 1.6990740740740742, 'no_speech_prob': 0.0060877613723278046}, {'id': 195, 'seek': 157414, 'start': 1583.5, 'end': 1588.94, 'text': ' So you want to do an update in a manner that I traverse my statements once but the points', 'tokens': [50832, 407, 291, 528, 281, 360, 364, 5623, 294, 257, 9060, 300, 286, 45674, 452, 12363, 1564, 457, 264, 2793, 51104], 'temperature': 0.0, 'avg_logprob': -0.07506107442519244, 'compression_ratio': 1.6990740740740742, 'no_speech_prob': 0.0060877613723278046}, {'id': 196, 'seek': 157414, 'start': 1588.94, 'end': 1595.26, 'text': ' to relation I get eventually actually works for no matter which order I would have seen the statements.', 'tokens': [51104, 281, 9721, 286, 483, 4728, 767, 1985, 337, 572, 1871, 597, 1668, 286, 576, 362, 1612, 264, 12363, 13, 51420], 'temperature': 0.0, 'avg_logprob': -0.07506107442519244, 'compression_ratio': 1.6990740740740742, 'no_speech_prob': 0.0060877613723278046}, {'id': 197, 'seek': 157414, 'start': 1598.22, 'end': 1602.7800000000002, 'text': ' So this analysis is able to do that. So the way this works is let us consider', 'tokens': [51568, 407, 341, 5215, 307, 1075, 281, 360, 300, 13, 407, 264, 636, 341, 1985, 307, 718, 505, 1949, 51796], 'temperature': 0.0, 'avg_logprob': -0.07506107442519244, 'compression_ratio': 1.6990740740740742, 'no_speech_prob': 0.0060877613723278046}, {'id': 198, 'seek': 160278, 'start': 1602.78, 'end': 1610.3799999999999, 'text': ' for now this particular set of instructions, set of statements. So it looks at A and it says that', 'tokens': [50364, 337, 586, 341, 1729, 992, 295, 9415, 11, 992, 295, 12363, 13, 407, 309, 1542, 412, 316, 293, 309, 1619, 300, 50744], 'temperature': 0.0, 'avg_logprob': -0.14212539562812218, 'compression_ratio': 1.5, 'no_speech_prob': 0.0006554542342200875}, {'id': 199, 'seek': 160278, 'start': 1610.3799999999999, 'end': 1623.1, 'text': ' A points to X. Then it finds B and it says B can point to Y. Then later it finds out that B', 'tokens': [50744, 316, 2793, 281, 1783, 13, 1396, 309, 10704, 363, 293, 309, 1619, 363, 393, 935, 281, 398, 13, 1396, 1780, 309, 10704, 484, 300, 363, 51380], 'temperature': 0.0, 'avg_logprob': -0.14212539562812218, 'compression_ratio': 1.5, 'no_speech_prob': 0.0006554542342200875}, {'id': 200, 'seek': 162310, 'start': 1623.6599999999999, 'end': 1627.98, 'text': ' points to B equals ampersand Z. So what should it do?', 'tokens': [50392, 2793, 281, 363, 6915, 18648, 433, 474, 1176, 13, 407, 437, 820, 309, 360, 30, 50608], 'temperature': 0.0, 'avg_logprob': -0.12250788782683897, 'compression_ratio': 1.5220125786163523, 'no_speech_prob': 0.02203163132071495}, {'id': 201, 'seek': 162310, 'start': 1631.26, 'end': 1638.3799999999999, 'text': ' It should do a union of these things. Essentially what it will do is it will say that X and Z,', 'tokens': [50772, 467, 820, 360, 257, 11671, 295, 613, 721, 13, 23596, 437, 309, 486, 360, 307, 309, 486, 584, 300, 1783, 293, 1176, 11, 51128], 'temperature': 0.0, 'avg_logprob': -0.12250788782683897, 'compression_ratio': 1.5220125786163523, 'no_speech_prob': 0.02203163132071495}, {'id': 202, 'seek': 162310, 'start': 1639.8999999999999, 'end': 1645.98, 'text': ' so B can point to either X or Z. So it will put them in the same class. It will say it points', 'tokens': [51204, 370, 363, 393, 935, 281, 2139, 1783, 420, 1176, 13, 407, 309, 486, 829, 552, 294, 264, 912, 1508, 13, 467, 486, 584, 309, 2793, 51508], 'temperature': 0.0, 'avg_logprob': -0.12250788782683897, 'compression_ratio': 1.5220125786163523, 'no_speech_prob': 0.02203163132071495}, {'id': 203, 'seek': 164598, 'start': 1645.98, 'end': 1652.8600000000001, 'text': ' to a bunch of things and X and Y are both possible. Then it encounters a statement', 'tokens': [50364, 281, 257, 3840, 295, 721, 293, 1783, 293, 398, 366, 1293, 1944, 13, 1396, 309, 26310, 257, 5629, 50708], 'temperature': 0.0, 'avg_logprob': -0.09170899073282877, 'compression_ratio': 1.4972375690607735, 'no_speech_prob': 0.014793808571994305}, {'id': 204, 'seek': 164598, 'start': 1652.8600000000001, 'end': 1664.38, 'text': ' which is A equals B. So what should it do? A points to, so now you see there is a problem.', 'tokens': [50708, 597, 307, 316, 6915, 363, 13, 407, 437, 820, 309, 360, 30, 316, 2793, 281, 11, 370, 586, 291, 536, 456, 307, 257, 1154, 13, 51284], 'temperature': 0.0, 'avg_logprob': -0.09170899073282877, 'compression_ratio': 1.4972375690607735, 'no_speech_prob': 0.014793808571994305}, {'id': 205, 'seek': 164598, 'start': 1665.34, 'end': 1672.38, 'text': ' If I say A points to X, Y, Z then I would lose the information that then the order in which these', 'tokens': [51332, 759, 286, 584, 316, 2793, 281, 1783, 11, 398, 11, 1176, 550, 286, 576, 3624, 264, 1589, 300, 550, 264, 1668, 294, 597, 613, 51684], 'temperature': 0.0, 'avg_logprob': -0.09170899073282877, 'compression_ratio': 1.4972375690607735, 'no_speech_prob': 0.014793808571994305}, {'id': 206, 'seek': 167238, 'start': 1672.38, 'end': 1678.7, 'text': ' two happen matters. What if A equals B came first and A equals ampersand X came later?', 'tokens': [50364, 732, 1051, 7001, 13, 708, 498, 316, 6915, 363, 1361, 700, 293, 316, 6915, 18648, 433, 474, 1783, 1361, 1780, 30, 50680], 'temperature': 0.0, 'avg_logprob': -0.0725528347876764, 'compression_ratio': 1.4331210191082802, 'no_speech_prob': 0.0024640318006277084}, {'id': 207, 'seek': 167238, 'start': 1679.5800000000002, 'end': 1688.94, 'text': ' Then it would have been A points to X. So I want to do an update where both of them,', 'tokens': [50724, 1396, 309, 576, 362, 668, 316, 2793, 281, 1783, 13, 407, 286, 528, 281, 360, 364, 5623, 689, 1293, 295, 552, 11, 51192], 'temperature': 0.0, 'avg_logprob': -0.0725528347876764, 'compression_ratio': 1.4331210191082802, 'no_speech_prob': 0.0024640318006277084}, {'id': 208, 'seek': 167238, 'start': 1691.3400000000001, 'end': 1695.3400000000001, 'text': ' so it does not matter which order the statements ran.', 'tokens': [51312, 370, 309, 775, 406, 1871, 597, 1668, 264, 12363, 5872, 13, 51512], 'temperature': 0.0, 'avg_logprob': -0.0725528347876764, 'compression_ratio': 1.4331210191082802, 'no_speech_prob': 0.0024640318006277084}, {'id': 209, 'seek': 169534, 'start': 1695.34, 'end': 1706.22, 'text': ' So how should it change? What should I do now? How should I, so this is my points to graph at', 'tokens': [50364, 407, 577, 820, 309, 1319, 30, 708, 820, 286, 360, 586, 30, 1012, 820, 286, 11, 370, 341, 307, 452, 2793, 281, 4295, 412, 50908], 'temperature': 0.0, 'avg_logprob': -0.1603689006730622, 'compression_ratio': 1.4098360655737705, 'no_speech_prob': 0.015872102230787277}, {'id': 210, 'seek': 169534, 'start': 1706.22, 'end': 1718.22, 'text': ' this point. So how should I change it? I will put A and B in the single class.', 'tokens': [50908, 341, 935, 13, 407, 577, 820, 286, 1319, 309, 30, 286, 486, 829, 316, 293, 363, 294, 264, 2167, 1508, 13, 51508], 'temperature': 0.0, 'avg_logprob': -0.1603689006730622, 'compression_ratio': 1.4098360655737705, 'no_speech_prob': 0.015872102230787277}, {'id': 211, 'seek': 171822, 'start': 1718.22, 'end': 1728.38, 'text': ' No, no, no. There we did not, I just, so this statement is if I could have done a strong update,', 'tokens': [50364, 883, 11, 572, 11, 572, 13, 821, 321, 630, 406, 11, 286, 445, 11, 370, 341, 5629, 307, 498, 286, 727, 362, 1096, 257, 2068, 5623, 11, 50872], 'temperature': 0.0, 'avg_logprob': -0.2053911403074103, 'compression_ratio': 1.4817518248175183, 'no_speech_prob': 0.10045446455478668}, {'id': 212, 'seek': 171822, 'start': 1728.38, 'end': 1735.1000000000001, 'text': ' I would have liked to throw away the set of A and just put the set of B. Here I cannot do a strong update.', 'tokens': [50872, 286, 576, 362, 4501, 281, 3507, 1314, 264, 992, 295, 316, 293, 445, 829, 264, 992, 295, 363, 13, 1692, 286, 2644, 360, 257, 2068, 5623, 13, 51208], 'temperature': 0.0, 'avg_logprob': -0.2053911403074103, 'compression_ratio': 1.4817518248175183, 'no_speech_prob': 0.10045446455478668}, {'id': 213, 'seek': 174822, 'start': 1748.22, 'end': 1755.18, 'text': ' Right, but if you think about it, it is the other way around. The question is that,', 'tokens': [50364, 1779, 11, 457, 498, 291, 519, 466, 309, 11, 309, 307, 264, 661, 636, 926, 13, 440, 1168, 307, 300, 11, 50712], 'temperature': 0.0, 'avg_logprob': -0.20963180541992188, 'compression_ratio': 1.5771428571428572, 'no_speech_prob': 0.017109651118516922}, {'id': 214, 'seek': 174822, 'start': 1757.02, 'end': 1764.06, 'text': ' so okay, so let us say B which can, so okay now, so one thing is that once I say A equals B because', 'tokens': [50804, 370, 1392, 11, 370, 718, 505, 584, 363, 597, 393, 11, 370, 1392, 586, 11, 370, 472, 551, 307, 300, 1564, 286, 584, 316, 6915, 363, 570, 51156], 'temperature': 0.0, 'avg_logprob': -0.20963180541992188, 'compression_ratio': 1.5771428571428572, 'no_speech_prob': 0.017109651118516922}, {'id': 215, 'seek': 174822, 'start': 1764.06, 'end': 1769.34, 'text': ' I do not consider such order in which the statements happen, what can happen? Which of these', 'tokens': [51156, 286, 360, 406, 1949, 1270, 1668, 294, 597, 264, 12363, 1051, 11, 437, 393, 1051, 30, 3013, 295, 613, 51420], 'temperature': 0.0, 'avg_logprob': -0.20963180541992188, 'compression_ratio': 1.5771428571428572, 'no_speech_prob': 0.017109651118516922}, {'id': 216, 'seek': 176934, 'start': 1769.34, 'end': 1779.1, 'text': ' two sets is going to be larger? PTS of A or PTS of B? So now A can point to everything that B points', 'tokens': [50364, 732, 6352, 307, 516, 281, 312, 4833, 30, 31218, 295, 316, 420, 31218, 295, 363, 30, 407, 586, 316, 393, 935, 281, 1203, 300, 363, 2793, 50852], 'temperature': 0.0, 'avg_logprob': -0.11653321319156223, 'compression_ratio': 1.5759493670886076, 'no_speech_prob': 0.2680850327014923}, {'id': 217, 'seek': 176934, 'start': 1779.1, 'end': 1785.02, 'text': ' to because of this, but A can still point to more things, right? Like for instance,', 'tokens': [50852, 281, 570, 295, 341, 11, 457, 316, 393, 920, 935, 281, 544, 721, 11, 558, 30, 1743, 337, 5197, 11, 51148], 'temperature': 0.0, 'avg_logprob': -0.11653321319156223, 'compression_ratio': 1.5759493670886076, 'no_speech_prob': 0.2680850327014923}, {'id': 218, 'seek': 176934, 'start': 1785.02, 'end': 1788.78, 'text': ' A can point to X, but there is no way B can start pointing to X.', 'tokens': [51148, 316, 393, 935, 281, 1783, 11, 457, 456, 307, 572, 636, 363, 393, 722, 12166, 281, 1783, 13, 51336], 'temperature': 0.0, 'avg_logprob': -0.11653321319156223, 'compression_ratio': 1.5759493670886076, 'no_speech_prob': 0.2680850327014923}, {'id': 219, 'seek': 178878, 'start': 1788.78, 'end': 1802.86, 'text': ' Set of states, what does it even mean? Because I need a points to set for A B variable.', 'tokens': [50364, 8928, 295, 4368, 11, 437, 775, 309, 754, 914, 30, 1436, 286, 643, 257, 2793, 281, 992, 337, 316, 363, 7006, 13, 51068], 'temperature': 0.0, 'avg_logprob': -0.2962374687194824, 'compression_ratio': 1.0481927710843373, 'no_speech_prob': 0.08575699478387833}, {'id': 220, 'seek': 180286, 'start': 1802.86, 'end': 1817.58, 'text': ' No, so at the end of the day, I want a points to graph like this, which tells me,', 'tokens': [50364, 883, 11, 370, 412, 264, 917, 295, 264, 786, 11, 286, 528, 257, 2793, 281, 4295, 411, 341, 11, 597, 5112, 385, 11, 51100], 'temperature': 0.0, 'avg_logprob': -0.19341868367688408, 'compression_ratio': 1.3759398496240602, 'no_speech_prob': 0.09975237399339676}, {'id': 221, 'seek': 180286, 'start': 1817.58, 'end': 1828.54, 'text': ' so what should I do? How should I change my graph? So I have A points to X, B points to Y and Z. That', 'tokens': [51100, 370, 437, 820, 286, 360, 30, 1012, 820, 286, 1319, 452, 4295, 30, 407, 286, 362, 316, 2793, 281, 1783, 11, 363, 2793, 281, 398, 293, 1176, 13, 663, 51648], 'temperature': 0.0, 'avg_logprob': -0.19341868367688408, 'compression_ratio': 1.3759398496240602, 'no_speech_prob': 0.09975237399339676}, {'id': 222, 'seek': 182854, 'start': 1828.54, 'end': 1844.1399999999999, 'text': ' is the state current state now. And who will point to that? So A points to X, Y and Z and B', 'tokens': [50364, 307, 264, 1785, 2190, 1785, 586, 13, 400, 567, 486, 935, 281, 300, 30, 407, 316, 2793, 281, 1783, 11, 398, 293, 1176, 293, 363, 51144], 'temperature': 0.0, 'avg_logprob': -0.17525698457445418, 'compression_ratio': 1.4191176470588236, 'no_speech_prob': 0.10584067553281784}, {'id': 223, 'seek': 182854, 'start': 1844.1399999999999, 'end': 1853.02, 'text': ' points to? Okay, so now here is a choice. So now the problem is that later, so if there was something', 'tokens': [51144, 2793, 281, 30, 1033, 11, 370, 586, 510, 307, 257, 3922, 13, 407, 586, 264, 1154, 307, 300, 1780, 11, 370, 498, 456, 390, 746, 51588], 'temperature': 0.0, 'avg_logprob': -0.17525698457445418, 'compression_ratio': 1.4191176470588236, 'no_speech_prob': 0.10584067553281784}, {'id': 224, 'seek': 185302, 'start': 1853.02, 'end': 1860.66, 'text': ' which was pointing to A, so I will have to go and update that also, right? Because let us say,', 'tokens': [50364, 597, 390, 12166, 281, 316, 11, 370, 286, 486, 362, 281, 352, 293, 5623, 300, 611, 11, 558, 30, 1436, 718, 505, 584, 11, 50746], 'temperature': 0.0, 'avg_logprob': -0.20582652914113012, 'compression_ratio': 1.6743119266055047, 'no_speech_prob': 0.48957744240760803}, {'id': 225, 'seek': 185302, 'start': 1860.66, 'end': 1867.18, 'text': ' this guy says star of something. So anyway, so here you have to make a decision. So there', 'tokens': [50746, 341, 2146, 1619, 3543, 295, 746, 13, 407, 4033, 11, 370, 510, 291, 362, 281, 652, 257, 3537, 13, 407, 456, 51072], 'temperature': 0.0, 'avg_logprob': -0.20582652914113012, 'compression_ratio': 1.6743119266055047, 'no_speech_prob': 0.48957744240760803}, {'id': 226, 'seek': 185302, 'start': 1867.18, 'end': 1871.26, 'text': " are two decisions, two possibilities. So Steingart's analysis is something called", 'tokens': [51072, 366, 732, 5327, 11, 732, 12178, 13, 407, 3592, 278, 446, 311, 5215, 307, 746, 1219, 51276], 'temperature': 0.0, 'avg_logprob': -0.20582652914113012, 'compression_ratio': 1.6743119266055047, 'no_speech_prob': 0.48957744240760803}, {'id': 227, 'seek': 185302, 'start': 1871.26, 'end': 1875.94, 'text': ' equality based analysis, which does not distinguish the direction. It does not distinguish between', 'tokens': [51276, 14949, 2361, 5215, 11, 597, 775, 406, 20206, 264, 3513, 13, 467, 775, 406, 20206, 1296, 51510], 'temperature': 0.0, 'avg_logprob': -0.20582652914113012, 'compression_ratio': 1.6743119266055047, 'no_speech_prob': 0.48957744240760803}, {'id': 228, 'seek': 187594, 'start': 1875.94, 'end': 1882.74, 'text': ' exactly the same as the set I think. So I said that points to A is points to B is a subset of', 'tokens': [50364, 2293, 264, 912, 382, 264, 992, 286, 519, 13, 407, 286, 848, 300, 2793, 281, 316, 307, 2793, 281, 363, 307, 257, 25993, 295, 50704], 'temperature': 0.0, 'avg_logprob': -0.15432370750649463, 'compression_ratio': 1.6872246696035242, 'no_speech_prob': 0.17742565274238586}, {'id': 229, 'seek': 187594, 'start': 1882.74, 'end': 1888.26, 'text': ' points to A. This is going to be the case, right? So A can point to, it is surely pointing to things', 'tokens': [50704, 2793, 281, 316, 13, 639, 307, 516, 281, 312, 264, 1389, 11, 558, 30, 407, 316, 393, 935, 281, 11, 309, 307, 11468, 12166, 281, 721, 50980], 'temperature': 0.0, 'avg_logprob': -0.15432370750649463, 'compression_ratio': 1.6872246696035242, 'no_speech_prob': 0.17742565274238586}, {'id': 230, 'seek': 187594, 'start': 1888.26, 'end': 1897.06, 'text': " which can be in B, but A can point to more things, right? What Steingart's analysis does is,", 'tokens': [50980, 597, 393, 312, 294, 363, 11, 457, 316, 393, 935, 281, 544, 721, 11, 558, 30, 708, 3592, 278, 446, 311, 5215, 775, 307, 11, 51420], 'temperature': 0.0, 'avg_logprob': -0.15432370750649463, 'compression_ratio': 1.6872246696035242, 'no_speech_prob': 0.17742565274238586}, {'id': 231, 'seek': 187594, 'start': 1897.06, 'end': 1904.3, 'text': ' it actually assumes an equality. It completely forgets about that. And then for this particular', 'tokens': [51420, 309, 767, 37808, 364, 14949, 13, 467, 2584, 2870, 82, 466, 300, 13, 400, 550, 337, 341, 1729, 51782], 'temperature': 0.0, 'avg_logprob': -0.15432370750649463, 'compression_ratio': 1.6872246696035242, 'no_speech_prob': 0.17742565274238586}, {'id': 232, 'seek': 190430, 'start': 1904.5, 'end': 1911.7, 'text': ' thing, it will essentially unify these guys and it say that, okay, because this guy can point to', 'tokens': [50374, 551, 11, 309, 486, 4476, 517, 2505, 613, 1074, 293, 309, 584, 300, 11, 1392, 11, 570, 341, 2146, 393, 935, 281, 50734], 'temperature': 0.0, 'avg_logprob': -0.14593010478549534, 'compression_ratio': 1.6951219512195121, 'no_speech_prob': 0.008778184652328491}, {'id': 233, 'seek': 190430, 'start': 1911.7, 'end': 1916.26, 'text': ' anything, because A can point to anything and these two guys are the same. So both A and B', 'tokens': [50734, 1340, 11, 570, 316, 393, 935, 281, 1340, 293, 613, 732, 1074, 366, 264, 912, 13, 407, 1293, 316, 293, 363, 50962], 'temperature': 0.0, 'avg_logprob': -0.14593010478549534, 'compression_ratio': 1.6951219512195121, 'no_speech_prob': 0.008778184652328491}, {'id': 234, 'seek': 190430, 'start': 1916.26, 'end': 1929.62, 'text': " can point to any of X, Y and Z. So there is another analysis known as Anderson's analysis.", 'tokens': [50962, 393, 935, 281, 604, 295, 1783, 11, 398, 293, 1176, 13, 407, 456, 307, 1071, 5215, 2570, 382, 18768, 311, 5215, 13, 51630], 'temperature': 0.0, 'avg_logprob': -0.14593010478549534, 'compression_ratio': 1.6951219512195121, 'no_speech_prob': 0.008778184652328491}, {'id': 235, 'seek': 193430, 'start': 1934.58, 'end': 1940.3799999999999, 'text': ' Which essentially maintains this relation that points to of B is a subset of points to of A.', 'tokens': [50378, 3013, 4476, 33385, 341, 9721, 300, 2793, 281, 295, 363, 307, 257, 25993, 295, 2793, 281, 295, 316, 13, 50668], 'temperature': 0.0, 'avg_logprob': -0.24101745514642625, 'compression_ratio': 1.3643410852713178, 'no_speech_prob': 0.006426473613828421}, {'id': 236, 'seek': 193430, 'start': 1940.3799999999999, 'end': 1958.5, 'text': ' This is referred to as an inclusion based analysis, right? So what is the advantage', 'tokens': [50668, 639, 307, 10839, 281, 382, 364, 15874, 2361, 5215, 11, 558, 30, 407, 437, 307, 264, 5002, 51574], 'temperature': 0.0, 'avg_logprob': -0.24101745514642625, 'compression_ratio': 1.3643410852713178, 'no_speech_prob': 0.006426473613828421}, {'id': 237, 'seek': 195850, 'start': 1958.5, 'end': 1964.78, 'text': " of Steingart's over keeping an inclusion based thing? Why should it help me to just merge these", 'tokens': [50364, 295, 3592, 278, 446, 311, 670, 5145, 364, 15874, 2361, 551, 30, 1545, 820, 309, 854, 385, 281, 445, 22183, 613, 50678], 'temperature': 0.0, 'avg_logprob': -0.1511253233878843, 'compression_ratio': 1.641255605381166, 'no_speech_prob': 0.1864977777004242}, {'id': 238, 'seek': 195850, 'start': 1964.78, 'end': 1977.58, 'text': ' two states? Yes, yes, exactly. So in inclusion based thing, you have to maintain a graph of', 'tokens': [50678, 732, 4368, 30, 1079, 11, 2086, 11, 2293, 13, 407, 294, 15874, 2361, 551, 11, 291, 362, 281, 6909, 257, 4295, 295, 51318], 'temperature': 0.0, 'avg_logprob': -0.1511253233878843, 'compression_ratio': 1.641255605381166, 'no_speech_prob': 0.1864977777004242}, {'id': 239, 'seek': 195850, 'start': 1977.58, 'end': 1983.14, 'text': ' these inclusions, right? Which is, who is containing what? And if there is a new element', 'tokens': [51318, 613, 17204, 626, 11, 558, 30, 3013, 307, 11, 567, 307, 19273, 437, 30, 400, 498, 456, 307, 257, 777, 4478, 51596], 'temperature': 0.0, 'avg_logprob': -0.1511253233878843, 'compression_ratio': 1.641255605381166, 'no_speech_prob': 0.1864977777004242}, {'id': 240, 'seek': 195850, 'start': 1983.14, 'end': 1988.1, 'text': ' added, you have to revisit it and make sure that is covered again. So essentially it does', 'tokens': [51596, 3869, 11, 291, 362, 281, 32676, 309, 293, 652, 988, 300, 307, 5343, 797, 13, 407, 4476, 309, 775, 51844], 'temperature': 0.0, 'avg_logprob': -0.1511253233878843, 'compression_ratio': 1.641255605381166, 'no_speech_prob': 0.1864977777004242}, {'id': 241, 'seek': 198810, 'start': 1988.1, 'end': 1992.86, 'text': ' a transitive closure on the inclusion graph eventually. And that is why this algorithm', 'tokens': [50364, 257, 1145, 2187, 24653, 322, 264, 15874, 4295, 4728, 13, 400, 300, 307, 983, 341, 9284, 50602], 'temperature': 0.0, 'avg_logprob': -0.19826522676071318, 'compression_ratio': 1.596638655462185, 'no_speech_prob': 0.004063074942678213}, {'id': 242, 'seek': 198810, 'start': 1992.86, 'end': 1999.1, 'text': " goes to cubic time. This is an O-N-cube algorithm. The Steingart's analysis, as you said, I do not", 'tokens': [50602, 1709, 281, 28733, 565, 13, 639, 307, 364, 422, 12, 45, 12, 66, 1977, 9284, 13, 440, 3592, 278, 446, 311, 5215, 11, 382, 291, 848, 11, 286, 360, 406, 50914], 'temperature': 0.0, 'avg_logprob': -0.19826522676071318, 'compression_ratio': 1.596638655462185, 'no_speech_prob': 0.004063074942678213}, {'id': 243, 'seek': 198810, 'start': 1999.1, 'end': 2004.26, 'text': ' really have to bother about. So once I do this union, I know that I have covered all ways A and', 'tokens': [50914, 534, 362, 281, 8677, 466, 13, 407, 1564, 286, 360, 341, 11671, 11, 286, 458, 300, 286, 362, 5343, 439, 2098, 316, 293, 51172], 'temperature': 0.0, 'avg_logprob': -0.19826522676071318, 'compression_ratio': 1.596638655462185, 'no_speech_prob': 0.004063074942678213}, {'id': 244, 'seek': 198810, 'start': 2004.26, 'end': 2010.78, 'text': ' B could have interacted. So this analysis turns out to be almost linear time. So it is a very fast', 'tokens': [51172, 363, 727, 362, 49621, 13, 407, 341, 5215, 4523, 484, 281, 312, 1920, 8213, 565, 13, 407, 309, 307, 257, 588, 2370, 51498], 'temperature': 0.0, 'avg_logprob': -0.19826522676071318, 'compression_ratio': 1.596638655462185, 'no_speech_prob': 0.004063074942678213}, {'id': 245, 'seek': 201078, 'start': 2010.78, 'end': 2026.74, 'text': ' analysis, right? So I will not get into details of it, but I think this much should be enough to', 'tokens': [50364, 5215, 11, 558, 30, 407, 286, 486, 406, 483, 666, 4365, 295, 309, 11, 457, 286, 519, 341, 709, 820, 312, 1547, 281, 51162], 'temperature': 0.0, 'avg_logprob': -0.1395083221734739, 'compression_ratio': 1.3722627737226278, 'no_speech_prob': 0.07356463372707367}, {'id': 246, 'seek': 201078, 'start': 2026.74, 'end': 2032.78, 'text': ' get you going with points to analysis. If you want to implement points to analysis in LLVM,', 'tokens': [51162, 483, 291, 516, 365, 2793, 281, 5215, 13, 759, 291, 528, 281, 4445, 2793, 281, 5215, 294, 441, 43, 53, 44, 11, 51464], 'temperature': 0.0, 'avg_logprob': -0.1395083221734739, 'compression_ratio': 1.3722627737226278, 'no_speech_prob': 0.07356463372707367}, {'id': 247, 'seek': 203278, 'start': 2032.78, 'end': 2062.06, 'text': ' how will you go about doing this? How will you go about building it in LLVM? So iterate', 'tokens': [50364, 577, 486, 291, 352, 466, 884, 341, 30, 1012, 486, 291, 352, 466, 2390, 309, 294, 441, 43, 53, 44, 30, 407, 44497, 51828], 'temperature': 0.0, 'avg_logprob': -0.1309677141684073, 'compression_ratio': 1.1917808219178083, 'no_speech_prob': 0.8907971382141113}, {'id': 248, 'seek': 206206, 'start': 2062.06, 'end': 2082.18, 'text': ' over all basic blocks. How will you maintain the points to relations? What is union? You', 'tokens': [50364, 670, 439, 3875, 8474, 13, 1012, 486, 291, 6909, 264, 2793, 281, 2299, 30, 708, 307, 11671, 30, 509, 51370], 'temperature': 0.0, 'avg_logprob': -0.3823464062749123, 'compression_ratio': 1.3237410071942446, 'no_speech_prob': 0.07702305167913437}, {'id': 249, 'seek': 206206, 'start': 2082.18, 'end': 2086.98, 'text': ' are going to disjoint set union, right? Okay. So that is a very good, actually that is the data', 'tokens': [51370, 366, 516, 281, 717, 48613, 992, 11671, 11, 558, 30, 1033, 13, 407, 300, 307, 257, 588, 665, 11, 767, 300, 307, 264, 1412, 51610], 'temperature': 0.0, 'avg_logprob': -0.3823464062749123, 'compression_ratio': 1.3237410071942446, 'no_speech_prob': 0.07702305167913437}, {'id': 250, 'seek': 208698, 'start': 2086.98, 'end': 2093.1, 'text': " structure which is used in Steingart's. So that is why it is able to make it almost linear time.", 'tokens': [50364, 3877, 597, 307, 1143, 294, 3592, 278, 446, 311, 13, 407, 300, 307, 983, 309, 307, 1075, 281, 652, 309, 1920, 8213, 565, 13, 50670], 'temperature': 0.0, 'avg_logprob': -0.1800376933108094, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.48998942971229553}, {'id': 251, 'seek': 208698, 'start': 2093.1, 'end': 2100.22, 'text': ' So essentially now, essentially what you do is you maintain these sets and whenever this merging', 'tokens': [50670, 407, 4476, 586, 11, 4476, 437, 291, 360, 307, 291, 6909, 613, 6352, 293, 5699, 341, 44559, 51026], 'temperature': 0.0, 'avg_logprob': -0.1800376933108094, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.48998942971229553}, {'id': 252, 'seek': 208698, 'start': 2100.22, 'end': 2106.46, 'text': ' happens, you use this union-fine data structure to do a quick merge of these different sets', 'tokens': [51026, 2314, 11, 291, 764, 341, 11671, 12, 69, 533, 1412, 3877, 281, 360, 257, 1702, 22183, 295, 613, 819, 6352, 51338], 'temperature': 0.0, 'avg_logprob': -0.1800376933108094, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.48998942971229553}, {'id': 253, 'seek': 208698, 'start': 2106.46, 'end': 2115.18, 'text': ' and keep on assigning it to the respective, to both of them, right? So any questions on this?', 'tokens': [51338, 293, 1066, 322, 49602, 309, 281, 264, 23649, 11, 281, 1293, 295, 552, 11, 558, 30, 407, 604, 1651, 322, 341, 30, 51774], 'temperature': 0.0, 'avg_logprob': -0.1800376933108094, 'compression_ratio': 1.6406926406926408, 'no_speech_prob': 0.48998942971229553}, {'id': 254, 'seek': 211518, 'start': 2115.18, 'end': 2118.8999999999996, 'text': ' We did a very quick thing. Some people have to leave at 5, so I wanted to cover it.', 'tokens': [50364, 492, 630, 257, 588, 1702, 551, 13, 2188, 561, 362, 281, 1856, 412, 1025, 11, 370, 286, 1415, 281, 2060, 309, 13, 50550], 'temperature': 0.0, 'avg_logprob': -0.3286630785143053, 'compression_ratio': 1.1523809523809523, 'no_speech_prob': 0.6821376085281372}, {'id': 255, 'seek': 211518, 'start': 2118.8999999999996, 'end': 2124.3799999999997, 'text': ' Okay. So we can close off this thing.', 'tokens': [50550, 1033, 13, 407, 321, 393, 1998, 766, 341, 551, 13, 50824], 'temperature': 0.0, 'avg_logprob': -0.3286630785143053, 'compression_ratio': 1.1523809523809523, 'no_speech_prob': 0.6821376085281372}]