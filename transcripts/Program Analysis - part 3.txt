 So, let us start with data flow analysis. So, now in data flow analysis we will start with four important class of optimizations. The first is what is called liveness analysis. The second is... The fourth is, we forget I will come to it later. Liveness organ, available organ, reaching the Okay, so let us first try to understand the four analysis. So, liveness analysis says that if I have a program for every statement I would like to figure out. So, essentially it says that now I can talk in terms of control flow graphs because you all understand control flow graphs and for the time being let us assume control flow graphs which have only single statements just to make our life easier. So, now in liveness analysis what I want to do is I want to figure out if there is an assignment to a variable x from that point onwards is there any future use of x or not. Right, why would I be interested to do that? Because if there is no further use of x along any path from x from this assignment to x I can simply discard this statement and that is what is called dead code elimination. Right, the second thing that we would like to talk about is something called reaching definition. So, what does reaching definition say? Reaching definition says that let us say I have a program So, look at this particular program. Right, so what I might be interested to figure out is that whenever you reach this particular basic block this particular expression x times y has already been computed along all paths. So, essentially it means that oh sorry this is available expressions. So, this is available expression. So, essentially in this case what we say is that this expression a star y is available. Right, what it means is why would I be interested in figuring out some expression is available or not. Right, so essentially for instance let us say you have something like z equals x star y in that case what is the optimization you can do? Right, so I can essentially compute I second say h equals x star y h equals x star y b is equal to h a is equal to h and z is equal to h. Right, so now essentially what has happened is instead like if you look at every path this path x star y would have been computed twice this path x star y would have been computed twice, but now with this optimization I am computing x star y only once. Right, and that temporary value I am being able to reuse multiple times. Right, so that is an interesting so that is available expressions. Right, so very busy expression says what very busy expression says that if you have a computation which is so it says that from this point onwards is there a computation which is happening along all paths like if there is a computation of x star y here also x star y here also x star y here also so let us say a is equal to x star y b equals x star y c equals x star y. Then again I can do something I can hoist up this computation of x star y here I can say h equals x star y and I can just assign them here. Yeah, so I come to those conditions so that that even holds for even the other cases I have not come to those let us just I try to understand these different cases but let us let us say you have talked about it so what is the condition under which it can happen. So x and y should be unaffected along that path so I should not be I should so these are modification free. Right, so there should be no updates to x or y only if that happens only then I can do this so that also holds for available expressions because there were expressions computed and I can use their values only if again along the path from where I define this a star b to the place where I used it there is no and reaching definition says that if you have a variable h equals a star b in that case I say like if you have a use later right say x equals h plus 1 right so then I would say that the definition so essentially whenever you have so what is let's me just define what is the definition our definition is basically an assignment so whenever you have x equals b plus c this is a definition of a and these are uses of b and c right so this statement uses b and c so these are the b the values of b and c are being used and the value of a is being defined so something is being put into that box right so definition and use so if it is possible through any program path a definition is being so our definition can reach a certain use then I would say that it is a it's a reaching definition problem right so again when can it not be a reaching definition thing like for instance I can have so h equals 2 for instance right there is a update to x right then so this is a definition point of definition this is d1 this is d t right so the definition d1 reaches the statement s1 earlier when d2 wasn't there but once I have d2 then the definition does not reach this location so that the reaching definition problem is that for every in the program or every state program we would like to figure out which are the definitions which are reaching but location now there may or may not be a use of that location that's a different matter but I would like to compute it for every program point the other important definition is I'll keep on using it again is this notion of a program point so so you have let's say a statement s1 and you have a statement s2 so a program point is a stable location where I can ask the state of the program so the next question is what is the state of a program so the state of a program is basically thus the vector containing values of each variable right so if you have three program variables a b and c so at every program point I would would like to figure out what is the value of a what is the value of b what is the value of c so that constitutes one state of a program and a program points are points where I may be interested in querying the state of a program so this for two statements s1 and s2 the program for valid program points is this one this one and this one so it's either before the statement has got executed or after the statement has got executed right so whenever I ask you say what happens at this program at at statement s2 and you said you should tell me that I don't know what happens at s2 I can tell you what happens before s2 or what happens after s2 what is the state before s2 or what is the state after s2 when the statement is running I don't know what's going on right so these are runtime behavior but your static analysis is also an approximation of the runtime behavior right so I will come up with instead of having concrete states of the runtime remainder I'll have abstract states which essentially say what are the possibilities that can happen here like for instance I can say that I do not know what is the value of x there but I'm sure that all the values of x will be greater than zero right so but that also I have to say at a program point I cannot say at instruction what happens doesn't really make sense right because things are changing I don't know how they're changing what is happening so I can only tell you what thing what happens so so whenever I query a state I can only query a state at a program point I cannot query a state at any other location so are we clear about the definition of these four statements of these four analysis okay so let's talk about reaching definitions let's say so how does reaching definition work so essentially so now how will you so what is the computation on so what is the set of values that you will try to output so so you would like to figure out that at any program point you would like to figure out the set of all reaching definitions so it's a set of all reaching definitions right so so the universal set from which you will be able to extract this particular set at a given point is the set of all definitions so what are the set of all definitions in the program how will you get the set of all definitions in the program all the assignment statements right so all the statements which assigned to a given variable is a definition what if there are two statements a equal to one here in one basic block and a equals one here in another basic block are they the same definition or are they different definitions now we are only doing intra-procedural analysis so they are everything is in the same function no they constitute different definitions so they will be d1 and d2 two separate definitions and it may happen that one of them reaches a program point but the other one does not reach this program point right for instance i may have like a equals three here or maybe this does not even reach this location right so so my so net let's try to formalize this whole business so i have my universal set here is the set of all definitions in the program and i can arbitrarily give names to each definition so d1 d2 d3 d4 d5 i just these are static names i just look at an instruction and say give it a name which is what what definition now can you give me some idea of how can i compute this switching definition how can you compute this set so when can a definition stop reaching anything else when it is reassigned the same variable is reassigned then it may stop uh like propagating further the other way it may not reach a given location is if there is no path that goes from this particular program point to the other program point so there is no way for this guy to go there right so there are two ways like it's like a car which is moving so the car may not be able to reach another location either if there does not exist a road which can take it there or somebody stops it in between right so it says no you cannot go further okay so now can you think of a way of computing this set of reaching definitions and maybe you can use the idea of how did we compute the dominators can you extend that idea somewhat and think of a way of doing it in a slightly more efficient manner so so let's let's think about the inefficient algorithm first what is the inefficient or the bad algorithm to compute the reaching definitions okay collect all um all definitions of the same variable like look for each variable i can figure out that if it goes to a certain set or not so let's say i give you a program point and i want to figure out what is the set of reaching definitions here how will you how will you compute it traverse it okay um then right so essentially one way to do that is like is basically collect all the program paths which are reaching from the entry point to this particular location right and for every path figure out which is the set of definitions reaching here and take a union over all of them this solution is referred to as the mop solution or the meet of all paths solution so meet means you are just taking a union over the solutions over different paths how do you figure out the solution over one path so now let's simplify our case now we take a union over all paths so now let's try to figure out how would you compute reaching definitions on a single path on one given path so how can you do that so let's current means the beginning entry point no the are you saying one from where it is now down here okay okay okay then Mason any any other ideas? Why not go forward? Right, but you will be able to get the whole set in one shot. Right, so you start with saying the set being empty, whenever I get a new, if I get a statement of the form A equals B plus C, what would you do? How will you update this state? I will put A in this set and keep on going down. Right, so if you get another A equals, like sorry I have to say that A was there and I will have to remember that it is like because it is definition D1, that is what I need to output, not A. Right, so if I get a definition D2 with A again, so here I will say D1 is in the set for variable A. Right, so when you get D2, you will have to remove this out and you say now I know that this is D2 which is the most recent definition of A. So when you reach here, you keep on doing it, so you will then you will have the most recent definitions for all variables in the program along that path. Can this work? So right now we are assuming there is only one path because we are thinking of this particular solution. But so are you convinced about this particular solution? Will this work? After this particular definition, after that statement, there is another definition A, yeah, yeah but that is another path, right, that becomes another path. So path is a sequence of instructions, so one path would have terminated here, the other path would have gone through this and come back here. So this, the problem, you can immediately see the problem here, there can be infinite paths. So immediately understand this solution is not going to work for us. But still, I mean, let us do the stupid thing first before we do something else. But at least we know that if given a path, we have a not so bad algorithm to compute the strategic definitions. Now let us try to extend this algorithm to something slightly more doable. So what can we do? So now let us say we have a control flow graph out what are the reaching definitions at this location. So at this location, maybe at this location. No. So this guy is not dominating it. But if there is a definition of A equals something that will also reach here, because there is a path through this and there is nobody stopping it here. Okay, so we start, so let us do a full summary once more, right. First, we are looking at this problem of reaching definitions. What is this problem of reaching definitions? The problem of reaching definition is that at any program point, I would like to figure out what is the set of definitions which are reaching this program point. Question was, what is the definition? A definition is something of the form D equals or A equals B plus C. A equals B plus C is a definition of A because it is assigning a value to A. Every such assignment, every such lexically different instruction in the program, no matter they look alike or they look different, constitutes a different definition. Now in my program, I can construct my universal set. That is a set of all definitions in the program. How? By simply collecting all the assignments to these, all these assignments to this in the program. So every time I get A equals B plus C, C equals A plus B plus A, I mean all of them I just collect and that becomes my set of all possible definitions. That is my universal set. Now what we want to do is, I would like to figure out that what are the set of definitions reaching a particular program point. Let us say this particular program point. How would we do that? So one solution we first figured out was a solution which is not even practical, but one way to do that would have been that I figure out all possible paths to that location from the program entry point. Along every path, every path is nothing but a sequence of instructions. Along every path, I collect what are the definitions which finally reach the final location. So how do we do that? So in the path, I start with an empty set. I say I do not know what all is there. Whenever I encounter a statement of the form A equals B plus C, then what do we do? We add this definition D1 as the new definition which may reach the final location. But at the same time, if this A redefines, if this particular definition redefines some other definition, that definition has to be removed from the set. So at every point we do two things. We do something called generation which is we add something to this set and we do something called killing which is we kill something of the set. We remove something of the set. What do we generate? The new definition that I encounter and what do we kill? Any existing definition to the same variable. So my set will always contain. So that is what this thing is. So these are the two steps that I have to keep on checking. What to generate and what to kill. Now can we extend? Now the question is instead of a sequence of statements, if we have a complex control flow, can we answer this question in somewhat not so expensive manner? So let us see what is the problem here. Till this point there is no issue at all. I can start with an empty set. Whatever definition is in this basic block, I add it to this set. Again I go to this particular location. Whatever is in this set, I generate the new instruction and if it redefines something which was in the previous basic block, I kill it. The problem is here. Whenever these two basic blocks merge at a basic block, what do I say is the reaching definition here at the entry to this basic block? That is just before the statement contained in this basic block. What should I do? I need to keep both. Excellent. Why is that? Because if there is a A equal to this and A equal to this, then both of them are reaching definition to this particular location. Both of them are reaching here. So what should I do? So I have a set here, I have a set here, so I need to take the union of the sets. So essentially what we do is, so one way of visualizing this whole business is that you can think that every definition is generating a token stamped with that location, the program point where it is generated. And then we leave these tokens to flow in the CFG. If it hits another location which has a token marked for the same variable or a statement which redefines the token for that variable, that token gets killed, it gets thrown out. Whenever it gets to a position where it can go in both the directions, either of the two directions, what does it do? It propagates a token in both the directions. And if there is a location where I have multiple arrows coming in, then I collect the tokens along all the directions. I keep on doing this collection of tokens and at any location what is the set of tokens I have becomes my set of reaching definitions. All the predecessors means how would you do it, how will you update this guy saying what definitions were there? So this algorithm, I would like to get the set of all reaching definitions at all program points, not at one program point. In one shot like the way we were computing dominators, we wanted to get the dominator tree which means I need to compute the dominators for all instructions or all statements. Similarly, here I would like to get the reaching definition set for all locations. So this algorithm is very similar to the dominator algorithm. So we compute something and extend it slightly for the next location, extend it slightly for the next location and keep on doing it till my full flow graph is full. So essentially what we do is there is a flow of information forward because we move from one basic block and the tokens move downwards and whenever we collect these tokens what we do is we take a union of them. Right? Okay. Do you sort of at least intuitively understand this algorithm? Can we try writing out or maybe it is too early but let us try. Can we try to write some equation like we wrote for dominators? So if I want to write the reaching definition at a node n, at a node n, maybe I just say it is just after the node has executed, after the statement has executed. So how do I write it? Right. So there are two things. So let us assume that I can say that if it is, let us say entry to the node, entry to n or it is exit from n. Has it become too bad? Still reach readable? Tell me when it is too, not very good at, let me type it here. Okay. So entry to n, what are we going to do? When take a union over, union over predecessors of, where p is basically the predecessors of n and I take this thing over the reaching definition of p. Okay. And what about at the exit? So now you can assume that I have the reaching definition of like n begin. You already have this, then how can I use it? Excellent, excellent. Do you all agree? So what I will do is I will just say this is RD of n begin, union the set of statements that are generated. So let us say I have gen of n, which is saying the set of statements generated at this node minus kill of n, which essentially says what are the set of definitions or did I screw it up, I should have done it the other way. Hoping that it will not create a problem, but still. So I just kill the definitions which are in this set and then union with gen. If there is self loop and something I do not want to screw up. This, do you sort of understand what is going on? Okay. Now let us come to liveness analysis. So what is liveness analysis? I would like to find out the set of statements which are. So again, how do I do liveness analysis? I want to find, so for any location. So now let us look at liveness analysis. So again recap what is liveness analysis? So liveness analysis is that at any program point, I would like to find out that what are the set of variables which have a use in the future. So in this case, what is my universal set? Set of all? No, this is liveness analysis. So liveness analysis tells me liveness analysis. It just says what are the variables which are live at a given location. Set of all variables. So this is set of all variables. And what I want to figure out is that which of these variables have a use in the future. How can I do this analysis? How can I set it up? Till the end. Till the end. So it has no future use. It means that I can, like for instance, as I said, we can do dead code elimination. Like if there is a definition of a variable and it has no further use, then that is dead code and I can delete it. Yeah, so to begin with, we will not care about that I am going to use it in dead code elimination. When we are doing the analysis, we should not worry about what the optimizations. We just ask a question and we should be able to answer that question. Right now the question is that what are the variables which are live from this location. Yes, I want to find out what variables like, what are the set of variables which have a future use. See available expressions. Come to available expressions or, okay. So let us say available expressions. What does available expressions compute? Available expression computes. I will say an expression is available at this location if that expression has been computed along all paths reaching this location. So what is the universal set in case of available expressions? All the set of expressions. Here it is a set of all variables. But you do not care about what expression it is. It has been used, it has been used, that is it. It has been used in A plus B or used in A minus B or A star B. How does it matter? It has been used, that is all we care about. Okay, so now think in a slightly different manner. Think in a similar way we talked about this token business. We generate a token and try to flow it. So where will I generate a token and how will I flow it? Excellent, very nice, very very nice. So okay, now we have an algorithm. So the algorithm is that we, so what is the set of the set of live variables at the exit to the program? Nothing, empty set, because well I am done with the program so nothing is going to be used anymore. And then what I can do is for the statement before it, for the statement before it, how can I construct the set of available, set of live variables? So let us say I have a statement of the form A equals B plus C. V and C are used, very good. So B and C are used, so these will get added to the set or these are generated when we go through this particular statement. And anything else? A was not there, yeah, that is okay, but I want to like now let us say that okay, I should not confuse you. So let us say I know what happens at exit. Now let us say I have the set of live variables at this location and I want to find out the set of live variables at this location. And this is a statement A equals B plus C. I have to kill the use of A, why is that? Because think about it, so if you have A equals 1 and again I say A equals 2, the value that got set in this A equals 1 has no use because immediately I set A to 2. So this is as good as any other place, any other thing, it is as good as not setting it at all. So if I redefine a value, if I redefine a variable, then the old value is lost. So it is no point computing that old value. So if there was a statement which let us say instead of 1 it was an expensive statement foo, that some function was computed and it computed some foo and after that I set A to 2, what is the point of doing A equal 2? Make sense? So whenever I get a definition, I would kill the definition A, whatever has been is being redefined. So what is my generated sets? The whatever is being used in the expression in the statement are the generated set, what is the kill set? Whatever is being defined is going to be the kill set. So again this analysis, how does it flow? It flows backwards. I have defined how to generate and kill statements. What about if you hit a statement like this? So if particular statement has multiple predecessors, then what do you do? You have propagated to both of them and if the other thing happens, that multiple statements have the same predecessor, then what should I do? Union, because what is the definition? The definition is if it is used in any path going through the from that location. So this is union, available expression. So what is my universal set? You guys told me that instead of all expressions in the formula. Now the same business if I ask you, if you have a statement A equals B plus C, how will you handle it? So where do you know the set of available expressions? Where is it known already? What is the set of available expressions? Like for instance, like variables you could say that the exit of the program, nothing is live because nothing gets used after that. You really nothing gets used because I just have never. Here do you see where is it? Which location you already know the set of available expressions? So now can you think of this analysis? How will this go? Okay, good, good, good, good, good, good. Intersection wise that because it should be coming from all possible paths. So I will take an intersection ensure that available means it is surely available. I am surely computed it. So I should not miss out on any path through which it has not been computed. So I take a intersection over all paths and the flow is forward or backward? Forward. And how do I do this particular thing? A equals B plus C. So how what is my how do I generate a statement? How do I generate a data flow and how do I kill a data flow? So what is the statement when I do A equals B plus C? Let us say I know what is the set of available expressions at N1. How do I get available expressions at N2? How do I do that? So what is what gets generated here? Yeah, the expression B plus C gets generated here. What gets killed? Not uses. Right. So all previous expressions, whichever expressions were there, which contained A, those are killed because they are no more available. I computed them with some value of A, but the value of A has changed now. So it is not the same value that I computed them with. So I cannot use that value anymore. Remember what we wanted to do? We wanted to store it in a temporary and use that value, but it was computed with the whole value of A. Now the value of A has changed. So that value cannot be used again. So my kill will be all expressions with A containing A. All of them get killed. So again, this is a forward analysis. This I flow the tokens forward. The generating set is the set of all the expression that gets computed at that state and kill are all expressions assigned to any or that variable is assigning. Whatever that variable is assigning to, all expressions with that particular variable participating gets killed, gets removed from the set. No definitions. Here is the set of expressions. Now the data flow facts are expressions, set of expressions. No, no, no. So again, let us go at the, so whenever you have an expression, like you have z equals A plus B, then this is a definition of z and these are the uses of A. So whatever variables are used in that expression gets killed. All variables which are, okay, so maybe let us use this term, like A equals B plus C. So A is being defined. So all expressions which have A as a used variable, as A where A is being used will get killed. And is it, or what we do at, like wherever I need to combine multiple data flow facts when I have multiple predecessors? So what should I do? I think we have already discussed it, right? It is intersection. Because I want to make sure that it is surely available along all paths. It is like no matter where I come from, it is there. What about very busy expressions? So what do very busy expressions say that from a given location I want to figure out what are the expressions which are surely computed. So these expressions are very busy. I mean they are always being computed again and again, right? So in that case what I can do is, why would I like to do this optimization? How does it help? Because the, I know, but still I am computing it only once along all paths. Okay, that is one idea. But again, they may not be the same if statement. They may be, no, you cannot do that. I am sorry. You cannot do that because somebody else might be using that statement. Oh, you can use the statement structure you are saying. Sure, sure, sure, sure, sure. But what does it help with? It does not help the computation cost. That comparison, okay, fine. But other than that what it does is mainly reduce code size. The same code of A plus B is happening multiple times. It can be large expression and then you just do it once. But it is a nice classic analysis. So we will keep it. Now how do I do this? So here how can I do this analysis? Excellent. Intersection of and so the flow is backwards because I have to do it. And what is the gen and kill? The expression being generated is a gen. So it is very similar to available expressions, right? Because I again want to say that I want to waste it up so that I can compute it once and all the branches I end up using that value. So when does it get killed? When the expression does not, it is not valid anymore. Re-definition to one of the variables values, expression variables values. So the same, it is the same business. So these are four very different analysis. But can you see some commonality here? There is a lot of commonality, right? There is, it is almost the same structure, right? So that is the cool part about data flow analysis. Now to get an image, okay. So essentially now we have reaching definitions which we have available expressions, we have very busy expressions and we have liveness analysis, right? So we have one aspect is the direction in which I need to move my analysis. In reaching definition I move it forward. In available expression, forward. Very busy expression backwards and liveness analysis backward. So the meet operator, what do I do when multiple flows meet either in a backward direction or in the forward direction, right? So reaching definition what do we do? Union. Available expressions? Available expressions surely must be available. Intersection. Intersection. Very busy expression surely must be there in all blocks. Available liveness analysis should be used along some path. Union, right? So these are, these unions are some path or any path and these are all paths. Then there is how to compute the gen and the kill sets, right? And then there is this question of the universal set. So the data flow facts. So the facts in this case in reaching definitions they are what? They are definitions. In available expression they are expressions. In very busy expression they are expressions and liveness analysis they are variables. Agreed? So now for all this analysis can I try to write a unified equation? So either forward or backward it sort of accumulates. So there are two things. One is either at the forward point or at the backward point the data flow facts are accumulated using the meet operation. That is one part, right? So one is accumulation. The second part is that once I have accumulated these values I need to say that what is going to be the value of that, of the set the data flow facts after I cross the basic block, right? This is something referred to as a transfer form. So it says that if I know the data flow facts either at the beginning or end of the basic block how do I move it to the end or beginning of the basic block respectively? That is how do I transfer it through the basic block, right? So what does the transfer function for all of them look like? Gen of n minus, sorry, sorry, sorry, I should have, where is the value? Still of n union gen of n. Really interesting, right? Four different problems. All of them have looking transfer function. And what is the accumulation thing? It just basically does either meet or union or intersection over either the successor or the predecessor of the previous or the next set of data flow facts. So the question now is that if there is and no matter what, no matter which data flow analysis you come up with you will see a very similar structure. What can change is the transfer function may look very different, the meet operator might look very different, but the idea would sort of remain the same, right? So if that is the case, the question is can we come up with a unified model of such analysis, right? Which will say that okay now if this is algorithm you can use, you can plug in your version of the transfer function, you can plug in your version of the meet operator, you can plug in like the direction which way you want the data flow analysis to work, but everything else I will take care of, right? How do I propagate it, which order I do it, when do I say I have computed the whole thing and so on. Yes, that is a very good question. So yeah, so we also have to plug in the initial set and for the moment I would say that for case to case basis you should see for yourself which works, the empty set works or the universal set works. Can you give some idea of which one will work? So initial set is like for the first or the last basic block. Now again we have the same problem if you look at it, right? We have the same problem that we had with dominators. I can apply a very similar algorithm for every node essentially now if I say that let's say right pick it for something it is easier to do it than let's say reaching definition. So for reaching definition for a given node n, now the equation turns out to be you take a union over the predecessors r d of p, right? Minus for you subtract what happens at that particular node n and you union with the gen of that n, right? So for every node n you can come up with such a equation. Agreed? So the problem is that there is a r d here sitting here and there is a r d sitting here, right? And not just that I mean this p can like if what if there is a self loop, I can immediately see that there is n can occur in both sides, right? And even if there is a longer cyclic loop there will be a transit dependency. Eventually I mean you will compute some value which through that cycle will again propagate and affect this value again. Again for this particular business I have to do this fixed point computation. The problem is dominators we could get away with removing the back edges in this case we cannot get away with removing the back edges, right? So essentially the way you will do it is you will keep on applying these equations again and again and again and again till it comes to a stage where even if you go through all the nodes apply the equations again it will not create any change to the whole algorithm, right? So now the question is that if I am going to do that I need to initialize my sets the initial sets. What are going to be my initial sets? So for liveness analysis like maybe so that is homework. For each of these cases can you figure out what are going to be your initial sets? What should you initialize every basic block width? Of course I mean there will be exception the top most or the bottom most will be initialized slightly differently because you already know that set. The others you have to initialize to either the empty set or the full set the universal set. So which case what you have to initialize it. So that is something you have to think about. So now I will just leave with this. Can we write out this algorithm very quickly? What would this algorithm look like? Or maybe we will do it tomorrow. I think we are already cross time. So have it in your just in your head try to get this going. Try to come up with a clean formulation of what this algorithm might be doing. Tomorrow first thing we will do is we will try to see if we can we will try to actually write down the algorithm and then we will argue about it. What does it why is it correct to do something like this? Why do you think it will compute the correct solution? Why do you think it will terminate? What will happen? So we will try to analyze that. Also try to use LLVM play with it. See what it looks like tomorrow. We will look at how the statements in LLVM look like. And then we will try to implement a data flow analysis. So my plan is actually that for the motivating example we saw in the class today, which was giving different results on GCC and different result on Clang. We would like to analyze that particular program automatically and try to figure out what the problem is. So we will try to write a data flow analysis to do that and then we will try to write a dynamic analysis to do that. So I know it's a little short time and I give my students a lot more time but if you have to somehow get used to LLVM. Try out a few things, struggle a bit that's okay. But get used to LLVM so that tomorrow we can do something more fun. So any questions still here? So the summary is that we looked at four different analysis and you can find out there is lot of things which are very common. So we want to extract out those things and try to come up with a unified algorithm which works for all of them when we plug in the right parameters, the right transfer function, the right meet operator, the right initializations, everything else will just work magically.