 The next topic which we are going to dive into is the object files. So remember the compilation steps which we saw earlier. So the compiler produced the textual assembly file, which was fed to the assembler to produce the object file. So we will first look at what is object file and what all it contains and then we will go into details of assembler and linker on how they operate with these files. So object file is essentially a file which has the machine code which is produced by the assembler and whatever is the related data for it. Now in most common cases the object file itself will be stored as a binary file. It will not be a text file. But there is no rule that object file has to be a binary file. In most common cases it is done that way because it allows linker to efficiently process that input. If you had an object file which was textual then linker needed to deal with lot of strings and ASCII which slows it down. So in most common cases you will find that the object files are in actually binary form. And what is in the object file? So we need some way to hold the instructions which were generated by the assembler. So MOV instruction in its binary encoding form. We need some way to say that there is a variable called GBL which was initialized to value 5, 6, 7 whatever. So this is the core information which we need to store in the object file. Whatever is the data of your program and whatever are the set of instructions which it is supposed to run. But object file needs to have some more details for linker to operate correctly. For example object file needs to have information in terms of what all is defined in this object file and what all is referenced in this object file but not defined. For example remember we had int GBL in one file and extern int GBL in other file. So somehow we need to record the information in the object file that GBL is referenced in this file but it is not defined here. And in the other files, in the other object file we need to say GBL is defined here and that will be used by linker to actually merge the inputs together. So there are three forms of an object file. The first one is called as relocatable object file. So someone had question at very beginning of the session on what is a relocatable object file. So relocatable object file is the one which is actually produced by the assembler or compiler for that matter. It represents that it is not the final thing which can be loaded into the memory. So it is an object file which may have references which are not defined in that object file. So for example when you compile something and if it has a external reference which will by another object file then this file cannot be run directly because we have to first resolve that dependency. So dependencies are not resolved and that is typically an relocatable object file. It is called relocatable because it gets relocated first before it can be loaded into the memory and we will get into details of what exactly relocatable means as we learn the linker part. Then there is a executable object file. So executable object file is the one which has all the dependencies sorted out and is something which is now ready to run. So when you produce a.out in your program it is actually an executable file. When you produce .o file it is a relocatable object file. Then there is something called a shared object file which is essentially you might have seen these files on your Linux or Windows machine which have .dll extension, something .dll or something .so. So these will be the shared object files and we will get into details of why they are needed. So let us say I told you that it is in the binary form. So what format it actually follows. So again this is a platform specific things. Different platforms will have different object files. There is something called as .cof, a binary file format called .cof which stands for common object file format. This was actually introduced in the first Unix implementations. Then there is something called as .pe which is portable executable. This is the format which is actually used on Windows. So the .exe which is produced on Windows files, Windows platforms is actually in .pe format and it is a derivative of .cof. So .cof format defines something and then .exe format is very similar to that. Then there is something called as .elf which is what we will actually study in this class. So .elf is actually a binary format which is used on Linux and related operating system. So anything which is a derivative of Unix like Solaris other things use .elf. .elf is also used by lot of other things. For example, CUDA from NVIDIA uses .elf format for storing the binaries. PlayStation 3, PlayStation 4 binaries are stored in the .elf format. So it is kind of very widely used and that is why we will focus mostly on .elf in this class. Whatever concepts we are teaching on what goes into the object file, the same things will need to be stored in .cof as well as .pe just that the format in which they are stored will be different. And then there is Maco which is essentially used on the Mac platform. So given a file, how do you determine which file I am dealing with? So there is a Unix command called file. So if you do file on something, it tells you actually what type of file it is. To show this as a demo, so let us say I had this program. So when I do gcc-c sample.c, I have produced sample.o file. And if I do file on sample.o, it says it is a .elf file which is 64 bit and it is relocatable, which is what we had seen earlier. Now if I do say dash m32 which tells gcc to compile for 32 bit and if I do file again, you will see now it is .elf which is 32 bit and relocatable. So there is some information in the object file which is helping file command determine what type of file it is. Now let us look at gcc-sample.c. I produce an executable file and I do file a.out. I see it is a .elf file, but it is an executable. It is not relocatable. And then there is a bunch of other information. The file command helps you determine what type of file it is. Now there are various tools which you can use on Linux to examine the contents of the object files. There is a command called objdump which we will heavily use in this class. So objdump is essentially will dump the content of the object files. And objdump works on any type of object file. It is not sensitive to a particular format. For example, I can use objdump on a.exe. Just to show you, so I have windows also on my, so my machine is actually windows. So I will create. So let us say I have, so say I create some program. I am using gcc even on windows because I have sigwin installed, but it could be a Microsoft compiler. Now if I do a.exe, you can see actually file command was able to detect it is a pe file. It did not say it is a .elf file because this was on windows. And objdump is actually capable of dumping this, something about it. We will see more details. And similarly objdump can dump even for this. So objdump is a tool which can be used to dump contents of any object file. Nm is a command which can be used to dump various symbols from the object files. Then there is something called as readelf which is essentially specific to elf. If you know that object file is elf, then you can use readelf to read various parts of the elf file. Similarly there is something called as dumpbin which is on Microsoft windows which can be used to dump various contents of the pe file. In this class we will mostly use objdump and readelf. But I just wanted to list these so that you are aware that there are various tools. Now let us look at elf. So elf is actually a format which can be used for all the three types of object files. So elf can be used to represent a relocatable file and typically has extension dot o. Elf can be used to represent an executable file which typically has extension dot out. And elf can also be used to represent shared object file which typically has dot so extension. Now if you look at the elf structure itself, this is how elf organizes information in the object file. So the content of the object file can be thought of as set of instructions which were produced by the assembler, set of various data elements which were present in the object file. All of this is organized into sections. So there are sections, one section representing one type of data. So there will be a text section which will have whose content will be the binary encoding of the instructions. There will be data section whose content will be whatever global variables etc you have declared in your program. Now what elf does is elf has something called as elf header at the start. Elf header describes various information on where to locate other parts of the elf file. There is something called as a section header. So section header will describe the information about various sections. So section headers will have information about where is the text section present, where is the data section present and so on. And section headers will essentially point to the contents. There is also something called as program headers which we will get to when we actually look at how programs are executed. So if you look at elf, this is how it looks. So elf starts with an elf header. Then there is an optional program header. Then there are various sections in which the data is actually organized. And then there is something called as a section header table. So section elf header actually has information on where to locate the section header table. So elf header will tell information about where is the section header table present. Section header table will have pointers to various sections from which you can locate the sections. And this is what linker sees. So the linking view is what is in the relocatable elf. Relocatable elf will have information in this format where you will have information organized into sections and there will be a section header table. When elf is produced as an executable file, it has something called as segments which you can think of as something formed out of collection of sections. So segments are collection of sections. And then there is a program header table which has information about where the different segments are. Is it clear? So just to summarize, the elf will have elf header which will have pointer to section header table. And section header table will have information about various sections, where to find them and so on. Now if you look at the elf header itself, elf header always starts at byte 0 of the file. So if I have the elf file, the byte 0 will actually always be start of the elf header. So elf header is always at the deterministic position. Rest of the things in the elf could be at any place, but the elf header always has to be at 0th position. And it has information about what type of machine the elf is produced for, what type of ABI it is following, where is the section header table and so on. So you can actually do this. So if I compile any program, so I have compiled a program with dash c. If I do readelf dash h sample.o, readelf is the command which is used to read the elf file. Dash h is telling headers, display me the header from sample.o. You will see an output like this. Now to demystify this output, let us look at some interesting aspect. So it is saying that the class of this file is elf32. It is saying version of this file is 1. There is something called as os slash ABI. It is saying it is a Unix system 5 binary. The ABI version is 0. Type is rel. rel is essentially indicating it is a relocatable file. And the machine for which this file is present is intel 80386. All of this information is present in header because this can help eliminate mismatching elves. For example, let us say I give linker one file which was produced for windows and one elf file which was produced for Linux. Can linker link them together? It cannot link them together for one reason because windows and Linux might be following different ABI. If they were following same ABI, linker in theory could link them together. Similarly, can you link x86 code with ARM code? No because these are going to be different processors. The same binary bits might be interpreted differently by different processor. If add means 5 to x86, add 5 might mean LD to ARM processor. You cannot mix and match things. That is why some of these information is present directly in header. Linker can ensure that whatever files are being fed to the linker have consistent information. And then there is something called as magic which you are seeing at the start. The first 4 bytes of the file will be these 7f, 40f5, 4c, 46. If you leave the 7f part out, this is actually ASCII value of elf. So 45 in hex is actually capital E, 4c is capital L and 46 is f. So elf, to identify a file as elf, you can simply read first 4 bytes of the file and see whether they are 7f, elf and that tells you that it is an elf file. And then remaining is the structure of the header. If you look at the actual structure, this is how it looks. So the first 4 bytes are magic which are telling elf. Then there is object file class, data encoding version, ABI version, what is the type of file, what is a machine, version and bunch of other things. The interesting thing is this shof which is essentially offset in the file where the section header table begins. So if this offset value is say 1000, that means if you read byte 1000, that is where the section header starts. Does that make sense? So you have an assignment to do now. This is actually coding assignment, you have to program things. Where you have to write a C program or C++ program which will take an elf file as an input, a relocatable elf file as an input from command line argument or you can hard code it, it does not matter how you take that file as the input and read the elf header from that file. And the structure of the elf header itself is documented at this location. Is the assignment clear? So you have to open that file for reading and you have to read size of the elf header data from the start of the file and interpret that data according to the structure given here and print out these 4 fields. I will keep this structure on the slide so you can see. But it is in user include elf.h. So the question is to be able to read, so your program should read a file which will be actually a relocatable elf which you might have produced using compiler. Read the content of the elf header. Remember header is always at the start of the elf file. So if you read this much structure in the file you will have read the elf header. Is the assignment clear? Are we good with it? Can we move on? So now let us look at various aspects of program and how they map to various things in the elf. So let us say I have this program. I have bunch of variables which are defined here and then I have main function and I am doing some stack allocation and then calling a function printf. Now whatever is the content of the function is going to be instructions. So that will go into a section called as text section because that is where code goes. Then there is something called data section which is where all the initialized variables go. Then there is something called as bss where uninitialized variables are stored. Any idea why uninitialized versus initialized there is a distinction? Why cannot we have all of them stored in data section? So essentially all the uninitialized, so if there is a global variable which is uninitialized by default it will be 0. Now you have bunch of 0s and do you really want to store them in the file? Because see this value you will actually have to store in the object file saying that somewhere there is 2 in the data section, somewhere there is 10, 11, 12 in the data section. But for uninitialized variables you just need to have the information that we need these many 0s. So I need 4 0s or I need 100 0s. So imagine if I had an array of 100 elements which was uninitialized do I really want to store 100 0s? It is just a waste of space. So bss actually stands for block started by symbol but you can better remember it as better safe space because it is saving space in the object file. It is saving space without having to store 0s and it obviously does not occupy space in the object file. And then there is something called as ro data which is read only data. Now the string which is this actually goes on to read only data section. So any strings which you are using will actually go into read only data sections. So for example, I do not know how many of you are aware but let us say I have code something like this const char or rather char star ptr is equal to hello world. Can I do star ptr is equal to g? Can I do this? Why? Now you understand what makes it non accessible for writing because this string will actually go into ro data. Unlike this string hello will actually not be in ro data. data section. So that is why a pointer to a literal string is not same as array containing that string because this will actually put it in data section. This will actually put it in read only data sections. That is why you cannot modify this. What about variable x? Where does it go? Variable x which is here. How many of you think it needs to be in data section? How many of you think it needs to be somewhere else? Where? Correct. So x is actually a local variable. It will be on stack and stack is not stored as part of data section. Stack is separate which somehow so there is no information about x in the object file. There are couple of reasons for that. What had happened is all the references to x would have been changed to either esp plus something or ebp minus something or something. So there is no entity x which needs to live in the object file. Linker has nothing to do with x because x cannot be referenced from outside. So linker has no job with it. Now let us look at content of the text section. So just like we saw there is elf header. Elf header will have a pointer to section header table and there will be a section called as text section. So how do you examine content of the text section? So I will simply compile my program and use command objdump dash d sample dot o. This is the content. Now if you look at it, this what you are seeing here is the binary encoding corresponding to this instruction. So when 55 is being read by the x86 hardware, it assumes it is an instruction push ebp. So push ebp is translated by assembler into 55. Push ecx is translated by assembler into 51. Proof this is translated by assemblers to something like this. Is it clear? So what assembler, this was the textual program which you must have written. And assembler translated it into these binary encodings. And what objdump dash d did is disassembled it so that it is doing a reverse mapping of binary number to the actual text. Is it clear? Yes. I am supposed to do this. We have got gdb and we have got disassembly. Correct. So that disassembly is essentially that we have to source and get so this is it. You are talking about source or looking at assembly instructions. So during gdb you can see both things. You can see the actual c source or you can see the x86 assembly. So which one are you talking about? It is exactly same. So both of these just to give internal details. So there is something called as bfd library. Binary file descriptor library which exists on Linux. Which is essentially used by all the clients like kuda gdb, objdump and other things to actually read stuff. So all of them end up executing same piece of library code to be able to achieve this. I do not know their specific implementation but there is nothing sacred about this. x86 publishes the encoding information. So anyone can write a disassembler on their own. Now let us look at the data section. Now in data section we said init where an arr needs to be there. That means somehow I should be able to see 2, 10, 11, 12 somewhere in the data section. So if I do objdump dash dash section dot data I can actually see that. So I see that there is 2, there is a which is 10, 11, 12. So I can see somehow if I examine the object file I am able to see this content. Can anyone tell me why it is 0 to 0000 and not 000002? What is Indianness? So this has to do with the Indianness and Indianness information is also present as part of the elf header. So if you read the other bytes of the magic they are actually representing that type of information. What is the Indianness in which the file is? So for example if you look at the header it does say it is 2's complement littleindie. So you have to be able to read all these fields to be able to interpret the section content correctly. If you didn't know whether it was littleindie or bigindie you don't know how to interpret contents of the data section. Now just like data we should be able to somehow see this output as %d in RO data and we do see that. So this is actually ASCII corresponding to this. What strings command essentially does is it looks at all these sections and tries to interpret whatever forms ASCII string and dumpster. So just to show an example, so this is the code which we had. So if I do redelve... So we can see the %d string here which was used in this code. So essentially I can do strings command which essentially lists the various strings which are present in the object file. We could see there is a string called main, printf, bunch of other things but this string didn't appear there. Now let's look at the section header table itself. So remember the sh of field in the elf header had a pointer to section header. That means if I read that value and if I read starting from that byte a structure of this size I will get the elf section header. Does that make sense? No? What's the doubt? So let's look at the read. So here we get start of the section header which says 976. What this is saying is if I read from start of the file after 976 byte I will expect section headers to be present. So if I somehow move forward by file pointer to 976 and read a structure of this type I will get the section header table. Now section header table itself has information in chunks of records. So each of the section has a section header which describes the section. Each section will have a name. Name could be .data, .text, .rodata and so on. Then there is a type of section which is saying what type of information this section has. Then there are various flags of the sections and then there is offset where the content of that section lives and bunch of other information. So for example if you look at this file we get these section headers. So what I was saying is if the elf header had a pointer saying 976 from 976 I will get this data. And each of the entry in this section header table is of this structure form. Now what we can see here is essentially there is a section name which is .text, .rodata, etc. Each section has a flag. So flag is essentially saying what type of function section it is. So A here is saying it is an allocatable section. Allocatable section essentially implies that it is a section which will occupy memory when running. As it is the content of the section will be loaded into the memory and it will occupy space during the execution. X here is indicating the content of this section is executable. That means this section holds instructions which need to be executed. So if you look at .rodata, .rodata does not have X flag. So you cannot put instructions into .rodata section and start executing it because it will not be executable. Similarly you can see that every section has size. If you look at data section it has size 10 which is in actually hexadecimal that means it has size of 16. Now if you look at Y16 so this is 12 bytes and this is 4 bytes. Similarly RO data has size which is actually string length of this which is E. Each of the section has offset. This offset is telling where the data of this section lives. So at offset 78 the content of .data section is present. So within the file if I read at offset 78 I will get content of the .data section. Now to try out this actually happens I can actually do a command called od. So od is just a binary reader of some sort. It is not trying to interpret it as L for anything. What I am simply doing is to od I am saying read 16 bytes of data because 16 was the size and the start offset is 0x78. And if I look at that content it is actually content of the data section which we have seen 2ABC. Does that make sense? So remember this every section had a file offset which told where the content of that section began. And if I read that offset into the file then I actually see the content which was present in the data section. Similarly I can now simply execute this command where I say read starting from offset 88 in the file then I will get this string which is output is percent D. So remember this so far what we have seen is from ELF header we somehow can come to the ELF section header. ELF section header has offsets pointers to where the actual content is living and I can read those contents to see the actual data within the section. Is it clear? So this command is od dash x n is telling the number of bytes to read which is 16 then it has some different syntax so I was using traditional command and then sample.o and the offset. So what this command is trying to do is from sample.o starting offset 78 read 16 bytes and dump it. Ok. Yes. Correct. So any hex dump or hex editor should be able to show you the same thing. Now one of the things is we have seen that each section has a name. But if you look at the structure which I showed you earlier name is actually a word it is not a string. So it is not really storing string in the section header table itself it is holding a word. Now this word itself is an offset into another section. So strings are not really stored in the section header table. What is stored is offset of the string and the strings themselves are stored in some different section. So there is a section called sh str tab which actually holds all the section header strings and then there is a section called as str tab which holds all the other strings. And if I dump the content of that I will actually see all these strings. So to show an example so let us say so we had this elf header file. So we know that section header starts at this offset. If I actually look at the sections so it has these sections. So there is text, trail, data something something. These names themselves are not really stored in the section header and offset of this is actually stored. So if I read. So what is the content here is essentially content of the section sh str tab. And sh str tab has at offset 1 a string called sim tab then at offset 9 a string called str tab. And what is section header storing is 1, 9, 11, 1b and so on. Is it clear? So you need these string names for linker to work. For example linker needs to know that this is a section name this type and it will do something with it. So take 5 minutes write some sample program and try following commands. So you should try following commands. One is readelf-h sample.o. So you can see the elf header. So this is section headers. Then you should see then you should try this command od-n some size dash dash. sample sample dot o and offset of data section. So write some sample program where you can actually observe these things. But how to actually associate that with the symbols. So for example I saw in this program 1, 2 and 5. But how do I know 1, 2 is actually content of a symbol called arr and 5 is content of a variable called x. Or even in earlier case when I had global variables I need some way to say that this data belongs to this symbol. I can't simply have data without having a reference to those data points. So that's where elf also has symbols. So elf actually has a symbol table which contains various symbols which are defined in the program. And symbol is actually representing a location within the section where it is defined. A thing to note is elf does not hold all the variables which you had defined in your program. It only holds variables which are relevant for linker. So it holds all the symbols which are global. So any module scope variable which you declare as a global variable will be in the elf symbol table. So any non-static function like main, foo, printf, whatever all of them will be part of the elf symbol table. Any module scope variables which you define will be part of the symbol table. Then it will also have all the external symbols. External will mean any symbol which is simply used but not defined. For example, printf or any variable if you say external in c then c will be an external symbol. And it will hold any static variables which were defined in the local scope. So it holds three symbols. All the functions, all the variables which were declared and module scope, all the symbols of the external things it could be a function or data and it could be a local symbol in which case it will be a static variable. So an elf symbol table itself holds the information in this format where every symbol has a name. Again name is not really stored as string but it is again a pointer into a different called str tab. It has value which we will get to a later. It has size. So size is essentially whatever is the size of symbol 4 bytes, 8 bytes, 20 bytes and then it has type and some other things. So if I look at this program I can dump this symbol table using redelf dash s. Note s is small here. For section headers we were using capital S and this is how the symbol table looks. Now first thing you have to realize is for every symbol there is a type. Type is indicating what type of symbol it is. So main has a type called funk. So it is saying main is some function symbol. Arr is some sort of object symbol. So any variable is called as object in elf and any function is called funk. So every symbol has a type. Every symbol has a size. So for example in it where you can see it has size of 4. Arr has size of 12 and in it where has size of 4. So size is size in bytes of that symbol. Then there is something called as value. Now value is unlike the term value it is not really representing content of the symbol. So if you look at var 1 it says 10 which is 0x10 but it is not really the value of var 1. It is really the offset within the data section of var. So value is essentially representing offset within the section. Is that clear? So if you look at it that way so what this is saying is in it where is at offset 0 in the data section. So if you now print data section of this the first thing which you should see at 0 byte is actually content of in it where. That means you will see 2 first. Then it says Arr is at offset 4. Why 4? In it where is 4 bytes so Arr must start at 4 bytes after that. Then it says there is var 1 because this is occupying 12 bytes so this must start at 16 and there is something y which is starting 4 bytes after that. So the content of data section according to this symbol table is organized such that first the value of in it where is stored then the value of Arr 3 is stored then the value of var 1 is stored and then the value of y is stored. So if you actually dump the content for this program you should see content in that order in the data section. Is it clear? How to interpret this field? Now every variable also has a section. So if you look at this ndx field it is called a section index. This is actually an index into the section table. So what this is saying is in it where has section index of 3. What that means is if you look at the section header it is the section header 3 actually holds dot data. So what this is saying is in it where is a symbol which is defined in dot data section at offset 0. Arr is a symbol which is defined in dot data section at offset 4. Is that clear how we are trying to relate all the fields together now? So for every symbol you had some data which belonged in dot data section but how do you know symbol and dot data section are associated by this ndx field. Now if you look at this something called as printf it actually has u and d. This is telling that printf is actually not defined in this file because there is no section which holds the content of printf. If you look at main, main actually has one which means it belongs into dot text section. So main is defined in dot text section. Printf there is nothing to define because we do not know what is the text section for printf because it will come from somewhere else. That is why it is marked as u and d. This uninit where is uninitialized and it goes into something called as com which we will see later. Is it clear? So now what you should do is write this program and examine what is the value of a symbol and whether you see the dot section content according to those values. So declare 4-5 variables with different values. So you can actually see and you can simply do this command. So what you can do is obj dump dash dash section equal to dot data and sample dot o. So let's say I have file 1 dot c where I declare something as static int myvar is equal to 5 and then I do int main byte and say I do printf percent d slash n myvar and then I call a function foo and I return 0 and here I define external void foo. So just to show you the code. So this code says that there is something called as foo which is external then there is something called as myvar which is static and then uses myvar prints myvar and then calls foo. File 2 says myvar is external and then defines foo. Now let's try compiling this. So I do gcc file 1 dot c dash o file 1 dot o. Similarly I do file 2 dot o and then I try to link these two programs. What will happen? It will generate an error. So it says that there is something called as myvar which is undefined. Why did it say that? I had myvar which was defined. It was because static because if you look at redel's output file 1 dot o it said myvar is local. So linker is not trying to say the myvar which is in file 2 dot o is same as myvar in file 1 dot o. It says these are some different things and it ultimately didn't find any reference to myvar which was supposed to be global. So that's why linker said something is undefined here. Whereas if I simply change this to normal variable and I compile my file again. Now look at what happens. Now myvar is actually global and I do gcc file 1 dot o file 2 dot o and the program links. So linker is using the information of local versus global to determine what can be external in other things and what is specific to this file only. Is that clear? Now one strange thing is why for some reason has this name y1940. Any idea why? So if I declare a static variable which was y here in main its name came as y dot 1940. But why is that needed? Like var 1 didn't have var 1 was also static. Why does it need that? Correct. So there are couple of reasons. One is I couldn't have a function called foo which also can say static int y. So I have two y variables which are actually different. So I need some way to distinguish y in foo versus y in main. That's why I need to change the name to something random and in this case it chooses 1940. Now to summarize the elf structure, this is how it looks. So we had elf header which was at the start of the file. It had a pointer to section header table. Section header table consists of individual section entries. Each section header table has a field called offset. Offset actually points to the content of the section and each section has a size which tells how much data lives in that section. Name of the section itself comes as an index into another section called sh str tab. Then there is elf symbol whose name again comes from another section called str tab. shn index field of the elf symbol table points to the section in which it is defined. So every symbol is defined in some section. Value of the symbol table is representing offset within the section where the data of that symbol belongs and size is representing the size of that variable. Is this clear? Because if you understand this metadata, you should be able to traverse elf file and read elf file using a program. You don't need a tool like read elf. So just to reiterate, elf header will give you offset to the section header table. Section header table will have the offset which is where the content of the section begins and the name itself comes from sh str tab. Symbol is nothing but offset within the section where data of that particular symbol starts and the size essentially gives how much is the size within that section associated with that symbol. Is that clear? Now quiz. So I have this code where I define a function called foo as extern. I define a variable called int var 1 and I call foo and then in the other file I say extern float var and I do var is equal to 5.0. What will happen in this code when I link together? One person thinks it will give an error. How many of you think it is an error? Quite a few people. What do others think? What do you mean by type will be default for both the elfs? Correct. So one thing you have to realize is see linker is dealing with object files. Linker is not looking at main.c and foo.c. So linker is dealing with the information which is present in the object file. Does that make sense? Now let us look at this code. Let us say I write this code in file 1.c. Gcc dash c dash m32 file 1 dot. Now let me read the symbol table. So it says that var is of some variable of size 4 bytes. Does it say it is var which is integer? Does it say that? So does linker know that main.c is defining var to be integer? No. Similarly, when it compiles foo does it know that var is float? So linker has no idea that there is var which is integer here and float here and to be able to issue the error. There is no way linker can issue that error. It is not even runtime error. For example, if you run this code var will actually hold whatever is the IEEE 5.0 32 bit encoding. So it is a logical error. There is no crash or anything which will happen. 32 bits. So var is simply saying print the 32 bit content. Whatever that is. And 5.0 has some representation in 32 bits in the floating point numbering system. It will simply print that number. Coming to that. Next question. So now I have int x which has size 4. Here I define it to be double. No, but can it issue error in this case? Does it have information to issue error? Size information is there. So here it knows x is 4 bytes. Here it knows it is x bytes, 8 bytes. So let us try that. Let us try this. So I have int var 1 and let me print y. Now here I define this to be x turned double of var. Now var is equal to 5.0. Now in this case we expect linker to give error. Because it is defined to be double here and defined to be integer there. There is size mismatch. File 1.c, file 2.c. It didn't. So linker didn't issue error for this case either. And if we print, it printed something. So what actually happened is y was also overwritten. Because this statement wrote 8 bytes of data which ended up writing 4 bytes here and 4 bytes here. So y was also overwritten. So not only linker didn't catch the error, it also overwrote something which it was not intended to. Now can you tell me why linker didn't catch it? Linker had the size information. No, so let us look at it. So best way to answer these questions is examine object files. So let us look at it. So I will do GC's. So let us look at the symbol table of file 1.o. So it says var is a 4 byte variable and y is a 4 byte variable. So it has the information that both are 4 4 bytes each. Now let us look at the same thing for file 2. So file 2 says var has size 0. It didn't say it has size 8. And then linker says that whatever is 0 could be 4 or 8 or whatever. So the assembler produced elf actually didn't hold the information that var is 8 byte value in this program. Although it was extern double. Now it's an exercise for you to figure out why assembler didn't store this information even when it had that information. Now an interesting thing I will show something more interesting. So here I simply said var is actually a variable. I could be more evil and say something like this. So var is a function which is of type void. And I will call that function. Now let us look at it. So I will now link file 1.o which defined var to be a variable. And file 2.o which defined variable to be a function. Linker still happily linked things together. So linker says var variable var function I don't care. I will just link them. And then when I execute I get segmentation fault. Segmentation fault is because when I start executing this I will jump into the data segment. And if you look at the data segment. If you look at the data segment it doesn't have execute permission. That's why it's set faulted. So linker is really lazy in figuring out what matches with what. It simply looks name. Okay var var. Does not do any other things. And it's your exercise to figure out why for the functions it couldn't do it. And why for the external variable it stored the size as 0.