 right. So we are saying if you look at this code here m was m as x and y top top on the left branch x is 2 y is 3 right branch x is 3 y is 2 what is the meet bottom bottom 2 meet 3 is bottom 3 meet 2 is bottom. So here z will be bottom right if I had not eagerly done the meet here and come like this what would have been z 5 and if I come this way what would have been z 5. So what happened I mean even though it is a constant even though it is a the value of z is a constant we could not identify using our technique and the reason being and the reason being that the constant propagation the way we are doing is not distributive that is if we take the flow function here take the flow function here take a meet is not same as is not same as doing this one first and then this one and taking a meet. What we are saying if I take this is f1 this is f2 right if I do f1 first then f2 and then take a meet and then do f3 that is not same as f3 on f1 meet f3 on f2 take a minute to chew over it if this is f1 if the flow function is f1 f2 f3 I am doing f1 f2 take a meet and then f3 that is f3 on I am invoking f3 on meet of f1 and f2 we are saying that is not same as f3 of f1 f3 of f1 meet f3 of f2 both all of them start with the same m0 some initial map right so that way what we are saying this constant propagation the way we are doing is not distributive over the meet right so we will lose a few constants here we are not losing constants because we are impregnated I mean one of the condition is never taken or anything here the conditions can be taken even then the value of Z should have been I mean we know it is 5 but the way we are doing is bottom right oh yeah okay okay okay okay okay yeah good reminder so during the in the lab yeah our friend asks that I have Z equal to 1 here I do constant propagation I get 1 here then I can do loop invariant code motion this can go out and then I can throw away the one of the Z's because the outer Z this Z equal to 1 this definition reaches nowhere right then she says so this is the order we follow constant propagation then loop invariant code motion then do reaching definition it so turns out this is not necessarily the best order among all the optimizations we study you will see the ordering is a big pain is a big problem if you do a followed by B sometimes it is good sometimes it is good if you do B followed by A there are times there are some optimizations where it is well understood that whether you do a followed by B or B followed by A it is going to be suboptimal unless you do them together okay so such problems such optimizations where there is a dependent cyclic dependency or like a a depends on B B depends on A this called as a phase ordering problem so there are some optimizations which have a phase ordering relation between themselves okay so in this case we said hey this is good to do maybe sometimes you may want to do some reaching definition so that you can throw away some unnecessary definitions and then that may lead to some optimization so the there are some optimizations which are invoked many times because you do not want to do all of them together proceed writing each optimization first pass itself is complicated now writing something together is much more complicated so compiler writers in what they do they write individual optimizations they just invoke it few more bunch of times so how many times so I mean this is kind of now lot of engineering expertise gets into so those of you care there is a book called much Nick compiler design modern compiler design if I'm not wrong the first page it shows the the flow chart of the different optimizations that are that are followed in the HP compiler GCC follows a slightly different structure but it's pretty hairy lot of so yeah so in this case we did in this order but you cannot keep on applying them forever right for example in the first example we looked at we kept doing again and again and again so when do you stop yeah so then it will take yeah so why author way author way saying why don't we do one thing let us try to reach a fixed point here let me take one do to do do do do till the end something changed again take this keep on feeding it to the same thing that's also not there are two challenges there number one the time how much time are you ready to give for compilation right and then there are optimization phases where one does X the other does X prime so it may keep changing some some bit then let's say you say no no let me not let me drop those things which are kind of going against each other but only focus on that yes as long as it's changing I'll keep on doing the time takes a lot of time okay yeah okay any questions on the distributive nature of this all right correct it doesn't matter right okay let's say let's take a guess let's say we are building some database software say Oracle right take a guess how much time it may take to compile that huh I couldn't hear you I heard some one I didn't hear the unit I'm sorry no no let's say we have a powerful computer pick you tell me what are the server class machine on which they will compile it's the order of days if it is in the order of days your comp if it takes to compile just one round now you want to do multiple rounds it's kind of pretty we are talking about a tough thing and the worst part is when I start compiling in the compilation phase you have seen right I start with high level code then one IR then lower level then lower level then I reached a very low level IR and finally machine code and there some more optimizations are done now if you want me to again optimize that then I have to again get back the structure which is which may not be I'm not be able to do all the high-level optimizations all the high-level IR I may not be able to reach there at all I'm saying assuming you reach it takes a lot of time but reaching there itself is hard so pretty much no compiler does this forever because I mean practically it's much harder I do not know yeah it depends on the optimizations I do not have a reason to say it will not terminate I do not have a reason to say reason to say it will terminate depends on the optimizations involved so I do not have enough information to make a comment on that right so what we are seeing the constant propagation is not distributed an interesting property to note okay let's look at a piece of code we said as part of optimizing an if condition we said if we have code like this if I know the condition is true I can throw in the then or the else part but that is another optimization constant propagation is another optimization during constant propagation let us say I had some I here not necessarily one some value during constant propagation I found that at this point value of I is going to be one now I need to do something otherwise during constant if I do constant propagation like this let's say it's I equal to some case some computation and I found I equal to one and then if I do not deal with the then and else part I will say J is not a constant here right why because J is one year J is two year meet is bottom correct now you may say look let me do one pass of constant propagation where here till here I will get I equal to one right so I have a statement I equal to one then invoke if simplification come back do constant propagation again good so I did this then let us say there is some more if part inside then here then again do constant propagation again do if switching if simplification keep on doing it will take lot of time right so what we will do we will do something called conditional constant propagation as an extension to the basic Kildar's algorithm that we talked about so this is this is the 1975 paper and an extension that we may if we have time we will go over an extension of this 91 paper this 91 paper we are talking about Wegman and Jadak paper we will go over this work and if possible an extension to that if time permits okay so what's the idea during the constant propagation algorithm execution if I find that branch is see at this moment I may say that hey only the then branch can be taken right then why should I process the else branch see the J became a bottom here because both the L then and else branches were both processed at this point I know that only if I know that only the then branch will be taken why should I add the else branch to my work list that's the basic intuition let me add only those branches which are which I know will be taken right if I know that only one branch will be taken then let me add that branch during processing if I find that no no the else branch will also be taken then I will add that but let me not add them eagerly let me evaluate the condition depending on the condition add either the then branch or the else branch or both depending upon the value of the condition the intuition is clear so I see all types of head shakes some like this some like this some like this some like this so that that's pretty confusing do we have a yes good so this is something that you have seen right I mean the head shakes the traditional understanding is this is yes this is no we also have this and sometimes we have I mean an eight type of I know so what does it mean maybe or don't care how it's a bottom I have no clue what's happening bottom would be okay okay okay we will try to take this intuition that we had so far and now we will design an algorithm so what's the main idea with each block I will have a Boolean flag that says is the block executable or not I will process only executable blocks if they are in my work list if a block is not executable I will not process it okay so to start I again I am saying I'll only process the blocks which are marked executable to start I will only process the entry node so let me be kind and mark it as executable okay if I processed one node you have processed one node that means it is executable after processing this node what should I do let yeah so one point so either there is a condition at the end of it that means it will have multiple successors or there is only one successors both are possible so if I am if I am processing a node and this node has only one successor that means if I am executed executable my successor will also be executable right so if the current node has only one successor that means if I am executed my successor will definitely be executed so let me after my after finishing my execution I will also mark my successor as executable right if I have multiple successors then what that means I may if my basic block ends with a condition the condition can be true or false let me do one thing like I did here this condition is always of the form either y of z or some Boolean right so let me look up this Boolean value in my constant propagation map constant map in the map if it is true I will mark the then branch as executable if it is false I will mark the else branch as executable if it is bottom both as executable if it is stop I will mark none as I will not touch them right what I am saying I will evaluate the condition during the constant propagation using the current constants map if the constants map tells me that can we close the laptop if you are not using it to take notes if my constant in my constant map tell me that the condition will evaluate to a constant then I will take either the then branch if it is true and if it is false I will take the else branch rather I will mark them as executable once they mark them then they will be processed in the and remember I am not changing once I mark it executable later I am not coming and saying oh hey I will make it non executable once I mark it executable it remains executable and this is consistent with our idea of monotonic progress where if I have true now in future it will not become false now it is true in future it can remain true or become bottom similarly now if we now if it is false in future it can be false or bottom but it will never become only true correct okay and we will iterate till there is no change I have now two lists one sorry I have two things to keep in mind has my because of my basic block did the constant map change or did any new block became executable even if my constant map has not changed if some exit new block has become executable then also I want to continue processing okay what we will do we will take the previous example for this and one more on the board and try to do it okay so in this case what is my M here let us say I am J I is top J is top after this statement 1 comma top so now this was executable right after this is processed I will mark just the this block the header I will evaluate the header because this so let us draw the CFG for that rate the CFG would be oh I am asked to write only on one side so my CFG would be right so now I I mark this one as executable process this right what is the end of processing this my M will be 1 comma top I J and now since it has two successors I will check the condition is a condition true the answer is yes then I will mark this as executable okay and then I will process this so after processing this it will be 1 comma 1 right after processing this it has only one successor so I will mark this guy as executable so here it will be it came as 1 comma 1 it goes out as 1 comma 1 it has no successor so I will stop and now I will do so my constant identification is done I will make one more pass and wherever the constants are there I just replace so the here this is a constant I will replace it with 1 here I will replace it with 1 comma 1 I have not removed this part now you can do a so the constant application 1 equal to 1 will become 0 sorry it will become true right so now I have a code that looks like this I equal to 1 if true do this false do that now I can do if simplification well if simplification job is to only remove the just look at the condition and throw away unreachable code right trivially unreachable code so now this can go away make sense if you are fine we will take an example and want you to let me see if I can write the example here itself oh this guy doesn't like to add blank pages is it now this is not going to let me write I am bad at doing that this is going to be fun you will see some interesting aspects we will do in steps in the same we will just take the same code and write yeah some minor addition to that code so do this until some condition and then print ij let's let's see what constants do we get keep an eye on your what is executable okay okay for each statement keep marking okay okay so okay you know fault here good question so she says all these optimations we are talking about it just because the programmer has been extremely lacks in writing the program if he had done his job well then probably it wouldn't have happened the answer is yes and no I think it's worth telling a story here in 1950s when the first compilers came into existence people started pushing for using compilers programmers hated it programmers said no we will not use the compiler I can write better code than the compiler okay okay so as the program became bigger and bigger it was becoming very challenging for the programmer to write very efficient code but in those days programs weren't as big and the program and the compiler was not getting getting as optimized code for those small codes but slowly the compiler optimization became more and more powerful the program became bigger so the programmer just couldn't manage like keeping it modular you can optimize individual functions but what about across functions maybe you are causing a library you have no clue what the library does the program the compiler knows what the library does what you do you didn't write the library you didn't write the third party software in industry those who are in industry they are 15 member team each person is writing different code right and all of these is compiled together right so yes if the optimizer will have no work to do right because they got a library code whatever is done is already done it there examples we are giving on the other hand are deliberately toy examples right because because I am putting them up on the fly and but if you look at the real world programs you will see tons of these things yeah yeah yeah yeah yeah done done so what is it? I will be constant is it? true true so you mark this as executable when you do I equal to I plus 1 what is the value of I? 2 good good no no if it is true what is the value of I? it will be 2 how? because of I plus 1 no you will do a meet here and that will be? bottom bottom and then which one will be executable? this will be executable no no so if it is bottom both are executable if it is bottom both are executable so mark both of them as executable and then? are we done? yes sir bottom bottom how are we? sir I am confused like when I am taking the plan I will definitely mark this as executable and next round the value of the data is going to follow you got I equal to 1 you missed the I plus plus so now what will happen? value of I will be? it will remain it will be? it will be what? it will become 2 and then? no from here you will come to the while condition and while condition you can go either here or here which is executable? it will consider both of them as? no what is the value of I? I equal to 1 and now I have to mark both the parts make sense? make sense and once you take both the parts what will happen? how are we doing? how did you mark both as executable? I is 1 so J equal to 1 therefore I mark this I becomes 2 here and then? condition and then you are going back to beginning so what is the value of I at the beginning? sir you go here yeah what is the value of I? 2 no sir you are making I equal to you made I equal to but at this block how many predecessors does this block have? no this block has 2 predecessors coming from top and coming from here so you are taking meet of? 1 and 2 meet of 1 and 2 will be? no meet of 1 and 2 will be? the constant of the relation I have any two constants they are different depending on the meet they will become bottom so I will become bottom if I become bottom what will happen? if I become bottom it will take the value which is recent no it will take bottom because we cannot keep only the rate see when I have to start processing a block I have to compute it in M what is the in M in this statement? whatever is coming in it has two predecessors sir you are taking meet right? make sense? yeah so if it is bottom what will you do? take the meet of 1 and 2 see right? so I is bottom then what will you do after that? so at this point value of I is bottom value of J is 1 what will you do then? continue processing may I? value of I is bottom and J is 1 because that is what has come so from here I equal to 2 and J equal to 1 came and you take a meet with I equal to 2 J equal to 1 this is coming from one branch from the top branch what am I getting? 1 and J equal to top what do I get? meet I equal to bottom J equal to 1 one meet top is 1 so now you take this and process this statement process this condition is the condition true or false here? should be false no we do not know what is the value of I? I is bottom so is it true or false? no no no we do not know that if we know it so in round 1 it was top top after I equal to 1 it became one top I will evaluate this condition so this was executable I marked this as executable then this is marked as executable this is marked as executable and I equal to 1 true or false? true which one will I mark as executable? I will mark this as executable so here it was 1 comma top so after executing so here also it was 1 comma top after executing this it became? I am just marking it here in and this is out was? 1 comma 1 okay after executing this how many success this guy has? 1 so it will mark its successor as who is its successor? I plus plus this guy so this is marked as executable these two are not marked executable yet then what is the in for this? 1 comma 1 after executing it so 1 comma sorry it was 1 comma 1 and after executing it became? 2 comma 1 okay how many success it has? 1 it will mark the condition as true I mean executable and then I do not know the value of condition it is some bottom so I will mark both its successors as? executable executable how many successors it has? the print and the do so mark this now I have to process see the out of this guy it was initially top top it became 2 1 right so when I add these two they are not only marked executable but their in has changed so I will look at its previous in okay previous in was something now it is changed now it will again I have to compute its new in anyway how do I compute its new in? how many predecessors this guy has? 2 I will take a meet of its in from left side in from both the branches so I will take a meet of 1 comma top and 2 comma 1 which will be meet of 1 and 2 is? bottom and top and 1 is? 1 now I will process if i equal to equal to 1 so incoming is bottom comma 1 what is the value of i? bottom is the value of i is bottom what is the value of this expression? bottom there is nothing called don't know there is nothing called there is I only all my expressions take values of constants top or bottom that is the only values I can have right so if i is bottom this expression is value is bottom which one will I mark as executable? both both okay so I will take j equal to 1 something as j since it was different from what I had before so after executing this it was it took bottom comma 1 and output will be bottom comma 1 here the input was bottom comma 1 output will be? no no output of j equal to after j processing j equal to bottom bottom no bottom 2 right side is 2 here right side is 2 so if initially j could be bottom but after processing j equal to 2 it is 2 so it is bottom 2 now there is a join point here so processing i plus plus it has two predecessors in the previous case the predecessor was giving only bottom because I was not processing it it was only giving me top for from its side but now I have one side bottom 1 the other side bottom 2 so the in for this i plus plus is bottom bottom bottom in comes bottom bottom if I do i plus plus what is the value of i when the old value was bottom bottom so the output is bottom comma bottom after this I come to while so now that all are marked executable I won't talk about what is being marked as executable I will only see is there any change so previously it was 2 comma 1 now it is bottom bottom right so I come here something has changed I will say okay hey add this guy and this guy to my work list this is already there in my work list let me add the do let me take now a meet to process this do statement I have to take a meet of its predecessors so what is the meet of the what are the predecessors from here it is going bottom bottom from top I am getting 1 comma 1 comma top 1 comma top so what is the meet of bottom comma 1 comma top bottom bottom in is bottom bottom out is also bottom bottom and now is it different from what was there before yes it was this was before this is new so something has changed so I will process this and I will its output output is also changed bottom bottom so I will process this if I process this in comes sorry in comes bottom bottom out is bottom one bottom one good this same as this bottom one and bottom one nothing has changed so this guy says I do not need to add my successor because I mean nothing has changed I mean nothing has changed but the way we have done we are saying if my in has changed add my successor my successor will decide whether to proceed further or not so what I will do I will mark I will say hey do process this we will hold on to that and similarly j comma 2 this j2 in comes bottom bottom out goes bottom two and at the meet it becomes bottom bottom now this i plus plus will say hey my in previously was bottom bottom now is also bottom bottom nothing has changed so it will not add anymore what is there in my work list only this print so print the in comes bottom bottom it is not assignment statement so nothing changes second iteration second iteration here one two three four bottom one in came bottom comma one out was bottom comma two yes see if I do not know what it can be let us say it is a function that I library code or some function call or something that I do not know then what will I assume it could be true or false right bottom everyone on the same page if you look at it even though during the analysis the middle of it it you had a case of hey something becoming true only the then branch was becoming true later both became true some of you said no no no where is the code yeah some of you said erase that code is it fine code is here code is here some of you said in the second iteration value of i will be two at the beginning no value of i will not be two after meet it will become bottom value of i is two here but after meet it became bottom otherwise think about this way if you keep if you do not take the meet the value of i will keep on increasing right one question that might come to your mind what if the loop never terminates in practice in what if the loop is such that this is here what if it is this this is the code while true you know it to be true what will you do the execute will not become executable okay that is fine so what you are saying the print will not become executable okay but the question is will you terminate no i will terminate yeah terminate so the question is in the modified example my while has only true has its condition so will i terminate so will i terminate the yeses are still murmurs here few murmuring no's as well i want a firm yes or a firm no i still hear both so those who are saying yes can you give a reason why it is yes or rather let me do the other way around those who are saying no can you say why it say no why it won't terminate why you fear that it won't terminate i is constantly changing let us see what will happen i start i equal to 1 right after it became i plus plus it became i equal to 2 and then i come back here because it is true i don't mark this as executable i come back here what is the value of i what is the value of i bottom because i took a meet of 1 and 2 once it became a bottom i will see i did not add this do this statement back only because this was true i added because look something has changed something has not changed and i don't care right we said we will keep on iterating till either a new executable block is added or something has changed this is already executable it is marked executable even before i am not resetting its executable it is a mutable bit right those who are saying yes it will definitely terminate not just in this example but any example what is the argument we will draw everything will is it gapped let's start it would change if it doesn't change then it would terminate good the key is let us say some variables values do not change for example let's say there is no i++ the value of i is not changing what will happen it will remain 1 value of j will in this case remain 1 but will we terminate will we terminate why will we terminate no change why will we terminate because there is no change make sense yes good if value of i keeps on changing then exactly after some after few steps of our analysis we have finite values that i can take we cannot take infinite values for the variables since it will take finite number of variables we can take infinite number of variables we can take infinite number of variables we can take infinite number of variables since it will take finite number of values we will terminate make sense so it doesn't matter whether user program is an infinite loop or not we are not an infinite loop that's a good point i like this let's do this i will make some minor modifications under some conditions i will make aha aha i am just being evil i like it so value of j is flipping between 0 and 1 it was 1 it was 1 it was 1 it was 1 it was 1 0 and 1 it was 1 it became 0 0 and 1 0 and 1 0 and 1 and yeah so okay my handwriting right so let me read i equal to 1 j equal to 1 if j equal to equal to 1 i plus plus and j equal to flip basically if it is 0 make it 1 if it is 1 make it 0 and the way the code is designed both i and j will keep flipping we k our values are always going in one direction but now my i will my j will flip and it will flip i so will i go into infinite loop so so so so so so so so so so initially i will be 0 after one iteration it will be 1 but at the end of the iteration when i take a meat it will become bottom let them flip in real in the real world in the abstract world we wont go to infinite loop are you guys convinced of this anyone who is not i can go over it no issues but this is kind of a very a beautiful point here that even though the values keep on either increasing decreasing or going back and forth it is not that only when it is increasing continuously we will hit a bottom for us we are not checking whether it is increasing or not we are seeing it is different or not