 So, when I here at the end of this end of the round you have bottom bottom. When you come back at this point it is bottom bottom. What is the value of your map after j equal to 3? Bottom 3. It is not bottom bottom and has the value instead of going only one direction has gone in the other direction? No. The value for each at each end of each statement it should go in one direction. At the end of it here it was bottom 7 it became bottom bottom. So, in one direction here it was bottom 3 remain bottom 3. So, it is not that we are going in sometimes up sometimes down no. So, the monotonicity property still holds and then once you get bottom 3 here you will go to the if j not equal to 3 and then check that the in has not changed it was bottom 3 before it remain bottom 3. So, you will stop your analysis and then you will say replace the constants you will find this j has not j equal to 3 and then this j you can remove this because this j is always 3. So, this is if condition and this part can go and this will become j equal to 5. So, the code will become I think just j equal to 5 because the else part can go sorry the then part can go does not make sense why? So, with that so yeah so that was the last thing I want to say ok. So, let us do a quick recap of what we did today morning. What did we do? We started with constant propagation we started with the intro of data flow analysis looked at constant propagation we took the iterated data flow analysis the general algorithm and then we derived an algorithm for constant propagation we then took it for conditional constant propagation we are finding we are now finding conditional constants. And now I am in a dilemma I have 3 more hours to go I have 4 topics that I have in mind which I definitely cannot cover. So, the topics I have in mind are something called SSA and use that to improve the constant propagation. Second one is about flow analysis which will inlining. Third one is loop optimizations. Fourth one is dependence analysis I am nearly sure I am not touching dependence analysis because that will probably require us to go in a different direction completely. So, what I am thinking I will do I will cover flow analysis and inlining depending on time we will quickly do loop transformations then we will skip SSA and optimizations. Because I kept thinking should I pick A B C somewhere I did inky pinky ponky and this came in. So, when we say flow analysis what is flow analysis? You have been actually doing flow analysis when you did constant propagation at some level you did flow analysis to find out what is flowing what constants are flowing into different variables. So, this is not flow analysis what flows into it what flows into the expression what flows into a variable and one instance of flow analysis is what you did in constant propagation where you saw constant flowing. Another instance is let us not look at scalar variables, but let us look at reference variables. Say in Java you have when you do when you declare a variable A of type X at runtime point to an object of type X or subtypes X or any of its subtypes. Now, I want to know given a variable some such variable X what flows into it I want to know what type of flows into it that is which at runtime it will hold some object what is the type of that object what are those classes. I mean if we say that the flow set of an expression E is A B C it means at runtime this expression may hold an object of type A or B or C. If I write X equal to nu A later again both are two different objects, but for me both are of same type A. So, I am only looking at the type make sense. So, we say that if an expression E has a flows I mean the flow set of an expression is A B C it means at runtime either it can be null or A or B or C nothing else. It is a main analysis. So, whatever it says will not flow will never flow make sense. What is the use of such a flow information? Let us say in Java or any of these O languages if I have some expression E dot foo this foo can be present could be present in anywhere right the method foo can be present in many places. I want to know which foo should I call and if I know that this foo can be only present in class A because this E will hold an object of type A only then what I can do I can inline the method there, but if multiple if this E can hold objects of multi different types or where I cannot be sure then I cannot inline because which method should I inline this guy or this guy right. Here is one more thing let us say you have looked at your whole program and found that for a certain class it has a method m which is never called anyway. So, this is the method anywhere method m is called, but not from this class then in that class you can remove that code that is dead code correct. So, what is our goal? We want to find out for each expression using which I am making a call something of E dot foo types I want to know what is the flow set is the flow set a singleton set if it is singleton set then I can inline it. So, we will study two things one how to compute this flow set number two how to inline this flow set number two how to inline. So, what is our we will have an assumption that we have closed world assumption that is I know the whole program nothing else is missing all parts of the program including library they are all available and will not change. So, we want assuming we want to assume dynamic class loading this and that sometimes you have some analysis is done using open world assumption for instance when you do when in java when it does type checking for a class right it may not have the rest of the whole all the library available it still does type checking that is an open world assumption here for our analysis we will assume closed world assumption. We already know that inlining is an important optimization for over languages. So, if you can say example let us say I have a class A with a method M B extends A it also has a method M class Q has a method P S extends P and it also has a method M. So, this is also has a method P see the funny thing is when I when I say I want to know what flows into E it will impact which foo it is if I know precisely what is getting inside this I will know what is happening inside precisely what is happening in foo if I know what is happening in foo it will help me in doing more precise flow analysis. So, to know to know what is called I mean what is the type of arc I need to know who is calling M to know who is calling it. So, it is as if my analysis needs me to know what is flowing into this arc you need flow analysis to know that you need to know who is calling M, but to know who is calling M you need flow analysis. So, there is a you will see there is a recursive dependence like. So, in this case here I have a method X equal to nu A Y equal to nu B and I am calling X dot M nu Q X dot M Q X dot M Q X dot M Q X dot M nu Q which X is this here the declared type of X is A the run time type also happens to be A here the declared type is B run time type is B I could have this the declared type of this Y could have also be A when I call X dot M which M will I call X dot M X dot M what I call A's when I call Y dot M A B A B I think I need to do a quick revision of Java's how virtual functions work. If I have sir is it ok ok ok. So, I have this class A method M class B method M I am not declaring the written type and all that. So, and now I have A method X method X method I have field int f sorry some field f 1 here field f 1 A X ok if I do X 1 dot M X 2 A X 2 dot M X 3 dot M X 1 dot M which which M will it be A's M or B's M A's M X 2 dot M which one will it be X 3 dot M which one will it be X 3 dot M X 3 dot M which one will it be X 3 dot M ok A B wow 50 50 is it sorry my bad thank you yeah otherwise it is of otherwise this this should be wrong yeah B extends yeah. So, yeah so X 3 dot M will it which one will it be B or A B why B because it run time because it run time because it this is this will be resolved to object B what about this if I write if I access X 1 dot f X 2 dot f and X 3 dot f which one will it be X 1 dot f X 2 dot f not not loud enough X 2 dot f uh ok B you said A this you said B X 3 dot f joule this is allowed Thank you all right I will try same question one is I can P P X X X x3 dot f. B or A? Yeah, yeah, f is there here. Both are declared. So, some type, let us call it c. So, x3 dot f. B. So, it so happens one of these answers is wrong. So, in java the method resolution, all methods are virtual, c plus plus you have declared it explicitly. Java the method resolution happens at runtime. So, that is it depends on the runtime object. You can do it statically if you can. So, x3 dot at runtime the object x1 holds an object of type A. So, it will be A dot m. x2 holds an object of type. So, it should be B dot m. x3 holds an object of type B at runtime. So, this will be B dot m. Field resolution happens based on the static type. So, what is the static type of x1? A. So, x1 dot f is A dot f. What is the static type of x2? B. So, this will be B. What is the static type of x3? A. So, this should be A. Now, I will do this. Yeah, one minute. It is not visible, too small. Thank you. I have this bad habit of making it smaller and smaller than that. Wait, wait. Just give me just, just, just, just, just, just. I am nearly done. Okay. Yeah. Perfect. I was coming there. I was coming there. We will come to that. Let me not, I was coming there in a minute. Okay. Now, I have added a method. So, m calls foo. There is a method called bar which calls foo. Class B also has method m which calls foo. Now, I am calling x1 dot m. Okay. Which in turn calls foo? Which foo is it? A's foo. Okay. I call x2 dot m. It calls B's foo. x3 dot m. When I call x3 dot m, which foo will it call? That side is pretty silent. So, keeping silence is safe. So, let us see, know, x3 dot m. What is the dynamic type of x3? It happens to be B. Let us go here. There is a call to foo. What is the receiver object here? You need receiver object for every call, right? What is the receiver object here? The this pointer, right? What is the type of this, runtime type of this? B. So, which foo will it be? Sorry, x3 dot m here. Which foo is it? B. It is the dynamic type is? B. So, it will call B's foo. Fine. Okay. Now, if I do x3 dot bar, which bar will it call? This bar is only there in A. So, this will go here. Now, there is a call to foo. Which foo will be called? What is this pointer? B. So, it will call B's. Right? Okay. Let me write this. In foo, I am writing to F. I am accessing F here. In this foo also, I am accessing F. When I call, oh, better. When I call x3 dot bar, which bar is it called? Only one bar. If I am accessing F there, is it an F, is it reading the F of A or B? So, some of you have already said this is this dot F. Correct? What is the static type of this? At this position. Right? What is the, because this here is different. What is the static type of this in this class? B. What is the static type of this pointer in this class? A. So, this is an F of A. I am calling x3 dot bar, but I am getting the F of A. Make sense? So, this field resolution happens using static types. The method resolution happens using dynamic types. All on the same page? Declared type. So, in this case, type of x3 is A. Type of this in a class is the class name. Static type of x2 is B. And as you can easily see, the static type and dynamic type need not match. Like the static type of x3 is A, dynamic type is B. And not always you can see it this way, right? I could have written type of A is static type of x4 is A, if some condition x4 equal to nu A, else x4 equal to nu B. And here I may call x4 dot foo, right? I may call x4 dot foo. What is the static type of x4? What is the static type of x4? A. What is the dynamic type of x4? We do not know, because depends on the condition. Every variable will have a fixed static type in Java. Dynamically, at runtime, of course, it will have only one type, but statically we may not be able to know it. So, your question is, why do not we even methods, sorry even member fields, why do not we do dynamic access, right? If we do that, it is an excellent question, think about it. What we are saying? We are accessing the static fields, sorry fields using static type. Why not access the fields also using dynamic resolution? What will we lose? Something we will lose. No, no, no, well, I mean you can, you will lose a bit of static checking, but that is okay, I mean some overheads, I mean you will, what is, I mean we have to postpone some checking to runtime, that is okay. I mean some more cache type of things have to be added. Those things can be done, but we will lose something else as well. See, one thing is this checking, right? For field checking, you do not do the type checking for fields at runtime during the execution time at all. You do not need to. Why? Yeah, because it is all statically done. So, it speeds up the things, but there is something else. If you do not do, if you do the field resolution at runtime, right? How do I access my parent classes field? Let us say there is a get method, right? To access my parent classes field, the get method always returns f. Okay, good, good, good, good, good. I like this, I like this. Let us do this. No, no, no, I understand what you are saying. So, in this x3.bar, what will happen here? I am typecasting x3 to a, x3, why x3? x2 I will make it, still better. Dot 4 bar, does not matter. Okay, I am doing typecast on x2 and then doing dot m. Which m will it be? Asm or bsm? Wow, half. Asm or bsm? Asm, bsm. Wow, if you, if this was con managya kararapathi and you take popular opinion, you lose your money. Okay, this is Java 101 or C++ and any OO101. Typecast does not change the object. Typecast does not change the object. The memory has already been allocated here. The memory has already been allocated. You do not change the object, right? So, here since the method resolution happens at runtime, you look at the runtime object. What is the runtime object? You are asking, wink wink, for static type checking, you can assume an object a exists. At runtime, you are guaranteed that at least an object a exists, a or more, a or higher up, but at least an a exists, that is it. So, this will be the static type. What is the dynamic type of x2 here? B. So, it will be bsm. So, let me, why did I come to this? Do you have question on this or something else? Okay, so I should go to Java discussions. Okay, good question. We will come there. Too many context switches. So, you said I could do a typecast to get the field, does not help. If it is dynamic resolution, the dynamic field remains. See, now if to access the method of my parent class, I have to do something like super dot something, right? So, then to access the parent's fields, you need to do something like my dot super, some such complications you have to do, but in the absence of that, it is hard. So, what normally we do is we do static resolution of the fields because it avoids type checks at runtime. I can do all the type checks at compile time and just methods become the expensive one. Coming back to why do we have the cast? Now, you tell me which field it is. Sorry, which field it is? What is this expression? It is an expression of type. X2 is an expression whose dynamic static type is B, runtime type happens to be B, I do not care, but what does this tell me, this typecast? It tells me that this is an object of type A. So, the static type of this expression is A. So, when I access an F, which F will it be? A is F. So, from the B's object, you can do a typecast and get the field of my parent of B's parent. It is very simple, only two rules, method resolution, runtime, field resolution, static type. That is it. Everything, so, I have pulled, maybe this is just my bad. All the explanations should stop at the same thing. Resolution, field resolution, what is the static type, what is the dynamic type? Field resolution, look at the static type. Method resolution, look at the runtime type. So, these two, I think you will see less complication. Do not go to, oh and if this is a method of that method, do not look all that. Just look at just that method call. No, this, not location, this. Look at the type of this. To get the type of this, you need the See, let us keep the problem in a small. The problem is to find the type, the problem is to find the method. Both are different. So, in this example, for instance, perfect. The static, the errors you get, a type mismatch, they are all static type mismatches. For instance, if you have a field variable BX5 and write X5 equal to X3, what is the type of X5, static type? What is the static type of X3? A, type mismatch, type error. And now, I could put a type cast here and tell the compiler, trust me, trust me, you will get an object of B. So, what the compiler says, I shall not trust you, but I will give you an impression that I am trusting you. So, what the compiler says, okay fine, for the time being, I will let you go. So, it will compile this, but it will also add a check that will check at runtime, but in X3, indeed, there is an object of type B and if the cast may fail at runtime. For example, we have this if then else here, right, with X4 equal to nu A or nu B. So, if I write here, it will compile successfully, but runtime it may fail if it is not an object of type B. Make sense? Yeah, so we are, I mean the other classes, they are. Right, we should have a separate this thing on PL theory, summer school. PL theory is very interesting, I mean, programming language theory. You are studying programming languages, but there is a theory behind programming languages. Lot of math on why the programming languages are designed, the way they are designed. It is not just somebody's whims and wishes, okay, so that is later. Right, so now let us look at this. I am calling X dot M passing Q. X dot M will call this guy and which will call R dot P. So, this R can be type of type Q and here I am passing an S, right. So, an S can also flow here at some level. Now, it is coming here, Q dot arg and here I am not calling anything, but I could have called nu S as well here, right. If I was calling nu S, what will happen? An arg will get an S. So, if I, when I do R dot P, which P is it? Right, S or, so I need to be careful, right. So, given such a program, right, I want to know what is the flow set of X, Y, arg and so on. What is the flow set of X? Simple, right. X, I mean, there is only one guy here, that is the only assignment to X. So, flow set of X is A. It should be set A, right. Flow set of B, sorry, flow set of B is, sorry, flow set of Y is B, okay. What if I have code like this, nu Q, nu Q dot P, right. Wait, wait, I do not know why, I, it should have come later. Wait, just a minute. So, see, since it was X dot M, if I know that flow set of X is A, what can I do? This method can be inline. If I inline this method, what will I get? Nu Q dot P, correct, because whatever, not why, nu Q, nu Q. So, nu Q is the argument, right. We have not yet covered how to do the inlining, but we are just showing nevertheless. So, this X dot M, nu Q, this became nu Q dot P, because this is arg, arg dot P became nu Q dot P, right, okay. What about Y? What is the type of Y? B, can I inline this? So, B, what is, what do I do? Whatever the code, right, whatever the code there, I have to plunk it in here, okay. So, this, I am not showing the code, right. So, we will, we would not show that. And there may be some code in between, then I have to make sure that what is flowing into X, what is flowing into Y. And now, instead of just looking at the code, we will try to come up with a scheme in which we can do this in a systematic manner, okay. We want to know unique colors, that is our goal. We will use a set based analysis, that is, we will, for each expression, we will compute a flow set, right. And again, this is an approximation. This is not a, we are not saying exact this thing, we would not know it, right. And there is always a tradeoff between precision and speed, we will see how that comes. Okay. Given a variable, something like here, X3 dot bar or X1 dot m, X2 dot m, given any method call, can you quickly tell me what all the possible m's it can be? It has to be either that class or its child. This m may be present in so many other classes, but definitely not those classes, only that class and its children. So, using class hierarchy, you can quickly give me a conservative estimation of which methods can be called. This is called class hierarchy analysis, right. This is called class hierarchy analysis. You want to watch? Okay. So, class hierarchy analysis is super fast, but the precision is less, right. In this case, in X3 dot m, I will say it points to a or b, whereas we can be slightly more precise and get that this is b. Question is there? No. Okay. Fine. We will not use CHA. So, CHA is a common word people keep using class hierarchy analysis. We will instead use a method called control flow analysis. Why the zero will come to that later? Okay. So, CHA I will skip. So, using CHA, if we use CHA, for the same example, what is the flow set for X? X can be an object of type. No. Class hierarchy analysis will say a or b, right, but flow set of Y will be unique. It will be only b, because b can be anything below b, right. So, but X is not precise. So, I cannot inline X dot m. Okay. We will instead see what is called a zero CFA. Here, this is we will keep a flow. We will learn a flow insensitive version. Flow insensitive as in we would we would not remember the order in which the statements are processed. Okay. And we will also, this is also context insensitive, that is we would not remember a given call. We would not differentiate a method call from here and here. We will treat all the, we will mix up all the method calls into a single method call. So, okay. So, here is the process. We will generate some constraints about what can flow into variables. We will solve those constraints and get the answer. For each expression E, we will keep a flow variable. So, for example, if I have a program new, whenever I do a new C, whenever I do a new C, I say that C flows into the this expression. And when I do X equal to E, whatever was flowing into E will flow into X. Simple idea. Okay. So, we will say whatever was flowing into E will flow into X. But X may contain other things as well because at some other point I may write X equal to E prime. So, that will also flow into X. Again, we are not remembering the, we are not flow sensitive. I want to have a statement what all may flow into X, not what all may flow into X here. Okay. This is flow insensitive. Okay. So, if I have a method call E1 dot m equal to E1 dot m and pass E2 and the method m looks like this. It is a type of A, I have an argument small a and it returns b. If I write E1 dot m, right, and I am passing E2, it is as if I am writing small a equal to E2, right. So, whatever was passing into E2 should also pass to A. So, E2 is a subset of, this set is a subset of whatever is flowing into A. And E1, E1, when can I say that E2 will go into A? Only if E1 includes C. If E1 does not include C, it does not make sense. If C flows into E1, if C flows into E1, then whatever is flowing into E2 will also go into A. Is it too complicated? Anyone? Last part once more. Okay. Look at this way here. I have a, I have a, I have a method call here which is calling E1 dot m. Just syntactically looking at my code, I can see m is present in class A, class B, class D, class whatever. So, all I am saying one such class is class C. I am saying if, if C flows into E1, right, this implies whatever is there in E2 will also flow in A, flow into A, right. Because there may be another call which will pass some other E3 that will also flow into A, right. Because at the end, I want to answer what flows into A. Is it singleton or not? Because maybe there is a call here A dot bar. I want to know can I inline it? I can inline it if only a single type object is flowing into A, right. Okay. So, if I have a call like this, I will add a one constraint like this. And what is the type of this expression? It has to be related to the written type of m, correct. So, I will say if C flows into E1, if E1 can be of type C, then whatever is flowing into this written type of E, not just B, whatever is flowing into the written type of E can flow into this. And now you have to tell me the direction of this guy. Why am I saying this to be a subset of the right side and not the other way around? I am saying whatever flows into it can be part of the written type of this, not the other way around. Why? I am not even equating it. I am saying it is a subset. Where? Very good. First point is I can have multiple return statements. If some condition return, if some condition return, so all of those will flow into this. But let us say there is only one return, then what? Correct. See I do not know which m will it resolve to. This may be in class C1 or C2. I am saying if it is C1, this gets added. If C1 is present, if C2 is present, something else will get added to the written type. Because if I write here some variable D equal to this expression, D will get any of those objects from class C or D or E. So pay attention to these directions. But if the bracket is missing here. Any questions? No? So this is how we want to generate constraints. So my constraint generation, we will, if you look at it, now the constraint generation is very simple. I have only every assignment I will deal in the exactly same way. I have a new allocation, assignment and function curve. I am just looking at these three. I am just looking at A, B, C. I can actually, I am not looking at the fields at this time. I load and store A dot F equal to blah and blah equal to A dot F. But they can be dealt with similarly. Let us only look at this part for the time being without complicating with store. It does not complicate much but a bit. So we will assume that all program names, variable names are different so that this X does not collide with that X. So when I say what flows into X, it is a unique name, simple. And we will use for this pointer to make it unique. See there is a this pointer in class A also in class B. To make it unique, we will say that this pointer in this, I will call it this A. Here I will call this B. We will generate the constraints and then at the end I will have some set of constraints. The constraints will be either of this form, something belongs to blah, something is a subset or a superset or something is a conditionally subset or a superset. Only three types of conditions, nothing else. So this is what you get in the beginning. Just looking at the code itself, when you do new, when you look at the new statements, you will get these elements, belongs to constraints. During when you process the assignments, you will do this propagation type of constraints and then you will have conditionals looking at the calls. And if you have these constraints, you will see that we can get a minimum, minimal solution guaranteed. We will see that. So what are my constraints? Every time I have an assignment statement, I will say whatever flows into expression will also flow into ID. What about this? Here I have this variable, this A, here I have this B. What flows into this A? What can be the type of this A? Similarly, this C will have C. Whenever you have a new C, C gets into it. If you have a method call, which is also called as a message send of some receiver dot method name, we will look at all my programs and see where this method is present. And then I will generate the constraints of the form. I will find out these methods and then generate constraints. For this ID1, the type of EXP1 will flow. For this IDN, EXPN will flow. Right? This will flow only if C, where this method is present, is present in the type of EXP. Right? Okay? And I will also generate the further written type. Since this is written EXP0, I will say type of EXP0 is flowing into this whole expression. Okay? Now, once I have the constraints, I am saying we can solve them. We will see with an example soon. For the same example, let us generate the constraints. What are the belongs to constraints? So, I will have A belongs to this nu A, B goes to nu B and Q goes to nu Q and S goes to nu S. That is it. So, that is easy to generate the starting constraints. Right? Next, let us process the assignment statements. So, what constraints will I get by processing the first X equal to nu A? I will say whatever is flowing into nu A will flow into X like this. Whatever is flowing into nu A will flow into X. Whatever is flowing into nu B will flow into nu B will flow into Y. There are only two assignment statements. What are the condition statements I have? Calls I have. I have a call here X dot M, Y dot M. I have a call R dot P. Three calls. For each call, I will have conditional statements. What conditional statement I will have? I will say, see M is present in A and B. If A flows into X, then this nu Q whatever is flowing in, that will flow into arg. If A flows into X, nu Q will flow into arg. If B flows into X, then nu Q will flow into B dot arg. Similarly, if A flows into Y, nu S will flow into arg. If B flows into Y, nu S will flow into this arg. So far so good? Okay. Once I have these conditions, solving them is pretty easy. I will, it is as if I initialize this to this and keep on pushing it. And while pushing, once in a while I will check these conditions. If this condition is true, I will make these the subset constraints. See, if I know the condition is true, then I can add this constraint. The constraints can add. So, we will see that. So, we will take one more example for constraint generation before we solve them. A implements some interface I. X is nu D and here again B implements I. Here I have a method M. Here also I have method M and I am calling nu A dot M dot M. Look at the constraints I may generate. For this, I will have, why do not we do one thing? For this, why do not we generate the constraints? That will also help us wake up. I see some of you are having bit of a trouble. Right. So, we have three types of constraints. What are those? Belongs to constraints, subset constraints that you get from assignment and method calls. Right. Let us write the constraints for this. So, three types of constraints. First type of constraints is belongs to constraints. So, can we write the belongs to constraints? What are those? D belongs to nu D, then A belongs to nu A, then B belongs to nu B and to nu C. Write those. Now, do we have an assignment statement anywhere? Yes. So, what is the subset constraint we have? This is some left hand side equal to right hand side. Whatever flows into the right hand side will flow into the left hand side. So, I will write it as subset constraint. What will it be? Whatever is flowing into D, nu D will flow into X. Any other assignment? No. Now, let us generate conditional statements. So, I have multiple method calls here. First method call is E1 dot m, then dot m, one more m. Let us handle the first m first. This is E1 dot m. So, what conditions can I write? Where is m defined? In which class? A and B both. So, what will the conditions be? If A flows into nu A, I will write A is in nu A implies what? If A flows into nu A, then whatever is flowing into this guy will flow into A dot F. Whatever is flowing here will flow into A dot F. Any doubts? Good. Fine. What am I saying? Whatever flows into A dot F, nu B will flow into A dot F. And whatever flows into F dot m dot X will flow into A dot F. Correct? So, for this argument flows into this, this written expressions, whatever the types, they will flow into this guy. Right? I mean this F. I just named it A dot F. So, that it is we do not conflict with this. You can just since there is only one F, just call it as F. That is F. This is G. So, we are in business. But if whatever is then just make it A dot F P dot G. Just we need to make sure that names are not conflicting. Now, let us look at this whole thing as one expression. Let us look at this whole thing, this whole nu A, this thing as one expression. So, this expression dot m, this expression dot m. So, what will I do? What condition will it be? If A belongs to this whole thing, then nu C will flow into F. And if A belongs to this whole thing, then F dot m dot X, whatever the flow set will flow into this expression. Similarly, for B what will I write? If B belongs to nu A, then what is the name? No, not the pink, the magenta color shirt. Yeah. So, if B flows to nu A, then which method will it be? Which method will it be if B flows to this expression? Which m will it be? A's m or B's m? B's m. B's m. Very good. So, what I am saying? If B flows into this, then this nu B will flow into which argument? G. This will flow to? G. G. And if B flows to nu A, then this will flow to this expression. So, now if you do all these constraints, this is what it will look like. We have this and now how do we solve them? What we are saying is we are generating the constraints, we need to now solve it. We will skip one or two slides. Wait. Okay. How do we do the constraint solving? We will solve one constraint at a time. We will process one constraint at a time. Not solve. We will process one constraint at a time and then see if we have more constraints to solve. We keep on solving. Once in a while, we add new constraints. When will we add a new constraint? We have this conditional constraints, right? If the condition is true, I will add the right side as my constraint. So, once in a while, we will add new constraints. But when we add, there are finite number of conditional constraints. So, I will add them finite number of times. We will take one constraint at a time. At any point of time, it will maintain a minimal solution and what we will do internally, the constraints can be represented as a graph where n is the set of flow variables and if there is, if I have V is a subset of W, I will add an edge from V to W. That is whatever is in V should go to W. You see this is one directional, right? What is in V will go to W does not mean whatever is in W will also flow to V, right? Okay. We can store the flow variable X in a bit vector, initialize the bit vector for every variable to 0. That is nothing flows into no variable, nothing. With each bit, we will have some pending constraints also. We may have some pending constraints that says, if something flows, this will come in. Okay. If that bit is set, then what should I do? Okay. So, if I have a condition, constraint of the form, if C flows into X, then Y is a subset of Z. Okay. Then what will I do? In X, for each variable, I have a bit vector, right? There is a bit for every class. If I have 10 classes, I will have 10 bits. For the bit corresponding to C, I will keep a constraint, which is Y is subset of Z. So, if that bit is true, this Y subset of Z can be added. If that bit is false, I will keep this pending constraint. I will keep it pending. Okay. So, this is how do I deal with different constraints? If I am inserting a constraint of the form, I belongs to X, what do I do? I will call a method called propagate. Basically, what I want to do, whenever I see that I is getting added to X, push it as far as possible. Okay. If I have an insert X subset of Y type of constraint, what will I do? First, I will add an edge from X to Y. I will add an edge from X to Y and then what will I see? Hey, hold on. I am saying whatever should flow into X should flow to Y. What is already there in X? Whatever is there already in X, what should I do? Push it. I will propagate. So, for every I which is already present in the bit vector for X, I will say propagate to Y. Simple idea, right? We will see the method propagate. We will see the method propagate, but what am I doing? I am taking the, I am seeing, hey I have to add the flow set of X to Y. Whatever is already there, let me push it. For conditional constraints, what will I do? I will see when I am processing it, I will see, hey see if it is already present in X, what should I do? If C is already present in the flow set of X, then I can process this constraint itself. That is what I will do. If it is already present, I will call the insert function for Y subset of Z. It may not be present yet, it may get added later. What will I do? I will add a pending constraint. I will say if it is not currently present in X corresponding to C, okay, whatever, it may have some set of constraints, add one more, add one more. We will solve it when it comes, okay. So, we have processed all the three types of constraints and we said we call a function called propagate. What does this propagate do? What do you think it should do? There is an edge from the variable Y. So, let us say here. There is an edge from the variable Y. Yeah. From the variable Y to any other. We should propagate further. Yeah. So, what he said is very simple, right. He says, see propagate, let us look at here. If there is an edge X to Y, I am saying whatever is in X, push it to Y. And while propagating in Y, you see hey, in Y I got something new. What you should do? Wherever there is an edge from Y, propagate. And again, let us say Y has an edge to Z. From Z, propagate further. So, recursively call, right. That is what we will do. Okay. When you want certain, when you want certain bit to be propagated for a variable, you first check is it already set. If it is already set, what does it mean? Whatever is required is already done. Do not need to do anything more. If it is not set, then set it to 1. And then for each edges like you said, from V what are the edges? Propagate. I may also have, after I set B, V, I equal to true, it may have some pending, hanging constraints. For all those hanging constraints, insert them into my list of constraints. So, I will call insert. And after you process these constraints, just make them empty. Very simple idea, right? If it belongs to constraint, propagate. Subset constraints, propagate to the right side. Whatever is in my left side, propagate to the right side. If it is a conditional constraint, if you know the condition is true, insert the right hand side. If you do not know the condition is true, keep it pending. Okay. With this, do you remember these constraints we generated for the first example? Can we solve this? Right. I will see if I can keep both of them together. Okay. Is it visible? Font is a bit small, but is it visible? Okay. So, solve this and let me know how things go. And again, like before, the order in which you solve does not make a difference, even though it would be faster to solve using a certain order. You will figure out that order. Yes, sir. Are you starting? So, by the way, the B set, so for each of these things, the B is initialized to, bit vector set is initialized to all zeros, right? What is the size of my bit vector set? 4, 4 bit set, right? A, B, Q, S, they are 4 bits. Okay. For every expression, we need one such bit vector. Yes, sir. So, one thing that we can try doing is make a table A, B, Q, S. For every expression I have, for every flow expression I have, nu A, nu B, nu Q, including X, Y, what is this? A dot arg. Why am I calling it A dot arg? Just to give it a different name from the A's arg and B's arg. Okay. So, for each one of them, you have, you have 0, 0, 0, 0 initially for all of them, right? Fill this table and then keep modifying the table. When you process, let us say A goes to nu A, you call the propagate function. Is the bit 1 or 0? The bit is 0, so you will make it, you will set it to 1, true, and then you will see, is there an edge from nu A? Now you have no edges in the graph yet, right? Your graph has no edges at this time, so nothing to do for the first for each loop. Does it have any constraints, no pending constraints? So, nothing to do. Now, process the second constraint. B goes to nu B, so you will make it 0, 1, 0, 0, call the propagate function, finish the invocation and proceed. When I process this propagation constraint, nu A goes to X, what will I do? So, I will randomly pick a person, they have to answer. Let us say, a green shirt, what is your name? Varun. Yes, Varun, what will I do when I process this? Yes, so which method will I call? Which insert? I have three inserts here, first one, second one, third one. Second one. Second one, very good. What will I do first? I will add an edge, so what? So, I will add an edge from this node, which node? Nu A to, I will add an edge and then, then call, then do what? No, for each i in bit vector of X, what is there in bit vector of nu A, which is only, only A is set, only A is set, so for that I will call, I will call propagate. So, propagate, I will do propagate X, A, so in this case bit is 0, right, X, 0. So, what will I do there in the propagate function? Let us ask your neighbor, what is your name? Aditya. Yes, Aditya, what will I do? Do not know, so what does the propagate function say? I am sorry. I thought you came pretty, you came back pretty early. Was it? So, sorry to hear that, you could have, okay, what about on the other side? Good, it will set it to 1 and then? For every edge from X. Yeah, so what edge do I have from X? Nothing at this time, so nothing more to do. Is there any pending items on X? No, nothing to do, okay. When I do the next constraint, nu B flows to Y, what will I do? What is your name? Nimisha. Nimisha, yes, Nimisha. We add an edge from nu B to Y. We add an edge from nu B to Y, okay. B is set here, so for Y and B, okay. What will happen in propagate, what is your name? Lakshmi. Lakshmi, yes Lakshmi. The B bit of Y, yes. Are there any? No. No, stop. Are there any pending constraints on Y? No, at this time, okay, good. So, what happened? So, this, we said, right, when we process this conditional constraints, we will add to this pending constraints, they have not come yet. So, you remember we said, whenever I process this, I will add, let us do one thing. Let us, for the heck of it, I am undoing Lakshmi your changes, okay. Lakshmi and Nimisha, we will just undo these changes. We will process this constraint later, okay. We will process this constraint later. Let us process this constraint first, okay. Prerna, go ahead. Will third function, yes. Hello. Okay. Sir, why is there? No, first I will check, if B is set, is it set? So, what do we set? In the bit vector of Y, do I have B? Do I have it? No. So, I will not, since I do not know if it is already there, I will not add process the, I will not add the right hand side yet, but I have to remember it. How will I remember? I will, in X, okay, that is in this case, in Y, in Y corresponding to the B bit, I will add a pending constraint. What will I add? Yes, what constraint will I add? Nu S, whatever that constraint is, right. So, let me, can you, can someone dictate? Nu S. Nu S, right. So, this is a pending constraint and now, what is the name? Amea. Amea. So, Amea, you process this constraint and see what will happen. No, first we will come here, we will add an edge, let us add an edge from nu B to and then, okay. So, what is there nu B? B. So, it will call propagate on Y and B, okay. So, let us go there. Is the bit set? No. So, it will set it to 1 and then, is there any edge from Y? No. Then, pending, what is pending here? Nu S and B dot arg. What will it do? It will call, it will call insert and then remove, okay. I am just removing it first, okay. It will call insert. So, what will it do in insert? It will add an edge from nu S to B dot arg, nu S to and then, set B. And then, for each i which is set in nu S, it will propagate to B dot arg. So, which bit is set? 1 bit is set. So, it will copy the 1 bit. So, in propagate, what will happen? Let us say, yeah, what is your name? Prof. Yes, Prof. Please tell me. So, I have to now do propagate B dot arg and S bit. So, is that bit set in B dot arg S bit, Prof. In the bit vector, for B dot arg is the S bit set. For the B dot arg, the bit vector is the S bit set. No. So, if not, then what will I do? I will first set it. Okay, let me do that. And then, what will I do? For each edge that is going out of B dot arg, do you have any outgoing edges from B dot arg? No. Since, we do not have any outgoing edges, no pending arguments, pending conditions, we are done here. Okay. So, now, let us process the other constraints. So, we are done with all these four, we are done with these two, we are done with the last one, we are done, we are still, we do these three. Let us process which one? Let us say, this A, let us process this condition. Insert K. Insert K, we did it, right? We had, we inserted, we set every constraint which is pending on the, which right-hand side is pending, we will call the insert on that constraint. So, we call the insert for this part, do you remember? Right? Okay. Yeah, what is your name? Yes. Yes, yes. So, let us process this constraint. What will happen? Okay, is it set? It should not be. Why? Because we made a mistake, it should be in B, right? Yeah. And then? Right now, so, correct, correct. We have to add to the pending list. What will we add? Where will we add? Here, what will we add? For space, I will just mark it here and write below. Yeah, what will I add? Nu S. Right? Good. So, this is a pending constraint. If in future, A gets added to Y, I will call insert on this constraint. Make sense? Okay. Now, what is your name? Neha. So, Neha, can you process this constraint for me? Which insert will you call, Neha? Which insert will you call? First one, second one, third one. Third one, good. And third one, what will I do? Is the bit set in X, is the B bit set? No. No. Then, what will I do? I will add a pending constraint. Okay. I will add a? Okay, what will I add? Nu Q B dot A R G. Right? Good. Good. Chai kitne bhi chik hai? Four o'clock. We have time. Okay. And that is it, right? Okay. Now, let us process this constraint. Who will do it? Kaun bach cha? The first one. Okay. Is it set? IIS. It is set. Then, what will you do? Then, I will call the insert. Insert on which one? Nu Q subset of A dot A R G. Very good. Oh, by the way, this is… Okay. Go ahead. So, we are calling what? Nu Q subset of A dot A R G. So, who will… So, you will now call the insert on that, right? Okay. Yeah. Prakhar. Prakhar. Okay, Prakhar. We will call the second insert and then add an? Nu Q to A dot A R G. I do not know why I am using two different colors. Does not matter. And then, we will call propagate on? A dot A R G. A dot A R G. For which bit? For which bit? So, in nu Q, which bit is set? The Q bit. So, you will call propagate for Q bit on A dot A R G. Okay. What is your name? Rathuja. So, Rathuja. So, what do we do here? So, we have to call propagate on A dot A R G and Q. What will you do? Q is to be set. Q is to be set. If it is not set, is it already set? No. So, I will set it to 1 and then? And then? And then? Are there any edges from A dot A R G? No. Are there any pending edges here? No. Have I finished processing my constraints? Yes. Have I finished processing these constraints? Yes. Are there some pending constraints in some of them? Yes. I will just drop them. I will just drop because those will now won't be satisfied. Those won't be satisfied anymore. So, I will just drop them and my flow information becomes this is my flow information. Then we will you will call propagate again. Yes. We will call propagate again. So, there is something interesting here. We seem to be adding constraints. We are processing these and we are kind of adding some constraints during the processing. But still there is a confidence we have that it will terminate. What is the confidence? Sorry. Number of these constraints are finite, but I am adding new ones. Right. Either there is a change like we are always setting it. Okay. So, we are always going towards having every bit as set. We will either achieve fixed point or we will have achieved all of this. But what if I am continuously just processing? I am not changing anything. Nowhere I am checking for till no change. Here I am not checking for till no change. Am I? But. If you go back to like insert, if you try to propagate something that you have not that is already set, you will not like you will not enter you will not actually enter doing anything because of the if condition. Because of the if condition. If it is already set you are not doing anything. Right. But what if I am not setting anything, but I am continuously calling propagate insert, propagate insert. But I am adding newer constraints. That is a good point. Number of constraints are finite, but even the ones on the right hand side the conditional ones that I may add that list is finite. There none of these are recursive. So, the number of times I will process them is finite. In the worst case I will call okay process these and these. But is it possible that within them while processing them the propagate which is a recursive function I will keep on recursively calling forever. What is the guarantee? No, if the bit is not set. If the bit is set I would not call it. So, you will never have a infinite this thing. Right. No, see these things are important. I mean they look subtle, but when you design your own algorithms you should be able to argue that yes this will terminate. So, if you have N2 for the example we have shown here right where is the second example? Where is the second example? For this example also you will see the constraints are much simpler. There are a few direct things. Then you have bunch of conditionals, but none of them will get satisfied because you have x will have D, B will have this and this. There is nothing complicated here. I mean you should be able to just run the same thing again. Unless if some one of you is stuck we will go over the second example or if you think the second example should be you understand the concept then we will skip the second example. Can you skip the second example should you go over it? Skip right okay. Then so what is the complexity of this algorithm by the way? Complexity I mean why am I asking that? No, no we have to ask. So, let us say the program is of size N right N lines. So, there are N classes. So, or if I give you N constraints how much time will it take? You do not like such complexity things. Sorry. Give it as a homework. Yeah, we will help understand. So, what is the complexity of this? Let us look at the propagate function right. Wait how many bits can be there here? At most N, N classes N. So, I may call propagate N number of times. So, the cost of this insert is N times propagate. Cost of this one is no this is cost of this one is cost of insert which is same as N times propagate this is propagate. So, if we get the cost of propagate we are in business. Okay, what is the cost of propagate? How many edges can be there? N edges. So, N times propagate. Sorry. Yeah, in the worst case all are N order N. So, for each correct for each Xc I am doing for one specific i. How many times for that i I will call propagate only for number of them not more than that. But each one of them from X I may call propagate for Y from Y I may call for Z. But this whole chain is maximum bound by N number of times. It is not N times N times N times N right. Why? Because there may be an edge from A to B, B to C and C to B again. But I will not process this B second time because that bit is already set. So, what I will do? So, this propagate here will only be called N number of times recursively or otherwise. Either I am doing it for all my edges or by recursion at most N times. So, it is not going ever right. So, then so the cost of so I am calling propagate here N number of times and besides this for loop what else am I doing. So, in each of these N times what is the maximum I can do? I will call I will call the insert. What is the cost of that insert? What type of constraint am I adding here? A subset constraint. I am adding a subset constraint. What is the cost of that now? He does not like it. So, if you look at this insert here this is always a subset constraint of this sort right. When you called the propagate on a node for A bit it may lead to calling propagate on how many other bits? See for each of the bits it may call. You have called it for one bit here. You have called it for one bit, but you are calling insert k some other new edge completely new edge. In that edge it could be from P to Q. In P you may have some how many bits? N bits set. For each of those bits you have to call propagate. So, N bits for each of those N you will come back here. So, this is this propagate recursively can be called N times and then again you will call insert. So, what is the cost? See at most I am calling this how many times am I calling this propagate function? Again N times, but I have already counted for when I am counting this insert I have already said how many constraints do I have order N including the right side. I have already taken into consideration how many times will I call that. So, this is N times whatever the cost of this. So, N times N times that is N square I may have to do something more. So, N square times I may have to process the constraints. So, N cube times. So, do not we should not over count this how many times will I call this total N times either directly or via conditional. I should not say directly I will count once and conditional again I will count once let us not do that total I will call it N times. So, every time I call I may process this and I will. So, this is N times N square. So, I will do N cube amount of time at most. So, you can I mean there is another way to calculate if you care I mean there are N nodes up to N square edges you will for each at each call site you will have N possible calls N possible classes and you will add N number of constraints. So, that is O N cube. So, the work done at most is it is kind of bound by that, but if we calculate from the propagate side we say how many times it is called N square number I mean for each call you are calling once propagate that is also N cube. Moral of the story it is a N cube algorithm on paper, but as we have seen in practice it runs much faster. So, it is a common thing that people keep remembering doing this CFA is an N cube algorithm control flow analysis is an N cube algorithm in practice it is mostly linear. So, do not worry about this is an over this is taken this slide is taken from a class. So, there is an assignment due for you there is no assignment, but you should be able to from what we have learned given a program O program should be able to generate the constraints solve the constraints right we should be able to do that. So, the algorithm that we have seen is not very precise there are many challenges there can be large number of libraries I am going over all classes and all that right. So, that can be a bit of an issue we can improve by improve, but so that we do not generate too many constraints we will see two of them one we will say we will not generate code for unreachable code. For example, it is a library code right for a given program the library may not even be accessed why should I generate constraint if that for each class I am generating constraint right if that class is a member of this conditional constraint if that class there are lot of conditional constraints that we generate we can avoid that for library classes which are not called. So, what I can do is I can look at my main program look at the main program and say for in the main program whatever are the for those constraints I will add them the constraint, but in the library code right. So, I will take the methods of main add to live take from the main there is a method which is called add the constraints of that do not add the constraints of the whole world because the library methods which are not even called why should I add the constraints for that right. So, the complexity does not change the complexity still remains so in queue but it will be more efficient in practice similarly here is one more I have a class C in which there is a method id. So, here if you look at it I am doing new c dot id new c dot id the argument here I am passing new a here I am passing new b and then I am calling dot m this m is present in the interface. The problem is even though it is a identity function I am calling identity dot method. So, this should have been new a dot m this should have been new b dot m, but the way the code is written my x will have flow set of both a and b do you see that because I am calling new a flows into x new b flows into x I am calling returning x. So, whatever this return x will be the will flow into this guy. So, what will flow into this guy a b what will flow into this guy a b as a result this m is going from both a and b. So, one thing I could do is I can create a copy of this id this id I can create one id 1 and one id 2 and in new c in the class I duplicated the method in the class I can duplicate the method this id becomes id 1 and id 2 for new a I will call id 1 for new b I will call id 2. So, what will flow into this x now a what will flow into this x b so what I did I duplicated the method because I duplicated the method for at this context I am calling id 1 in the second context I am calling id 2. So, you can I mean and again this will this is more precise not changing the complexity, but making it more precise sorry so that I can inline we will come we will see now how will be inline we already have said every time there is a at a call site x.foo if x's flow set is a singleton set only then I can inline correct. Okay I can also I can also do a class duplication I will skip that there are few other methods in which you can improve the precision we will take a break now, but let us remember what we learned now we learned how to do flow analysis how to solve the constraints generate the constraints how to solve the constraints. So, out if you construct make a black box with what we have learnt to now in comes a program out tells out goes the flow sets for every expression remember this when we come back we will use that information to do inlining okay.