 Yesterday we started with data flow analysis. So, today we will go ahead with that. So, essentially the idea was that we essentially looked at 4 classic problems in data flow analysis reaching definitions, available expressions, live variable analysis and very busy expressions right. So, just very quickly recap what was reaching definition? What is the what do we try to compute reaching definitions? Yeah, so for from the set of all definitions. So, what are definitions? Assignments to variables are definitions. So, for every, so now we from the program we have the set of all definitions and we are asking what are the set of definitions which can reach a given location. So, what does it mean for a definition to reach a given location? That there is a path that exists from that particular definition to this program point and the definition is not killed during in that actually in at least one of these paths right. So, the second problem was available expressions. What was available expressions? Right, so what does it mean for an expression? It is computed along all paths reaching that particular program point. Then we have live variable analysis right. So, what are the set of variables that are used on at least one of the paths from the given program point to program exit right and finally, we have very busy expressions which say what are the expressions? Yes, yes. Next question which will be computed in every possible path from the given location to the program exit. Excellent, so now, so we will keep on revising whatever we did yesterday and let us hope that we do not have an issue. We have looked at the definition of region definitions. So, essentially we had this idea of this idea of tokens flowing in the system right. So, essentially we are thinking that every point there is a definition, there is a token that gets generated and if every time I have multiple paths reaching a program point, I will collect the tokens along all paths. If a program point bifurcates into two paths into there are two edges outgoing edges, then I will copy the token and duplicate along both the paths and if there is any definition which can kill a given token which is by redefining onto the same variable, then the token will vanish right. So, now, the set of definitions reaching a program point are basically the tokens flowing through that program point right. So, now, the question was that which direction we flow the tokens. So, where do we start from? So, we flow them in the forward direction right. So, this was forward. Then when do we say a definition reaches a use? So, when the token reaches here for the respective thing, what happens if the variable is resigned, we kill the variable. So, we discussed this and we will refer to RD of n as the set of reaching definitions at the basic block n. So, now, let us start designing this analysis. So, let us to begin with assume single statement basic blocks. So, now, remember from yesterday what how did we say we will design this algorithm. We will essentially come up with two things. We will define a set of what we call local sets. Local sets are set of definitions which are which can be computed by looking only at a given basic block right. So, essentially to compute gen of n or kill of n, I will not need to look at anything else, but only at n right. So, what is gen of n? What are the new definitions which are generated at the basic block? Are you convinced that I do not really need to look at any other basic block to compute gen of n right. When I am looking at n, I just look at what are the definitions in that basic block and just collect them. That is my set of that is gen. What is kill of n? All that gets reassigned right. So, assume that I have already collected the set of the universal set of all the universal set of definitions the set of all definitions in the program. After that to figure out which of these definition gets killed by this basic block again does not require me to look at any other basic right. Assuming understand the as you were pre-pass where I collect the set of all definitions right. From that set whatever definitions get reassigned, I can simply put them in the kill set. Right. So, these two sets I really do not need to look at anything else to compute the gen and kill sets. So, this is what why they are called local sets and then using them we will compute a set of global solution sets sets which will which will tell me what are the set of definitions which are which appear which are reaching at the beginning of a basic block and at the end of a basic block right. So, given a basic block I will compute two sets. So, one is in of B or in of n right for the basic block n and out of n. So, in of n will tell me what are the set of definitions which reach this basic block at this program point just before executing any instruction in the basic block right. Out of n will tell me what are the set of reaching definitions at this program point which is after executing all the instructions in this basic right. Now in this in this particular case I have only if I assume only one basic one statement in the basic block then it is a matter of just saying what happens after the before the statement and what happens after that statement. And then I will then we will look at the initialization how to really initialize the sets to get it. So, what is what is my global solution yesterday that is what we looked at right. The end of a basic block for reaching definitions essentially will take the union over all the predecessors and take a union over their outsets right. So, if you have a basic block I can compute the in at n by figuring out which are the basic blocks which are reaching which are the reaching definitions reaching here from the predecessor blocks and I take a union over their outs right. And the out will tell me what happens after I execute this statement in this basic block. So, I get this by subtracting my kill set whatever gets killed by the basic block and then adding the gen. So, you guys should immediately stop me if something is not clear. So, we are going to implement this so we should really be completely clear about what that is. Right ok. So, let us do a small example. So, let us say I have this particular program I have a equals b plus 2 I have a equals 5 I have b equals 9 and for this particular thing let us say I want to compute my solution right. So, the first thing we will do is we will first construct the universal set right. So, the universal set in this case of definitions is I just give arbitrary names to them I call this one d 1 I call this 2 d 2 and I call this 3 d 3. Right. So, my universal set of definitions is d 1 d 2 d 3. Right. So, now let us compute the gen at this particular block. So, what is going to be my gen? My gen is going to be d 1. Right. And my kill is going to be so from these definitions which is the definition does it kill? So, this is an assignment to a this is an assignment to a and this is an assignment to b which one does it kill? So, we can simply say d 1 and d 2 right both of them it kills. So, let us not even bother about see the how the equation is kept. So, first I subtract kill and then I add gen. So, even if d 1 gets removed I am going to add it back. So, does not matter right. So, I really do not have to worry about that I should not kill my gen. So, I do not have to worry about that right or you can write the equation differently and then you can also take care of that right. So, it is up to you. So, now my kill set in this case becomes what it becomes d 1 and d 2 that is my kill set. Right. So, similarly you can do the gen for this the gen for this is d 2 and the kill for this is again d 1 d 2. See I do not even care when I am computing the gen and kill of this I do not even care that d 2 cannot even reach here there is no path all these things I do not even bother about I just say look at this basic block look at the definitions in this basic block and tell me out of this set of all definitions which of them get generated which of them get killed I do not even bother right. Similarly let us say gen of this gen of this is going to be d 3 and kill of this is going to be d 3 those are my gen and kill sets. So, as you can see I did not even bother looking at other basic blocks when I am computing the gen and kill at any basic block. Make sense? Okay. So, now comes the question that now essentially the idea is very simple that I have got these gen and kill sets at all these basic blocks now I will simply go and write my set of equations I can simply now set write my set of equations I will write a set of equation like in of b 1 b 1 let us say this basic block is b 1 this basic block is b 2 and this basic block is b 3 and this is b 4. So, I will write that b 1 is equal to this is the entry basic block so the definitions are the entry is going to be empty and out of b 1 is going to be what is going to be gen of b 1 union in of b 1 minus kill of b 1 right. So, similarly I will write in of b 2 is something which is nothing but the b 2 union of all the predecessors. So, in this case there is only one predecessor so this is nothing but out of b 1 right and out of b 2 is going to be the same thing for b 2 similarly if I had to do it for b 4 sorry in of b 4 then it would have been out of out of b 2 union out of b 3 right agreed. So, I will have this huge set of equations and and we are hoping that these equations would eventually give me the. So, now if I solve this set of equations I will end up getting my in and outsets right there can be complications things are not so simple in life like for instance what if I have a loop going from here to here right. So, there will there may be a cyclic thing so in that case my in of b 1 may not be so let us say I have some other entry let us not bother. So, in in of b 1 can become out of b 4 right. So, then what is going on is that you can see that b 4 out of b 4 is dependent somehow on b 1 because b 2 is dependent on b 1 and b 3 is dependent on b 1 and b 4 is dependent on b 3 b 2 and b 3 and now the problem is b 1 is again dependent on b 4. So, b 4 is dependent on b 1 and b 1 is dependent on b 4 so there is a cyclic dependence. So, now these are set of equations you cannot simply substitute you cannot solve by simple substitution otherwise how do you solve equations you just substitute whatever you can substitute from later equations you put them up get a large equation try to solve it that is one generic strategy right. But now these set of equations you cannot do that because there is this cyclic dependence agreed. So, these are called what I said 6 point equations and we will spend a lot of time today understanding and to see how to really solve 6 point equations. So, right so now the question is that so we need some other strategy to solve these equations but let us try to understand the solution space first right. So, first of all the question is that for does these set of equations will this set of equations have the have only one solution or can it have multiple solutions. So, we have to whenever we have several equations we have to start asking these questions right and then if it allows multiple solutions are all the solutions okay or which solution is the solution that I am more interested right which solution would work for us. So, that is my next question the next question is that is the solution unique or can there be multiple solutions what is your guess. So, let us stare at these equations and try to think can there be just one solution or can there be multiple solutions no no the outcome so sorry maybe I should have so the outcome. So, how do you verify your solution on this okay we do not know how to compute a solution but can we know do you know how to verify a solution how will we verify a solution. So, what is going to be a solution for this let us ask that first what is my solution what we mean by this solution yes the in out sets of all basic blocks right. So, in of b 1 out of b 1 in of b 2 out of b 2 right this whole tuple is going to be my solution right how yeah. So, now the question is that how do I so now will I have only one such solution or can I have multiple solutions. So, let us try to stare at this equation and try to think okay. So, let us sorry it was about the question of verifying the solution. So, can I verify the solution how will I verify a solution. So, let us say somebody comes and tells you I think this is a solution for this how would you check he is lying or not. We have see we have abstracted everything out now everything is a pure nice mathematical set equations I really do not have to go back to my control flow graph anymore whatever I could have done with my control flow graph I have already done now all you have to do is live with these equations you have already extracted out the equations now the question is now you have a set of equations now you are talking about the solutions for this equation which will give me a solution to the control flow graph somehow yeah, but we have done this nice abstraction only. Excellent so we have the general set so now yes I will just go and plug in those values here if all the equations match up I will say that is the solution if they do not match up it is not a solution as simple as that agreed right. So, we know how to verify a solution now the question is how do you compute the solution right looks weird right. So, now so let us try to first answer that what would this so will this solution be will there be only one solution or will there be multiple solutions okay. So, I will give you a hint look at this particular graph and try to answer that question. So, now what I am asking you to do is to play the debits and locate try to try to break this thing try to say that okay this is not what I would have wanted but I can still get the solution. So, you are trying to compute reaching definitions and there is a self loop on this basic very simple case. So, okay so I will still make it easier let us say I already have a known solution right which is let us say let us say call it n 1 0 okay. So, let us say this is a set in 1 0 out 1 0 and into 0 these are the two things and this into 0 is okay does not matter but now the question is that I want to figure out so this in is going to be this so let us have a in 0 also something like that and I want to construct another solution which is in 1 in 1 1 in 1 into 1 and so on. Take this solution and somehow try to extend it into another solution if you can. So, let us assume that I already know that these guys already form a solution. This notation I do not like this notation okay let me just change this notation. So, let us just put a solution let me say that in 1 in it is not 1 this is some set S 1 and out of n is some set S 2 let us say this is my solution I know S 1 is solution to this it satisfies those equations. Now I want to say can I can you somehow use S 1 and S 2 and extend it to another solution which still works on this basic law do not think of the controller graph now just think about this set of equations and remember the equations you have the equations here. No understand my question is that you are already given a solution which is in of n is S 1 and out of n is S 2. This solution is given to you already in 1 and out S 1 and S 2 may not be the same that you can agree or they are the same. Excellent excellent very nice. So, what I can simply do is I can really play this game I take S 1 this guy is S 1 and to this I add some definition d i which is let us say not in this set right. So, what will happen to this this guy let us say is not does not get killed by this right. So, this will also have d i because this guy has d i this will come and merge with this. So, everything will stabilize. So, I got a new solution from this which is nothing but S 1 plus d i and S 2 plus d i do you see this I can just put a new thing and because there is a loop this guy will feed back and the whole thing will still stabilize they all the equations will still match up. Once I can put another definition I can put the whole set here right the whole universal set I can put here right. So, essentially there may not be just one or two there can be multiple fixed point solutions to this set of equations anybody who does not see this right. So, the question is that which of these solutions. So, now I can so these set of solutions if I try to give it us to us some sort of solver it will give me a whole lot of solutions. So, which solution is the solution I am really interested see how we are going from the programming language problem to a mathematical formulation and then back to the language problem right. So, we have abstracted into a set of equations now we see there can be multiple solutions to the set of equations now we are asking which solution is the solution I was looking to get when I was trying to solve the problem the original problem. So, which of these sets would work for us which of these solutions would work for us which one we should get. Exactly. So, I want this the solution which is the smallest set right. So, now we are like piling problem on problem because first we do not even know how to get a solution second problem is even if you get a solution any solution will not do we will actually need a solution which gives you the minimum size of these sets right what we can let us refer to that as the least fixed point solution right. So, I will call it the least fixed point solution or LFP right. So, multiple problems first we do not even know the third question is how do we even know a solution exists a set of equations may not have a solution right. So, that is another problem. So, we have multiple problems to answer first is does a solution even exist the second is even if it exists is it computable which means that can I take find the algorithm to compute that solution and the third is even if it exists and I get a algorithm to compute it can it give me the LFP or right. So, we have to answer all these questions. So, today's class we will actually try to see how to get an answer to these problems this is a point to ask questions anybody who has not understood what we are trying to do please ask it now because otherwise the whole day will become very boring will not even have the motivation to do it yeah in generally also there can be a whenever there is a loop which has this transitive I mean which will create a cyclic dependency we can always do that. So, instead of this one basic block had it being a sequence of basic blocks that also would have the same problem right I can just simply extend that idea right even last set of basic blocks from the last guy from where I have the back edge I add a new definition and that will go and like pause everything within the loop. So, if you do not have a loop then we are good because we do not have a cyclic dependency as soon as you have a loop you have a problem and programs will have loops yes we are increasing the size of the set that is true but think about this innocent question right you take this set of equations and give it to a solver right which will solve this six point equations and give you give it a solution to you that particular guy does not know what solution is the one you want right for it does not know the original problem it does not know we are trying to compute which definitions it just looks at this set of equations and then say there is some equations over set. So, can I solve it and give you a solution but not all solutions from that guy are admissible I cannot just take any solution and that will not be the answer that I am looking to get ok should we summarize it one more time or is it ok. So, so ok so the problem is again what would we do we did essentially we start oh this all goes oh thank god it stays ok. So, the idea was this idea was that we took our control flow graph from our control flow graph we figured out that we decided that analysis that we will do we will break it up into two phases we will do a local analysis to figure out some summaries about each basic block something which will tell me what happens at each basic block and these are will be do using this gen and kill sets. So, we will compute the set of gen sets we will compute the gen set which will tell me what happens at node n what are what are generated at node n and the kill set will tell me what gets killed at node n using this local sets I can start writing equations which will summarize the computation over the whole graph right. So, first we started doing it at one basic block and then we want to extend create equations which will work for the whole graph the whole control flow graph. So, to construct the global solutions we use these equations we use the transfer function which says that given what happens what is the set at the beginning of the basic block what is going to be the set at the end of the basic block. So, this is referred to as the transfer function agreed and second thing we will do we will use this inset sorry we will use this meet operator. So, we basically say that how do I know what happens at the beginning of a basic block right. So, we need to figure out what happens at the beginning of the basic block what happens at the end of the basic block what happens at the beginning of the basic block things get accumulated all the sets outsets from the predecessors get accumulated what happens at the end of the basic block I apply my transfer function to figure out how does my inset change into my outset all that is clear. Now one once we have this set of equations the rest of the work is very mechanical I just go and apply this equations to every single basic block in the system. So, then I get this large set of equations that I which tell what happens at every particular basic block I can simply expand it out nothing very serious going on I just plug in the right gen and kill sets for each of each of these cases right. Now I have what we have been able to do is we have been able to forget our control flow graph we forget what we forget what was the problem we were solving we were solving some reaching definition problem I do not care anymore we were solving something on a graph I do not care anymore I now I can just live with this set of equations if I can design a solver which can take these equations and give me a solution to these equations I am done I will get in and outsets which I can simply go and see oh that is what happens in the beginning of this oh this is what happens at the end of this that is it are we good till now agreed ok. Now let us forget the actual problem the reaching definition problem and just stare at this system equations first thing I notice is that this system of equations is cannot be solved easily by substitutions why because I can see dependence is going on here right I can see that BB1 depends on B4 and I see B4 depends on B2 B3 which in turn depend on B1 right so any change I make to any of these sets will get propagated to the other one which will create a problem and again which will propagate the change to the whole thing again. So I need a different strategy to solve these equations I cannot solve these equations simply by substitution that we should be convinced on right before that we have to so now that is one problem second is that first we have to looking at these equations first we have to figure out that do this is a set of equations even have a solution does a solution even exist in this case right if its solution does not exist there is not no point even thinking about an algorithm right. So first question is does a solution exist second problem is that if there exists a solution do we have can we come up with an efficient algorithm to solve these equations that is an important question in computer science if you can do something can you do it right so that is the second problem the third problem is that do the system equations have multiple solutions so first we are talking about no solutions and now we are talking about multiple solutions right so now the question is that do the system equations have multiple solutions if the system of equations have a multiple solution then which is the solution we are looking to get right so we saw that if I pick one solution to this equations I can very simply keep on adding definitions to get larger sets which are still solutions which are also solutions so this set of equations do have multiple solutions if they have multiple solutions then the question is that which is the solution that works for us not every solution works for us right so which solution works for us the smallest solution works for us right the solution which the sizes of the sets are the smallest okay think about it so what do we want to do with reaching definitions what can we do with reaching definitions okay that is a very good question so let us let us think about it so why would be interested in the smallest set so whenever you are faced with this problem that what are I mean why this solution is good for me why not something else you should think about the application of this particular analysis so where can I use reaching definitions can you think can you give me some idea of some very simple idea of what can be some optimization some transformation I can do with reaching definitions so if I know that a particular set like I have like x equals y plus z right and let us say I know that y has only one reaching definition right so it means that there is some y equals something something this guy is coming from can I do an optimization can I not let us say this guy reads from some function call can I not simply put the function call here could I have done it if there were multiple reaching definitions right so if there was a y equals foo and y equals bar then which one do we substitute I do not know which one I can substitute then I cannot do anything but I can do this optimization if I know that y is equal y has only one reaching definition better still for instance think about the case where instead of y equals foo I had just y equals 2 right if y is just equals 2 I can simply substitute 2 here and this other thing is already 2 so 2 plus 2 becomes 4 I can do it at compile time compile time I can just forget there was a y completely forget there was a y I can simply substitute 2 I can compute 4 at compile time not at runtime right something I would have done when running the program I can do at time and compiling the program so I get 4 better still it can create a transitive effect let us say y was the reaching definition of somebody else the single reaching definition of somebody else for that guy I can again substitute instead of x sorry x was the reason I can substitute instead of x I can substitute 4 that guy maybe we are added with something else right so you can keep on doing this and lot of code that would have otherwise got computed at runtime will now get computed at compile time so let us talk about the case where y is equal to 2 so I am saying let us say I know so I have x equals y plus 2 right now if I know that this guy is not there this is the only reaching definition of y that is the only reaching definition of y there is no other reaching definition of y at this program point then I can simply I know that it is going to read y from here from nowhere else right so I can I not simply take this 2 and replace instead of y put a 2 here right so what have you saved do you think we have saved a lot yeah we have stored saved the memory load a memory load is a very expensive operation half of the compiler optimization half of the architecture optimizations are actually there to reduce loads caches are there to reduce loads now at least reduce the effect of loads the run the latency of loads no no we are just substituting the value itself we are not even do we do we not even have y here we will just say it is 2 this this this y is always going to be 2 no matter what right so we forget y completely and then I say 2 plus 2 is nothing but 4 I write the whole thing as 4 I just say this is nothing but x equals 4 right and this can create other effects I can later down the line if x equals 4 is the reaching definition of the only reaching definition of somebody else I can do it further right so yesterday you were asking me that what why are these optimizations useful this is one place where optimizations are useful right see how many loads we can remove like this and load removing loads is a very very important optimization because memory access memory is very very slow your processor is very very fast so if you can save accesses trips to memory you will save a lot right so this is a very relevant optimization this is known as constant propagation so we just figure out constants and we propagate them also the program so this is a very weak algorithm for constant propagation we will see a better algorithm but but this is also a form of constant propagation this is not that powerful but still it is good this thing yeah sure this one right now just assume this is what it is yeah but it's a union over this guy also right union over this edge also no matter what comes from the other guys this guy is already there this guy is going to get union with so if I add a new DI to this particular edge it is always going to be satisfied things so it does not really matter what comes from the other side other guys no we will see that we will see how to compute it we are not even there yet no we will see a proper discipline we are coming up with a solution to fit for equations right we now will we will actually spend a lot of time looking at theory to say how can these equations be really be solved so let's not have like we will actually mathematically see they can be solved or not right so there is quite a bit of purity this so let's take the other questions yeah so think about the case think about somebody think about the solver as a black box right so you give it a you give it a set of equations it gives you a solution back how do you know what solution it has given you it is not it is going to get you the best solution and then I did something and give you that it is not that right it will simply search the just think about one really stupid way of getting the solution I simply guess solutions and verify it guess and verify it guess and check right I can just randomly select sets put them in and verify it is the right the solution or not that particular algorithm can actually give me any solution right so I do not know what the solver is doing right we just it you give it a problem it gives you a solution which solution gives you you do not know so we will actually actually like yesterday we replace the label by a string label exactly the similar way in the the program text using LLVM APIs we will replace that instance of y by actually two we will calculate it at compile time replace it by the new constant and then again get new solutions yes that is optimization that is exactly the optimized code you will get yeah I come to it so right now we are assuming single statement basic blocks we will consider multiple statement basic block just after this now let us come back to this particular application right on this application can you now tell me that what solution would work you guys said the smallest solution can you now think about why will a larger solution not work no that is the other way around here the I am missing order definition but I am saying here you are computing a definition which is a set of definitions which is larger than that that is what you do here right you took the initial S1 and you extend it by a new arbitrary definition di so your solutions become larger so generally that will not happen the reason is that every use will surely have at least one definition right otherwise it is garbage value right otherwise nobody nobody has assigned anything to it and we are using that value so that is garbage and if I put substitute one garbage value by another garbage value really does not matter right so that is not so much of an issue but the bigger issue is I think you are on the right track but think about the case yeah nine nine much simpler than that no but universal set is bounded the universal set is a set of all definitions the program the program is bounded size right you know this is all the program is I cannot invent new definitions there so we could do this definition only if the size of the set was one if it was singleton set I cannot do it if the size of the set was two now the size of this guy reports the size of the set is two I cannot do that optimization and that new guy di is probably a pseudo definition it was not a definition which is actually reaching it right so I am missing out on the opportunity of doing an optimization agree make sense so that is why I would like the smallest set so that I can do these optimizations I do not miss out on optimizations okay think about the same case let us say I had y equal to 2 here and y equals 5 here these are the two reaching definitions coming here then which one do you pick I cannot decide so we cannot do an optimization right make sense so we now understand why we would like the smallest set to be there so I do not extend my universal set a universal set is the same because there is no point in it that is garbage right anything out of the universal it is garbage to the existing set the existing set of definition so in and out are sets are definitions right so to this set of definition to the outset I just added a new definition because of which the insert will also have the definition because it is a union over the predecessors and one of the pieces itself out of itself right so so that definition would just stick around any definition I plug it in it will stick around and that will be a valid solution so I picked the definition carefully I picked the one which does not get yes so I am saying there are such solutions possible I am not saying all definition can be added and all of them will give you a solution all I am saying is there are multiple solutions possible there need not be a single solution not all solutions are like not all possible vectors are possible solutions but the set of possible solutions is not single term it may not be unique so it is a very common game in like mathematics right so you want to show a multiple solution you would actually take one solution and say can I do something and get another solution from this right so I give you a way of doing that right so the next question is I think it is your whatever you started with is the question of safety now think about the case what if what would have happened if one of the solutions in this set was smaller than what it what it should have been if I miss out on a definition a definition is actually reaching definition but that does not get captured not it will not happen with these set of equations it will not even stabilize there so that will not be a valid solution but I am saying let us say somebody I do not use this thing I just guess something and I say oh work with this right so what what so I should not call it a definition but but let us see I say an assignment to these sets this in and outsets right to this in and outsets if I put an arbitrary set of sets assign an arbitrary set of set of definitions such that there is some definitions meeting me missing from the actual set of definition that be there what would have happened wrong transformations that is dangerous that is sure dangerous right it is okay I can wait for another hour for my program to complete execution I live with it but I cannot say that okay I will give your execution in five minutes 50% answer wrong answer I cannot live with that right so so your compiler cannot give you wrong answers and they do give you wrong answers that is different matter altogether but and we saw it yesterday right we saw it yesterday there were different behavior of different compilers on the same program right so all at least one of them is surely wrong so but whatever so now the question is that okay so now the question is that so this this is what is referred to as safety right so I would say a solution is safe if it at least contains all the definitions it needs to have otherwise the solution is not a safe solution so you will see that these set of equations no matter what solution they give you that surely give you a safe solution they will not miss out on a definition right that is not going to happen right so it may be that we may not get the best solution but it will not do a wrong optimization so there are in program analysis people talk about these two important things one is safety people also refer to as soundness and it also talk about something called precision and they also refer to as completeness so safety or soundness means that I should not compute a solution which can lead to a wrong result for my client whoever is using this analysis right and precision tells me or accuracy tells me how close am I to the actual solution so I have the optimal right solution sitting somewhere how close am I to the right solution am I there or am I off that right so if I really have a precise solution I will be able to do all the optimizations I would have liked to do if I have a safe solution I will never transform my code in a wrong manner right so these are extremely important just keep it in your mind whenever you are doing anything with program analysis all good okay so right so it was in the slide itself so you have precision we have safety and the next thing as like which is important for engineers is scalability that how much can you scale it what is the efficiency of this algorithm what are the largest like how large is the piece of code I can handle right so this is from it so these are important from the of course from the application and the theoretical perspective this is again important from the system building perspective so we have talked about it so which set will work for us best the smallest or the largest the second question is does such the smallest solution exist or rather even solution exists and right so one intuition you can carry forward is that the best solution so now if you just somehow somebody gives you all possible solutions magically right the way to get the best solution would be to take the intersection of all this that is surely going to be the best solution right so just keep that intuition in mind but let us not try to devise a strategy to do this business so this is algorithm that you were trying to propose right so this is algorithm is that you see your solution sets by sure sure solutions like solutions which are surely correct surely safe right no not really so sure set I meant here was the what the set that you know is correct from the onset like for instance for reaching definitions I know that at the beginning of the program my inset at the entry point of the program is going to be large that I know right I know that for a liveness analysis at the end of the after the program terminates my live sets are going to be empty that I know right so these are things I already know so I can just simply plug in those values second is I initialize my sets by some values now that is a next question okay so let's answer that also so we have reaching definition sets so okay let me just complete algorithm so then what we do is we we initialize these sets all of the in and out so let's go back to the equation sets yeah so these are the set of equations right so what we simply do is we we know the gen and kill sets anyway so the in and out sets I don't know but I know the inset at the beginning of the entry block for every other block what we simply do what we do is we plug in the we initialize it with some set either the empty set or the universal set it will be one of those two things right and then you will run this fixed point iteration right so every time you run the fixed point iteration the solutions would change because the for instance the in is empty if we force the out to become empty not empty sorry the out to become something right whatever the out becomes that will force its children to become something right so that will change something in the in the structure of these sets you feed that again keep on doing it till at a point there is no change to the set of solutions and that is exactly my test that all my solutions will be satisfied then I've got my solution that is this strategy we will follow so the last question we have to answer is that what should we initialize our sets with should it be an empty set or should it be a universal set for each definitions just think about it and tell me okay I got one vote for empty set two votes for empty nobody says universal this is the game man it's okay why is it empty set why not universal set excellent I think all of you got answers right so essentially if I substitute it with the universal set what will happen is that all these d i's that I did not want they'll just stick around I'll never be able to remove them so one thing is sure that this set of equations no matter what always gives me a solution which is the correct solution right but I would like the best solution right so if I already give it a solution which is a bad solution the system would be stabilized the system will not even move so I should put it in an uncomfortable position where it does system solution is not correct it's not even a correct solution so then it will do something and build up a set and eventually the solution is going to be a solution which is going to be a safe solution right so that is why I do not want to initialize with the universal set because as you said like in the universal set whichever definitions would satisfy such condition they will simply stick around and I'll still get a solution but I'll get a bad solution I'll not get the smallest in that environment right yeah because see that that is the guide idea right so when we apply these equations when we apply these equations actually if you think about it I do not because I have got rid of the control flow graph now these are just set of equations for me the there is no ordering there there are just a set of equations it's a set of equation not a sequence of equations so now the way I do my updates that does not matter I can do this updates in any way and to do that my right hand side should also already have some assignments otherwise I will not be able to compute the left hand side so I'll just fix my short set which is my beginning of my basic block to the correct solution and everything else while I initialize to empty right so now I am free to choose any equation I will just update it and I'll let go of that I'll pick anything updated because I have already have things initialized I do not have to bother outsets depend on insets and insets also depend on outsets because of this guy right so the beginning the in depends on the outs of the free dc sets and at the end out depends on the in of the current how no it is you're just putting it as empty for the time yeah yeah huh so in this case when you put the in the left hand side will be a different it will be empty and the right hand side will be get computed and that is what is doing this this thing right this chaotic thing right so so whenever like here you will say you are whenever you are computing this in guy you will assume your out which is nothing but into to be empty but you will get a new value for in very good question let's see why should it stabilize okay so so this is referred to a six point computation I mean just again don't bother now let's try to sketch the whole algorithm exactly what are we trying to do so to begin with we start with doing initialization I forget to and that works because it is empty so yeah so so this is my initialization so I initialize all my insets to empty outsets I put them to gen I mean I'll see I hoping to save an iteration that's all like maybe one more iteration it would have stabilized one iteration earlier it will stabilize again so that's not the marriage don't work I could have just done it empty also would not have changed anything okay so next what should I do how should I set it up so this is my initialization after this how should I set it up for the entry block is not the universal set the entry block is also the empty set right reaching definitions is empty at the beginning so this takes care of this but you are right when I should have us in other cases in any other cases it could be the initialization set and the actual value may be different so then I will have to set it agree separately but in this case it works so I don't have to bother so then what do I need to do so I need to so let's say now I'll use this flag to say that have I reached a solution so I will simply set this flag to whenever I have reached a solution what is a solution a solution is basically remember what is the solution the solution is the in and out of all basic blocks not one basic block right so I have to check if none of these guys change then I will say that okay I have got a solution you understand that right so the solution is not the in or out of one basic block it's the in and out of the all the basic blocks right so you have to run through the whole basic all the basic blocks so your check for termination is what run through all the basic blocks ensure there is no change in any of them right so that is my flag then what do I do yes we'll apply the equations so basically we'll keep on doing it till the flag stabilizes we'll start with taking flag as false I don't know why I did that but you get no no I wanted to enter the value so okay so now so this is where the actual business is happening so for all my basic blocks in my set of basic blocks n I simply compute a new value of in depending on the outs that I get see here the I've not used the older in right that is was one conclusion somebody had and then I then I check if this new in that I got is it different than the earlier in or not right if it is different than the earlier in then I have to continue my flag cannot become true sorry the flag flag will remain false I mean it will not which which side did I see yeah okay you got it right so okay so then so if new in is not equal to in then I set my flag to true that means I I have still not done yet I again need to recompute my solutions and I update my equations right I update my in B to be the new in and correspondingly update my out to the new value that is all that there is very simple very clean very neat right so stare at this for a moment make sure you understand it so notice that this is the part which is actually talking about one solution right this is the part because solution is remember the solution was all the ins and outs right so this is the part which is actually talking about one solution and if the solution changes we go back in the loop so this loop is only just checking one solution this is check solution okay so so equations of the form like okay we will come to fixed point theory we will talk so these are these equation these sort of equations where things can depend on itself so these equations are called fixed point equations and a solution such that f of x equals x is referred to as a solution to these equations which is essentially what it means is so it's sort of it has reached a saddle point it does not change from there that's what it's called a fixed point it just gets fixed there not unique it's just that the solution doesn't move from there so essentially what it means means is that see fx equals x it means that if I take x and I apply again I get the same x back so if a solution x0 satisfies this particular condition then I would say that x0 is a fixed point solution of x of the function f so fixed point theory is a is a theory itself it's a lot so it's essentially studies such functions well no it says that the definition is that of a solution x0 is referred to as the fixed point solution of a function f if applying x0 to f gives you x0 back that's that's a definition and we are interested in this case we are interested fine fine solutions and this f in this case is the vector of all all your meet and join equations so it's not one equation it's the the whole vector is one question I am not bothered to ask it okay are we are we good so yeah so I think we are doing a very good job of like discussing and so you guys should also do that maybe just make sure that everybody understands and then we will get to the class so do we understand this algorithm completely any doubt anywhere even a little doubt because we will go back and implement this is an LLVM and we will see something happening we are assuming yeah for time being we are assuming only one instruction so only thing I have not told you is I have not told you how to compute the gen and kill sets for multiple statement that is the only thing remaining to be told if that is told everything else works okay if you just assume that somebody gives you a general tool set even for a multi statement basic block everything else works right we do not know how to compute the general tool sets for a multi statement basic block right now this works for you all good okay can I move okay now is the big question very good okay so okay I hope others have not heard it so okay look at this data at the solution and look at this algorithm and tell me that why should this halt why should I ever like there was this question right this system equations why should it ever converge right so stare at this and tell me why should it so you should tell me that what happens in every iteration what happens to this solution that I get what happens to that solution in every iteration excellent excellent either the set sets remain the same or they increase in size they can never ever decrease in size that you are sure why is that because I am taking union of for ins I am taking the union of outs you can only increase things cannot decrease things right and the gen sets are the same the gen and kill are the same when I computing the outs right so in the previous iteration if that will not remove something in the next iteration also they cannot remove the sink the same thing right it cannot happen that even does not remove the first iteration but even got in the second iteration that cannot happen right it is the same function the gen and the kill is the same are the same for every basic block right so can you are you convinced that the in and the outsets can only increase in size they cannot decrease in size okay good so they can only increase in size what is the largest size that they can grow to the number of definitions the universal set so there is a there is there is upper bound and there is upper one to this also so so so it is bounded by the totals the universal set of definitions right so eventually if it keeps on increasing at most in the worst case it can go and hit the ceiling if there is a ceiling right the ceiling is a set of all definitions right so it cannot grow beyond that so this guy someday or the other has to halt right so this algorithm will surely terminate are we good with the proof do you understand the proof okay now can you isolate the things in the proof what are the two things I used to do the proof what are the two properties of these functions or this type of analysis that I used in the proof there are two very important things I used and we will see that in when we really formalize it properly what are the two important things I we discussed you used the can you isolate those I am saying two so you cannot tell me so first is we looked at the nature of the function right these are the in and out functions I did not want to tell it but I think I should tell the what is the function here so essentially so we are talking about the fixed point computation right so let us let me just define what we mean by a fixed point solution so if for a function I say that is a fixed point solution if f of gives me back right just take it as a definition this is a definition so I say that is a fixed point solution of if I apply again and give me on applying f to x0 again gives me x0 again gives me x0 back then I say that x0 is a fixed point solution does it does it make sense so here if you think about it I we are actually computing a fixed point solution the solution it looks like this there is a in one in b1 sitting here out b1 sitting here in b2 sitting here out b2 sitting here so this is my these are my solutions right what is my function what is my function f no no no mathematically what is my function now so again look at it so this is what my x0 looks like so my f should be able to take this x0 and give me an updated value so what does my f look like what is my f what is my function f so if you think about this algorithm what is this algorithm it says that while so I initialize x0 to some in some initialization we will theoretically say what that is one moment and while not stabilized I say x is equal to f of x0 f of x sorry so I they put x to some initialization I do some initialization of x and then y while this does not hold not stabilized means while x is not equal to f of x I say I apply f to it again and do and put it back in x essentially this is what we are doing nothing more than this you should be able to see this that is all we are doing nothing nothing more serious to them now tell me what is my so this is the computation of f this is the update of f so can you tell me what is this f no no no so you understand my x0 is a vector of these guys right so my f should also take a vector of these guys and give out a vector of these guys so what does my f look like I will keep on repeating it so why what is my f so what should I what if my x0 looks like this my f should be able to take this vector and spit out a similar vector the updated vector for each value of the vector mathematically tell me what is f you guys are trying to sneak out I will not let you no no f is a function now so to say what is that ah somebody said something set of all outs no but f is a function f is a function look at this look at this thing I wrote compare with whatever you see on the screen on left hand side this this is this is all that we are doing this three lines of code is all we are doing we wrote ten lines that is a different matter so you have to somehow summarize those ten lines into this okay so f is basically that like if I want to compute enough b enough b1 what is enough b1 it is empty set what is out of b1 out of b1 is enough ha jen of b1 jen of b1 then union enough b1 enough b1 minus kill of b1 comma so my function is basically a vector over all these mutant update functions and I apply this function f by doing a component by component application of these functions do you see what is happening this is the simplest form I could think of so essentially think of this function f itself being a vector of functions right every element of that vector of functions every element is a function and that function applies updates the respective element in the solution right can you see this so this empty is a constant function this is also a function which takes anything and gives you an empty function right so it will take this and give you an empty function again this guy will take this and give you an updated solution for this this guy will take this and give you updated solution for this so it is a function of vector it is a vector of functions which is applied on the vector of solutions or the solution vector gives you an output solution vector does it make sense to communicate it now it is not obligated right make sense look at this particular loop that is exactly what this guy is doing it is just running over my vector of functions and updating each respective element in the solution and giving you this particular update exactly this particular update is what this guy's doing nothing more right yeah 9 light wheel is wrong you are right so this I did in my taxi so the shaking too much yeah so this should be this should be in B minus kill of B union j. Thank you done got it so essentially we have figured out we are doing a so essentially we are not doing something very serious we are doing something very simple it just the function is complicated that is all it is right so now we are we know that we are able to compute the fixed point solution and we know that the solution halts do we know that we get the smallest solution can you argue that yeah but half you get them what is the argument why can not a arbitrary definition speak in okay so one way to do these proofs how can you do actually mathematically do this proof how can you really write a proper nice proof okay how will you do maybe what you are saying is right but you have to formalize it better so what is the type of what is the proof strategy that you use no you cannot do so there is no direct this thing so what sort of reasoning to use what are the proof techniques to know of induction contradiction and so what is the sort of proof will work here so there is a loop here so whenever you have a loop then what is works well induction works well right so what you know at the beginning of before you enter the while loop is that is smaller solution smaller than the original solution right we it does not contain an extra definition it does not contain an extra definition that we know why because we have initially empty and generally there right that we know so my base case holds right so my theorem that in trying to prove is that I do not have an extra definition in any of my sets in the beginning the base case is that I have not entered the loop I have taken zero iterations and my solution is solution holds yeah the lemma holds the theorem holds once good that holds because I have not everything is empty so I don't care now you have to say that how do you apply induction so you use an induction hypothesis so what is the induction hypothesis right so you use an induction hypothesis which says that for any iterations for any any iterations of the loop I do not have an extra definition yet that is the assumption and then I do the inductive step the inductive step says that given that after any iterations I did not have not introduced a new definition after an additional step I will still not introduce a new definition right so can you try that on this very interesting area it's it's a theoretical area and it's a like practical area right if you just do theory it's not interesting if you just do like applications or build implementations it's not interesting you have to do both you have to do proofs and you have to also build things right so we will be to improve now and afternoon we will build things yeah so the proof you will do at home you try to but you have to understand the structure of the proof right this is exactly what you have to do okay so we know that the last thing is that what is the complexity of this algorithm maybe maybe maybe what we should do is that let's try to think about the complexity of this particular step rather this particular step right so these are two important steps that are happening in between right so so this particular step is actually for all basic blocks it is doing some unions and some in some updates and so on so before coming to this let's think about the data structures because then the analysis becomes maybe we can do something more tighter so what what do you can you think how can we represent these guys how can we represent these sets so that I can do this updates fast right I have this union sitting here and we have a differencing operator sitting remember what you need to do these are just set manipulations in and outs are sets okay I see what you're saying so you're saying B out of B is a hash map yeah okay agreed but I'm saying what is going to be my what is the how will represent a set itself every of these all these guys are sets right so enough be okay I see what you're saying you're saying in is nothing but a set from basic blocks to something to a set given the basic block I would like the set the set of definition that it has right so I'm asking what how will you represent this set of definitions list of things list is not a like linked list and a what what can you use what should you use so this is what is called a bit set it's a very common data structure in almost all compiler frameworks right so essentially for a set I need to just say that it is a member of that set or is it not a member of that set right so I will allocate a vector of bits of the size of my universal set right for every element for every set I will put the respective bit bit on if it is a member otherwise off it is not a member right so you understand what you think right so the d1 d2 d3 d4 I will just order them in some way and I'll create a vector of bits b1 b2 b3 b4 and I will set it to 1 if I want d2 to be in the set and set it to 0 if I don't want it to be in the set so now I can have these bit strings or bit vectors which will tell me what are the elements in that set of course I can only do it for a bounded side size set I cannot do it for an unbounded sense if the universal set is bounded right so now assuming that I use bit sets how do I get how do I do union over bit sets will be a or an or operation is a union over bit sets extremely fast bit operations are really fast right and what will be intersection and differencing you can figure out you can write that also as intersection and negation and things like that right so you can actually do these operations really fast using when you have bit sets so now let's assume that my sets are represented as represented as bit sets now can you look at the algorithm and tell me the total cost of this so you can assume that I can do this bit set of operations in constant time so I am NOT so essentially what I have thrown away is the size of my universal set I don't care how many definitions were there right they are represented by bit set and I can do bit set operations in a in constant time now what is the complexity of this so the definition loop you don't have to bother about so the set of definition would come in when you want to do these business right when you have to do a union or minus that is where the size of the the size of the set matters but I am saying because we are presenting them as bit sets we can do that in constant time so you don't really need to worry about the number of definitions you got what I am saying number of blocks yes so this iteration move this is this inner thing happens for for the number of blocks and the outer thing so that is one estimate at most the number of definitions because I can okay that's why you were saying definition I see so because every time assuming that I climb by only putting one definition and then it is number of basic blocks into number of definitions but that's a bad estimate can we do better number of edges inside the value so but but but that can create a long chain right you can have a long chain of dependencies which again goes back to a loop yes that is simple right computation inside is the number of basic blocks because all these are constant so these are so okay one thing we assume is that my graphs are like control flow graphs are generally small graphs right so the in degree and out degrees are not high right so because like what do we say if condition branches into two switch cases are not so much but even we do not have large switch cases a lot of times so we can assume that we can assume these relax these things and we can assume that these are constant time so even I'll assume this can be done in constant time let us assume this can be done in constant so this can be done in constant time this can be done in constant let's not even bother about those things so this now goes for the number of iterations right so now the question is how many times outer loop goes that is my main question actually so one estimate for the outer loop was that number of definitions because I can say every time I like maybe I'm really bad and I had I have to at most add one definition rather at least add one definition right but then think about it you have to add at least one definition your solution set is not one set it's a set of sets or a vector of sets it may happen that you add a definition to one of these sets which gets propagated to each of these sets and then this guy puts another definition to the first set again it propagates so the question is how many times my basic blocks have to get updated that is what I am asking so that is like you will tell me tomorrow what what goes on with this okay third question is like if you have to implement this algorithm so here I do not mention order on these basic blocks I'm not saying I just say pick one basic block and update it pick one basic block and update that's all I worry about right I'm just worried about that every iteration of the while loop I update all my basic blocks that is all I care about I have not given an iteration order on the basic blocks what do you think will be the right iteration order what will be what do you think will be a good iteration order period before child is not a graph traversal you have to tell me bfs bfs so essentially maybe but that is what you wanted to say so say essentially what you do so what is the idea essentially you would like to do some sort of a so there is a cycle so you cannot essentially get a topological order but if I use my dominator information can I do something or what if I look at the cycle free graph if I just remove the cycles and topological sort on the on the cycle free graph that looks to be a good order because exactly what you are saying that I would have computed the the predecessors before I look at their children so I would have not so the and what would have the worst order the reverse of this right I keep on I have the like the states have not get updated and I am computing it already and at the end I go and update the guy and this guy is the start the whole cycle right so that's the worst the worst case that is for a forward analysis for reaching definitions had it been a backward analysis then I would have done the other other direction right so these are interesting ways of like these are the so it does not change your worst case complexity but it will change your runtime when you are implementing so I think we have answered it so this is how you set the definitions and bit sets no what will change the worst case complexity will remain the same the runtime will change your implementation will be a better implementation so if you do forward analysis you should do topological order why because you should have computed whatever you are dependent on so in the forward iteration your in is dependent on the union of the outs of the predecessors so first compute the predecessors and then only compute your the correct node if it's a backward analysis then you have to do the other way your successor should get computed before you compute the present so now what if we have multiple statement basic blocks right so that's the only thing remaining to be covered so I did not tell you how to compute the gen and kill sets if I had multiple statement basic blocks first question is why would I have a multiple statement basic blocks why why should I even bother having multiple statements why can't I live with single statement basic blocks nothing nothing I mean I don't lose anything right still do fixed point iteration all these business so no but why do I have to have basic blocks which have multiple statements I can have basic block which have single statements what is the requirement of something being a basic block it has a single entry and a single exit that's all so every statement by itself is a basic block what what complexity reduces how I have to do updates on all of them anyway I'm doing a fixed point computation what does it impact size of the solution it impacts the size of the solution right so I'll have to do my function vector will be larger so my inner loop in the while loop will be larger because I'll have to run through a larger set of larger vector function vector right instead what we do is we try to summarize the information for every basic block separately and try to do this so my number of equations increase so I do not have to so I can live with a smaller set of equations if I combine multiple statements together into a basic block so there looks to be a interesting reason to do this now the question is that if I have multiple statement basic blocks the only question is how do I what is going to be my gen set and what is going to be my kill set let me give you a problem let me give you a example like a basic block on which you can think about a equals 5 b equals 29 a equals 26 let's say this basic yeah that is all you need everything else you already have the equations you already have just apply them everything else just works only thing we don't know is for multiple statement basic block what is going to be my gen what is going to be my kill for a single statement basic block we know it I hope gen is the guy which is sitting there right and kill is all the definitions that particular assignment is killing right now how do I get the what do I do for the multiple statement basic block so for instance for this basic block let's say this is d1 d2 d3 what are going to be my gen and kill sets are you sure is gen going to be d1 and d3 sorry sorry sorry sorry d2 and d3 why not d1 right right right and my so this is my gen and what is my kill kill is going to be well I have to really consider other universal these things corresponding to what why do so how do you initialize it whatever your list is both empty so one for gen one for kill let's talk the general worth of us these are separate anyway d1 have you got it so I we simply do a scan through the through the linear the this thing the basic block we start with for gen I start with an empty set start with an empty set I just say that I get the first statement I put that definition in the set I get the next statement I put that definition in the set and I may remove things if it kills anything already present in gen because by the by the time I reach the end of the basic block the new definition will not be exposed like for instance a right whenever I'm hitting this last a equals 26 I need to push out the earlier definition d1 right so the gen set here it will become start with empty at this location it will have d1 at this location it will have d1 and d2 at this location it will push it will have d1 d2 d3 and it will push out d1 right because now d1 cannot be generated because somebody in the basic block itself has killed it right so this is my gen algorithm what is my kill algorithm kill I can just take a union of everything and whichever these variable skills because I kill and anyway I generate later after that so I don't have to watch no so there are no no so you are you for the kill set you will start with you have to talk about what are definition in the universal set get killed kill is much simpler right you know that there are updates to a and b in this basic block so in the universal set whichever definitions are defining a or b all of them get killed so now we all know data flow analysis of at least reaching definitions very well