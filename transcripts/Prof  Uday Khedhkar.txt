 Good morning to all of you. So this is an optimization of virtual function calls. So I am really not going to explain how the optimization is done, but what I am trying to do is I am trying to explain what are the issues here. So we will begin by looking at C++ inheritance, how the data is stored and in particular how does a compiler deal with virtual functions, how does a compiler handle virtual functions and then we will just look at what optimizations can be done although it is beyond the scope of this lecture to get into the details of how these optimizations are done. So we are going to look at internal representation of a class, we will talk about translating virtual function calls and we will talk about what the proposed optimization is. So here is a certain class, it has some members, public members int y and z and there is a private data member x and it has a private function f2 which essentially increments its argument and f1 calls f2 with its argument and multiplies it by 2. So I am just trying to show what exactly happens internally, what does a compiler do with this kind of a code with something being private, something being public, something being data, something being function. So we want to look at exactly what happens under the hood. So we have data memory and code memory, we saw the organization yesterday, there is a code memory, there is a data memory and data memory, we have static stack and heap. So here we are not making that distinction but we are basically looking at the data and code memory. So we have two variables declared, small a of the class a and b again of the class a The important point is in the code memory we will have this function a of f1 and in the data memory we will have object a and object b. So the data members and the function members get distributed in the memory, the function members go in the code memory and the data members go in the data memory. So in the data memory we have x, y, z, note that in the data memory there is no tag of which one is private and which one is public. All this is a matter of scope resolution during parsing and type checking. So when this code is translated there is no notion of private or public. So we have x, y, z for object a, x, y, z for object b, both of them are for the same class and we have this function, we have this function f1, we have this function f2. So every function with n parameters is translated to a function with n plus 1 parameters and the first parameter always happens to be what we call as this pointer which is a pointer to the receiver object, the object on which the certain function is being called. So effectively this is nothing but a C program. So C++ is at an intuitive level is translated into a C program and that is exactly how it used to be earlier, now it is not so but at an abstract level you can see a C++ program as a C program with a clever use of pointers. So we have this which is the object, pointer to the object. So when this function says x is equal to something is going to translate it as this arrow x equal to something. So effectively this function it says return i that is a parameter so it is not an object. So effectively this function ignores this argument. So this is the whole point. Now let us see how execution happens. So we say let us say we call a of f1 is equal to 5, what will be the output of what will happen because of this call a dot f1 5, spend a few minutes and tell me what would happen. f1 will get called with 5, so it is going to call f2 with 5, f2 is going to return 6. So this will multiply 6 by 2, result will be 12, so we will have x equal to 12, the question is which x will be a is private. So we should have 12 written here. So the way it gets translated is that this f1 5 this call gets translated like this. The address of object a is passed and because the address of object a is passed it says a arrow x is equal to and note that this is translated as a colon colon f2 this. So we get so we know that we are doing something for object a and therefore we will end up this x corresponds to this x and we will end up writing 12 in that x. Is the overall arrangement clear? Next one easy easy what will happen with b dot f1 with 10, we will write 22 where in this x. So we will once again have in this call for the next call address of b is passed and then it becomes b arrow x and therefore we will end up right that is the arrangement of c plus plus. Now what we want to see is what happens when there is inheritance and in particular what happens when there is there are virtual functions in an inheritance hierarchy. So this was the easy stuff warming up exercise. So now let us say I am just trying to show how inheritance happens. So we have three classes white blue and pink. This is the base class, class white has just w1 with and this is the object w for white, b for blue and p for pink. So this is the object for w1 and now this class blue says public white which means that is going to inherit everything from white and additionally going to include these b1 and b2. So b this small b would be it would have something called w1 which is this field and b1 and b2 which is this field right and then we have class pink which derives from class blue. So it will have everything that class blue has but additionally it will have p1 and p2 the two pink members right. So this is how the inheritance of data takes place clear. Every derived class would have everything that comes from the base class and the size of the derived class will keep growing as we derive more and more we will have more things coming in right. So this is the inheritance of data. Now we want to look at inheritance of functions. What happens in case of inheritance of functions? So non-virtual functions are inherited much like data members. So there is no difference between non-virtual functions and data members except that because it is the same function that is inherited there is one copy of the code across the entire hierarchy. You don't keep separate copies of and of course these functions go in the function memory they don't go in the data memory right. Can you all visualize it? Data is of course different. So we have to create separate space for this data. This b1 is different from this b1 and this w1 is different from this w1 which in turn is different from w1 but that doesn't happen for inherited function members in particular non-virtual function members right. So inheritance of data is easy. Inheritance of non-virtual function members is easy. Inheritance of virtual functions is where some interesting things happen and which is what we want to understand. How does the compiler set up the things in order to make sure that the right function is being called? That is the problem that we want to look at in the next half an hour or so. What is a virtual function? Maybe I should have asked you. How many of you have not used C++ before? So everyone has used. Would anyone like to answer that question? What is a virtual function? Yes, yes and a standard example there is which I think I can take. Every C++ book would have the standard example. We first create a class called shape which among other things has this function called draw. Now what does a draw do? It depends on what the shape is. You cannot draw an arbitrary shape and then when we say class square public, I do not remember the syntax, yes, public shape when it derives when a square derives from shape it draws something like this. In a similar manner when we have a circle, circle derives from shape it will draw something like this. So, the whole idea is that we want a certain functionality which is common to the class, hierarchy, but that functionality has to be distinguished based on the particular instance in the hierarchy. So, I want to be able to say that every shape has a draw function, every shape has an area, every shape has a certain perimeter, but what it is depends on the particular instance of the class and therefore, we use virtual functions. Because a draw here does not mean anything or area here does not mean anything until you tell me what the shape is, I cannot tell you how to draw it, I cannot tell you what the area is. So, it is so the idea is to say that there is a function draw, but and often what happens is we say draw equal to 0 which is a pure virtual function which means that this is an abstract class. There cannot be an object corresponding to this and every derived class must necessarily give this function. This is a functionality which is common to the classes that are derived, but at an abstract level we cannot really execute that functionality. We do not know how to execute that functionality. So, when you put equal to 0 it means pure virtual function and if this draw has not been defined in a derived class the compiler will give an error. If you do not put a pure virtual function the compiler will not give you an error. So, that is a virtual function. Virtual function is a function which is virtual. Now in what sense is it virtual? It is a function, but whose functionality is defined by the classes down in the hierarchy. Any other question about virtual functions or inheritance or C plus plus in general related to this before I proceed? It is important that you stop me. It is possible that I might be assuming some things and that assumption may not be true. So, please feel free to stop me at any point of time when you have a question. Can we proceed now? Is it ok? Ok. So, that is a virtual function. Now let us look at the difference between virtual and non-virtual function. If draw had been a non-virtual function it means that this class itself will tell me how it has to be executed. The rest of the classes will simply get it. What happens within draw if it was a non-virtual function does not depend on the object, does not depend on the class of the object. It simply depends on the class in which it has been declared. Whereas for a virtual function because a pointer to a base class could hold an object every shape every square is a shape every circle is a shape. Therefore a pointer to shape can point to a circle therefore pointer to shape can point to a square. And therefore virtual functions take a different avatar depending upon the particular object that the pointer points to and this is a runtime decision. So you might say x arrow draw if x points to a circle you will end up drawing this if x points to a square you will end up drawing this. This looks like a runtime activity. It is a runtime decision. That compiler can do something. So we talk about yesterday we talked about advancing binding compilation and optimization is all about advancing bindings. I mentioned yesterday that I belong to that school of thought which says do not put off until runtime what you can do with compile time that exactly is advancing binding. So one option is to leave this decision completely to runtime and the other option is to leave the minimal decision to runtime and do as much possible at compile time at static time. And as I said yesterday these are the things that make interesting ideas require interesting ideas and this session is aimed at showing yet another beautiful idea of runtime behavior for that a lot of work being done at compile time. So when you see the signature all business is external. You know compile is the angle of everything. Scope etc is all external. When you look at the intermediate code or when you look at the machine code there is no scope. Where is the scope? You might have a compound statement or local declaration. Show me that in the generated code? No. So all these things are for checking. You know validating the input not for generating code and putting some restrictions on the code. So what is generated that information is lost. Which is what I want to show you. How it happens in the case of virtual functions. Any other question? So this is clear how data members are inherited. Pretty simple. No big deal. Non-virtual functions again pretty simple. No big deal. So virtual functions create interesting possibilities based on the object to which a pointer points to. A pointer to base class may point to an object of any derived class in the class hierarchy and the virtual function should be picked up for that object. And we want to do as much decision at compile time as possible leaving very little to the run time. So what is this arrangement? What is this static plus dynamic arrangement which enables this? It can't be pure in general it can't be purely compile time but virtual function optimization means try to do it purely at compile time. So let's look at some example of a virtual function and I am going to explain this. So we have class A, B derives from A and C derives from B. We have this function F. In A we have F without an argument. We have F with an argument so there is overloading. So depending upon the parameter we call different F and there is a G. All these are virtual functions none of them is a null virtual function and because they are not null virtual functions we should have their bodies and we will look at their bodies. But let's look at what this does. Class B defines a G and says it's virtual. It also defines F. So when B is called with F it should call this F and not this F. Because this F is virtual when there is object of class B F we will look at this in more example and C in turns only defines F. So the complex arrangement of virtual and non-virtual functions and we want to see what can a compiler do with it. So let's first look at their bodies. So this function F because it's in A it simply prints A colon F. This function prints A colon F and also prints the string the argument and this function simply says A colon G. So most of function simply say where they have been invoked from. This function G says that this function belongs to B colon G. This function F says that this belongs to B so it's B colon F and this says this is C colon F. So a simple idea behind just to identify which function is being called at what time. Is the arrangement of functions clear? Now let's see what happens when we look at execution. So these are the virtual functions. So let's look at this. We have this A, B, C three objects of respective classes A, B, C and now we are doing certain things and we want to imagine what's going to get printed. We want to see some calls. So here we have P points to an object of type A and then we call P arrow F with this string class A. This P arrow F, this P arrow G. So this function is going to print AF dot class A. Let's look at the function body. It says AF dot that particular string. So this will print AF class A. Easy? No doubts about that? This F will simply say this is an F in class A, the one without the argument and this will say this is a G in class A. So this is a pointer to the base class anyway. So we will have everything printed for the base class. So that's not so much of an interesting thing. Let's make the situation a little more interesting by having a pointer pointing to address of class B. What do you think should be printed here now? This should be because there is no string function here. So the string function of A dot F should get invoked. What should this print? B dot F. What should this print? B dot G. So it prints the following. A dot F class B because parameter is class B. So you are passing the name of class B to a function which is virtual but it has not been defined in B and since it has not been defined in B, it is going to pick up the copy from A and therefore it says A dot F with the parameter class B. Now we are calling F which is a virtual function which has been defined in B. So it is not going to pick up the value from A. Instead it is going to pick up the function body from B and therefore it will print B dot F. Similarly for G. So it is going to print B dot G. Easy? No doubts in anybody's mind? All of you with me? Wonderful. Let's make the situation even more interesting by picking up a pointer to C. So when we have a pointer to C, now what will be printed? This will print. This function will have to come only from here because there is no F with string anywhere. What will this print? P is B equal to and C. P is a pointer of P has been declared a pointer to A but it holds object of C. What should be printed? Tell me. So this will be AF. What will be this? C dot F and what will be this? Have I managed to divide the class? How many of you think this will be A dot G? No one. How many of you think this will be B dot G? Anyone who thinks it will be C dot G? No because there is no G in C. And this F, how many of you think it will be A dot F? None. B dot F? Why will it be B dot F? There is an F defined here. Pointer doesn't point to A, pointer points to C. So let us see what does my output say? It would have picked up this F. I don't know whether this should have been virtual. I don't remember that. So this will override this function. It will override this function. So there is overriding and there is a virtual business. Now let us see how is this complex arrangement implemented? That is the overall idea. Now let us get back to, so if this is the virtual function, if no virtual function, it will always be based on the declaration of the pointer. It will always be A dot F. So virtual function resolution is partially static and partially dynamic activity. At compile time, a compiler creates what it calls a virtual function table. There is a virtual function table for every class in the class hierarchy, a separate virtual function table for every class. And a compiler generates code to pick up the appropriate function by indexing into the virtual table for each class. So it is very efficient. In one table, at the second position, you want to put the function, at the third position you want to put the function and that function will be called. And we want to see how this arrangement is made. Okay, so again the same code with, so we have naive code looks like this. We have these three functions. V stands for virtual. We have these functions and so this class has inherited all these functions and then there are local functions of this and this class has inherited everything that V has and additionally has F, the same arrangement. And now we want to first look at some examples before we actually look at the arrangement. Okay, so first look at this case. P is a pointer to class A, okay, but we do not know what P actually holds. It is a pointer to class A, but it may be holding an object of class B or an object of class C. Anything is possible. So we do not know which class is. Okay, and now we are calling P F. Okay, so at compile time, in general, which object, what is the object whose address is being held in a pointer is a runtime activity in general. At compile time, we do not know that. Okay, so we do not know the class of the pointy of P. So it may be this F, right. If it happens to be a pointer to class B, it is going to be one of these two. Okay, if it happens to be a pointer to this class, it is going to be one of these and we will rule out which one is based on virtual function, but in general, that is a possibility. So we are looking at what are the decisions that can be taken without any runtime information. Here, without the runtime information, the idea is no decision can be taken. Let us look at this situation. Now Q is a pointer to class B. Now, if I do not know what this points to. Okay, can Q hold the object, can Q hold the address of an object of class A? No, it is not allowed. By typing, it is not allowed, right. So therefore, compiler can simply rule this out. No runtime information needed. It cannot be this function. Even if I do not know what the class is. If the program is type correct, it can never be this function, right. So I am showing what are the things that can be easily derived at compile time. What are the things that need runtime decision and where things require compile time plus runtime decision, what the arrangement is made. That is the way in which the story is progressing, right. Now, it could be an object of B. So then we have to choose between these two and we will see how do we choose that. Or it could be these. Third situation is we have a pointer R which is a pointer to C. Now, by the type system, this object can never be an object of class A or an object of class B. So, a compiler can rule this out completely. Similarly, a compiler can rule this out also completely. Not possible. The only thing that is possible is here, right. So there are certain things based on the declaration of the pointer, there are certain decisions that are taken, okay. So, if we have a pointer to one of the derived classes, certain decisions are taken. What happens when we have a pointer to the base class? We saw all these possibilities. How do we pick up the right possibility, right, without knowing what that object is? So, that is the arrangement that we want to see, okay. So, non-virtual function, let me just skip it. I think it is all the same story. Let me just, so, yeah. So, resolution of virtual function depends on the class of the pointy object. It needs some dynamic information. Resolution of non-virtual function depends on the class of the pointer and compile time information is sufficient. In either case, a pointy cannot belong to a higher class in the hierarchy, okay. So, we are back to the same story and consider a pointer to an object of class A. Now, we are ruling out the possibility that pointer is a pointer to these. Although it could hold an object of this, but by declaration, it is a pointer to class A, okay. And this pointer could point to an object of class A, B or C. So, that is the situation that we want to look at, okay. So, we have these functions in A, these functions in B and these functions in C, okay. And now, let us see what game we can play with this information, okay. So, now, we have these and we are trying to see how we can create a virtual function table in order to rule out things that are not possible, okay. So, if we have these functions, so now, we say that for each functions there is a single copy. This A dot F, if at all this function is called, we will refer to this. If at all this function is called, we will refer to this. So, we remove the replicated functions. We write only the functions that are not replicated and then make an arrangement so that these functions can be appropriately called. The reason why we want to do that is unlike data members, function members are not really replicated. It is the data that is replicated. Data has separate space. Function has only one function per class, right. So, we have this. So, these are the functions and now, we want to set up the pointers appropriately. If we have an object of this class, it can be any. So, this function will call this, this function will call this, this function will call this, clear. If the object is of class A, right. If the object is of class B, then it could call this function or it could call this function. What is the right thing to do? Right thing to do is to call this function, right. So, therefore, we remove that function. We say B dot F will always, A dot F is over A colon colon F is overridden by B colon colon F, right. Easy. So, now, we set up this pointer, okay. If we call this, this is the only function. There is no function F with a parameter, right. There is no function F with a parameter here. So, we say A colon colon F is inherited. So, for an object of class B, when F is called, it will call this. For an object of class B, F i is called, it will call this. Easy to see, right. And when G is called, there are two possibilities, this or this. Clearly, we are going to remove this. We say A colon colon G is overridden by B colon colon G. So, we now have determined. So, what are we doing? We are saying for every class, if I call F or if I call F i or if I call G, which function is going to be called? I want to make my arrangement. So, what I am trying to do is, what this system is trying to do is that we want to create a table. If we have an object of class A, what is F, what is F i and what is G? If I have an object of class B, what is F, what is F i and what is G? So, we are essentially setting function pointers. If we have an object of class B, what is F, what is F i and what is G? So, we want to set up these function pointers. We want to set up an array of function pointers. So, here we have said that this function pointer actually points to that function, whereas for these two function pointers, they point to this function, right. Clear? Now, let us come to class C, object of class C. There are three possibilities, this, this or this. Which one will retain? Obviously, the last one, right. So, the first two are gone. Both A colon colon F and B colon colon F are written overwritten by C colon colon F, right. So, now, in this table, we are setting up pointers here. So, we say this F is C colon colon F, ok. If it is F i, a parameter, a function F with parameter i, then the only option is this, right. So, we say A colon F i is inherited, right. And then, when we have G, we have this G, we have this G and we have this G, ok. But, this G has not been defined here. So, we are going to pick up this G and therefore, we will say A colon colon G is overwritten by B colon colon G, which is inherited in C, right. So, we are talking about all these three things. Something is overwritten, something is inherited, ok. So, with this arrangement, now, we have exactly one function per class. Is that clear? So, all these decisions can be taken at compile time. This is a virtual function table. Now, we have this virtual function table. Now, the advantage of this is that in the entire class hierarchy, we make the size of the virtual function table same. And then, we know F is at index 0, F i is at index 1 and G is at index 2, right. All we have to do is based on the object at runtime, we get the address of the right virtual function table. No, no, whether a function is virtual or not, that is declared by the programmer, is the programmer's intent. There is a virtual keyword appearing in the class. Let me try to understand your question well. Let us go back to that situation. Now, tell me. See, what happens is the following. Because this is non-virtual, if this function has been defined here, ok, this function will be picked up. If this function has not, I mean, and the pointer is to this. If it is a pointer to the class hierarchy, it is going to pick up the function at the top level, right. So, that overriding will happen based on the declaration. So, it will not happen. So, this I should put a virtual here. I think there is a mistake here. I will just correct that slide. Because that overriding happens not, it is not a runtime decision. It is a compile time decision based on the type of the declared type of the pointer, ok. I will check it once. Please note it down. I think this is an error here. I will run this program once again. Check it and just want to make sure that I am not making one more mistake. So, let us assume for the time being that there is a possibility of a mistake there. Now, let us see when we have constructed virtual function table, how do we use it? So, we have created this virtual function table, ok. Now, at runtime we need 2D references. Basically, we are going to talk about this. At runtime, we need 2D references. One is to get the virtual function table, find out what is the virtual function table and the second is the index in the virtual function table, ok. So, this is, let me skip this, ok. So, what is the compile time activity? The compile time activity is to collect all virtual functions across a class hierarchy, ignore non-virtual functions, analyze the class hierarchy to locate the appropriate function with a given permission of argument types and execution time activity is dereference object pointer to access the virtual function table. So, within the body of the object, there will be a pointer to a virtual function. So, the way we have x, y, z data members, we will have a hidden field called pointer to virtual function, right. So, as soon as, because you have the object, you have pointer to the virtual function, you dereference it, you access the right virtual function and then you get the right index, ok. So, this is how the translated code would look like. For here, we will get this underscore vptr is a pointer to the virtual function table. So, you get the pointer to virtual function table. For this function, you take index a, you take index 0, 1, 2, 1, 0, 2, whatever that arrangement is, I do not remember. So, these indices are fixed, you pick up the things at the right index and then that is going to lead to, so this is a function, a call on a function pointer. So, this is a pointer to a function and these are the arguments to that function and this table essentially contains pointers to the functions, right. This is what happens internally. This is the code that compiler generates, ok. Now, you will see that there are some runtime overheads, ok. There are untied, first of all every call has 2 dereferences. More than that, I mean Anshuman today talked about the call graph. What will be the call graph here? At this point of call or at this point of call, you will say all three functions are possible. So, you have a call graph that is imprecise. It is highly desirable to eliminate the spurious information from call graph. Can we at compile time do some kind of analysis and eliminate the, so if we are calling three functions, it is ideally we would like to say, I am not calling A colon colon F, B colon, I am, these three are not possible. I am calling this particular function. So, there are indirect calls. Those indirect calls can be converted to direct calls. This is a desirable activity. Sometimes it may not be possible to convert those calls to direct calls. In that case, we can say at this call point, instead of these possible 10 functions, I am calling only these two functions, then the interprocedural analysis results can be more precise. So, the optimization that I am talking about is the following. Each function call in, so this is the runtime overhead and no function call can be resolved at link time. So, call graph is not known and hence interprocedural optimizations are prohibited. So, we, the optimization here, because we know the object, all indirect calls have been replaced by direct calls. Here, this is easy. Here, this is easy and I do not know whether LLVM and GCC does it. Perhaps, in these simple cases, it may be able to do it. Here, there are no indirect calls and now, I know I have a precise call graph. Here, it is very easy because the pointer assignment is right here within the same function. What happens if the pointer has been set up somewhere else and you are passing that pointer as an argument? So, you have virtual function call x arrow f and the pointer has been set up somewhere in some caller's body or some function that has been executed before. Can you still resolve virtual functions? Can you still do something? That was the topic of another PhD student in my group. She submitted the thesis just now and she has come up with a very nice analysis which is able to do virtual function resolution which is much more precise than any of the existing things. Obviously, it takes care of these simplest cases, but it also takes care of the more general cases, most of the more general cases and certainly more precise than any other approach to virtual function resolution. So, that is a small part of a thesis. Then, the thesis goes on to build theory of bi-directional analysis. She does it in demand driven manner for efficiency. So, lots and lots of things which are at the moment irrelevant to our discussion, but this was optimization. So, optimization that I want to describe was whenever you have a virtual function call, try to do one of these two things. A, try to find out a single callee and replace the virtual function call by a direct callee if possible which is what has happened in all these cases. Thus, if you cannot do that, it is possible that you may not have information about the object or you might have information about two objects from different paths. A might hold a pointer to, a P might hold the address of a pointer to A along this path, but address of a pointer to B along this path. Then, you cannot say compile time which path is going to get executed and then you have to say it could be this function or that function which is also useful because the inter procedural path certainly becomes inter procedural control. The call graph for inter procedural analysis certainly becomes more precise and therefore, all inter procedural optimizations can benefit. So, this is what we wanted to, I wanted to describe and I will check that virtual business. Just give me a few minutes. Most of these decisions cannot depend on whether it is two level or three level. I mean, unless in two levels, it is able to find out in three levels, it is not able to find out, but you are saying the other way round. In three levels, it is able to find out. I will take a look at it. I have to understand any other question. So, the slides for yesterday have been uploaded already on the workshop page and Nimisha will be uploading these slides as well, but let me first correct. Let me just check this. You already uploaded? Okay, fine. So, she will upload once again if there is a correction, but there is a possibility that I may have to make a correction here. Can destructor be made virtual? I do not know. See, destructor, it is definitely the case that destructor of a derived class internally calls destructor of a base class because destructor, because we are also getting the data, the data members of the base class. So, you are saying that then the memory allocated in the base class may not get freed, allocated in the derived class may not get freed possible.