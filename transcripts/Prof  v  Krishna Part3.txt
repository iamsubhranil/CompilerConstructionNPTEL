 So, if you look at the previous example, if you see it as a flowchart, this is the flowchart of that Fibonacci code. If you look at the flowchart, you say there is an if then else, there is a nice loop. In this flowchart, there are a sequence of instructions here, where there are no one is jumping in between and the control is not flowing anywhere out. The control enters at the beginning, exits at the end. I will call such a sequence of instructions as a basic block. Basic blocks has been already covered. I heard, I hear both yes and no. Yes, who covered it? Shubhajit. Did you also learn how to build basic blocks? Fine. Perfect. Have you also been, was dominator is also covered? Yes. Perfect. So, that saves me more time. So, did Shubhajit cover loops, how to find loops using dominators? Natural loops. Natural loops? Lovely. So, then I can jump, then I can jump. So, I will, what I was planning to cover, half an hour or so, I will make it much faster. So, we have loops, sorry, we have from the code, we can construct control flow graphs. So, what is a control flow graph? It is a graph where the nodes are basic blocks and the edges indicate flow of control, right? Good. And here is a question, if I build, so this is, so, given a sequence of code, we do whatever, generate the IR and then do control flow analysis to get some graph like this. The question is, can the control flow analysis expose control structures which are not obvious in the high level code? In the high level code, it is not obvious, but it is more obvious in the, the answer is yes, right? Because in the high level code, for instance, in this high level code, this could have been the high level code, the loop is not obvious, right? So, you can have loops constructed from if and go to's and so on, which are otherwise not, okay. Question, is it? Okay. We already know that the CFG has a special entry and exit block and all that, okay. We know what is the dominator, right? What is the dominator? If I dominate you, then the control starting from the start to reach you must go through me, right? Okay. And then the, the dominator relation is anti-symmetric, reflexive and transitive. Reflexive as in I dominate myself, if I dominate you, you dominate him, then I dominate, that is transitive. If I dominate you, you do not dominate me, that is anti-reflexive, okay. And we know how to compute the loops from your dominators and you know how to compute the dominators as well, right? Was it covered? How the dominators, how do you build dominators? Okay. Before you go to dominators, we talked about basic block building using leaders. Yeah. And then we talked about, I mean, you said, you already know about leaders and how to construct basic blocks using them. Let me ask a question. If there are, if there is an if then else, I can build my CFG understands that. Does C support something like exceptions? Exceptions, no. Sure. No, the idea, what is an idea of exception? You install an exception handler, right? Like when you have a tri-catch block, you are saying at the beginning of the tri, you are installing a handler which is the catch block. You are saying anything that happens in this tri-block, I will return back to the handler and that could be happening way deep inside a function call. So, it is not just checking at that place. The point is how do you go to get back? So, the short answer is C does have some way to handle exceptions, okay. Read about set jump and long jump. Those who are interested, find out the set jump and long jump instructions in C. Anyone heard of these two, these instructions? Yes. Really? You use set jump and long jump? Okay, yeah. Tri-catch looks more high level. Yeah, that looks more, I do not know. I find tri-catch to be more intuitive, maybe because I started thinking of exceptions from there, but this is not terribly bad either, okay. But nevertheless, read what these are. When you see a function call in your code, right? You have built the, I have code for which I want to build the control flow graph. Every instruction or rather every sequence of instructions become a basic block. If there is a function call in between, what will happen? What, I mean, you see what I am saying, right? Say for instance, in the previous, no I would not go there. I mean, let us say in some piece of the code here, let us say I have a call. What will you do? Typically, we treat the call as a single instruction. In the same basic block. I do not treat, I do not make a separate basic block for it. It is easy to deal with, deal it that way. We have looked at this way, right? This call, the control reached it from the previous instruction and its next instruction will get the control after the call, okay. So, just a minor point, okay. In most cases, it is not considered as a branch and return. It is considered just as a single instruction, okay. You already have done control flow graph. You know what is the successor of a node, predecessor and all that, okay. You know dominators. I wanted you to understand how, two things. Given dominators, how do you identify, get the loops? You already know that. How to get the natural loops from a dominator? Now, the question is how to get the dominator information? Has it been already covered? If yes, I will not cover. Else, I will cover that. Not covered? Okay. Then, I will start from, yeah. See, given the control flow graph, I want to compute the dominator information. Let us say, I want to compute the dominator information of only the basic blocks. Once I have the dominator information of basic blocks, the individual statements is trivial, right? Or, I can, I will say, I will treat each statement as this individual basic block. Either way, it is fine. Does not matter. Now, how do I compute the dominator information? Any thoughts? I will give you a clue. The clue is, we will use this part. It is anti-symmetric, reflexive and transitive. These properties we will use to compute the dominator information. There is one particular node in your control flow graph whose dominator information you always know and that is entry. Entry dominates whom? It dominates all. Exit dominates itself, only itself, right? Let us use the first reflexive property. What does the reflexive property say? A dominates A. So, I know. So, I can first, what I can do? For each node, I will say, okay, dominates, yes, it dominates itself. Reflexive property, done. Okay. If I am a node and I have two successes, right? What can I know about, or if I have one successor, why two? If I have a successor, what if I know my dominators, okay? If I know, no sorry, A and B, okay? B is a successor of A. If you know what B dominates, B dominates someone or a set, what do you know about A now? Whatever A was dominating, that plus? Yes, make sense. Make sense. So, what I am saying, first of all, each node dominates itself. Then, if A is a predecessor of B and B dominates a bunch of nodes, then A will dominate all of those. And now that I know about A, what can I know, its predecessor can include all of these. Make sense? Good. If B has multiple parents, then what will happen? Good. So, now let us come to the, here is a block B. Now, we are saying B1, if whatever B2 dominates, B1 will also dominate, whatever B3 dominates, right? What about here? So, B4 may dominate, B4 may dominate a set, but will B5 dominate them? No. No. Will B6 dominate them? No. So, now what is the property that, I mean, that is kind of, what is happening here? I mean, what can I do to get the dominance information? If B5, so what I am saying, if I know B2, B3, in this case I can compute that of B1. Here, if I know B4, I cannot do for B5, B6, right? If I know, let us try the other way round now. I know what? That B1 dominates a few, right? Or rather, B1 knows who is dominating B1. If B1 knows who is dominating B1, can I know about B2? Yeah? Whoever is dominating B1 will also dominate B2. Whoever is dominating B1 will also dominate? Good. Whoever is dominating B5, are they guaranteed to dominate B4? Whoever is dominating B6, are they guaranteed to dominate B4? No. But the dominators of B4 are included in B5's dominators. The dominators of B4 are also included in B6. If I know the dominators of B5, if I know the dominators of B6, how do I compute the dominators of B4? So, now if I know my dominators, then I can pass this information to my children. My children, notes, will take the dominators of, take a intersection. What if there is a loop? So, this says that my children depend on me. If there is a loop, I depend on my children, my children depend upon me. What will happen? And this is where comes the beauty of iterative data flow analysis. You would have heard this phrase already, right? Have you? No? Data flow analysis. So, what we will do here? Here is a piece of algorithm. This algorithm, what it computes, let us see. It computes the set of all dominators. It initializes the dominator of root to be just the root. Then, for the rest of the guys, it initializes the dominators to be set of all nodes, set of all nodes. And then, do not worry about the repeat until loop yet. Look at just this part. What it does? It goes over every node. Find out the predecessor of the node. For each predecessor, it says, hey, who are all your dominators? Let me take an intersection. So, it finds out for each predecessor, it does an intersection. How does it compute the intersection? It sets t equal to set of all nodes and keep taking t intersection, the dominator of p. When I say this dominator, it is the current dominators. Initially, for each node, the dominator is set of all nodes. So, initially, they will try to, if my predecessor's dominators have not changed, I will take their intersection and still get the whole set. That is fine. After I do this, after I have taken an intersection, what I will do? I will check the new set of dominators. By the way, I will take the intersection and add myself. I have to add myself. I forgot about it. This B5, B6, right? You will take the intersection of the dominators of B5 and B6 and then add B4. You are adding the same n here, t union n. What is this d? d is the new computed dominators. You will check, is this d different from what my current value is? If it has, if it is different, I will just say hey, I am changed. My dominator value has changed. I will say change equal to true and say dominator, right? If it has not changed, no problem. And now, I am doing for here to here. What did I do in one round? I took whatever the dominator information I had and based on my parents information, my predecessor information, I recomputed myself. Done? At the end of it, I will check has any node changed. If any node has changed, you will repeat the same process. We will take an example. Should we take? Yeah, let us take the example and then we will analyze the algorithm. Let us take an example to convince ourselves, yes, this works for this example. Then we will convince ourselves this actually works. This is something that should make all of you at least be skeptical. Will this terminate? How many of you had this doubt? If none of you had this doubt, yes, good. I am happy at least one had this doubt. Others did not have this doubt. This is it will not. You already have studied fixed point analysis, right? So, now, at the end of this example, we will then reason about why this will terminate. We will come to that. Good. So, we will compute the dominators. Can you take on your in your text books or other notebooks I mean, take this example and run the algorithm and compute the dominators. So, we will initialize the, so write a nice simple table. I mean the way to do it would be you can do a nice table here. B1, B2, why B1, B2? It should be entry as well, right? So, in round one, you are computing the dominators. Yeah. So, what will I initialize the dominators of each of them? To their own self. No, no, sorry, root as entry and all others with the whole set. I will just mark it as N here and then what I am doing? I am in this loop. In this loop, let us pick for B1. B1, what will happen? B1 will take an intersection of all and entry. It will get entry, right? Entry, then union with B1. Entry, B1 and then what will happen to B2? Entry, B1, B2. Then what about B3? B4, B4 be careful, right? B4 has two predecessors, B3 and B6. What is B3's dominator of information? I already have entry B1, B3 intersection with the full set N. So, the intersection will give me entry B1, B3 and I will add B4. So, why do not you finish it individually? The rest of the table, once you are done with round 1, let me know. First round is over. So, at the end of the first round, the value of change flag is true. So, we will go to the second round. Yeah, continue with the second round. So, at the end of first round, so let me fill the table. Tell me the names for this. What is the number for B5? Entry, yeah, louder. Entry, yeah, B1, B3, B4 and B5, okay. And B6? Entry, B1, B3, B4, B6, okay. And exit? Entry, B1 and exit. Everyone got the same set? Anyone who got it different? No? Okay, then we will go by Konbanega Kararpati, audience poll. Okay, next round, anything is changing? Did anyone say yes? No change. No change? Did something change? Which one? B4, what happened to that? B4 was entry, B1, B3, B4, right? Okay. Now, B6 is getting added, is it? How is it getting added? Let us compute that of B4, no? So, in the second next round, so for B4, who are the predecessors of B4? B3 and B6, let us take the intersection of their dominatives. What do you get if you take the intersection? Same? Nothing has changed? Okay, fine number? Okay, anyone? Good. So, if you look at it, in this case, within one round, we could get the same set. Okay, finished. Now, but in general, what is the guarantee that this will terminate? At any, in every round, either the set remains the same or it reduces, okay, reduces by at least one. We start with a finite number of elements. You are reducing and finally, at most you will reach the empty set. So, this gives a guarantee of termination. What is the complexity of this? There is, sorry? Okay, so we will do one by one. We will start with the, we will start with this, what is the cost of this loop? How many predecessors can be there for a block? At most n, order n and you are doing order n intersections. What is the cost of intersection? It can be done under some circumstances constant, okay, but the more naive algorithm will take o n. Okay, because sub, size of the set is o n. So, if I consider this as n square, if intersection is one, it will be o n. If intersection is n, then it is n square. What is the cost of this loop? What is the cost of this body here, dominated by this loop? What is the cost of this one? o n times, so this is o n. o n times o n square, which is o n cubed. Good. What is the cost of the repeat until now? Perfect, perfect, perfect. So, to compute, so here is the key, right? If we want to compute the complexity of the repeat until loop, we have to fall back on the termination condition. What was the termination argument given by? Savit. Savit. The termination argument given by Savit was at every point, in every repeat until loop, at least one node's dominator information has changed by at least one. So, for one node, how many times it may change in the worst case? N times. N times. I have n nodes, so n square. So, this is o n to the power of 5. But in practice, how much time did it take? Just one round, much faster in general. So, it is not as bad as it looks, right? Fine. So, once you know the dominator information, once you compute this, you can now compute the loops. Here, when I did this for each n in capital N, in the example, I started from entry B1, B2, B3, B4. What if I had started from exit B5, B6, B4 and all that? Let us say, I started in the opposite direction. Try it for just one round. Start from exit and do it. Start from, do the same thing like what we are doing there on the board, but just start from exit. Just do, you do this, take this as the starting point and then start filling from here and see how many rounds you will take. Will it terminate in first round? Same. We will do the same initialization. Take this initialization as same and just start from exit. Two questions. Will it still terminate? Number two, will it still terminate within one round? How many rounds it may take, right? But are you convinced that it will not terminate in the first round? Intersection of? So, how many will get, how many will have dominators set to capital N? All except entry and B1. So, the moral of the story is the order in which you choose the nodes will have a practical, will have an impact on the actual execution time. The order does not change the complexity of the algorithm. The complexity is still O and 5, but the order makes a difference on the actual execution time. And you will see that many of these iterative data flow analysis, wherever they will say keep on doing till you reach a fixed point, the order in which you do this makes a difference. By the way, I hope you have noticed that here I am computing the dominator information of one node and pushing it to its children or rather in this case the children are pulling it does not matter, but the information is flowing top down. So, such analysis are called as top down analysis. There are also bottom up analysis. Have you been exposed to any bottom up analysis already? Which one? Liveness analysis. I thought liveness analysis will be called in the low-level optimizations. Oh, is it? Oh, very good. Then, please mention it to Govind. If he is doing register location, he does not have to repeat this. So, this is a top down analysis, liveness analysis is a backward analysis, this is a forward analysis, that is a backward analysis. What I will do? You have been already exposed to natural loops. So, can you give an example of a what when will I get a non-natural loop? Can you write a code where I will have a non-natural loop? Code, write a piece of code which is which will lead to a non-natural or unnatural loop whatever. Can you write a code which will give me natural loop? Normal while any loop it. What about non-natural loop? Do whatever. Should I write the code? You are telling the code, right? Yeah, wait and let me write it. Just a minute. Yeah. Else? Go to? Same. Yeah. No, no, he says go to L1, both. How is it a, where is L1? L1 is pointing just above. Some condition. Yeah. Yeah. Right. So, now in Java, can you get a loop using Java syntax without if then else, sorry without if and go to, can you get a non-reducible loop? Without go to's, can you get something like this? Okay, the quick answer is no. And I mean do not worry about exceptions, but if you look at the language Java, right, lot of people use it and you can write fairly complex programs, but you do not have these non-natural loops. The moral of the story is the techniques that give you let you handle, identify natural loops that is sufficient for a large set of programs. It is not that oh we are using dominators, I cannot handle non-natural loops, hence it is not good, not like that. Yes, you cannot handle non-natural loops, but it is okay. You have large class of problems where you can only, people only write natural loops, right. You can, you know go to's are not always so essential. Without go to's also, you can write fairly large number of problems. Okay. What I will do, I was thinking I will stop at 5.30, but I will slightly stretch it. Okay. We also started slightly late. Okay. So, one of the uses of control flow analysis is to do control flow optimizations. Okay. And one of the main goals in control flow optimizations is to produce longer basic blocks, produce longer basic blocks. What is it good for? Okay. But the complexity does not change much. I mean I guess I do not care much about the complexity. The complexity still remains something like O n or something. See, if I have longer basic blocks, I have few advantages, right. I can do within, I can do lot of local optimizations. Within one basic block, if I am doing any optimization, I can do fairly complex, very powerful optimization within one basic block. Within one basic block, I, see if there are multiple, if I have one basic block here, one basic block here, some structure like this, right, then you will keep taking intersection whenever you are doing data flow analysis, right. So, you will be kind of losing some information and so on, but if it is a long, longer basic block, you do not have, you have fewer jumps, you have, you can do more local optimizations and you will see later that register location, etc., you can do a better job when you have bigger basic blocks. So, this is our goal and you can also get better ILP. That is, if you have a longer basic block, those instructions can go in, you can kind of rearrange them, do a better scheduling to do better instruction level parallelism, okay, pipelining, improve the pipelining. If you have branches, then there will always be some issues, I mean, and the second goal of control flow optimization is to reduce code size. We will see, okay. The first one, when I build control flow graphs, the first optimization that comes for free is unreachable code elimination. Yes. So, what I can do, I can start from the leaders, keep building my basic blocks, whichever code is not part of anything, any of this, any node in my CFG, I can just throw it away because that is unreachable. So, if I have some piece of code like this, if some condition go to L1, right, or why if condition? I only go to L1 and I have S1 here. So, I will take the code above, it will go to L1, that will be part of some basic block. From there, there is an edge to S2. If this S1 is not part of any basic block, then it is automatically deleted. So, control flow analysis gives me free unreachable code elimination pass, right. Second, I want to see, now that I have this go to L1 here on S2, how will my basic block look like? I have one basic block for this, I will call it as B0 and there is another basic block for this, which is B1. If I have a basic block, which has a single predecessor, then I can merge the two. I do not need a jump, right. So, this is called code straightening, but when can I do it? Only if it has single predecessor, right. So, if B0 has a single successor and this guy has a single predecessor, if this guy has multiple successors, then I cannot straighten it. Similarly, if this guy has multiple predecessors, then also I cannot straighten it, right. Any questions? Any doubts? If simplification, let us say I have some pieces of code which are like this. I have if condition then do this, else this, okay. Let us say both the then and the else part are empty statements, what do I do? Can I remove the whole if then else? What is the question? I have some expression if E then somebody else somebody, let us say both of them are no ops. How did they become no ops? May be because of some optimization that code got thrown away. The user is unlikely to write if some condition then semicolon else semicolon, right. Can, but unlikely. So, can I throw away the whole if then else? Yes. Perfect. There may be some, so I can remove, so I can replace it with E. If E is no op, then I can throw away no op. So, we can do one step at a time. You replace this with E, some other pass will find that E is empty and throw it away. Make sense? What if? Why java does not allow arbitrary computation? No, but java does allow a function called foo, if foo, right. No, no, do not worry about it. So, his question is when we are building the dominators, let us say there is one particular node. We initialize the everything to n. Now, there is one node which has no, which is not connected to start, which is not reachable from start, right. If it is not reachable from start, we could probably, first thing we could do is do this. We could do unreachable code. Any code which is not reachable from start, I can throw it away. So, one possibility is I will first do this. Any basic block not reachable from start, I will throw it away. So, this is a code which is part of some basic block, but it is not reachable from start. Throw it away. Second option, second thing, let us say no, you did not do this optimization. You have a basic CFG where it is a weird CFG in the sense it is not starting from entry. It has an entry and exit point, but there are some nodes which are not connected. If you have such a code, first, how that code came is separate issue. Then, you will have a node, right. So, it will have a bunch of n. I mean it will have everybody has its dominator, but you will probably throw it. I mean you would not use it for anything, right. So, yes, it is. But you can say do I mean. So, his suggestion is when you are doing the dominator computation, let me mark every node. Let me mark every node with no every node with initialize the dominator information every node with n minus r, n minus root. And he says at the end if there is a node whose dominator information is still n minus r, then that node can be thrown away because every node should have been dominator. I mean should have root as the dominator. If there is some node which does not have root as the dominator, then that can also be done or I can just do a simple reachability, right. I can do simple BFS or the CSG and do it without complicating the rest of it. There are multiple ways in which it can be done. Here is to continue if I have a condition if let us say if some condition which happens to be in our case if you remember I did some constant propagation because of which one of them became one variable became a constant. And let us say I had some comparison that looked like this. Initially it was a greater than 3, then s1 else s2. And what you found this to be a constant which became 2 let us say. So now this constant value is false. Then what you can do? You can throw away the s1 and just keep s2. You do not need the condition you can just keep the s2. And similarly if it is always true you can keep the then part and throw away the else part. Here is another type of example you will find. If i greater than 3 in the then part you will see if i greater than no wait i less than 2. If i greater than 3 in this piece of the code here I am taking if i less than 2. You know that this condition is false because of the then condition. So if you have in nested if conditions if the outer condition implies the inner condition or the outer condition is guaranteed to implies the negation of the inner condition you can optimize away the inner then or the else part. Here is a more a popular word that you will hear loop inversion. What is it? It takes a while loop. What is the while loop? In while loop you check the condition and enter. It transforms the while loop to a do while loop. It transforms a while loop to a do while loop. What is the advantage? Check. Sorry I could not hear sorry usual right. The check condition that we have in while loop. So that the check condition. Happens at the end now. That instruction will execute one time less. So in a while loop how many times do I check the condition? Let us say if I am checking the condition k times in the do while loop you are saying I will check it one less time. But is it equivalent? Let me ask you that question. Is while loop same as do while loop? So how can I make a while loop equivalent to a do while loop? First add a if. If you have a while loop if I have a while es I transform it to if e do while e. If I know that this e is true for the first time. Let us say this condition is i equal to 1 while i less than 100. Then you do not need to check this if e. But if you do not then you have to keep the if e. Now my question is what is the advantage of this code over this? I will be saving one go to statement. Because in the while loop you will come back, check then decide whether to continue or not. Here you will first check and then go back. So let us look at this. There is an additional advantage. Let us look at this code. x equal to 3 while some condition s1 x equal to 4. At this point is x a constant. Why not? While might or not execute. But if you know that the condition is guaranteed to execute and you let us say you turn it into a do while loop. Then if this was a do while loop do s1 x equal to 4 while some condition. You know that x will is guaranteed to be a constant. So this turning this to a do while loop can have some side benefits as well. So basically do while gives a guarantee that the loop is executed at least once. The last thing we will. I think we have already talked about when we know that the loop condition will hold we will throw away the if e. If we do not know we will keep the if e. So what we looked at now? We looked at control flow analysis by building the control flow graph. Both the advantages have to be mentioned on y e. Or just simply negated by having the if because. Because. Because the if will also add a block. Good. And it will also. So if is a condition check. You are checking and then entering. Here you are checking and entering. Both are same. Let us say at the end of this loop what do you do? You will go back and then check and if it is false you will come out. Here what happens you did you check and then you do not go here to come back. Make sense right? Simple subtle point. Let us see right. Let us let us write the steps here. E1 correct. S1 jump. E1 jump. Here what is it? E1 then S1 then E and then I mean follow through. So it is kind of saving one or two jumps. Saving one edge. One edge. So the last while here also is a jump. So this follow through is conditional jump right. So I can I can probably make it as conditional jump. Here also it is a conditional jump. So one jump less. This jump. This is same. In both the case this is a conditional jump. This is also conditional jump. Both are same. Just you are saving one the last jump. Why should I worry about one jump? One jump here. What is this do while loop is inside a loop which is going over a million iterations. Then this is million jumps you have saved. See those of you who are doing this P1 P2 with small values of n you found no improvement. When you increased it you started seeing more improvements right. So take care of your pennies. Your dollars or your paisas and then your rupees and dollars will take care of themselves right. Okay any questions? Any further questions? Okay in such a case I will summarize before we wind up. We started today with introduction to optimizations compilers and optimizations. We looked at constant propagation what it is. We looked at copy propagation what it is. We looked at loop unrolling its benefits. We looked at loop invariant code motion. We looked at strength reduction. Then we came to control flow analysis in the post launch session. The control flow analysis we looked at basic block building which you guys already knew. Then we looked at how to build dominators right. Then we looked at different optimizations we do by after we build the control flow graph as part of control flow optimizations right. There is one important control flow related optimization which is called which is based on again control flow analysis which is called inlining okay. We will do it hopefully tomorrow towards the end okay. Any questions before we wind up for the day? No? They would not like you. Excellent question. Correct. So the question is when you do loop unrolling you are increasing the body of the loop. It may have an impact somewhere else. If you keep on unrolling why did we only unroll by 2 or 4 why not 8 or 16 or 32 or full 100 right. How did the compiler decide how much to unroll? Any thoughts? So do you know what are the factors that decide that? Yes so what size of the? Cache. Which cache? Size of the eye cache is important here. See if the loop body is fully within my eye cache it is better but at the same time unrolling has its own benefits right. So because of unrolling I get some benefits because of unrolling I am also filling in the I mean I may cross the the loop body is not fully fitting within the eye cache I may have some penalty. So now so that means you gain some you are losing some. Traditionally there is no agreement on what is the golden formula or how big my loop unrolling can be. There is no such golden formula. People do not agree. Then pretty much every compiler has their own group of experts who say okay this is let us do this. They test it on a large set of benchmarks and say this looks good. I mean it is kind of engineering and they do the engineering at a level that you will say how did they arrive at this number k where that k could be your favorite random number 37 right. Not 37 but they say look do not go beyond this. Similarly for unrolling they say do not unroll a function which will lead which will have more than some k number of instructions sorry do not inline a function which has more than k number of instructions. Again this is I mean there is lot of engineering expertise that gets in gets into it for different architectures for different compilers that combination they have different sets right. But yes it is a very important point that how much to unroll. They definitely will not unroll too much. What is too much there is a clear understanding. What is the right thing there is no agreement yet. I mean because some will say no I can do see because by unrolling my block has become bigger because of which I am able to do better register allocation which will give me yes I am losing on iCache but I am getting benefits somewhere else right. So there is a push and pull I am able to do better pipelining because of unrolling great right because unrolling helps me do better instruction scheduling do better software pipelining. So these things are kind of not so easy. So that is why so when Shaujit mentioned about the decision tree basically what he is saying is people use some many complex heuristics to compute what is right. So I do not have an easy answer what is the number but all I can tell you is it is a complex problem and the factors that impact are iCache the fall the impact on the register allocation the impact on what do you say pipelining and so on okay. ILP instructional parallelism okay. Any other questions? I still have an through even though I am tired I still have an through those who are those who want to wait they can wait any questions on what we have covered. I do not see why it cannot happen tomorrow unless the critical mass says the same thing for tomorrow. Well tomorrow will also be the same thing I think I mean I tomorrow let us start at 5 30 or so if we start okay is that fine then okay we will we will try to wind up tomorrow slightly early and talk about that. Any other question before you wind up?