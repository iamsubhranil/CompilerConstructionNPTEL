 It is essentially data types ok. Now, I do not have slides for this. So, we will try to code up things and try to look at it ok, but everyone understands what is a data type in a language right. So, every variable which you declare has some type int float char right. So, how do compilers implement these things? Now, one of the things you have to realize is languages like C do not really specify all the details for a data type ok. For example, when we say int is a data type in C, int C language standard does not say what is the size of int ok. It does not specify all the characteristics of it and some of these things are deferred to be specified by ABI ok. That is why size of int is actually dependent on ABI ok. So, that is some aspect which we kind of already talked briefly about. Now, let us look at some of the other aspects where we have say a structure right. So, how does how is a structure implemented can does anyone have any idea? What all needs to happen for implementing a struct? Correct. So, we need to have storage for the structure which again will be to some way dependent on ABI right because size of integer is 4 bytes is stated by ABI ok. But one other thing which C says in terms of structures it just like array all the members will be contiguous ok. So, but there might be padding in between ok. So, if I take a char pointer to a structure I should be able to traverse it ok and get to the next data elements. Now, in context of this structure what is the size of this structure? 5 bytes. 5 bytes ok. Let me make the question simpler. So, what is size of this struct? How many of you think this structure has size 8? Almost everyone. Let us verify it once ok. So, we got 8 ok. Why is it 8? So, character took 1 byte, but since integer had to be aligned to 4 bytes we had to leave bytes 1 to 3 right. Now, in this case what happens? So, this is going to take 4 bytes. Character does not have any requirement for padding or alignment. So, it can be actually at byte 5 right. So, should the size of this structure be 5? What will be the size? It has to be because it has to make an array of this particular then that array must also be made a byte of your. Let us test that hypothesis. This structure also actually has size of 8 and the reason is what he was saying. It is not because the standalone object of this structure needs standalone object should be able to fit in 5 bytes without any problem, but when we create an array of structures the next element of the structure must be again 4 byte aligned. So, there must be some padding in between. Now, where should this padding be accounted for? Should it really be accounted for in the object? So, let us say I created a structure. So, let us say I created my struct S of 100 is size of S 0 8 bytes or can we have a scheme where we have size of S 0 is 5 bytes, size of S 1 is 5 bytes and there is a padding in between. Each of them have to be created because if you write them to a file, it will be your struct and if you write it in the back, they all need to be. Correct. So, you have to make it a part of the object. It cannot be something hidden outside the object. Does that make sense? Now, what is the alignment requirement? Itself is again specified by the ABI. It is not that everything has to have the alignment of that much size. For example, if I create array of 100 elements, it does not mean I need to have alignment of 100 into 4. It is the alignment of the individual element that matters. Is that clear? Now switching back gears to C plus plus. What do you think? Correct. Let us try that. So, let us say I make this car. So, it is 2. So, there is no unnecessary thing that everything has to be 4 byte. It can be smaller than that. So, the structs, it will be essentially decided by what is the largest size member in your structure. So, if your largest size member is double or 8 bytes, then it needs to be 8 byte. Now, let us look at C plus plus. Now, C plus plus supports things like classes. Everyone knows a class. So, you have a class which has some private members and then I can have some public members which can take some parameters. This could have been a constructor. I am just writing some code for understanding. What will be the size of this? So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. So, this is the size of the class. What will be the size of this? So, classes have data as well as functions. 8 bytes. So, it is 8 bytes. The reason is as he said, functions are simply not going to occupy any memory in the object, because every object will not have different function. The functions are kind of shared by all the objects. So, it does not make sense to store functions as part of the objects, plus that will complicate other things, because you will have text section within the data segment, which is going to be another weird thing. If you make it part of the object. Now, when we say something is private versus public, what does it really mean? Is there going to be some sort of a memory protection? So, can I modify? So, let me do this. So, let me call. So, I do s dot foo 4 comma 5. So, let me print s dot get x, get a. So, let me write a method called get a. And I got the value of a. Now, if I wanted to modify a in main, is there a way to do that? So, one option is if I want to modify main in main, I can call a function called set a or change a or update a whatever. But that is standard thing. Is there something more evil I can do to actually change value of a? So, I could create a pointer p, which will hold, which will point to s. And I do star s is equal to 10. Sorry, star p. And it actually printed 10. So, what happened is essentially since I know s only holds data and it is going to hold in these specific order, I could actually change it. So, there is no private public whatever you have is not giving you any runtime protection. It is merely a compile time protection where the at compile time you cannot say s dot a outside the class. Does that make sense? Now, what I did here, does anyone know what is this called? There is a term for these kind of things. Has anyone heard of something called as type punning as a term? No. Has anyone heard of this? So, one of the things which data types allow to languages is you know all these things, but you also now know compilers. So, let me just say that I have a data type. So, I have a data type. So, I have a data type. So, I have a data type. So, I have a data type. And the company does not want to differently add working class code. So, this must also have a different configuration. How do we do this? To show that everyone published a webappropriation code. So, a êµ¬ Hypered ci is not able to do it. pointer. And let us say I do PTR, let us say I read something from PTR, then I read, then I write something to PTR 2 and then I read again from PTR. So, here I let us say read A is equal to star PTR, star PTR is equal to 5.0 and I read again B is equal to star PTR for some reason this, something like this. Now, can compiler translate this to A is equal to star PTR, star PTR is equal to 5.0, B is equal to A. Can compiler do this? Correct. So, the problem is if I call this function as something like this and A comma and A where both these pointers were pointing to the same location, then this optimization is illegal, because it would accidentally end up have different effect than what programmer wanted. But actually it is legal for compiler to do this. Compiler can do this optimization, because of a rule in language called as strict aliasing. What languages like CC++ say is, if you have a location, you can have a pointer to it of the data type of that location. So, if I have a integer stored in memory, I could have a integer pointer to it, I could have a character pointer to it, but I cannot have any other pointer to it. So, I cannot have a float pointer pointing to an integer or a int pointer pointing to a float or a struct pointer pointing to a int and so on. This allows compiler to say that since integer PTR is a int pointer and PTR 2 is a float pointer, they should not be pointing to the same location. This is called type based alias analysis, where languages say that two pointers of different types must point to different locations. But you know that you can still write code like this which I wrote to modify. What I did here, I said address of S is actually an integer pointer, and I modified it. Here, I broke the rules of strict aliasing and it results in undefined behavior. So, types allow you to do, compilers are free to rely on this and if you are doing a trick like this which I did, then it is undefined and your program may not work as expected. So, although it works in this particular instance, compiler is free to make assumption that S and pointer are pointing to different locations. So, data types in languages like C also have some aid for pointer analysis because what they allow you to do is they allow compiler to distinguish two pointers are not strictly pointing to the same location. Now, why char star is allowed any idea? So, what I said is to any location you can have a pointer of that type or a char star pointer. So, if this was instead of float star, if it was char star, then this optimization cannot be done by compiler because compiler cannot prove or assume that PTR and PTR point PTR to point to two different locations. Any idea why special treatment for char star? Correct. So, if char star was not allowed, then there is no legal way for you to implement functions like mem copy. You cannot implement mem copy in C complying to the standard because you have to assume the data is byte by byte and you are copying it to some different. So, if you did not allow char star an exception, the problem would be that you cannot implement mem copy which is complying to the standard. So, standard cannot say that mem copy is not possible. So, they had to allow char star an exception, but every other things standard says that two pointers must be pointing to their own data types and cannot point to. So, int and correct float cannot point to the same location. If you write that code, you might see some warning saying strict aliasing rules are being violated or type burning is being done both of which are undefined for the language. Yeah, void is just like void. So, compiler cannot make out of what it is pointing to. Now, there is also something called as restrict. I do not know how many of you have. So, there is I forgot the syntax, but it is something like this where you can say it is a restrict pointer. So, by declaring something as restrict, you are giving this guarantee to the compiler that the location pointed by ptr2 is not pointed by any other pointer. So, these kind of things you can do in your program to help compiler solve pointer analysis to some extent. Does that make sense? So, in data types we just saw, I mean we kind of digressed a bit, but we saw that data types help layout the data within the any structure or aggregate and data types can also be used by pointer analysis in the compiler. Any other questions which you have on data types which may have heard and do not know or what is confusing. I think we can. Yes. Because they simply store in higher format. For example, the example which you gave, let us try that. So, 0.7 is not representable. So, let us say when I do float f is equal to 0.7 and I do print f percent f slash n f, I do not really get 0.7. Actually, it did print. Let us try some other number. So, these two were kind of gone, because it could not represent this number. Now, if we simply change this to double. Actually, no it is not representable. Do you know a number which is not precisely representable? Kind of trying to. No. I will need to work out, but we need a number which is not precisely representable in float. And what needs to happen is for languages like Python, etc. they will actually support higher precision. So, they will start storing everything in higher precision to get that accuracy. I do not know actually. But they have to, I do not see any reason how can they not do arithmetic in IEEE 754. Yes. I will need to check. I do not know any other things. Correct, it does. And that is why, but information hiding was more of a logical thing that did not something at runtime which changed it. So, a strict implementation would say that somehow you need to ensure that it is not modifiable even at runtime. But that you can imagine is very hard to implement scheme. Because what will happen is for every object, you will somehow need to say that this region of code is allowed to access this memory, but this other region of code is not allowed to access this memory. And that itself could be very hard to implement. Because there are, at least if you look at the current processors, they do not have a way to say that it is accessible only for this, but not for that. Even in Java, I do not see how that would work. Because if you get. Correct. Allow you to do this. So, there are couple of things. One is your type checking must be very strict where you are simply not allowed to compile such code. And one other thing is Java actually can do this because it is running in a managed environment. So, runtime can actually keep track of multiple things and do it. It may not be doing it by default, but it is at least in theory possible for runtime to manage it. In raw processor level, there is no such protection which exists. So, if you get some raw access, you can do anything. Next is function overloading. Everyone understands C++ supports something called as function overloading. So, essentially function overloading is nothing but have ability to define a same function multiple times with different parameters. So, I have int foo, I have void foo which takes int x. So, if you look at this code, essentially I have function foo which does not take parameter. And I have function foo which does take parameter and I call them. How does this work? Any idea? How does compiler know that this foo is actually calling the first foo and this second foo is actually calling the second foo? So, from signature it will try to figure out. And what is part of the signature? Is a return value part of it? So, let us do it this way. So, I have two foo, one which returns a value. So, let me say return 4 and one which does not return a value. Is this allowed? Is this allowed? So, I have two foos. So, let me collect the return value here int x. So, do you think this will work as expected? Say it is error, new declaration of void foo, ambiguous old declaration of int foo. So, it is not allowed. So, you cannot have two overloaded functions differ on the return value. And the reason being return value is something which you may or may not get. For example, here when foo is called, how do I know I do not want I want a version which did not return a value versus I want a version which returned a value which I am not trying to collect. So, there is some ambiguity here. That is why this is not allowed. But when I have parameters, then I know what I am trying to do. And then it will work. Is this clear to everyone? Now, let us try something more interesting. So, I have say function overloading 2 dot CPP where I say I want extern int foo. And I have here function say void bar which calls foo. And here let me call bar. Now, let me try to compile this program. This also worked. And it correctly worked. So, when I called foo from bar, it also worked. So, how did this work? How did bar know which foo to call? Because at compile time, compiler can say this foo is calling one with the parameter. So, I must call the second foo. And in this case, I am calling the foo which does not take parameter. So, here how did it work? Correct. Now, in the elf symbol table, if there are two symbols with name foo, what will happen? How does linker know that foo taking parameter is different from foo taking no parameter? Remember, we were seeing in elf symbol table everything had an entry. Now, if there are two symbols which had same name foo, one which took parameter, one which did not took parameter. Correct. So, that is where name mangling comes into picture. So, let us look at the object file for this. So, when I do func overloading.cpp, if I read the symbol table, I do not see foo. I see something called as underscore z3 foo, then I see something called as underscore z3 foo i. So, this compiler is not actually putting foo as it is into the object file. It is actually changing name of it and the name it changed this way. So, we have underscore z which is actually the prefix. This is the string length of the function name. How big is the function name? Then we have foo, then v is indicating it does not take any parameter void. Here it takes integer as the parameter. Is it clear? So, linker is doing. So, compiler whenever it is compiling any program, it does this mangling for functions. Now, tell me can it do mangling only when the function is overloaded or it should do always. So, should the mangling happen only for function which is overloaded or should it happen irrespective of anything? Correct. So, when you are reading elf or any consumer is reading elf, it will not know foo means underscore z3 foo v or whatever. So, it cannot happen unconditionally. Does everyone agree with that? Now, tell me when this file is there, how does compiler know that foo which is extern would have been mangled? So, if you now compile this second file and if you look at read elf, it actually says foo which is undefined is also mangled because you have no idea to know whether a function will be overloaded or not overloaded. So, you have to unconditionally mangle. Is this clear to everyone? Every function in C plus plus gets mangled irrespective of whether there is function overloading or not. Now, one of the interesting things is function overloading is not the only reason why mangling needs to be done. There are other features in C plus plus language which force mangling to be done. Have you heard of something called as namespaces? So, namespace allow you to define your own namespaces in which you may have functions. So, foo function may be present with the same signature in one namespace and with the same signature in other namespace. So, it needs to be mangled. When you have different classes which overwrite the methods, there needs to be mangling. So, mangling is kind of a fundamental thing which is present everywhere in C plus plus. So, does that make sense? Now, tell me let us say I have some program which I have written in C plus plus and I want to call it from C. Is that possible? Now, the question is how will C know what is the mangling? Because when C compiler is compiling your C code and when it sees extern void bar, it is going to assume it is called bar. It is not going to assume it is going to be called underscore Z3 bar V. Is the problem clear to everyone? If I have a C plus plus code which I want to call from C, the C compiler when it compiles anything, we saw when we called printf in the object file it came as printf. It did not came as underscores Z3 printf something something. So, when I call bar, it is also going to come as bar only, but what is the actual definition is different. We can try that. So, let us say funk o dot C and let us say I say extern int of 4. Sorry. Correct. So, in that case you cannot have two fun overloaded instances which take variable number of arguments. So, you just there is a mangling. I will come to that, but his question let us keep printf aside for a moment, but the question is if my function is var arc function, I do not know all the parameters of it. So, how will I mangle it? So, the mangling scheme itself will be simply that you say somehow that this is a var arc function and you cannot have another instance of the same thing which is overloaded differently. So, you can have only one instance of a var arc function. C does not mangle. C does not have overloading support function overloading support only exist in C plus plus. So, I have extern int foo which I am declaring in my C program and I have bar in which I call foo. So, couple of things. So, now we have this CPP file which says there is something external called bar which I am calling and it is defining foo and I have another file which is defining bar and as extern of foo. Now, let us try this. So, I do GCC. So, I compiled my C code. Now, I am going to link it. So, it says there is some undefined reference to foo and it says some undefined reference to bar and if you look at the elf you will actually see why that is coming. So, read elf dash s. So, funk over which was trying to look at a C plus plus symbol is simply saying there is something called foo which is undefined. So, it did not do any mangling because C does not have mangling and the bar was also defined to be just bar underscore plain bar. Now, if I look at the other object file it says look for I am defining something called underscore z 3 foo v and this is saying look for a function underscore z 3 bar v. So, there is some issue. Does everyone understand the problem? So, you cannot call a C function directly from a C plus plus code and C plus plus function directly from C code. There is a way for calling a C function from C plus plus directly. So, whenever you have to call a C function from C plus plus you have to declare it as extern C. Now, if I try to compile this code I only get undefined reference to foo. I do not get undefined reference to bar because when I said extern C this is an indication to the C plus plus compiler to say please do not mangle this. Now, can I do this? So, if I overload functions and I try to mark them extern C that will not work because then the names have to be unique. So, I cannot have extern C functions with same name multiple times. So, if I want to use C plus plus style feature like namespaces etcetera etcetera then all of those will be mangled. That means I cannot interface that code with C directly. The only way you can do this is by creating additional wrappers. So, what you can do is you can create if you wanted to expose foo. So, you can create say foo 1 which calls this foo internally and foo 1 is declared as extern C and then you say foo 2 that is declared as extern C and so on. Is it clear? So, all these features end up requiring mangling of some sort. The next thing we are going to look at is inline functions. Everyone understood the you must have learned function inlining as an optimization in your earlier classes. So, you saw that compiler is capable of removing the function call completely. Now, can someone tell me why function calls are costly? Why are function calls costly? So, one aspect is the aspect of branch itself because you were executing this path then you suddenly started executing this path. What are the problems with that? No, just the transfer of the control. Correct. So, what happens is once you are executing something, you have instruction cache which is fetching data back to back. As soon as you need to transfer control to somewhere else, your iCache needs to be flushed because now you are executing something else. When we looked at the function calls in details, we saw that it is just not simply jumping to some program point and executing it. Around function calls, you have lot of other overheads because you had to do all the caller save register saving and once you jump into the function, you have to do callee save register handling and so on. So, the function calls are costly not just because of the branch but the associated operations which need to happen to make function call work. That is why C++ has a way to say please inline this function. Compiler will do it by default, but you also have a choice of marking something as inline. Now, I have code which is declaring a function called max as inline because it is a very small routing. It is just computing max between two integers. Now, I have this in dot h file. Then I have inline 1 dot cpp which calls this function and calls some other external function foo and it includes inline dot h and then I have inline 2 which also includes inline dot h and calls max function. Will this work? So, I have two programs both of which are including inline dot h which defined the function max. Let us try that. So, I do g c i dot h saying please look for all the header files in this folder. So, it worked and it did print whatever it wanted to print. Why did it work? So, what did we learn yesterday that there are all the functions are strong symbols. So, this is let me just recap. So, yesterday what we saw was there if you have a function which is defined multiple times, then it is a problem because linker considers them as symbols. When we were looking at d s o, I kind of invalidated that statement because you were able to override it, but that happened only in d s o. Let us try this. So, let me try to make this as non inline function. It actually gave multiple definitions. So, multiple functions with same name is not allowed unless they are overloaded. Why did inline allow it then? So, why am I allowed to have two functions with same name which are inline? Correct. So, the reasoning is when we look at inline 1 dot c p p when the call to this is done, the function is already inline. So, there is no max for the linker to c. Does that make sense? Now, this is bit weird because inlining is an optimization. What if I compile this program with dash o 0? Dash o 0 means please do not optimize anything. How many of you think it will be an error now because compiler did not inline it? Now, let us look at let us try to. So, let me simply compile it with dash o 0. So, what we are saying is we should not see max in inline 1 dot o. Everyone agrees with that. We should not have max as a function in inline 1 dot o. There is max z 3 max i. Now, let us look at inline 2. Welcome to. So, even this has max. Now, the interesting part to look at is it is weak. It is not global. So, if this was not inline function. Now, let us try it again. Now, max is actually global. So, when we had inline, when we marked it inline, linker as in the compiler actually made it a weak symbol. And remember what was the semantic of weak symbol? If there are multiple weak symbols, anyone it chose and that is why this works. So, you can actually have multiple max functions in object files coming together. But in the final executable which you will have, there is only one copy of max. Does it make sense? Now, tell me in what cases compiler may not be able to inline the max function. One is o 0 which we saw in o 0 compiler should not inline. Are there any other cases where compiler may not inline it? That is a heuristic. So, if you have very large function, it may not get inline. Any other cases? . Correct. So, if you have a recursive function, which you have marked as inline, then there is no way to inline it. So, recursive is 1, large could be 1. I mean compiler may still try to inline it. Any other case? . Pointers. . Correct. So, if you take address of an inline function, compiler has to keep it. Compiler cannot inline it. I mean it can inline it, but it also has to keep a copy of that function, because someone may call that function through function pointer. So, far what we have seen is there is some mechanism to mark some symbols as weak. Remember yesterday I told you that uninitialized global is one of the cases of weak. There are other cases. This is one case, where you have inline functions, they need to be weak. And this is one case where one definition rule of C plus plus is violated, because at link time you actually had two copy of max and two definitions, but since they were weak that was ok. So, ODR has exception for weak symbols. Clear? Next things, templates. How many of you know what is a template? . So, templates are essentially a flavor of generic programming, where you can have some function which works on generic type. So, let us say I do something like this. So, I have some header file template dot h, where I define a template with some type name t and I define the same function max which takes t a, t b and it is going to return if a is greater than b, then return a else return b. Does everyone get this? Now, actually sorry I should just put declaration here. So, let me move this to here. So, I have a max function which is template and I define its body in template dot cpp. Now, I have some client dot cpp which is going to include template dot h and stdio dot h. Then I am going to call max, max of 5 comma 4. Yeah, I mean actually it should not matter in this case because. So, now let us try this. So, I do g plus plus first I will compile template dot cpp, template dot cpp dash c. So, I can later link it against my client program and then I do client dot sorry what was that client dot cpp. So, it says undefined reference to int max int int int something. Any idea what happened? So, in client when I call main it is not able to find it. So, here I am calling max which is declared in template dot h and defined in template dot cpp. That is the traditional way of how you write your things. You have a dot h which has declaration and you have dot c or dot cpp which has implementation and the client code simply includes the header file. Why does this not work? No. So, let us look at how templates work right. For template to work when compiler looks at template dot cpp does it know what its t going to be? How does it going to figure out where is t coming from? As in how does it know that there is some code which is going to call max with int as t. So, there is a version of max function with t as integer right. Then there is a version of max with t as float. Then there is a version of max with t as xyz. So, when compiler compiles template dot cpp can it generate all the combinations? It cannot because it does not even know what combinations to generate. Like for example, if it generates int float char, but this might also be called with some class object with overloaded less than greater than and other things. So, compiler has no way of knowing when compiling template dot cpp what code to generate. When client includes max there is no information of how information flowing from here into template dot cpp of how to create a version of max with integer right. Let us try something different now. Let us take all of this and put this in header file. Now let us try compiling this code and I do not need template dot o and now it works. Because in header file the template was included here and when compiler saw there is something called as max as the template and it is being called from here. Then it created an instance of max with int and int. Does that make sense? I simply copied the definition of the template from cpp to dot h. Without this there is no way compiler can generate code for max just by looking at template dot cpp. Now let us try something different. So, let us say I have client 2 dot cpp which also has essentially the same code. So, in client I also call foo. So, what I have done is the template dot h is also included in client 2 dot cpp and I have a function foo which also calls max and I have a client dot cpp which calls foo. Now let us try to compile them and it works. Now how many definitions of max are present in the object file at link time? So, once max was instantiated when client called it. So, there is a copy of max present in client dot o that we can verify. So, it has max and similarly client 2 is also going to instantiate it. So, client 2 also has max. So, essentially at link time there are two copies of max which are coming. How do you solve that problem? So, there is one max definition which is coming from client 2 and one max definition coming from client. How do you solve that? I did not get that. Actually the object file has that definition already. So, all the template instantiations are again weak symbols. So, if you look at redels, it is marked as weak. So, just like inline functions template instantiations are also marked as weak. Now just to kind of give a complete picture there are some compilers called max which allow template instantiation at link time. So, they do not generate code at compile time. They will defer everything to the linker. So, what will happen is when max comes with integer integer there is no code generation done for that and at link time you do the code generation of max with int and int and then it works. So, this is typically done on Solaris operating systems, but that kind of puts lot of burden on linker because linker has to figure out all the instantiations which are needed. So, in most common cases your header file contains the implementation. That is why if you open any STL header file you will actually see the entire implementation of vector or anything because there is no other way that once you hash include it to instantiate it separately. So, templates do not go very well with separate compilation because compiler needs to know the definition to be able to compile things. Initializers. No, actually that is static because what happens is compiler know what is the return value of whatever function. So, if you do auto i is equal to foo and this compiler knows that foo is going to return 8. So, it is just a substitutable thing. Now initializers we already kind of saw to some extent. So, we saw if I have int gbl is equal to 0 how does it work. It works by putting this 0 into the data segment in the object file. We also saw something along this lines where we say int ptr is equal to and of gbl. This was supported by creating the relocation. You still remember that? Now, let us say I have something like this. So, let us say I have int foo which returns 4 and I have a global variable which I initialize with foo. Will this code work? Will this code work? So, I have a variable gbl which I am initializing with the value returned by function foo. How many of you think this will work? Couple of people. How many of you think this will not work? One person. Now the reason is very logical that it should not work because initializing a global variable has to be done prior to linking. Because if I initialize it with a constant value then compiler itself can put it in the data section and it works. And if it was some address or something like we saw earlier where int star ptr is equal to and I was done, linker was able to handle that via a relocation. For this scheme to work what needs to actually happen? Correct. So, somehow foo has to be executed and by at what point in time it has to be executed. Before main. Before main. So, if I have a printf here saying in foo and if I have printf here in main then if this scheme was supposed to work then ideally I should get in foo in main and then gbl is still initialized. Now is there a way by which you can say before running main run this bunch of other things? How? Underscore start. So, underscore start is going to call main but do you have interface to underscore start to do something? Okay. So, there are some pragmas but that is all compiler magic. Is this going to work as it is? Yes. Without any additional magic. How many of you think this will work without any magic? I mean I will literally compile this code and it should work without any additional flags. Any additional flags. How many of you think that will happen? Okay. Let us try that. Keep your fingers crossed. Okay. It compiled. Okay. It compiled. Hold on. It worked. It worked. Okay. So, no additional stuff. It worked. Now, why did it work? Okay. So, this is called as dynamic initialization. Okay. In fact, this is no different. I just showed you a cryptic version of this code which was more surprising. What if something like this was present? Let us ignore this for a moment what I showed you. What if this was the case? So, I had my struct which had say int a int b and then I had a constructor of my struct. Okay. So, I had constructor of my struct which initializes a to 5 and b to 10 and I create an object of this struct called x, y, z. When does the constructor get called? When does the constructor get called? When the object x, y, z is created. When is object x, y, z created? Before main. Right. So, the feature which I showed you is not just for doing these kind of funky things, but even to be able to call constructors before actual main. Okay. Does that make sense? So, going back to some magic which I did not show earlier. You remember I showed you a complex diagram of what happens in CRT. So, this was the diagram which I showed you earlier. Okay. So, what I told you back then is loader is going to call underscore start and then it will ultimately reach main, but there is this something called as pre-init array 1 dot dot n. Okay. This is the magic which is making the other things work. So, pre-init array is actually holding some function pointers which it is going to call as part of the initialization of the program. Okay. Now, you can see this here. So, if you look at the object file for this. Okay. So, you see something called as init array here. Okay. Which I was just mentioning. There are some relocations on the init array. Is this still readable? So, init array has a relocation which says change something with this and init array. Actually, let us show it in debugger. I think that might be easiest. Okay. So, let me put a breakpoint on foo. Okay. So, if I look at it, the breakpoint is actually hit and if I go up, it is actually being hit from here and if I do backtrace, I do see some startup code before actually calling main which is somehow calling into this foo. Okay. So, there is some scheme by which dynamic initialization is actually supported. Okay. This actually is not supported in C. It is a feature in C++. C++ requires it because the constructors need to be supported. Okay. Now, I would actually go past virtual functions. Okay. How many of you know what is a virtual function? How many of you know what is a virtual function? Okay. Can someone explain me what is it? Okay. What is the use of virtual function? Let us forget what they are, but why do you write virtual functions? What is possible with them which is not in general possible otherwise? Virtual function is a base class pointer. But why do you need that? Because you can do all the functions from the base class. Okay. You tend to access them using the base class pointer. Why do you want to access them using base class pointer? Because let us say I have some base class manual and I make 10 types of manual and I have all these animals that I want to call one function all of them. That would not be possible if I have one class pointer which can point to all these objects. Okay. That is why I want something. Does everyone understand what he is trying to say? So, the essential idea is if you have bunch of instances of some classes and you want some one common thing which can refer to all of them, then you can write it using virtual functions and that is useful. Because otherwise you would have to create a class an object of dog, an object of bull, an object of donkey and so on and keep track of it yourself. So, whenever you want to call donkey's function you have to use the object d and call it. Whereas, if you had virtual functions it would actually work. So, how do virtual functions work? Right. So, I have some base class okay in which I declare let us say I have some public function virtual my virtual wide my func right and I make it a pure virtual function. So, base class will not provide the implementation. Now, let us say I have child one okay. So, child one will implement this okay. So, so okay and then I have say. So, I create a base star ptr is equal to nu of child one and call will this work sorry sorry okay. Okay. So, it works as expected sorry this should have been child one right. So, everyone understands how this works right. So, what happened here is an object of child was created address of that was put into this. Now, when I called ptr arrow my func it actually looked at what is the address which is present in ptr and called my function of that okay. If this was not marked virtual what would happen? So, if this was not marked virtual and I had parent then parent will get popped. Now, as soon as I mark it virtual it starts working. So, something happened when this function was marked virtual okay. Now, let us look at the size of base. So, let us say I create an object of base class okay. What will be size of b? There are earlier remember data types what we saw is functions do not occupy space only data occupy space. There is no data here size should be 0. Size is 8. Anyone knows why the size is 8? What pointer? What sort of function pointer? Now, that can point to the most derived of that function. Correct. So, essentially what needs to happen behind the scenes is when I did ptr arrow my func compiler cannot statically determine that this needs to call this version of the function or this version of the function. So, compiler has to wait to figure out at runtime what is ptr pointing to and that is when it will actually be able to call this function. So, what happens is silently there is a pointer which is inserted here which is called as vptr into every object. So, every object has a pointer called vptr and it points to a table called as vtable. So, you can think of it like this that every virtual function has a table here. So, if there were say my func my func 2 my func 3 and so on. So, vtable essentially has addresses for all these functions and vptr essentially points to this table and from this table you actually get to the actual thing. So, what happens is the vtable is created by the compiler such that all the virtual functions are put into the table and their addresses. So, for example, the base class will have one vtable which will hold all the addresses of all the virtual functions in the base class. First child 1 will have a vtable which has all the addresses and child 2 will have all the addresses. Now, whenever you create a object you create a pointer called as vptr which points to the correct table. So, this call is actually getting translated to something like so ptr my func is essentially same as look up vptr first access ptr arrow vptr. So, we get the vptr and then whatever its function will have some index which will be similar to what we saw in got. Every function or every variable has some slot into the got similar to that we have this and then you load from vptr of my func index and jump to that address and call that address. This is yet another problem which gets solved by additional level of indirection. Virtual functions are just creating additional level of indirection and solves this problem is this clear? No, every class has a vtable and every object has a vptr. So, every class has vtable which holds address of all the virtual functions and vptr when the object is constructed depending on if you are creating an object of child 1 then you will point to the child 1's vtable and you will if it was child 2 then you will point to vtable of child 2. So, there is only one vtable per class, but vptr is duplicated in every object. Now, some of the this is actually my last slide and I had if I had more time I could talk about more things which I could not cover. So, the first thing is common linker optimizations or and link time optimizations. So, one of the things which linker could do. So, for example, you have all the things together at link time. So, one of the most common optimizations which linker can do is it can figure out that there is no one calling function foo. No one is calling foo. So, actually linker can eliminate it from the object file. So, linker can remove foo from the object file. So, there is more visibility at link time. So, linker can do some of these things. Link time optimizations are actually slightly different. What link time optimizations do? It is typically they will store the object file with more additional information. Remember we had this example where we had this code where I had client 1 dot sorry. So, I have client 1 dot c which said external int, external int var and I have int main void and this printed var and I had client 2 dot c which defined var as float. Remember this code which we had seen earlier and what we did was client 1 dot c and client 2 dot c. So, linker did not detect this error because there was not sufficient information present. Now, to be able to do link time optimizations, linker actually needs more information because without more information it cannot do more optimizations. So, with LTO, linker actually puts more information into the object file and actually this error does get detected. So, LTO does detect these kinds of errors which so far I was teasing you with that are not possible to detect. So, it might be a good practice to simply compile your code with FLTO just to see if linker catches something. But typically the way linker, link time optimizations are implemented is they will actually store some sort of an IR. So, if you are using LLVM toolchain for example, and if you ask client to do link time optimization, client in object file will not really store the machine code. It will actually store the LLVM IR and then it will do a full fledged optimization at link time. So, link time optimizations can get heavy depending on how aggressive linker wants to do them. But it could duplicate the entire compiler for example. One other thing which we did not talk about is debug information. One of the most interesting things is how does. So, for example, I have this code. So, one of the things is when I do gcc-sample.c and when I am debugging my code and let us say I put breakpoint. How does debugger know when I say break on main, the breakpoint needs to be set on line 5. How does it know that? Let us start executing the program. When I do n which is next, how does it know that the control jumps from here to here? How does it know how many assembly instructions were generated for int x equal to 5 because it had to execute all of them and then only stop. Correct. So, that is breakpoint insertion. But how do you know when I say break on function main, main is on line number 5 in source code. Does everyone understand the type of thing debugger needs to do? All of this is actually supported by compiler. So, debuggers do not work standalone. For source level debugging, you need lot of support from compiler. So, if you look at redelf-s of a.out, you will actually see lot of sections called. It has stripped away those sections, but I will show you a compiled code. So, if you look at this, so there are bunch of these sections which you are seeing in elf. There is something called as debug line. There is something called as debug info, debug range and blah blah blah. So, if you actually decode them, so if you look at this, this section actually has some interesting information. So, this section is present in a form called as dwarf. How many of you have heard of dwarf? So, dwarf just like elf is another format in which actually the debug information is stored. So, this information is actually generated by compiler. So, what this is saying is something like this. So, advance address by 0 to this, advance line by 3 to 4 and blah blah blah. So, it has some encoded information which says if you move address from 0 to this, you also have to move the line number from 3 to 4 and so on. And if you look at actually the decoded line table, that is much more. So, what this is saying is in sample.c, line 4 maps to address this. So, it is a mapping of how assembly code maps to the source code. So, what it is saying is assembly instruction at this address is corresponding to line 4. Assembly code at this line number corresponds to line number 5. And if you look with obj dump, it gives some more things. So, if you look at now main, so it is actually able to associate this. So, it says that this instruction was generated for this code and you can correlate it because this is trying to move value 5 into something in the stack. Printf, this code, this line generated this code. So, if you want to understand how your C code got converted to assembly, this is a much better way because you could actually see that this was C code and this is how it looked in assembly. And all of this compiler has to generate. Now, it is a nightmare for generating this information when compiler is doing optimizations because this information is very hard to preserve as compiler keeps modifying the code. So, that becomes yet another set of problem in compiler which is very hard to solve. The other interesting thing is stack unwinding is stack unwinding and exceptions. Remember we talked about the stack frames were linked list together and in x86-64 ABI, I said frame pointer is optional. And that is optional because compiler can actually generate something called as eh frame in the debug section which gives information to the debugger on how to unwind stack, how to go from one function to its parent function to its parent function to its parent function. Then we obviously did not talk about things on how malloc actually works. I briefly talked what it does, but we did not get into details. We did not talk about details of threads and how threads work and how context switching between threads happen and synchronization between them. And we did not talk about virtual machines which is essentially environment like python and java which have managed environment to run the things. But what we have seen is just scratch of the overall topic, but I hope you found it interesting and you learned something out of it.