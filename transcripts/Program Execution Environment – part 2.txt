 Correct. So, C99 onwards that means if you are using fairly recent compiler it should be there unless you are using some turbo C kind of thing this would not be there, but in any recent and decent compiler this should be supported. This concept is actually called as variable length array or VLA in short form. Now, the question is when you have VLA in your program how will the offsets computed because n is dynamic value and it can vary for every call which you make to that function. So, how will you allocate and access the variables? So far what we have seen is you have ESP from which you can reference and ESP will keep growing or changing. So, whenever you have VLA you have to change the ESP dynamically. Yes. So, that is one way to implement VLA where you can actually allocate it on heap. So, that would solve the problem to some extent, but if you had to allocate it on stack then what will you do? By the way the semantics of VLA is by the time function returns you have to deallocate. So, what you will have to do is you have to insert a malloc call and free call at end of the function. So, that is how you can implement it on heap, but you have to implement it on stack what will you do? What I would suggest is today end of day or whenever you have time try writing such programs and look at the assembly and see what kind of stack layout is generated and you can try this with base pointer preserved and with dash f omit base pointer and see how things are changing. But this essentially requires dynamic allocation on the stack as the program is running you have to keep allocating. Any doubts before we kind of move on? So, so far what we have seen is how to handle local variables and we have seen how to transfer control back and forth between caller and callee. The other thing which is interesting is how the parameters need to be handled. So, we had parameters which need to be passed from caller to callee. Now just like the problems which we had earlier the callee function needs to know where the parameters are so that it can access it and caller needs to know where the return at value is so that they can interface between the two. So, typically how will where will you pass parameters? Let us go with the same set of things which we were trying to answer. Can we store them in hardware registers? We may not have sufficient number of registers and plus we might have an aggregate which is like a struct like a struct of 10 elements or struct of 5 elements those again may not fit into the registers. What about global variables? Correct same problem with recursion so the answer is stack. So, now you should know at least how to get to stack. So, this is the stack frame which we have seen so far. So, we have stack frame of the caller function and stack frame of the callee function and here we know we have local variables which are stored. So, where should parameters be stored? Should they be stored in the stack frame of callee function or stack frame of the caller functions? Why callee? But how will a caller function allocate something into callee stack frame? Because remember to access callee stack frame you must have written address already pushed on to the stack and that will happen only after call instruction is executed. So, how will you say how will you create a hole in the stack? See to be able to allocate in the callee stack frame what you need is caller is executing somewhere here you need to create a hole for return address for the call instruction then allocate stuff here get back stack pointer here and then so that it is laid out. So, it actually gets allocated in the caller stack frame. So, these are allocated on the caller stack frames. So, caller function will push things on to the stack and then the call instruction will push the return address. So, parameters are just above the stack pointer sorry return address and this essentially forms yet another contract. Now, callee needs to access things from the caller stack frame. Does everyone understand this? We could not allocate it in callee stack frame because caller does not have access to callee stack frame, but callee can access callers stack frame and this kind of gets to a point which we were getting earlier and you need to make sure that callee can access callers stack frame. You cannot have a violation there. So, what will happen is so let us say I had this function. So, this has bunch of local variables x y and some those we have already seen those are saved here. So, if EBP is here they are at EBP minus 4 EBP minus 8 EBP minus 12 and then there are parameters m and n. So, those are actually pushed here. Again the same thing applies that if you had a base pointer then they will be at the fixed offset. So, you can access them as EBP plus 4 is written address EBP plus 8 is this parameter EBP plus 12 is this parameter. And you can access the parameter with their EBP relative address. Again in this case you can use stack pointer it just adds more complexity within the compiler, but there is nothing wrong with being able to use stack pointer. Now the question what should be the order of parameters on the stack? Should it be passed left to right or should it be passed right to left? Correct. So, does that even matter? So, does the order of parameters on the stack matter? So, as long as both caller and callee agree that I am passing left to right or right to left and both of them access in the consistent way there shouldn't be any problem. Yes. Correct. So, in this case if you actually look at it the parameter I mean parameters are passed in right to left order. So, if you look at n is pushed first then m is pushed. So, in this case things are actually passed right to left and the reason for that is vararq functions. Does everyone know what is a vararq function? Printf is an example of vararq function. So, let us say I had a printf in which I pass a string and I pass x y z w whatever number of parameters now let us imagine what is happening in vararq function. So, let us try to say that I will push things from left to right that means what will happen is first percent s will be pushed then x will be pushed then y will be pushed then g will be pushed then w will be pushed and my stack pointer is here. Now the problem is printf function the callee function does it know how many parameters were passed? It does not know how many parameters were passed. The only way it can figure out how many parameters were passed is by looking at percent s. So, if this was say percent d percent d percent d percent d. So, it knows that four things were passed to me. But how does it know where this string itself is stored? The string itself will be stored at some location in the caller stack frame and I do not know where it is. See because what is happening is so this is in the caller what is happening in the callee. So, in callee I need to access the parameter. So, I can access the parameter using ebp plus 4 ebp plus 8 ebp plus 12 and so on. But I do not know where is this string stored right because it will depend on how many parameters were passed. Instead let us look at it differently. If I pass things in right to left order then caller will look like this. So, I have w I have y x sorry I have z y x percent s. How does callee know where is the string? ebp plus 4. So, first parameter always is at deterministic location no matter how many other parameters were passed. So, no matter 100 parameters were passed or 200 parameters were passed first parameter will always be at deterministic location which allows us to implement var arc functions. If you do not have var arc function it does not matter whether you pass left to right or right to left or even any other order for that matter. For example, I might say I will first pass middle parameter then one on the left one on the right and keep going. So, it does not matter as long as both of them agree on something. So, var arc function causes us to have this. Now, can you help answer this quiz? So, I have two functions foo and bar both of which print their name and return some value and then in printf I call foo and bar. We know parameters are passed from right to left. Sorry. First we call bar. So, are you saying the output will be 2 4. So, is the output. So, one output can you tell me exact output bar then foo 4 2. So, this is one possible answer we have got bar foo 4 2 any other. Bar foo 2 4. Okay. Any other answers. Yes. Okay. Sorry. Bar foo 2 4 previous one. So, this one is discarded. Can you explain why you discarded this option? Correct. Correct. Okay. So, the param no matter order in which parameters are passed foo is still printed. I mean whatever value returned by foo will be printed as first and whatever value of bar is printed here. So, this has to print 2 and 4. Yeah. Okay. And then since things 4 and 2 and then bar and foo any other answers. Yes. Okay. So, we have someone saying foo bar 4 2. Can this also come? How many of you think first answer is correct? Raise your hand. Okay. Majority. How many of you think second answer is correct? Okay. Minority. Any other answers? Any one for f, b, o, a something some mix. Okay. So, the reasoning why second answer is coming is because it will evaluate foo first by looking at first percent d and then it will look at evaluate bar by looking at second percent d. Okay. So, what is the correct answer? Okay. So, this is where we get into unspecified behavior. Okay. Both answers are correct. Okay. But you have to remember order of parameter passing is not order of evaluation. Okay. Nothing in c says that foo must be done first and bar must be done after that or vice versa. So, order of parameter passing does not influence order of evaluation. So, this code is actually equivalent to this. T is equal to foo, T2 is equal to bar or T is equal to bar and T2 equal to foo. Okay. Just for that matter you must have by now you should be preparing for your campus interviews. Right. So, you must have seen codes like this. So, what is the order in which things are evaluated? So, tell me the answer to this question. i is 1 to begin with, j is 0 to begin with. What is the textbook answer for this question? Correct. Okay. So, eval from right to left. So, first minus minus j will happen. Then i plus 1 will happen. So, this will actually print 2. Then it will again print 1 and this will again increment 2. So, that is the bookish answer which you must have seen in some MCQs. Right. Now, that is actually incorrect. That is incorrect for two reasons. One is you do not know the order in which things are evaluated. Second is this code actually has undefined behavior. Because it is trying to modify value of the same variable multiple times within something called as a sequence point. Okay. So, just sequence points are the points where language says all the side effects must have completed prior to that. And there is no sequence point within this which causes that to happen. Okay. So, the answer to this question is undefined behavior. But most likely in the MCQ, you will not have that option. So, remember evaluate from right to left to get the correct answer to match the book. But it is not correct. Okay. So, if you have undefined behavior, take that. If you do not have, remember how to evaluate. Okay. Now, so far we have seen this that stack grows down, stack grows down. How do you detect programmatically? So, can you write program which will detect that stack is growing down? You do not have, you do not have access to push from C. You have to write a C program to detect. Okay. So, let us do this. So, I do something like this. So, I have f int foo where I create x, y, z. What will I do? How do I detect stack grows down? What is the problem with this? ASLR will not play a role here. But we will see what is ASLR actually. Correct. So, one of the things is C does not say or mandate that x must be allocated first, then y must be allocated and then z must be allocated. So, compiler is first free to allocate z first or y first or x first. So, you cannot rely on the addresses of x, y and z. In what case there is a guarantee for having contiguous is array. So, if I had ARR of something, then C mandates that array is allocated contiguously. That means address of ARR 0 and addresses of ARR 1, they are related and contiguous. So, how will I actually write the expression? What should I write to actually say stack grows down? What should be the condition? If blah, blah, blah printf down else A1. Does everyone understand how this is happening? So, if you look at even our diagrams, they had it that way. So, ARR of 5 addresses lower than ARR of 6 addresses. Now, can you figure out the answer to this question? This will take some time. Please work out on paper and tell me what happens. Everyone understands at least the syntax and the code. Sorry, infinite. Okay, any other answers? So, they are saying it is some sort of infinite call to bar. It doesn't look like. It is some simple pointer manipulation. Any other answers so far? Yes. Do you need to know? In this particular case, it shouldn't matter. But can you explain why you were curious about that? I mean, how does that help you know the answer? I am just trying to understand what is the intuition. Okay. Sorry. Okay, so it will just call infu. I mean, it will print infu and then it will print indbar. That is it. It will never return from main. It will never return from main. Okay. So, if I had put in main as a printf, then it will get printed multiple times. Okay, why do you think that way? So, so far we have two answers. One is there is infu which is printed and then inbar, inbar, inbar, inbar which is continuously printed. Then we have another answer which is infu is printed, inbar is printed and then some sort of hang occurs. But neither we are infu or bar. Is that correct? Okay. Any other answers? And one answer was infu, inbar successfully exit. No issues. Let's try. Let's I think. Okay, so I have the same code. Okay, now we are going to run it. So, it is some sort of a loop in bar. Okay, so this answer that it successfully terminates is incorrect. Your answer that it somehow will be an infinite loop in main is incorrect. Let's look at what has happened here. Okay, so let's see what happens here. So, when we first call foo, there is no problem so far. We are just calling a normal function. We come here. What is the layout of stack as soon as we enter foo? So, stack looks something like this. So, we had parameters which are passed which is a essentially. Then we have return address. Remember params were passed in the caller stack frame and after that return address was present. Right. So, p holds address of a. So, p is pointing here. Right. Then we say minus minus p. Okay, that means p now starts pointing here. Okay. And we save this value to val. Val now holds return address. What is return address in this case when foo is called? What is the return address? It is the instruction following foo. That means it is called to bar. So, if this statement was location 0x100 and if this location was 0x200, then this value is holding 200. Everyone got so far? Okay. Now, then we print foo and then we return. Where will we return? 200. Sorry. 200. So, we will return here. See, we have not done anything. Okay. We have simply copied that value. Okay. Then we call bar. We come here. So, the stack frame will look somewhat similar to this where we have parameter b and p is pointing to b and then we decrement p. So, p is now pointing here and what we do is we say p is equal to 0x200. That means we changed the return address to then in bar prints and where will bar function return? 200. What is at 200? Call to foo. It again comes here. Again does the same thing. Again. So, it keeps doing the same thing. So, what we did is we overwrote the return address such that it calls bar multiple times. This is actually one of the security holes. This forms basis of something called as buffer overflow attack. Has anyone heard of it? Yes. Okay. So, imagine see here I did something simpler, but imagine if I could somehow do it something like this. So, if I said val here, val actually is some function man in the middle. If I somehow changed return address to a functions address called man in the middle, then what will happen? Bar will return to function man in the middle. Man in the middle will do whatever it wants to do and then can do whatever it needs to do. Right. So, what we have got access to is access to the return address of a function. And if we overwrite it or manipulate it, we can manipulate things very easily and we can do some interesting things with it. Okay. So, for example, let us look at it this way. So, let us say I had printf in main. Right. And I simply did this. Okay. Now, let us invoke this code. Okay. So, it has now gone to in foo, in bar, in main. So, I was able to successfully execute main in between foo and bar and do something in it. And this could be a function which has some malicious code which can actually do something harm foo. Okay. So, having written address on stack actually poses some security problems. Okay. There are some ways to deal with it, but in most cases you have this security issue in your system. And that is why you must have probably read somewhere, do not use strcpy, use strncpy. Right. Those kinds of things are there because you do not want to accidentally overwrite variables on the stack. See, if you accidentally overwrite variables on the stack, you will actually corrupting the return address. And when you corrupt return address, something bad can happen. Okay. So, so far, just to recollect, before the break we looked into how things were passed as a control, how parameters were passed, how local variables were done. Now, let us look at return value which is the last thing which is remaining. Right. So, return value is actually comparatively simpler because what happens is most of the programming languages support only one return value. So, they say you can only return one value from a function. You cannot return multiple values. Right. So, that you can actually do by register itself. So, most of the implementations including x86 simply pass return value via register. They do not put it on the stack. So, you can return. So, whatever is your return value, just before returning, you populate that value into EAX and the caller function will access EAX to get that value. Okay. Now, if you return a large struct, what will happen? See, C says return only one value, but it does not say it has to be a 32-bit value. It can be a structure. Right. I can have a structure of 100 elements. How will I return? See, if I have a function which returns a structure, so the simplest thing which most of the implementations do is EAX is a 32-bit value. So, it can at least hold a pointer for 32-bit systems. Right. So, what you can do is you can actually, the caller function actually creates the structure on the stack and it is some sort of a call by address where you pass that address to the callee function. The callee function modifies whatever it wants and EAX holds address to that and you use that. Okay. Does everyone get this? So, when you are calling a function, you pass a hidden parameter. The hidden parameter will be essentially address of the structure which is the return value. Okay. You call the callee function will do whatever update it needs to do in that address and then return address of that variable as EAX and the caller function can use that address in EAX to refer to the structure. Okay. That is how you return a larger value which does not fit into EAX register. Okay. Correct. Yes. So, that is a problem. So, the problem which Ujwal is trying to raise is return values are optional. Right. The caller function does not need to say x is equal to foo. It can simply say foo although foo is a returning a value. So, the caller function does not need to collect the return value. Right. But you will still have the overhead just because foo was returning struct. It had to populate all of that. Right. And that is needed because when you are compiling foo, you have no idea whether return value will actually be used or not used. So, you have to be conservative and do that. You cannot do much about it. Does everyone get this point? Because foo might be defined in a different file than the main function and foo function does not know whether main is actually going to use the return value or not. So, it still has to do whatever is required assuming worst case in which case it will actually use the value. Okay. This is same as how parameters are. So, think of it this way that compiler simply translated a function like this struct as foo with int x int y to something equivalent to this. Wide foo int x int y struct as star. So, it passed this as a hidden parameter, did all the updates and simply returned actually this should be int star or struct star struct as star and simply returned address of that. I will come to who specifies these things. Correct. So, it is in the caller stack. So, so far we have seen how things actually work between function calls. Now, one thing which is remaining which I think was coming earlier in couple of times is both the caller function and callee function are using the same hardware. It is not that caller function is executing on one hardware and callee is executing on other hardware. So, they have to share the hardware. That means they have to share the registers and someone was saying what if so, when we were talking about things like written address. So, what if the callee function needs eax and it overwrites it. So, in this case what is happening is caller function is moving value 5 into edx then calling the callee function and callee function is overwriting edx and when the control comes back this edx value is no longer present because there is only one register called edx in the hardware. There is no caller underscore edx or callee underscore edx. So, it was overwritten. So, edx must be somehow saved before and after call instruction. Who should save it? Yeah. So, let us go with some step by step things. So, let us say so, what is the requirement? Requirement is caller function should save and restore all the registers before and after call it is going to use and callee function should save and restore registers it is using in the function body. So, caller function uses some registers it saves and restores them across the call instruction. If callee function uses some registers it saves and restores them. Now, if there is a register which is used by both of them then there is possibly redundancy. So, let us say there is eax register is being used by caller. So, caller is saying that okay I am using this so I must save this register. So, it has saved that register. Now, callee comes callee is saying I also need to use eax. So, I should save it. So, there is unnecessary saving which is happening because both of them were using it both of them are saving it without it would have been ideal if only one of them saved it because that would save some time and same thing will happen is the question really is does the caller function know which registers callee function is using and does callee function know which registers caller is using does it know. So, when you call a function foo do you know which registers are being used by foo? You do not know because foo's definition may not be available and you have to do inter procedural analysis. Did you learn anything about inter procedural analysis in your okay and obviously in separate compilation things I mean separate compilation is the biggest hammer which kind of puts everything outside the scope of compiler. Compiler has simply no way to deal with it. So, if foo is defined in the file you can do something but you still have to do inter procedural analysis and if foo is defined outside then you simply cannot do much. So, in most practical cases you would not know which registers are being used. So, let us use the convention. Let us not the up the guideline which we want to have is we want to avoid unnecessary saves and restores. So, we do not want duplication of the work. So, let us come up with a convention that caller saves all the registers. So, caller function saves and restores all the registers before doing the call. So, what will happen is this is the caller function and it is calling a callee it will save all the registers before doing the call. Calls the callee function callee function does not do any save restore. So, callee function is happily using all the registers and returns and then callee function caller function restores all the registers. Okay now the problem with this is every time a function is called you have to do this save restore. So, the save restore is happening at every call instruction. And the problem is caller since it does not know what registers are being actually used it may actually end up save and restoring registers which are not even used. For example, let us say ESI register callee does not even use that. So, but caller since it does not know it will still save and restore it which is waste of time. Now, the question is does caller really need to save and restore all the registers. Correct. So, caller really need to save and restores only the registers which are used by caller. So, for example, let us say there was a register EBX which was not at all used in caller. Now, no matter whether callee uses it or not you do not have to save and restore it. Okay, does that make sense? So, if there is a register which is not at all used in the caller you do not save restore. So, you have one optimization even when caller was supposed to do all the saving. The other is if caller is using a register, but the register live range ends just before the call instruction. Does everyone understand what is live range of a register? Right. So, if the register live range does not cross the call instruction that means caller was using EBX register, but does not use beyond this point or overrides it beyond this point then it does not need to save restore. So, it does not need to save restore a dead register. So, if there is a register which is not at all used or which is dead across the call instruction it does not need to save restore. So, this is one convention, but there is still downside that every call has this save and restore logic. Let us look at the extreme other case where callee is responsible for doing every save and restore. Caller is happily using all the registers. So, callee will save all the registers at the start of the function and will restore them before returning. So, callee will save all the registers and restore all the registers. Again here you can do an optimization where callee will save and restore only registers which are being used. And one other better advantage is the code to do save and restore is kind of localized to the function. It is not kind of spread around everywhere. So, that is I mean when you are reading assembly it is kind of spread around in the prior convention. Here it is at least localized and here again the same problem happens it callee does not know whether a function register is being used. So, we should try to get best of both worlds. So, essentially you say that there are some registers which are responsibility of caller which caller will save. The other registers are responsibility of callee. So, you divide your registers into two parts. One is responsibility of caller other is a responsibility of callee and you do this. So, this is register saving convention. So, you split your sets into two sets. One is something called as a caller saved registers. As the name indicates it is caller's responsibility to save these registers before doing the function call and restore them after the function call is being done. No. So, only caller saved registers need to be saved and there it can do an optimization if there is a dead register or a registers whose live range does not cross then it does not need to save. If something is being. So, think of it this way any caller saved register callee is free to overwrite it without having to worry about it. That is why these are called as scratch registers. So, these are scratch for the callee function. So, callee function is free to overwrite them without worrying about what will happen at caller. If caller wants to use it across the call then it better saves it. If it does not want to use it, it does not need to save it. But callee does not have any responsibility of saving and restoring. Then there is callee saved registers which is exact opposite which is essentially callee's responsibility to save and restore. And caller function is free to use these registers across the call without having to save restore. And these are called preserved registers. These are preserved because the value of these registers does not change across the call instruction. So, they are preserved across the call instruction. And this is yet another agreement between the caller and callee. And where to yes. We will get to that. Now, where we have been saying that it is save and restore save and restore. So, where to actually save it right. Yeah, stack by now you should be able to articulate why global variables will not work and so on. So, answer is stack. You should whatever registers you need to save, you save them in stack. So, essentially this is what happens. So, let us say EAX is the register and it is caller save. Let us assume. Then before calling the callee function, the caller function will push this on to the stack and come to callee. Let us say EDI is a callee saved register. Then callee function will save it before using it and pop it before returning. And then callee function is free to use EDI without having to save restore. But for EAX it has to pop from the stack. Yes. We will come to that. Any other questions so far? So, so far we have two questions. What is the EAX register? Is it caller saved, callee saved? And second is what happens when a function is caller as well as callee? Correct. We will come to that also. Any other things? Sorry. You didn't get the benefit. So, the question is why are we doing this? So, one is essentially you. So, let us look at the various options we had. The first option we had is both caller and callee save all the registers. So, there is some redundancy. We said that then caller is responsible for saving everything. There is some issue with that. So, this is also not perfect, but it is trying to just load balance the two things. So, we don't want to burden too much caller or too much callee. We are just trying to get best of both things. And this actually enables some optimizations which we will see on having this split. So, to answer your question, if you look at x86, these are caller saved registers EAX, ECX, EDX. Callee save is EBX, ESI, EDI. And special registers ESP and EBP are callee saved. Now, can someone answer why stack pointer needs to be callee saved? What will happen if it? So, let us say I was designing my system. Can I make my stack pointer caller saved? Yes. But that is the semantic of callee saved. Callee saved is saying that if something is callee saved, callee is responsible for saving and restoring it. So, before returning from callee, the callee function must ensure that the stack pointer is pointing to the correct address. So, I didn't get why you think that makes it callee callers saved or callees. Correct. Does everyone get this? So, essentially, let us try to play this hypothetically. So, let us say ESP was caller saved. So, what will happen is before doing the call, caller will save it onto the stack. Now, control will transfer to the callee saved function. Now, since it is a caller saved register, callee function is free to modify it and does not have to change it to the original value. It is responsibility of the caller. So, callee function happily keeps modifying stack pointer. Then the RET instruction comes. RET instruction requires the stack pointer to point to stop a stack. If callee doesn't adjust it, then RET instruction will not work properly and it will start popping random stuff from the stack when RET executes. That is why it is callee saved because callee anyway has to clean up the stack to get to that. Does that make sense? Now, to answer your question on how many are here and how many are here, it is actually a performance thing. There is no right or wrong answer except in special case like this where semantics mandate you to have it callee saved. I could have very well said that EAX is my callee saved registers. So, there is nothing in the hardware which is forcing you to make EAX callers saved or callee saved. It is some convention which is decided and usually there is a lot of tuning which happens to decide this split. But it is an engineering trade-off. There is no conceptual answer to that that it must be this way and the other way is incorrect. Now, let us look at these quizzes. So, let us say you have a function foo which is calling bar. Now, let us say foo happens to be a very complex function. By complex, I mean it has lot of instructions, doing lot of computations and so on. And function bar is very simple. And you are an optimizing compiler. So, you have to do register allocation. Now, when you are generating code for foo, should you use more callers saved registers or should you use more callee saved registers? Is the question clear? So, there is a function foo which is very complex. It is calling a simple function bar. So, bar is likely have small set of instructions. Foo is going to be very large and foo is calling bar. Now, when you are register allocating function foo, should you use more callers saved registers in foo or should you use more callee saved registers into foo? Why callee saved? Okay, so they are saying foo should use callee saved register, more callee saved registers. Correct. So, what will happen is since foo is complex, you could assume that foo is going to use many registers. And many variables will be mapped to different set of registers. Now, if you use more callers saved registers, then every time bar is called, it is callers responsibility to save and restore them. So, foo has to do additional work plus it is already constrained on the registers because it is going to be large. So, it is useful for foo to use more callee saved registers. This kind of tries to answer the question which you had. So, if you didn't have this kind of split, both foo and bar will be responsible for saving all the registers, in which case both of them have to do equal redundant work, in which case you are doing suboptimal use of your resources. Instead, if you divide your responsibility between foo and bar, and depending on how complex either of them are, you could tune your register allocator to use more, shift more burden onto the simpler function than pulling it on yourself. Does that make sense? That is why compilers register allocation also need to be aware of these facts, not just for generating code, but also for optimizations. And obviously, what will you do in the opposite case? If foo was simple and bar was complex, you would do the opposite, where you will say foo should use more callee saved registers. Now, let us say foo calls bar, but bar does not call any other function. So, foo is calling a function bar and bar does not do any other call. So, bar simply computes whatever it needs without calling any additional function and simply returns. So, when allocating for bar, which register should you use? Should you use more caller saved registers or should you use more callee saved registers? Why callee saved? Okay. Correct. So, to answer this question, let us go back to the earlier question which we were getting. So, what happens when you have a function which is being called by someone else and it is also calling some other function. So, let us say that we have a chain, main calls foo and foo calls bar. So, let us talk about function foo. So, function foo is being called as well as it is calling other function. So, foo acts as a callee from point of view of main and foo acts as a caller from point of view of bar. So, foo has a responsibility in worst case to do both the worlds because when it is called from main, it has to save all the callee saved registers which it is using. And when it is calling bar, it has to save all the caller saved registers. So, foo has to do worst of both worlds. Now, if foo was not calling a function and if you use callee saved registers, then what it means is foo has to save and restore at least callee saved registers. But if foo was using only caller saved registers, then it has to do nothing. So, a function which does not call any other function actually benefits from using caller saved registers which is what he was trying to say. So, if you have a function which does not call any other function, if you use caller saved registers, that function has to do nothing as far as save restore goes. If it uses callee saved registers, then it has to do save and restore. And for an intermediate function as in a non-leaf function, it has to do both of them. So, leaf functions typically can do things without save and restore. Now, the third question. So, let us say you are compiler. In which order you should compile functions? So, should you compile and register allocate caller first or should you compile and register allocate callee first? Does the question make sense? See, it is not that you are going to register allocate entire program. You will probably do function by function. In which case, should you compile callee function first and register allocate it or should you compile caller function first and register allocate it? So, going back to this first example, we utilize the information whether foo is complex or bar is complex and decided our register allocation scheme. So, if you knew more information about the function which you are calling, not in terms of exact all the things, but even if you simply know that this function is using these many registers and these type of registers, you could take that decision and feed back to the caller. So, that is what most compilers would actually do. So, they would prefer to compile callee first and then caller and feed back the information from caller to caller, so, callee to caller and use that to influence the optimizations. Again, in whole program only, if you have separate compilation, everything goes for a toss. So, you have to be conservative and do the worst thing. So far, are things clear? So, so far, we have seen some contracts between caller function and callee function. We saw the contract, the first contract was where the return address is and we learned that on x86, it is part of the stack as per when we push the call the instruction and how are parameters stored on to the stack and in what order they are stored on to the stack. Where is the return value and how it is obtained and which registers are caller saved and which registers are callee saved. So far, we have seen these as contracts between the two. If any of the contract is violated, then we have a problem because if say caller is assuming that I need to pass registers in left to right or parameters in left to right order and callee assumes parameters are from right to left, then it is not going to work as expected. Similarly, if caller assumes that the return address is passed by a global variable, but the callee function is looking at it from the stack, then it is not going to work. So, both caller and callee function must agree upon something. So, these contracts are actually called as calling conventions. So, these set of contracts, there is a term called as calling convention. Now, coming back to the question of who decides calling convention? Is it hardware? Is it compiler? Is it someone else? Is it me? Is it you? So, calling conventions are actually decided by something called as application binary interface or ABI. How many of you have heard this term ABI? So, ABI is a contract which exists between binaries, binary interface and it is published by a platform. It is not operating system alone. It is not hardware alone. It is a combination. So, x86 does not have ABI. x86 Linux has an ABI. x86 Windows has an ABI and each ABI can be different. Just like we saw caller saved callee saved convention, x86 Windows may decide I may have a different convention than x86 Linux. But every platform provides an application binary interface and all the tools which are involved on that platform need to comply to that ABI. So, GCC has to comply to the ABI which is on x86 Linux. C lang on Linux has to comply on x86 Linux ABI. C lang on Windows has to comply to x86 Windows ABI. Does that make sense? ABI decides calling conventions, but there are other parts of the ABI also. For example, size of integer. It is not specified by compiler. So, do not think size of int is 4. It is compiler dependent. It is ABI dependent. ABI is the interface which is actually specifying what is the size of int. For example, long int has worst ABI. So, long int on 32-bit Linux is 32-bit. Long int on 32-bit Windows is 32-bit. Long int on 64-bit Linux is 64-bit and long int on Windows is 32-bit. So, Windows has a weird ABI for long int where it says long int on Windows is going to be 32-bit. And that they had done for portability reasons, but it is odd man out. And that is why you should not use long int as a data type in your program because it makes it less portable. Because if you are writing something as long int, assuming it will be 64-bit, then your code will not run on Windows 64 as expected. So, knowing ABI helps you write portable programs. The same thing you need to follow when you are writing assembly. So, if you are writing assembly program which might be called from another C program, your assembly program must comply to the ABI. So, your program must expect the pointers parameters are passed in this order and so on and so forth. So, you have to as an assembly programmer, you have to know what is the ABI which is being followed. As a compiler writer, you need to know what is the ABI being followed. So, you can generate code for that ABI. Does that make sense? Now, the question is, is there only one calling convention specified by the ABI? What are issues with only one calling convention? Correct. So, so far whatever we have seen were mostly trade-offs. There is no truly right answer and truly wrong answer. It was just a judgmental call that four caller saved registers is okay, four callee saved is okay. Whatever applies to broad class of programs makes sense. But as he said, it is not optimal for a specific use case. For example, if I know I am going to pass only two parameters to a function and my function is very critical. Let us say my function is called deeply within some set of nested loops and is very important for performance. Do I really want to pass my parameters via stack? Because remember stack is a memory access and memory access goes through a hierarchy of accesses and if it is not in cache, then you will hit to DRAM and it will take a lot of time to come. So, there are multiple calling conventions which are specified. So, there is something called as fast call. I do not know how many of you have heard of it. But fast call essentially says first two arguments of the function are passed via register. So, instead of using stack, if you have first two parameters will be passed on to the registers. And again you have to realize that it is not only caller who decides. Both of them have to agree and both when you are compiling both caller and both callee, you need to know whether it is going to be called with X convention or Y convention. It cannot be arbitrary convention. So, there are bunch of other calling conventions which are specified. And so, let us say there are no callee. So, there is only one calling convention. Let us hypothetically assume. Can calling convention be relaxed by compiler? Can compiler do that? So, let us say there is a function foo which is called from main. Compiler says I see foo is being used in a very critical loop. So, let me instead of using stack pass things via registers. Is compiler allowed to do that? Correct. So, compiler in theory can do it because it is generating code for main as well as foo. But what are the preconditions? So, let us say you come up with this optimization where you will say that I will do some analysis and figure out I should call this function and pass parameters via registers. What are the preconditions for that optimization to kick in? In what cases compiler cannot do that optimization? Programmer cannot assume that because language standard does not say that programmer can assume that. See, because when you are generating code as a compiler and whenever you are doing optimization, one of the most important aspect of optimization is to not break semantics of the program. So, no matter how good is your optimization, if it breaks the program semantics, it is illegal. So, what are the preconditions for you? So, let us say you implemented this optimization. When what will be the conditions you will check under which you can apply this and in what conditions you cannot apply this? Can a parameter be covered by argument? Okay, so there are some sanity checks that the optimization is only for function with two parameters. So, that is one check. Okay, so if the parameters are such that you cannot put them into physical register, like they are like 64 bit values or something like that, maybe you. So, two checks. Any other things you need to check. Remember, programmer is not asking compiler to do this. Compiler is kind of doing it out of its own magic. What if compiler does not know all the callers of the function? So, the function foo is being called, it takes two parameters, but I do not know from what all positions foo might be called. In what cases can that happen? Foo is defined in current file. But when can callers of foo come from other file? So, separate compilation foo is defined. The callers of foo can be other file in separate compilation. Is there something when I am compiling that I know foo might be called from other files? Okay, does anyone know something called as static when you apply to function, what happens? So, let us say if I do this, what is the meaning of this? Does anyone know? When I say a function is static? So, let me ask you this. What is the difference between these? So, you have to tell me difference in these four cases. So, there is int gbl, there is static int gbl2, there is void foo and there is static void bar. What is the difference between these things? What is the difference between gbl and gbl2? These are global variables by the way. So, all of this is written at outside main. So, is there any difference between gbl and gbl2? Yes. Correct. So, gbl is actually usable in other file using external int gbl. I cannot do external int gbl2. So, static keyword here is implying that this variable is not accessible outside this file. Gbl is accessible outside this file. So, there is a term called as translation unit, which you might have heard. So, gbl can be used in other translation unit, gbl2 cannot be used in other translation. In the same way foo can be used in other translation units, bar cannot be used in other translation units. So, when I have a function which is static, I know all callers of that function will be in the same file, even if I am doing separate compilation. So, if I mark a function static that is good, that allows compiler to do more optimizations, because compiler knows that static functions cannot be called from other file. So, even though I am doing separate compilation, I can assume few things about this function. And one of the things could be relaxing calling conventions, because I know that all the callers are in this file and they are at 0.1, 0.5, 0.10, 0.25. As long as those points match with the function, I am doing this optimization. What if someone does this? So, this code is actually doing a function pointer to bar, and the function pointer itself can be external in other file. So, I can do external this and use. So, it is not that bar is not callable from other files, but it is not callable directly, it can be called from function pointer. So, compiler cannot simply do this for every static function. It has to do it for static functions whose address is not taken or whose address is taken only in static function pointers. So, there are bunch of conditions you have to match to figure out yes. And by now you should know pointer analysis. So, even if this was static, I could do something like this. Some other pointer is equal to fp and then whatever other magic and everything goes for a toss. So, as soon as you put pointers, in theory it is possible, but for practical reasons it gets very hard. So, but simple condition is if your function does not have address taken, you can apply this optimization. That is why whenever you are writing programs with multiple files, it is very important for you to express your intent. For example, if you know this function is for this file only, like if you have a print routine, which is printing some data, it is unlikely that you want this to be called from someone else. It could be a debugging routine which you have written. So, you want that to be marked static so that it will enable compiler to do more things. And obviously, separate compilation is a problem. So, separate compilation poses problem. Function pointers create problems. So far we have seen calling conventions. Now, x86-64, which is a 64-bit architecture, x86 had only 8 registers. x86-64 has 16 registers. And the Linux ABI is something like this. First 6 parameters are passed by registers. For first 6 parameters, you do not need to use stack. And they are passed in this order. First parameter will be in RDI register, second will be in RSI register, third will be RDX and so on. And frame pointer is optional. There is no need for frame pointer. All the references will be relative to stack. Then how will debugger work? Remember we were using EBP for debugger. How will debugger work? How will debugger know where is the caller function stack free? So, with hyphen g, he is saying you can still have RBP. So, you simulate something. But you still waste space on stack and so on. So, compilers do something more interesting, which we will get to in the last phase of the session to solve this problem. And then rax continues to be the return address register. So, x86-64 changes the ABI in two particular ways. That one is frame pointer is now optional. Debuggers cannot rely on compiler would have populated the frame pointer. And frame pointer becomes available as a general purpose register for compiler to use. rax is same and it has first 6 parameters in the registers. It is an improvement. If you are compiling your program to x86-64 and if you are using limited parameters, most of them will get passed via register. You do not have to access stack. So, this is how the stack frame will look. You have parameters which are 7 plus in the stack. First parameters are in registers. So, they do not appear in stack frame. And frame pointer itself is optional. Now, there is something called as a red zone here. This is an optimization for leaf functions. So, what red zone allows, it is a region of 128 bytes, which the function can use without having to update the stack part. So, if I have to use some variables which fit within 128 bytes and need to be on stack for various reasons. We saw that if there was an array, it has to be on stack. If there was in the address of something was taken, it had to be on stack. So, if there is some local variables up to 128 bytes, I can actually put them on the stack without having to update the stack pointer. Now, why do I want to do this? This seems a bit bizarre. I want to use stack, but I do not want to use update the stack pointer. Why? Why do I want to avoid stack pointer update? But that again compiler would do. If it updates, it has to adjust the offset. So, one thing is remember stack pointer is callee saved. So, if callee updates the stack pointer in any way, it has to restore it. That means it has to save it and it has to restore it. So, it has to do at least two instructions. To avoid those two instructions, this exists. So, I want to use stack without having to save and restore the stack pointer. This I can do for leaf functions because leaf functions are not going to call any other function. So, I know the stack frame is not going to grow. So, if I simply access the variables which live beyond the stack, then I am safe to use that because they will not be overwritten by the subsequent calls. Does that make sense? So, it is an optimization to having to avoid save and restore. And leaf functions can use it. So, leaf functions can get away without having to do anything in the stack. If they use caller saved registers, which was their preference, and they can use red zone to save some simple variables. Any questions so far? So, so far what we have seen is we have seen how functions call actually work. We started off with how to transfer the controls. We then looked at how parameters are passed. We looked at how return address is populated. We looked at calling conventions and register saving and other things related to them. So, that kind of completes whatever happens for the function calls.