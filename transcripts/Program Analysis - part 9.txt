 Okay, so the last session I was sort of indecisive whether I should do it or not or how much but I think it's a good idea to talk a bit about pointer analysis. The reason is that Monday whenever you start looking at machine independent optimizations, he might want you to know about pointer analysis. So at least a little bit idea of it is important. So now pointer analysis exactly what is the data for problem? What are we trying to solve? So we are trying to figure out that given a set of variables, rather I would say given a set of pointer variables and a set of memory locations, we want to find out that what for a given variable says a given variable B, what are the set of memory locations it may be able to access, which it might be pointing to. This is points to. So for any given variable, I want to find out that what does it point to? So that is the next question. So let us say that we have a set of statements. I have x equals ampersand A, y equals ampersand B and say y equals ampersand C, x equals y. So let's say how will we go about doing pointer analysis? So essentially for, so what is the, what will it look like? What is the data for problem? What is the data flow set? What is the solution set look like? So for every variable, I will have to say what is the points to set. So there are how many variables? There are variables like there is x, y, these are the two variables. For each of them, I would like to need, I need to say that x can point to what all things and y can point to what all things. This is my solution. This is what my solution would look like. So now to begin with, I will assume that the pointy sets are empty. They are not pointing to anything. So let's say I start doing a flow sensitive analysis. I start doing a flow sensitive analysis. So in a flow sensitive analysis, I will need to maintain the pointer sets at each program point or at end of each basic block the way we were doing. So let's for this particular set of instructions, how would you go about doing it? So after the first statement, how will it change? So x will now start pointing to A and y will start pointing to still the set is empty. At this point, x starts pointing to still A, y points to B. At this point, x points to A and y points to C and at this point, both points to, yeah, so x also starts pointing to C and y also keeps on pointing to C. So this is all pointer analysis is all about. Now what about if we have, what are my meet and join operators? Like if I wanted to across two basic blocks, if I want to say that what should be the pointer set here? Union, variable, per variable. Per variable. For like x, you will unify the set of variables on x. For y, you will do it for y and so on. And what are my, how will I compute my transfer function for each basic block? So to come up with the transfer function, you have to come up with what are the important statements I have to model. So what are the different important statements that are there for pointer analysis? The first is the assignment of the referencing operator. So essentially y equals ampersand A sort of operation. So here what will happen? So what is the transfer function for such a statement? So kill whatever is the pointer set of y, throw it away and add A as the singleton element in that set. The second important operation is star y equals A. Point a dereferencing operator. Oh sorry, the other way round. So A y equals this. So that is not required. So I can do, what about y equals, assignment statement, y equals x. Replace the set of, whatever is the set of y, throw it and put the set of x here. And then you have, these are important, but you can also have y equals star of x. Why is that? It's a pointer to pointer. So then what will we do? So we will find out what is the set of location that x points to. Then figure out for all of these locations, what is the location that those locations can point to. And the union of that will finally get assigned as the points to set of y. And now the last thing is that if you have the other type of operation, star of y is equal to x. It can still be a double pointer. So then what will you do? Okay, so this is a little sensitive operation. How, what does it mean? So, so whenever I say, whenever I tell you this points to set, A points to A or B, what exactly does it mean? What is every element? Y is a variable. No, no, I'm saying what does this fact mean? What does A points to A and B mean? A may be pointing to A or B. You do not know which one does it point to at this point in time. Sorry, y points to. After n B. Yes, yes, yes, of course it will. So that is what you have to modulate properly. So what does then star y of equals x should do? Yeah, yeah. So types are matching. So don't worry about it. So then let's say y is pointing to, I don't know, let's say u and v. No, v, okay, u and w. So then. Can I kill the set? Yes, yes. So that is a very tricky thing, right? So had this been a simple set u, then I know that y is surely pointing to u. That's an easy case. In that case, I can kill whatever was point, whatever u was pointing to. And I can now say whatever x is pointing to, u also points to that. But if I have a situation where y was pointing to two things or more, then I do not know at this point what it might be pointing to. So I have to be safe. I cannot be unsafe. So if I throw away the contents in u, maybe u was not even changed, maybe w was changed. I don't know because it's a made point relation. It may be pointing to any of them. I don't know which one is currently pointing to. So in that case, I cannot, so this is what is known as a strong update and a weak update. So if you do a strong update, means you throw away whatever that variable is currently having and put the new fact. Instead, you can do a weak update when you know that I do not know which of them is the right guy. So let me just add it to both the data flow facts. So in this particular case, if it is pointing to u and w, I will not throw away the facts of u and w. I will simply add the points to set of x into the points to set of both u and w. I'll just union them. This is a weak update. And strong update is whenever, if it had been a singleton set, then I know that y is surely pointing to u. Then I can simply throw away that set and put the whole set of x as the set of, so the set of u. So this is how I design my transfer function. The meet operation you already know. So this is exactly what my points to analysis is. So we have this points to set, where variables points to values, and this is the business. So what is my, what does my lattice look like? What is the ordering relation on that? So it is set, right? So it is a set of locations. So the ordering relation can is generally. So for one variable, what does the ordering relation look like? MT and then it is a? Right, right. But what is the ordering on? How do I do an ordering? What is the ordering relation for this lattice? Yeah, subset equal to, right? So that is for every variable. And then the whole lattice is going to be the product of that, the product lattice, just the way we did it for constant propagation. And then the ordering is this huge humongous ordering among each of the component lattices. And then you figure out if something is bigger than that or not. Exactly the way we did for constant propagation. Right? Are you lost? Who is lost? Why ordering? You tell me. So if you have a set which is pointing to only A and B, and I have a set which is pointing to A, B and C, the same variable. So X pointing to this and X pointing to this, which is more approximate, which is over approximate? Later, later, later doesn't work guys. Please understand across program points, it does not, there is no comparison. This everything is working at one program point. Right? So I'm saying what, how do the updates move at the same program point? So every of these lattices are actually think about them, they are duplicated at each program point, and they're moving on their own independently. So across the program points, there is absolutely no relation. I can put any statement in between and arbitrarily change the, whatever happens at another program point. I can produce any state I can. So all these beautiful mathematics that we saw today was all telling you things about the same program point. Along the same program point, it should form that ascending chain and then eventually stabilize and all this business. So across program points, things do not make that mistake again. I mean, I know this is a very, I mean, it happens again and again and again to people, but don't like, don't get into that trap. That will be very misleading. So now the thing is that is it a separable analysis? Yes. Yes. So this is also not a separable analysis, right? Because if I change the points to set of one relation for this double, that pointer dereferences that may cause an update to the another guy's points to relation. So this is also not a separable relation. Yeah? So pointer increment does not change the point to set of anything. You just get to a new location, right? So pointer increment means what? So you are, this was pointing to, so think about my locations as L1, L2 and so on, right? So if I say pointer P is P plus 1, essentially now P is pointing to the location L2. That is all that is. So earlier it was like, so the other problem is that there are these, these increment statement happen on things like aggregate data structures like arrays, right? So the problem is even modeling arrays is hard because whenever we are modeling something, we would like a finite representation, but arrays can be of unbounded sizes. You do not know what size the programmer want the array for, right? Like for instance, let us say even allocate the array dynamically using a malloc statement. So at runtime, what is the value of that, the size of the malloc? Nobody knows, right? So I will not be able to do a analysis at compile time because I do not know how big the array is going to be at runtime. So what people do is, like I was saying yesterday, instead of these multiple locations, they assume that the whole array is just one location L1, right? And like if you say pointer the array A goes to, like let us say P goes to A and A0 and later you say P goes to ampersand A0, P goes to ampersand A1, what the compiler will simply do is because it is the same location, here also it will say P goes to L1. Here also it will say that, okay, I still see the same array. It is not a different array. So it will still keep it as P goes to L1. So it completely disregards your array accesses for the different elements. It does not bother because it does not know how many memory locations to model. So the one way is to like completely squish the array into one location and then say I will only keep track of does it point to this array or this other array. But I will not keep track of which index in the array it is currently pointing to, right? Excellent question. So this is an important point, but yeah, generally, right? So that is one way to handle arrays. Of course, there are other abstractions. We will have come up with more sophisticated abstractions, but let us not get into this. So again, like I said, people have this recency abstraction where what they do is they think that my array is two parts. One part is the rest of the array is squished into one location and the first element like A0 and the rest. And I will only keep track of these two, nothing else. So because people think that the most recently accessed location you will going to access again or something like that. So again, it depends on your domain, looks at depends on your problems. So are we good with this transfer function for all these statements? Any question with understanding point analysis? Probably this is the fastest point analysis, but it is very similar to constant propagation. That is the, so everything remains very similar. Any questions with this? Again, very quickly, so we have these points to sets. So for every variable we need to figure out what are the locations, memory locations it can point to, right? So the updates for these different statements are as follows. If you have one goes to Y is equal to ampersand A, then you will kill the set Y. You will throw away whatever is in Y and put A in that location. If Y equals X, then you'll throw away whatever is there in Y and copy the whole set of Y into the points to set of X, points to set of Y. If you have Y equals star of X, then what do you do? Then you will find out what are the locations that does that X point to. So let's say X points to location L1 and L2 and L1, L2 themselves points to, let's say AB and this points to C. Then what will you do? Yeah, so I'll take the union over all the locations that these guys could point to. So this will become, so X will start pointing to A, B, C, all them because it does not know where to go. And finally, if you have the most tricky situation is if you have a set of X points to location L1, L2, L3, L4, L5, L6, L7, L8, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, L9, finally if you have the most tricky situation is if you have star of Y equals X, then what can happen? Yes, so if it is a singleton set, then I can actually do a strong update by replacing that particular location by the set contained in X. Or if it is not a singleton set, then I do a weak update by adding that set to all the sets pointed to Y. Clean? Awesome. Now, pointer analysis is one analysis which is also done in a flow insensitive manner. So it is a good candidate for flow insensitive analysis also. Did I lose everything? Okay, so one interesting data structure or interesting visualization people used to track about point analysis is referred to as a points to graph. So what is this graph? This graph is all the variables and the memory locations. A, B, X, Y, so on. Let us say array something like that. And there is a directed edge from one location to the other if A can point to that location. So here essentially what does this show? So this captures the points to relation that A can point to X and Y, B can point to Y, and X can point to the array. So this relation is captured by this points to graph. Okay, so now there is a very interesting flow insensitive analysis called the steam. I keep on forgetting where is the beacon. So, so Stinger's analysis essentially these are flow insensitive analysis. So what it means is it does not look at the order in which I traverse the statements. The statements appear in the program. It is something known as a equality based analysis and I will tell you why it is called so. And this is probably the fastest point analysis available, but it is not very precise. So it is really meant for really large pieces of code where you cannot afford to run a like a very expensive analysis. But point analysis as you can understand is a precursor to almost every analysis because if they are pointers everything can go haywire. We do not know what they point to. So at least you need some point analysis to go any for any analysis to run. So even for large code bases where you cannot afford to run a very expensive point analysis you can still run steam guys analysis because it is extremely fast. Okay, so let us think about how does steam guys analysis work. So let us say I have A equals ampersand x, B equals ampersand y, B equals ampersand z, A equals b. Let us say I have this piece of code. So the way steam guys analysis work it is very similar to the updates that we have seen so far. But because it is a flow insensitive analysis it cannot do strong updates because it does not know which order the statements appear. So it can only do weak updates. That is one problem. The second problem with flow insensitive analysis is that think about that you have taken the statements in this order. And after some time there is a statement which assumes the previous statement like okay let us see how this works here. So how should I put it? So let us put some updates to these guys also. P equals maybe ampersand a right and and star P equals ampersand z. No ampersand z cannot happen. So type wise what can happen here? Star P can be ampersand B let us say. No sorry only B. So now essentially the problem is that when I let us say because I am doing a flow insensitive analysis the order in which I am seeing these statements just does not matter. So it can happen that I end up seeing this particular statement first. I start seeing star P equals B first. So at this point I do not even know what does P point to. Later down the line I discover P points to A. So now I have to figure out I have to go to the previous statement again and I will have to update all the locations where P was pointing to by this new information that I have got. What if later I also realize that P can point to C also? So then again I will have to go to this state revisit this statement again and put this particular information in C also. So you do not want a statement to be executed multiple times. So you want to do an update in a manner that I traverse my statements once but the points to relation I get eventually actually works for no matter which order I would have seen the statements. So this analysis is able to do that. So the way this works is let us consider for now this particular set of instructions, set of statements. So it looks at A and it says that A points to X. Then it finds B and it says B can point to Y. Then later it finds out that B points to B equals ampersand Z. So what should it do? It should do a union of these things. Essentially what it will do is it will say that X and Z, so B can point to either X or Z. So it will put them in the same class. It will say it points to a bunch of things and X and Y are both possible. Then it encounters a statement which is A equals B. So what should it do? A points to, so now you see there is a problem. If I say A points to X, Y, Z then I would lose the information that then the order in which these two happen matters. What if A equals B came first and A equals ampersand X came later? Then it would have been A points to X. So I want to do an update where both of them, so it does not matter which order the statements ran. So how should it change? What should I do now? How should I, so this is my points to graph at this point. So how should I change it? I will put A and B in the single class. No, no, no. There we did not, I just, so this statement is if I could have done a strong update, I would have liked to throw away the set of A and just put the set of B. Here I cannot do a strong update. Right, but if you think about it, it is the other way around. The question is that, so okay, so let us say B which can, so okay now, so one thing is that once I say A equals B because I do not consider such order in which the statements happen, what can happen? Which of these two sets is going to be larger? PTS of A or PTS of B? So now A can point to everything that B points to because of this, but A can still point to more things, right? Like for instance, A can point to X, but there is no way B can start pointing to X. Set of states, what does it even mean? Because I need a points to set for A B variable. No, so at the end of the day, I want a points to graph like this, which tells me, so what should I do? How should I change my graph? So I have A points to X, B points to Y and Z. That is the state current state now. And who will point to that? So A points to X, Y and Z and B points to? Okay, so now here is a choice. So now the problem is that later, so if there was something which was pointing to A, so I will have to go and update that also, right? Because let us say, this guy says star of something. So anyway, so here you have to make a decision. So there are two decisions, two possibilities. So Steingart's analysis is something called equality based analysis, which does not distinguish the direction. It does not distinguish between exactly the same as the set I think. So I said that points to A is points to B is a subset of points to A. This is going to be the case, right? So A can point to, it is surely pointing to things which can be in B, but A can point to more things, right? What Steingart's analysis does is, it actually assumes an equality. It completely forgets about that. And then for this particular thing, it will essentially unify these guys and it say that, okay, because this guy can point to anything, because A can point to anything and these two guys are the same. So both A and B can point to any of X, Y and Z. So there is another analysis known as Anderson's analysis. Which essentially maintains this relation that points to of B is a subset of points to of A. This is referred to as an inclusion based analysis, right? So what is the advantage of Steingart's over keeping an inclusion based thing? Why should it help me to just merge these two states? Yes, yes, exactly. So in inclusion based thing, you have to maintain a graph of these inclusions, right? Which is, who is containing what? And if there is a new element added, you have to revisit it and make sure that is covered again. So essentially it does a transitive closure on the inclusion graph eventually. And that is why this algorithm goes to cubic time. This is an O-N-cube algorithm. The Steingart's analysis, as you said, I do not really have to bother about. So once I do this union, I know that I have covered all ways A and B could have interacted. So this analysis turns out to be almost linear time. So it is a very fast analysis, right? So I will not get into details of it, but I think this much should be enough to get you going with points to analysis. If you want to implement points to analysis in LLVM, how will you go about doing this? How will you go about building it in LLVM? So iterate over all basic blocks. How will you maintain the points to relations? What is union? You are going to disjoint set union, right? Okay. So that is a very good, actually that is the data structure which is used in Steingart's. So that is why it is able to make it almost linear time. So essentially now, essentially what you do is you maintain these sets and whenever this merging happens, you use this union-fine data structure to do a quick merge of these different sets and keep on assigning it to the respective, to both of them, right? So any questions on this? We did a very quick thing. Some people have to leave at 5, so I wanted to cover it. Okay. So we can close off this thing.