 So, you have already seen some part of the compiler. So, you have looked at an interesting data structure known as the abstract syntax tree and I hope you have done some exercises using that and looked at like traverse state and see what it is look like and so on. So, the AST is useful for a lot of optimizations, but then there are many other optimizations for which it is useful to have a different intermediate representation and we will be looking at a different intermediate representation of an LBM and the what we are doing with that is that we will look at something called program analysis. So, let me just ask you because you all know what is a program and you all understand what is analysis. So, let me ask you what do you think is program analysis. So, what is what do you think we will be doing? And interestingly we have all been doing program analysis it nothing something nothing very new to any of us. The day you started doing programming you started doing program analysis which means that we are trying to understand interesting properties about the program. Excellent. So, you brought out a new term called debugging right. So, that is one thing that you would like to do using program analysis you might want to debug a program may want to understand what the program is doing and what is the cause for the bug I am seeing at this point in time. Why else would I like to do this analysis? Why would I like to understand my program? Other than making the program correct which is important, but other than that. So, let us run this program compile this program with our favorite compiler GCC and if I run it get answer 34. Maybe the compiler is buggy who knows right I mean compiler is a piece of software it can have bugs. So, let us try to compile it with another favorite another of our favorite software is Clang. You have seen this compiler right. So, let us compile it with this let us see what happens. Some warnings I do not care never care about warnings. It goes into infinite loop what is going on? It is the same program should have been 44 one compiler says 34 the other compiler goes to infinite loop what is going on with this program? So, how do you go about understanding what is wrong? Like if you had to debug this program you have to analyze this program how would you do it? I mean at a very high level do not get into details at a very high level what are the different ways of debugging this program? I can run GDB or even simply I can just put up printf in the program put a lot of printf just see what is going on at every point what is I what you see at different places and then maybe try to make sense of it. So, then what will I do? I will put a lot of printf's or on GDB and then run the program on some inputs and then see how do these executions look like. So, this way of analyzing a program is referred to as a dynamic analysis where the idea is exactly the same we put in extra code in your case printf's and then execute the program on certain inputs and then we try to understand what is going on with the program. What is some other way of analyzing this program? Yes excellent excellent. Dry running the program or just simply staring at this program and then trying to say that what is like somebody said that the program has error I mean somebody just stared at this program did not even run the program and they said looks like something is wrong. So, this way of analyzing a program which can simulate an execution like you said dry run a program or just try to just look at the program text and try to get some meaning out of the program without really executing the program. Those sort of ways of analyzing a program is referred to as static analysis. Static because we are not really running anything dynamic because we are running the program and then trying to figure out what is going on. So, the plan is so I do not have a very set agenda but we will go with the flow. I will see how the class is able to cope up and accordingly I will probably switch things. But the plan is that today I will start with static analysis. We will try to understand how different static analysis work. Then rather it will be an introduction to static analysis without much of formal foundation. I will sort of at a very high level throw things at you and say what would you do looks like a good idea or not that is not a good idea. We will try to form a common sense try to understand how can we write a static analyzer. In the next session onwards I will try I will give you a hands on with the LLVM compiler. We will look at another representation of the LLVM compiler known as LLVM IR which is a lower level intermediate representation and we will try to implement our analysis on LLVM compiler. Tomorrow we will look at the foundations of static analysis foundation of something referred to as data flow analysis and see why does mathematically it works. Why does it work mathematically? So, it gives you some very interesting guarantees that if you have analysis which looks like this it is surely going to give you something like this. So, we will see why how does it even end up giving you those guarantees and tomorrow we will try to finish off the analysis. So, the analysis target will be this program. Eventually we would like to write a static analyzer which is able to tell me something why this program might be broken and maybe catch such programs some other programs like this. The last day we will try to look at again depends on what is the pace of the class. The last day we will try to look at dynamic analysis. For the same program we will write a dynamic analysis and we will try to understand if the dynamic analysis can trigger the bug and show you that where the problem is. Looks good. So, the class is going to be very interactive. I will throw a lot of questions at you. You have to throw a lot of questions at me otherwise it will be one sided you will get bombarded with questions only. So, the attack is the best defense. So, you should start asking questions otherwise then it is a one sided game. So, the other thing is that if you do not keep it interactively interactive we will both bore each other out. So, it should not happen. Wherever you do not understand something or wherever you want something to be repeated please let me know and we will do it then and there. We will not wait for some later doubt clearing session or anything like that. Then and there we will try to clarify it. It is not important how much we cover it is important that whatever we cover you understand it and are able to do it. So, this is a very hands on course. Unless you are able to implement whatever we are talking about it does not help. You will not even be able to carry this information for another week after this. You will forget completely everything. So, it is very important that we finish our assignments and we have to work little slog hard on this because I will try to cover a lot of things. Yeah. Why do we need different presentations? Okay that is a very good question. Maybe I will answer that question after the break. I will show you something rather than tell you something. So, you will learn about optimization. So, Krishna will come after me. So, Krishna and Professor Govind Rajan they will talk about optimizations and then you will realize more that why these optimizations are required and so on. But I will give you I will show you a small program maybe I will make it during the break and I will show you how much effect an optimization can have on the programs performance. So, you will really be interested to know how can we really make the program efficient. Excellent question. So, in this at least in this session the analysis we are doing are can be used for optimization or can be used for human consumption. Like for instance in this case casting a bug or understanding a program. But you will see that Krishna will probably talk about that the information that we get from static analysis how can he exploit those information for additional optimizations. So, now let us come to static analysis. So, static analysis let me try to pull out my slides. Looks like Murphy's law has stuck again. But anyway so, I am not going to pull out that set of slides. I think they should do. So, any program there are two set of things that are relevant. One is right. So, one is that how have you written your control flow statements. Control flow statements are statements like if then else, for loops and so on. So, essentially they dictate how does the program counter move through the program. The other part of the program is about how do you manipulate your variables. Like what do you compute into a variable, where does that value flow into right. So, exactly to analyze these two components of a program we have a different set of analysis. We have something called control flow analysis which essentially says that in a given program how does the program counter move or how does the flow of the control move through the program. The other types of analysis are referred to as data flow analysis which says how do values move through the program. Can you analyze and tell us how values move through the program. So, we will start with control flow analysis and so essentially it is a set of algorithms which analyze the program statically. Of course, you can even have dynamic variants of these algorithms to determine the control flow behavior of a program. So, the reference is here and you can read more. So, let us try to understand what the difference between control flow analysis and data flow analysis. So, let us say first example I pick is something called alias analysis. So, alias analysis what it tries to answer is that let us say you have a lot of pointer variables in a program. I would like to understand that which pointer variable is accessing or pointing to which variable which other location memory location right. Do you understand what the analysis is. So, I will look at all my pointers in my program and I will say that for each pointer I would like to figure out which is the memory location that it is pointing to. What sort of analysis do you think it is? Is it control flow analysis or is it a data flow analysis? Excellent. Why is that? Because for the pointers the addresses is nothing but data right and essentially what we need to track is how do they move through the program right. So, okay let us say I have this particular problem which says that what are the nodes that must visit a node n along all paths from n to x. Let me just define what a node is assume that every statement in your program is a node right. So, now I can come up with something called I can come up with a graph for a program I will actually properly define that but or let us say do not even bother about it. Let us say I want to figure out that which is the instruction in my program which will surely be executed no matter which execution I run no matter what inputs are on my program with which are the instruction which will surely surely get executed. What is the type of analysis? Is it a control flow analysis or is it a data flow analysis? Control flow. Control flow because I am just trying to figure out does the control read that statement or not that is all I care about. I really don't care about that how can it reach to the program or I don't care about the values of the variables. Of course, there are certain scenarios where you have like okay we will talk about them later. So, mostly it is control flow analysis. Liveness analysis. So, liveness analysis says that are there variables in my program which are not going to be used ever again or are there variables in my program which contain values which are never going to be consumed by any other statement later. Why is that interesting? Why should I even care about something like this? Not so much but you can for instance you can remove those statements. If they are computing something which is not even going to be used then what is the point of computing that. So, if I say x equals foo and foo is a very heavy function and after that function finishes and the value gets into x I do not even use x ever again. So, why did I even compute x? So, this liveness analysis is able to drive an optimization referred to as dead code elimination. So, any statement which does not create an effect on the rest of the program does not have an impact on the rest of the program is referred to as dead code. You run that statement or you do not run that statement the behavior of the program is the same or that is the expected output of the program is the same. So, then we do not really need to run those statements. So, that is one of the optimizations. So, if your program has lot of dead code you can eliminate them and your program can run faster because it is not running those statements. So, that is one of the optimizations. In fact, it is one of the very important optimizations. That is again as we can understand what does this analysis do? Is it a data flow analysis or is it a control flow analysis? Data flow. Data flow because I am talking about values in those variables. So, do these values get used again or not? So, now I think you have got an idea of what is control flow analysis and what is data flow analysis. So, do not get mixed up now. So, for control flow analysis the most important data structure we will be using is referred to as a CFG or a control flow graph. So, if it is a graph then I have to tell you couple of things. I have to tell you that what is the start node of this graph? Where does the graph start from? I have to tell you what are the nodes in this graph and I have to tell you what are the edges in this graph. If I have to tell you these three things I have described this graph. So, the entry to this graph is the program entry point. Let me just tell you what are the nodes in this graph. The nodes in this graph are to begin with you can think of nodes in this graph as every instruction in the program being a node in this graph. Every instruction in this program is a node in this graph and edge in this there is an edge between two nodes n1 and n2. If after running statement at n1 I can immediately there is some execution on which I can immediately run the statement in n2. Does it make sense? Immediately after. So, if I have two statements somehow I do not know if I can use the board. So, if you have two statements let me see if I can use this. So, for instance let us say this is a node because it is some statement in the program and this is a node because that is a statement in this program. So, what is the edge between what can you detect one edge in this program? Tell me some edge in this program. Let me just switch my line numbers on. So, just 10 to 12 is 10 to 12 and edge in this graph. Line 10 to line 12 is line 7 to line 12 and edge in this graph is line 7 to 10 and edge in this graph. Yes or no? I could hear some. Why is it that edge? They are not even one after the other. Yes, whenever the statement the while condition 7 becomes false the control can immediately run 10. So, this statement at 7 how many edges does it have starting from it? What are the two edges? 7 to 8 and 7 to 10. Can you detect an edge which goes the other direction? 8 to 7. So, these edges which go in the other direction I will define what is other properly but does not look to be towards direction of the flow of the program. Those edges are referred to as a back edge. So, I can have forward edges or I can have back edges. So, I can see a back edge from 8 to 7. So, now you understand what is a control flow graph. So, this graph is a control flow graph and can you now tell me what is the entry to this graph? The first statement in this particular function. So, the first statement would be assignment of 0 to i. Notice that these declarations are not statements. To some extent they are but we will talk about them when we do the LLBM IR. But at this moment they are not doing any action as such. They are simply just saying allocate some memory. But they also turn out to be statements in your LLBM IR. You will see that. But as I can see an active statement here which is assignment of 0 to i. So, that would be the first node in this graph. The next thing is that this graph can become really big. So, there are nodes which are equal to the number of statements in this graph. Can you think of some idea to reduce this graph and still keep all the information intact? Excellent. So, let me just not even care about statements where the control, we know that the control must follow in that sequence. So, this set of statements where if you enter the first statement in that sequence, you are surely going to reach the last statement in the sequence. There is no way out. Such sequences of statements are referred to as a basic block. It's a block of statements and you cannot divide it further. So, it's like basic block. So, can you identify a basic block in this program? 4 to 7. Should I take 7 or should I not take 7? Okay. So, what does this while statement entail? There are two things it does. Okay. Let me just come to it a little later. Let me just ensure that everybody understands what we are talking about. Okay. Some simpler example. 10 and 12. Because if you enter 10, we will surely reach 12. There is no way out. We cannot do anything. Even including everything like you guys said like from 4 to 7 surely, including 7 or not is a thing of a discussion still. But at least we know from 4 to 7 all these statements should be in a basic block because if I start executing 4, it cannot happen that I can miss any statement in between. What about 7? So, 7, the while loop does two things. If you think about it, can you tell me what are these two things? It evaluates this condition, this i is greater than 0 and transfers control. So, evaluating this should be part of the basic block because it's a... So, no matter what you do, you have to evaluate that statement. And transferring control, which is a go to statement is also part of this because... So, after the control is transferred, it goes somewhere else. But the jump statement should be part of that basic block because you are going to hit that jump no matter what. So, this is a conditional jump. It's like if something, then go to. So, this statement should be again part of the basic block. What about the statement after it? Can I include this particular statement in the basic block? Statement 8 in the basic block? Why not? Yeah, so it is not guaranteed that I hit 7, I surely will hit 8. I can't guarantee that. Neither can I guarantee something about 10. Because after I hit 7, maybe I execute 8. I don't know. So, those cannot also be part of the same basic block which contains 7. Okay, so now the while statement is a little tricky business. Let's revisit the while statement. So, when I look at the forward execution, it looks like while statement. But think about the case when I execute 8 and then jump back to 7. So, if it is part of the... Now, what does my control flow graph look like? It looks like a set of nodes where each node is no more a statement. It is now a basic block. And I know everything in the basic block are going to execute in sequence. So, I don't have to care about the control flow within them. It is obvious. And my edges are edges from a basic block to another basic block if the first basic block can transfer control to the second basic block. Now, think about 7. Now, this is a little sticky situation. Because now if I make it the part of the previous basic block, then after executing 8, how do I transfer control to it? So, I cannot transfer control to the middle of a basic block. I can only transfer control to the beginning of a basic block. It doesn't make sense to transfer control middle of a basic block. Then what is the graph? I mean, it is very confusing, right? So, the only option is to pull it out and make it part of the next basic block, right? Now, okay, next basic block, that is fine. But can I now put 7 and 8 in the same basic block? That is also problematic. So, 7 has to be a separate basic block, 8 has to be a separate basic block, and 10 has to be a separate basic block. 10 can transfer control to 7. Not 10, sorry, 8. 8 can transfer control to 7. 7 can transfer control to either 8 or 10. Excellent. I mean, I am not even teaching anything. You guys are discovering everything. Okay, so now we have understood what is a control flow graph. Right, so essentially, so now let's just summarize whatever we have discussed. So, the very data structure we will use and we will use it a lot is something called a control flow graph or a CFG. Now onwards, the nodes in a CFG are known to have basic blocks. They have every basic block has a single entry and a single exit, meaning that the control can only enter from at the beginning of the basic block. It can exit only from the end of the basic block. Any, if there is any possibility of control transfer between two basic blocks, we will have an edge between these two basic blocks, right? And there are, we will always distinguish between two very important basic blocks. One is referred to as the entry block and other is referred to as the exit block. I can always make sure that I have a single entry. Of course, I have to have a single entry. There is no function which enters in two different places, right? So, for every function in my program, I will have a control flow graph, right? So, we will probably not be able to touch analyzing programs which span multiple functions. So, we will only look at programs which have only one function or every function in the program I can analyze in isolation, right? I will not be able to say the effect of one function on another. That is something referred to as an interprocedural analysis, right? So, because you want to figure out what interaction between procedures, we will constrain ourselves to what is referred to as intra-procedural analysis, right? So, these are the analysis only within a function, right? So, every function will have a control flow graph and the control flow graph will look like this. There is going to be a strict entry block and I can always transform my control flow graph so that it has an exit block. So, what will an exit block have in a function? Instruction will surely have written instruction, right? It's surely going to have a written instruction, but then the program may not or a function may not have a single return. I can say if something return, if something return, switch case return, right? I can have multiple returns in my program. So, every return is going to create an exit node. How can I ensure that my graph has a single exit node? Exactly that is the solution. I will ensure only that guy has a return. For every statement which has a return, you put a store that return value and transfer control to that block, right? So, I can ensure I can do a small simple transformation to the program and understand see from the first day onwards, we have started looking at changing the program to make our analysis easier, right? And that will be the trend all through. If you can do any simplification which makes our analysis easier, we'll do it, right? So, this is a very simple transformation, but you will see that when you're writing code, it will make your implementation much simpler, right? So, we will have a single. So, we will assume from now onwards, we'll assume that we have a single entry block and we have a single exit block. You can always transform programs with multiple returns to a procedure with single return. Okay. So, this is example of a control program. Big deal. It's a graph. There are, I can see two loops. There is a loop from, loop containing two, three, four, five. There is a loop containing, there is a, so this is a nested loop. So, there is another loop which is two, three, four, five, and six, right? And so, can you identify that statement at four? What could be creating such a weird jump? Actually, break will also not do because break will have just exit loop, go to. So, you need a forward go to, but had it been a single loop, then it could have been a break. So, looking at a control flow graph, you should be able to identify these control flow statements, right? So, can you think of what statement does two have? Note two have? And if condition, right? So, on a true, it goes to three and false goes to four or something like that. We don't distinguish between the true side and the false side in a control flow graph unless really required. So, in general control flow graph, we'll not annotate it. What if that node four wasn't there and the control from two would have just gone to five? What would the statement at two look like? What would the statement at two look like? If then it will transfer control to three, otherwise it would have anyway gone to. So, okay, excellent. So, you guys understand it and anything else? And can you tell me the nature of these loops? The loop at two and like two to five and two to six, they are variants of loop. They are for loop or while loop or do while loop, repeat until what sort of loops they are. So, what would they do while, right? Why is that? Because the check happens at the end. Had it been a while loop, how would it look like? Right, right, excellent. So, the next step is that now the program, the first control for analysis we'll do is to construct this nice data structure. This is a very interesting data structure. See, looking at the data structure, I can say so much about the program. Like you could, you can say that there is a go to statement sitting here. You can say, oh, there are two loops sitting here. Oh, these loops look like a two while loop. Right? You can say so much, but just by looking at this particular graph. Interestingly, I have not even told you what statements are there in these basic blocks. Right? They are completely abstracted away. So, abstraction is the key to program analysis because programs are very complicated. Unless you throw a lot of details, they are very difficult to analyze. Right? So, you only have to throw a lot of details and only look at things that really matter to you. Right? So, here I have thrown away all statements. Right? But still the structure of this graph tells me a lot about what this program is doing. Okay. So, the first control for analysis we'll do is we'll try to construct this control for graph. Control for analysis we'll do is to construct control for graph. Okay. Okay. So, have you guys seen some other intermediate representation other than your AST? Even in your schools? Have you seen three address code? How many of you don't know or how many of you know three address code? That's the easier answer. Mostly everybody. So, why does it become a tree? Yeah, but then it could have become a DAG. Even the cycle eliminated, this is a DAG. Okay. So, somehow it becomes a tree. So, maybe you can discern more. Okay. So, so, no direction we have not extracted out. We created, we can create a directed graph. You have a, the question was that you retain the same nodes as in the CFG and between n1 to n2 you create an edge, you can create a directed edge if n1 is the dominator of n2. So, why cannot, why can the idomb relation not be cardinality more than 1? Why can it not have two closest predecessors? Because, so, we said it is a poset. So, there may be no relation between certain nodes. No, but if it is a poset, then it means there are nodes which, for which there is no relation at all. So, there is nothing which is, for them I cannot say which is closer. Very good, very good, very, very good. Okay. So, so, this tree is referred to as the dominated tree, right? Data structure number 2. Again, a very interesting data structure. So, you can organize all your dominators into this beautiful data structure called the dominator tree and looking at the dominator tree, you can figure out the set of dominators for every node. How? How? Yeah, just look at its ancestors. Like from that node, just keep on looking at the ancestor, you will get the, all the nodes that are there, all of them will be its dominators, right? So, that is the next thing. I do not have a diagram of that, but you guys created some, I hope. Okay. So, this is the algorithm to compute dominators. So, you need to initialize all nodes to the set of the universal node, that set of all nodes. And then you say that domain is nothing but put in that node and union it with the intersection of the predecessors of the node. So, you could have also done with a different initialization. You could have also initialized it to empty. Why did we decide to initialize it to N? So, try to reason on this. Hey, easier kya hota hai? It will not give you the same result. No, no, do you say that, that if I can it as the empty set, initialize it to the empty set, I would have not got the, I would have got the same solution, but it is, would have been less efficient or you would have not got the same solution. So, efficiency first is correctness. Am I getting the, I mean what is correct is different, but here. But you will have to do it here in this case also, because I have not given any ordering on the how the nodes have to be computed. So, here I am assuming it to be a graph. I have not even removed my cycles and I am not even assuming any ordering on the nodes. So, I am just saying just pick a node and apply this and update the dominator set for it. Pick a node, apply this, apply the update dominator set. Keep on doing it till there is one iteration when none of the nodes dominator changes. So, that is the exercise. Do it, you will get a lot of intuition as to what is going on. Just work it out. Just try to put it as empty set. Do it for a small graph. Maybe you can do it with lunch break or drink the, this thing later. Initialize it to a, we will know the theoretical reasons behind it tomorrow. We will actually look at fixed one theory and we will say that why is it interesting, why we have to do it this way. But for now, just try to get an intuition as to why is it, why do we have to initialize it to n. So, the next topic is I will come to, so we will discuss about something called a reducible flow graph. So, any graph you should be able to partition the edges into two categories. One is something called forward edges where the, where with those edges the graph creates a dag. If you just keep the forward edges, the graph would have created a dag. The other are back edges which prevent it from becoming a dag. So, these are edges on top of the dag. So, these are, so one algorithm to identify back edges is where the head dominates the tail. Can you see that? So, see the dominators start becoming useful already. So, if you have a graph here for all the forward edges, you would see that the tail dominates the head. But for back edges, it will be the other way around. So, let me just see what I wanted to say here is, okay sorry. So, these are, so any graph, so I should have said the other way. So, any graph where you can divide your set of edges into these two categories is referred to as a reducible flow graph. There are other flow graphs which have the something called cross edges which, so these are called tree edges. But like for instance, this particular graph, let us not get too much into it. Like for instance, this particular graph, look at this graph on the left. So, here for node 5, this. The other thing is that this particular result that identifying back edges by identifying nodes where the head dominates tails, it only works for these class of graphs which are called reducible flow graphs. So, for this reducible flow graphs, so this is a graph, the graph on the left side is a graph which is not a reducible flow graph. Okay, so very intuitively the way to think about this is that in a reducible flow graph, it is easy to identify the loops. It is easy to say that which set of nodes forms a loop. So, if you think about the graph in the left, can you say that which are the nodes, which are the loops and what are the nodes in the loop? So, like 2, 3 and 2, 4, they seem to be loops, but just think of a program. So, these two loops are neither disjoint loops, you cannot say that they are two separate loops, nor they are nested loops, nor are they contained within each other. Or you can actually say both of them are contained within each other. You can think of 2, 3 as the main loop and this thing as something between that, but then it can switch between these loops. It is very weird. So, for the arrow, the arrow head, we say arrow head. So, wherever it is pointing is the head. So, whenever we say we draw an arrow, we say the arrow head points here. So, the wherever it is pointing is the head and wherever it is starting from is the tail. So, for graphs where you cannot partition the set of nodes into categories such that the loops are either disjoint or nested, if you cannot partition your nodes into those categories or loops into those categories, then we say the loop, the graph is a irreducible graph. Otherwise, it is a reducible graph. So, if it is a nested loop, then all the nodes in the nested loop will be contained into the outer loop. If it is a disjoint loop, they will not intersect at all. Disjoint loops is one for loop followed by another for loop. There is nothing which is intersecting with. In this case, this is neither. So, if you figure out 2, 3 is one loop, 2, 4 is one loop. In that case, there is an intersection. So, they cannot be disjoint loops and they are not nested because if they had been nested, then one loop should have completely contained the other. The set of nodes in one loop should have been contained completely in the other set. So, it is neither a full loop. So, the good news is, so in analysis, it is generally much easier to analyze reducible flow graphs. Irreducible flow graphs create certain problems. But the good news is that all graphs that you can construct using structured program statements, like while statements, if statements, do while statements, you can only produce reducible flow graphs. You can never never produce irreducible flow graphs. That is why there does not exist anyway. You can produce this left graph using just structured statements. How can you produce this left graph? You can still do it. Gotoes. Yeah. Yeah. So, if you use gotoes statements, only then can you produce such statements. And that is why people could talk. So, gotoes statements can create such weird graphs, but your structured statements will never do it. And many a times, the good news is that you can actually rewrite a reducible flow graph, irreducible flow graph into a reducible flow graph. So, generally it is by duplication of nodes. So, duplication of, but anyway, let us not get too much into it. So, the good news is that if your graphs are reducible, then I have a very simple algorithm for identifying the back edges, the back edges. So, this result holds that the back edges are the edges where the head dominates the tail. This only holds if you have a reducible flow graph. So, this is good. So, we are done. The last thing is about natural loops. So, the next, the last thing is we would like to find out that which statements in the program form a loop. So, those are referred to as a natural loop. For example, in this particular graph, what are the loops? We have two loops. One loop is from 5 to 2, the other loop is from 6 to 2. Each loop is identified by a back edge. So, so now our task is to find out the natural loops. How can we do it? Any ideas? How can we get the, so I will be, so what is algorithm take? The algorithm takes a back edge and it gives out the set of nodes which belong to that particular loop corresponding to that particular back edge. So, any idea how can we do about doing that? No, the back edges I can identify. Given a graph, I can exactly use this to identify my back edges. Where is it? So, I can use this to identify my back edges. Now you are, now I have, so see how the analysis is progressing. First from the linear set of statements, I have constructed my control flow graph, my CFG. In my CFG, I apply and let us say I only writing programs which does not allow good use. So, you are sure that this is going to be a reducible graph. If it is a reducible graph, then I can apply this particular algorithm to identify my back edges. So, on the control flow graph, I have already identified my back edges. Once I have identified my back edges, now I can pick up one back edge at a time and I can start asking that what is the loop under this back edge, for this back edge. So, this is the algorithm now we want to come up with. We want to figure out that given the back edge, what is the loop that this back edge consists of? How would you do that? Travels how? They fall in the loop, but that is not, I do not want to detect loops. I want to find out that what are the nodes in that loop? Like for instance, maybe I did not say it properly. So, in this case, what are the nodes in the back edge from 5 to 2? What are the nodes this loop consists of? 2, 3, 4 and 5. That is the set of nodes. And 6 to 2 has 2, 3, 4, 5 and 6. It completely contains the inner loop plus it has this extra node 6. No, no, the dominator does not come into the picture because look at 5. 3 and 4 do not dominate 5, but they are part of the loop very much. The dominator of 5 is 2. Yes. That is also not necessary. Like look at 6. Forget that edge from 4 to 7, but had that not been there, then 5 would have been the dominator of 6. 6 to 2 there is a loop. That has dominator as 2. So, the dominator of dominator. But, but even 8 has dominator as 2. Node 8 also has dominator 2. Form nodes which have dominator 2, but not dominator 7, not 6. Dominator 2, but how do you get 7 and 6? That is my other question. No, for 6, nodes 3, 4 and 5 have dominator 2, but not 6. Sorry, yeah what is it? For 4 node, we have dominator, we have 2 in dominator side and not 6 and in dominator side. So, for 3, 4 and 5, we have dominated 2, but not 6. So, there will be no loop. For 3, 4, 5 have dominator dominated 2. Yeah, but not 6. You are talking about this particular loop. No, but if 6 had 2 branches, let us say from 6, I could have split into 2 branches, then even 7 would not have dominator as 2, but it would have have 2 as a dominator. So, let us say from 6, I have a branch, I have 2 branches, 1 branch goes to 2, the other branch goes to 8, then 7 is not dominated by 6, but 7 is dominated by 2, 4, 5 and 6, 2 and 5. So, you have to somehow distinguish the nodes which are outside the loop from the nodes which are inside the loop. How do you do that? There is a path from 2 to 5. There is a path from 2 to 5, yes. Agreed, but how do you figure out in this automatically how do you figure that out? Because I can also find a path somehow differently. I can also find a path from 7 to 3. Right, I can say 2, 4, 7, no, not 3, but okay, in this case it does not happen. Yeah, sure. You are almost there, very much almost there. So, let us, we got interested in time, let us go there. So, essentially this is the idea. So, for a back edge end to D, the natural loop consists of nodes that can reach N without visiting. So, I mean, you want to just similar on those lines. So, now the algorithm looks very similar, looks like this. Essentially what you start is you have this set which is the loop set which will contain all the nodes which will be the loop for that particular back edge. And then you start, you have a stack which will be used to explore it basically. Some sort of a DFS traversal if you will like. So, now for each element C popped from the stack, for all predecessors in C, if P is not already in the loop, then you have to explore it further. So, you have to just think of some are doing a DFS traversal only the loop. Right. So, as soon as you try coming out of the loop, you will not explore further at all. So, you are using the stack to do that. So, you add P into the loop and push P into the stack. And then again, so you push P into the stack means what? You are trying to explore the children of P. Right. We are going to forward and basically you want to expand the DFS traversal into P. So, we are going the other way around. Sorry, sorry, sorry. Yeah, you are doing a backward backward DFS basically backward DFS into it. So, you are, so for all predecessors in C, so you push the parent till you reach the entry node. So, what we will do is we will try to implement this algorithm into LLVM in LLVM. Right. So, what I will suggest you to do is you can quickly do a a mock simulation of this on some graph. Try to see you understand this and then we will try to implement it and see if it really works on on this algorithm really works on real programs. Right. The idea is very simple. You just think about you start with the bottom of the loop like where the loop ends and start going up. So, essentially start exploring it to the other direction till you reach the head. Keep on collecting all of them in your loop. So, the stack is only used to do this backward DFS and the loop is contains all the statements. So, if you look at the loop it is just doing a DFS. There is nothing very simple. Why are we doing a backward DFS and not a forward DFS? How do you know you have got outside the loop? That is the main problem. That condition is hard to write. That this the head of this node is not in the loop, but you do not know the loop. Right. That is the main problem. Because you have a node and you start expanding during a DFS from that node. Right. So, now the problem is that once you have the successor expanding on the successor, if it goes out of the loop, what condition will you use to stop it? How will you know? No, head until you have. You have the back edge. So, you have both the. But how do you know that node will not reach the tail? The node you are going to that will not eventually reach the tail. How do you know? Right. In the backward DFS, you will not even get that problem because you will only go through the it can only traverse because you started with 6, can only traverse things in the loop. And once you reach the head, you stop. That is it. So, it looks little tricky. But if you like understand it, it is just backward DFS and collecting all the nodes till you hit the head of them for a back edge into D. So, that is it. So, I define the natural loop as the set of all nodes that can reach N without visiting D. So, without visiting the tail of the loop. So, one thing is that it is surely dominated by the head of the loop. Right. Because it is a structured graph like a false statement or while statement. They have to start from the head of the loop. Right. The beginning of the loop. Sorry. Right. And so, right. So, essentially what it says is that we chart the graph. Let us try to again come back to the example. So, essentially node 3 is a so, let us consider the back edge which is 5 to 2. Right. So, what about node 3? So, essentially we want to visit all nodes that I can visit without reaching the tail. Because once you reach the tail, reach the bottom of the loop which is 5, you are done. Right. So, what are the entry point until you reach the tail, the dominating.