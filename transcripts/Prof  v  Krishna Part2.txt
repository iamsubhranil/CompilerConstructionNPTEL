 Is this, can I, if I am going to the next P2, can I go to the next code or you guys, you have copied the basic piece of code right? Okay, so you can clearly see the difference right? So, anyone who is not able to see that, anyone who is not able to run the first version of P1 yet and need help, the reason why I said if you say no I do not want to do then that is hard but. 100 to 500 elements. 100 to 500 elements. Having trouble with it? Fine, then allocate two dimensional, I mean on heap if you can. Put it global. Put it global, sure, that is simpler. For the time being, I mean in general you should follow all the program practices, our goal currently is to test this thing right? So, are you VINIT student or? Oh, okay, cool. Say my hello to him. We go back a long way. He is a very good person. I came there to one and a half, one year back, no, one and a half years back also. You joined this year? No. Okay, I came there one and a half, I have come there couple of times but we know each other now. He was doing PhD in IAS when I was doing my Masters. In general I think VINIT is a very good person, once you meet you do not forget anything. Are you fine? Do not worry about initialization, Rama. Do not worry about initialization. Okay, the P1 is done, what about P2? No problem, we will go there. How much did you increase it to? Make it 1000, maybe. All we want to see is, I mean all we want to see, make you guys kind of appreciate is that a simple technique like loop and rolling can lead to visible gains and those of you who have finished this step. Okay. Hi, yes. No, no, no. Okay, there are, if you look at the time command, what is the output of the time command? You see that it gives you a few things, user time, system time and elapsed time. So, which one should you look at? So, the elapsed time is probably the end to end time, user time is the time that you have spent by you. So, you probably do not care if there was an interrupt in the system doing something else and all that. So, look at only the user time. Okay. So, in your case, what is showing in user time? No, because it says command terminated by signal 11. So, I think 10,000 it will not let me take, reduce it. Do not mind, but I think it is a bad programming practice. Replace all this by n. Do you see something else? Command terminated by signal 11. So, if you are getting an error, so that shows something like command terminated by signal 11. That means the command is terminated for some, may be out of memory or something like that, of that sort. So, may be movie, do not, you are allocating all of it on the stack, it is running out of stack or the windows is not giving you more information, that is fine. But may be what you could do is move these declarations to global and see if it is correct. So, you can, if that error goes out. Sir, so for the k-test one, the word. The original one. Yeah, original one. So, it is giving 0.0. No, it still says command terminated by signal 11. Oh yeah. Can you open the code? Yeah, move these two up. By the way, Malay is also here. He is, so feel free to keep, if you have stuck anywhere, just ask. Sir, I am just using the term. So, what is the value of n? No, but you are getting this error. Do you see this command terminated by signal 11? So, that means the program is crashing. Because it is crashing, it is not taking any time. So, what you could do, just open the files, let us say, of 2.c. This is VI? What I will do, I will just move them up. I will make them global. This is not the best way to do it. But for the time being, I just moved them to global. And now do the same thing. Why opt 1 to P2? Copy opt 2 to P2. No, I am not able to do that. No, that is what we have. So, now this did not direct. Now let me do time. This is doing something. Try both of them. So, move. Sir, how is it, if you move the variables to make it global, then how is it? How is it making a difference? We will come to that. Remind me there. This is a question that should. Good. Yes, how about things? Sir, I kept like 1 lakh. Then it is saying, but also saying user time is 0. Because command terminated by signal 11. So, it is dying. 1 lakh is too big. Just make it 1000 or 10000. That is enough. When I said 10000 also. Signal 11. That means the program is crashing. So, please check if you are getting an error terminated by signal 11 or if you see the time is 0 for large inputs, be very suspicious. Do not think that it is not taking any time. It is not taking time because the program is dying or rather getting killed. Use a macro here. No, may I? No. Whatever. Now, you do not have to change it 1000 places. You are also getting the same signal 11. If you are getting signal 11, that mostly means that you are trying to allocate memory on the stack and you do not have enough so much stack. Lift those declarations to global. Who? Redshift. Yes, sir. I actually ran the third code with i++ instead of i++ equal to 4. It should have had a much worse run time. But I am actually getting a very significant improvement. It has gone from 4 seconds to close to 0.1 seconds. I am not able to understand why. Let us do with plus 4 first and show me the time. 0.3 seconds. Very good. Now, just show me the code. Scroll down. I am going from 0 to n. Good. I like this. Now, you tell me what is the problem? I accidentally reduced this. Yes, I know. Now, you tell me what is the issue? The issue is that this runs much faster. The issue is that this code is buggy. You tell me what is the bug? First you run it. I will tell you what is the bug. You may be able to see the bug yourself. You just run it once. But the code is buggy. Do you see this? There is a segmentation fault. But now you have to tell me why the segmentation fault has come. Without running, I told you that there is a bug in the code. You tell me what is the problem? I will come back to you. Perfect. So, this is array out of bounds. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. I am going to run it. Okay. Guys, I think for the positive of time, we will... Can I continue it? Yeah. Should we do one thing? How many of you have at least tried P1 and P2? Most of you? Okay. How many of you still do not see any difference between P1 and P2? One hand? Okay. Let us make sure that is taken care. P2 and P3 you can keep trying, but I will mostly ask you to do it in the next class. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Last two minutes. A question. Last two minutes on this problem. We will have more, something more dramatically interesting problem is coming up. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. It is not a constant, but it is computed. But its value does not change across loop iterations. We call it as loop invariant. We want to factor it out and move it out. Right? Because its value does not change. Great. So that way the loop invariant code works once instead of n number of times. Okay. Here is another piece of code. i equal to 1 to 100, j equal to 1 to 100, k equal to 1 to 100, a sub ijk equal to i times j times k. Pretty simple code. How many multiplications are there? 200. 200? 10,000. 10,000. 1 million. 2 million multiplications. How many index operations? So, array index operations. So, I am doing a sub i something, something, something, right? So, I am doing So, I am doing A sub i how many times? Million times, then sub j another million, then sub k, 3 million array index operations and then you have the standard loop jumps, loop increments and all that. I am not touching that. Is there a part of the code that you see which is loop invariant here? Which one? j into k, this j into k is loop invariant is it? i into j, so the i into j is clearly loop invariant for which loop? For the k loop, for the inner most loop i into j is invariant. All of us are in the same page. So, i into j is a loop invariant. Is there any other loop invariant part here? A of ij, anything else? A of i. So, A of ij is loop invariant for the k loop, A of i is the loop invariant for the j loop. Why do you say A of i is a computation? Why do you say it is a computation? Because you are doing A adding the offset may be multiplying by the size and all that. So, to do such loop invariant code motion, we need to see when is it safe. What is the opportunity? When is it safe? We know that it is not modified in that. Where is the opportunity if you have a loop where you have lot of memory operations? There is an opportunity. So, you want to look at the loop. Easy to find. Profitability, it is machine dependent. Most of the time it looks profitable. I mean it depends whether I mean how much you are when you move it out. In this case, for loop in general for loop transformations, it is machine dependent. For loop invariant code motion, can it be machine dependent? Mostly it is profitable, but there may be some odd case. I cannot figure out where because you moved it out, some cache behavior has changed. Because of it, there may be some impact. I do not know, but most of the time it is profitable and modulo some rare combination. Register pressure can move from one place to other. See when we do register allocation, when we do cache fetching and all that, we are not doing any optimal algorithms. They are all heuristics. Some rare occurrence may impact the register pressure in some way, may impact the cache behavior in some way. That is why we say I mean we do not say it will always be profitable. So, we are talking about loop invariant code motion. So, for loop invariant code motion, we want to find out how did you say in that case i times j is loop invariant. Correct. So, basically what we are saying, there is part of the code which is not changing. How do we identify that? So, what we can do? We can look at the variables which are defined in the loop. So, if you look at this code, what is defined in this loop? In this loop, i is defined, j is defined, k is defined. And you are also writing to A. So, I just put ijk. In this loop, what are all defined? j, k and A. In this loop, it is k and A. So, now if you look at this, is there a part of the code, is there a part of the code which depends upon variables not in this loop def? See if you look at this code, this looks like a single statement. But if you have done three address code or IR, this will look like this is one computation i times j, then times k is another operation. So, now I have i times j. So, now for the k loop, for the k loop, find me an expression which is not, which depends on variables which are not defined in this, in this case i times j. So, I will do that. I will take this i times j, I will take this i times j and A sub ij and move it up. Nice. So, I created a temporary t1, computed the address of aij, t2 i times j and reuse them. Nice. All of us are on the same page. Good. In the previous page, I said there are 3 million array index operations. How many array index operations are here? This is 1 million, this is 10,000, no 20,000, right? 20,000. So, from 3 million to some 1 million chiller, right? How many multiplications am I doing? Here, sorry, here how many multiplications? 2 million. 2 million. Here how many multiplications? 1 million and 10,000. Right? Can I do anything further? I can lift this ai up, right? And so, yeah, so if you look at this part, this ai here has moved out. This t3, this t3, I am just focusing on just the t3 loop. The t3 has become local only from here to here. I created a t3, pushed it up. My life is, has become simpler now. How many operations? How many multiplication operations? The multiplication has not changed. Array index operations have changed. It has become 1 million, 10,000 plus 100. Nice. Can I do further? So, this is the first one. We can of course do unrolling and all that, right? And what we saw? Let us not go to unrolling for this example. You can do it, but not yet. Instead of multiplication, we can do addition. What? Where? Good point. Which one? k loop. Yes. What should t be initialized to? This should be a typo here, right? This should be t2. This should be t2. Let us say t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t10, t11, t12, t13, t14. The t4 is okay. t4 equal to initial value of t2 and then how should t4 change? I will add. You said add, right? What should I add it to? Let us get the value of t2. Initially t2 value is some value. Let us call it x. After first iteration, in the first iteration you will do t1k equal to x. In the next iteration you will do t1k equal to x plus x plus x. Next, x plus x plus x. So, what am I incrementing it with? This value of t2. So, what we are doing is basically strength reduction. We are doing strength reduction. See, if there is a loop induction variable, see if it is in the loop, there is a induction loop index variable which is changing from i plus 1, i plus 2 and so on. The induction expression is changing in terms of i. Whatever the current value of i, you are doing something more than that. So, initially if it was iC1 plus iC2, next i plus 1 times C1 plus C2, next i plus 2 C1 plus C2. In such a case, what I can do? Wherever in the body I am using this one iC1 plus C2, I will replace it with a temporary. This temporary value, I will keep incrementing. So, let us see what I will do. I took a temporary t5. Initial value of t5 was t2 and then I am incrementing t5 by t2. Multiplication, how many multiplications did we have before? 2 million. We started from 2 million. It became 1 million now, 0. Now that is done for, I will go back to the previous code again. So, we remove this multiplication. We removed this multiplication. Similarly, this multiplication can also be removed. This multiplication, in this code if you look at it, j is changing. j is the loop index variable. i is not changing within this code. So, this is as if some C1. For this loop, this is some C1, not a constant literal, but value that does not change in the current loop. So, I get same t2 equal to some initial value of i and then keep incrementing this t4. t4 equal to i, t4 equal to t4 plus n. Multiplication is completely gone. Now, I am going to do something else. Anything else I can do? . T1 sub k equal to t5. Yes. . No, but k is changing. . And then, which one you want to assign only once? This one, this is an array element. So, I am writing to first element, second element, third element, fourth element and then, but that is still the right statement to focus on. . We could be, instead of every time doing t sub something, what I could do? . Here, let us say, I have a new temporary. Let us say, which one is t6. t6 equal to address of t1 and keep writing to star t6 and keep incrementing t6. I will do star t6 and keep incrementing t6. Let us do that. So, I think that goes by one step further. So, this is what it was. Star something equal to blah and keep incrementing by how much? That is the question. Let us go back to the previous, because I missed something. Here, how much does from one point to the next point change? Only one. Here, it changes by, here it will change by 100, here it will change by 10,000. So, you have to be careful. So, what we did first? From here, we expanded away, we exposed the indexing. I think we also did a copy propagation phase. There are few copies that can be thrown away. If you look at, is there a copy that I can, t2 is it? t2 equal to t4. Yeah, from here. Is there a copy that can go? Just check. Am I missing something? Yeah, t2 equal to t4. Nothing is changing from here to here pucca. So, I can replace this with t4. Then, the same t2 is used here. So, I can replace it with t4. So, this statement can go. So, we do the copy propagation and then we expose the indexing. t1 sub k, I made it t1. I just exposed it and then this looks like the code that we have seen before, where I can further again do increments in place of array this thing. So, I will get code like this. Star t8 equal to blah blah, keep incrementing. See, star t8, t8 equal to t8 plus 1. There is something beautiful about this code. How many of you can know what is special about such a code? This code is very amenable for further optimization. This is store and increment. Have you heard of this instructions? This is lower end increment, store and increment. So, if you see such a code can be later optimized there to one single fast instruction. But even at this code, just this code, how many multiplications are there? 0. How many additions are there? Here there are two. So, this is an increment. This increment will mostly get folded into the store. So, this is the main this thing. So, there is definitely 1 million additions. From 2 million multiplications, we came to 1 million additions and we had 3 million array index operations. It came down to 0. This is just a plain store, nothing more. Awesome, right? We will take, what time do we take a break? 4.15. Then I will do one more before we. So, if we, I want to do a break. I want you guys to go home, take this piece of code, do what we did for the simpler thing. You should get a kick out of seeing this run. Here we not only saw the what part, we also know how to do this. We said what is, I mean how do you actually, when do you, I mean the procedure for doing this. We said find out the variables which are defined in the loop, which are and then find expressions which are using variables which are not in the loop. Those expressions are your loop invariance. Then factor them out. Then we looked at strength reduction, right? We looked at strength reduction and we saw how that works. So, we not only saw the what part, but also looked at some how part. Is there further propagation you can do here? T3. What is happening with T3? T3 equal to T6. This can go, this can be T6 and then where is next T3? Is there any other occurrence of T3? No. Wow. So, this is definitely gone. What else? Sorry? T1 equal to T7. Same is it? Good. So, this also goes. So, this one you are saying goes, right? This one goes. Hello. So, this is T3. So, this is T3. So, this is T3. So, this is T3. So, this is T4. Good. What else goes? This guy goes, right? Next. T5 equal to T4 and T5 equal to T5 plus T4. Is it doubling? No, right? So, let us say the initial value of T4 is pick 5. So, this becomes 5, then 10, then 15. If you keep left shifting by 2, it will be 5, 10, 20. So, that we cannot do. Right? Okay. Any other? Anything more? No, right? Can we? T4 equal to i. Can we replace T4 with i? Here, I can use i for sure. Am I? Can I? No, I cannot because T4 is changing in the loop. I cannot. No, I think that is it. I mean I am not able to do that. Okay. So, let me ask this question. How many of you understand the idea of when I am doing loop invariant code motion? How do I identify which parts are loop invariant? I first identify the variables defined in the loop and then find out expressions which use variables that are not defined in this. Right? The strength reduction in loops where I replace, if I have an expression iC1 plus iC2 where C1 and C2 are the current loop constants. They are not constants per se. They are constants as per the current loop. They do not change in the current loop. Then I replace this one with a temporary. Initialize the temporary before the loop. Right? And at the end of the loop, I increment this temporary by which value? See every time it is increasing by C1. What is the initial value? i0 C1 plus C2 and every time it is increasing only by C1. So, at the end I will do T equal to T plus C1. Right? What if the expression is C1 plus C2? The expression is not of this form iC1 plus C2. This scheme cannot be. You have to find some other scheme. But it is a fairly common pattern. It is a very fairly common pattern where I mean look at this. Even in our code for, sorry, yeah, if you look at this T1 plus K part, right, T1 times K, this is the K is the loop induction variable, T2 is independent. So, even though it looks like some expression, there is some part which is not changing, this T2 part. Make sense? Anyone who is still having issues here? No, right? Okay. We are done with the introduction to optimizations part where we looked at the basic idea of optimizations. We looked at couple of small optimizations and what they do and couple of small optimizations how they do. We will now look at a type of analysis called control flow analysis and its related optimizations, control flow optimization. When we, in the previous examples that we saw when we were doing analysis, we kept saying hey here is an expression whose value does not change. This expression can move out. Here is an expression whose value is a constant. I can replace it with a constant. That is all about data. So, the understanding of the program has to be in two directions. One on how the data is flowing, the other is how the control is flowing in the program. Control is in which instructions are executed after what, where are, I mean my if then else blocks, my loops and all that. So, we briefly talked about data flow analysis. We will come in detail about data flow analysis for most of tomorrow. Today what we will look at is control flow analysis now. So, here is an example. It is an example that computes the Fibonacci series, Mth this thing. So, if this is the input code, this could be the IR. In the input code, you can see there is an if, else, for and all that. In the IR, it is pretty high level IR. It is not very low level, but still the loop is gone. The if then else is gone. Can you look at this and say there is a loop? If we say I want to do optimizations and transformations on a higher level IR and the loop is gone, how do I say move the code above the loop? You may say hey, this is stupid. You had loop visible, you threw it away. Now, you are asking where is the loop? What if the code is written in this way? You see this could have been a valid code as well. Can you find out where is the loop? Moral of the story, you should be able to find loops from such code. It could have been your IR or the input code itself. So, it is not stupid to ask the question where is the loop in this IR? Yes. Have you seen something in this IR? What are the instructions I have? This is pretty much the code from there. This is a receive instruction. This says M is passed. The parameter says by value. Why do I need the receive instruction? Any guesses? Why do I need the receive instruction? If I do not have the receive instruction, what would happen? I am not sure. I am not sure. I am not sure. I am not sure. I am not sure. I am not sure. No, receive instruction is only about the parameter. It is only about the parameter. No, the value is sent by the sender at runtime. Anyway, I do not have the value now. Why do I need the receive instruction? Good. So, what she is saying, I guess is, look, if I do not have a receive instruction and I see it is being used, I may say it is an initialized variable. It is not initialized. Someone will send the value. Why do I have to say this is call by value? Because you need to know how you will generate code later whether call by value or call by reference. All of you understand call by value, call by reference? C supports call by value. C supports call by value. Java supports call by value. C plus plus supports call by value. C supports call by reference. Yes. Now, let us have a raise of hand for this. C supports call by reference. Yes. How many of you say no? How many of you say yes? C does not support call by reference. One hand, two hands, three hands. It is a question MCQ with only two answers. Yes and no. C supports call by value. C does not support call by value. C supports call by value. Good. C supports call by reference. C supports call by reference. One, two, three. Wow. C does not support call by reference. One, two, three, four, five. What about the rest? I do not think in this voting the nota is there. What do you guys think? How about Java? Java supports call by value. Java supports call by reference. One, two, three, four, five, six, seven, eight. Java supports call by reference. One, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen, fourteen, fifteen, sixteen. Wow. Wrong. C does not support call by reference. Java does not support call by reference. You pass a variable. Does the value of the variable change when you come back from the function? If yes, then this is call by reference. If not, it is call by value. Java when you pass a, even if it is a variable a pointing to an object, a's value does not change. The field therein may change. Same thing in C when you pass the address of whatever you are passing is that changing? If I have a int x equal to 3, int star p equal to address of x and now in a function foo I am passing p. In foo let us say I am setting a variable x, star y equal to 5. What will change when you come back? Value of x. Does the value of p change? No. What did I pass? This value. C supports only call by value. A common statement C simulates call by reference. Nah. There is nothing like that. You may feel that some memory location you are able to modify. Yes, but C supports call by value. Java supports only call by value. C plus plus supports call by value and reference. Now, there is some I see some faces with lot of agitation. Yes, question. Yes. Right. That book is mistake. Yes. If it says so. Right. See idea is very simple. You can what the book is trying to convey. Let us give the benefit of doubt to the book. What the book is trying to say is that look if you want to change the variable, the value of a variable in a function, pass its address, then you come back the value that will be visible. They may say the book may be probably I see I do not know which book you are talking about. There may be some books which may say that. That book may be saying that this looks like call by reference. Since C does not support call by reference, pass the address, change in the function via the star operator, come back. Right. Let us not pass judgments on the book. But if any book says that C supports call by reference, that is clearly a mistake. Right. C plus plus has this additional syntax. So, in C plus plus, I could do like this. In C plus plus, I can have function foo with int and y. It has some syntax like this. Where now if you pass x, is there a module on code generation as well? Who? Govinda is doing low level optimization. Try to do self reading on how the code can be, how the code can be code generated for call by value and call by reference. I wanted to bring out that this is an important point to note that the call by value, this information that we say that is kind of carried over to the IR is an important factor to remember. That this is a, this argument is call by value, pass by value, this is pass by reference because this will have an impact on how we generate the code, how we emit the code. When you, C arrays are again interesting. Do you know that C array, do you know how is it allocated? Read it anywhere? If I, give me a minute. Let me erase the board here. So, you should, probably you are aware that C arrays, when you declare a variable A as an array, that variable has no, normally every variable has some memory except arrays. The array variable itself has no special memory. So, when you write int A, this is as if you are saying, give me a box whose name is A. This box is in the memory and when you write something to write A equal to 3, you are writing in this box. If you write int B 10, what you are asking is 10 elements, 10 boxes, 10 consecutive boxes. No box for B. So, what is B pointing to? Let me repeat my statement. What do you mean by B is pointing to it? What, for something to point to, see if I write int star P, what does it mean? It means, if I write int star P, what does it mean? It means, if I write int star P, what does it mean? P is a box. If you write P equal to ampersand x, this address of x, let us say this, sorry, address, I will write here, so that it looks continuous. P equal to address of A. Whatever is this address, that is in the box of P. So, P has a box. Now, you may say P points to A. B is not pointing to anything because B is not a box. Have you printed the address of B in array? What does it mean by address? Yeah, so if you write B or address of B or address of B 0, same thing. What does it mean? B is not a box itself. B is just a placeholder that you can use as a programmer. See, during the code generation, I have, wherever there is B, I will replace it. I have allocated some memory. I will just give that address there. So, it is beautiful that C has created this illusion of an array as a variable which does not exist. Java, the array variables are actually variables. They are objects. Here, this B is not an object itself. It is just a pure, just a name. That name does not actually exist, I mean, point to any, I mean, it is not a memory location. There is no memory box. I like the idea of boxes for variables. It is very, you will see that it gives you so much clarity. Anyway. No. If you pass B, when you come back, does B change? Does B change? What are you passing? B. Does B change? It is a very simple concept, I mean, I know what you are saying. What you are saying is you pass B and changes of B0, B1, B2 will reflect. But if you pass B0, will B0 change? So, any further questions on this pass by value, pass by reference? It is very, there are all very common misconceptions. So, do not feel shy, do not feel awkward, but I think it is important to have this clarity. So, pass by value, this annotation here which is present in the IR is there for a reason because you will accordingly do the code generation. Any further questions? No. What will do? We will take a quick break. I guess how much time I do not know. For 15, you said you wanted a break, right? We will do a quick break and and then we will see given code like this because the input code or because it could be the IR, how do we infer the control structure? Control structure as in I want to know, remember when we did loop invariant code motion, there is a loop somewhere there. I want to know hey where are my if then else blocks? Is it an if then else block or only an if then block? If there is a loop, what is the loop body? What is the loop header? All such things we want to infer.