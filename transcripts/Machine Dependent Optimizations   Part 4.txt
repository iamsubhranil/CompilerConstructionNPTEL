 So, let us get started. So, we are going to continue today on code generation first and then we will see the dynamic programming approach. Yesterday we talked about the Seti-Wulman approach for doing code generation of trees which consists of two passes namely the labeling pass and then the code generation pass. So, we will move further and then we will see one more approach for generating optimal code for tree. So, in this approach what we are going to do is that if you want to generate code for any operation, the cost of generating code for this operation is same as cost of generating code for T 1, cost of generating code for T 2 plus the cost of this instruction itself. Therefore, if you are asking for the minimum cost for generating code for this instruction, that should actually be based on the minimum cost for generating code for this instruction plus the minimum cost for generating code for this instruction and then the cost for this. In other words, this has this so called optimal sub structure property of dynamic programming. In dynamic programming what do you say? The problem is divided into sub problems and the sub problems satisfy the optimal sub structure property. That optimal sub structure property is essentially satisfied here because the minimum cost for generating code for this instruction is same as the minimum cost for generating code for this instruction plus the minimum cost for generating code for this sub tree plus the cost of this. There cannot be any better way than doing this. If you take let us say a cost which is not minimum for a sub tree, is there any likelihood that eventually you will end up with minimum cost? No. So, this satisfies this optimal sub structure property and therefore, we could apply this dynamic programming approach and then we can get this. T 1 and T 2 can be executed in any arbitrary order and it may not have enough registers available. So, some if you do not have enough registers available, some results may be stored temporarily in a memory. That is really how it is. We will see how that is going to be done. So, the way that by which we proceed is as follows. For every node we want to compute the cost of generating code for that node and then we want to let us say if you have R register, then what you want to do is that you want to find out what is the cost what is the cost of generating code using one register, two registers, etcetera all the way up to R register. You also want to find out what is the cost of generating code for this and storing this result in memory that also you want to find out. So, the cost of generating code and storing it memory is same as the cost of generating code using R registers plus storing it in memory. That is really how we calculate that cost. So, essentially at every node we are going to have an array of cost. We will store in array element 0 the cost of doing it in memory and then 1 to R the cost of doing it using 1, 2, 3 up to R register. So, it is basically an array of R plus 1 elements. That is really what we are going to do. So, as I mentioned earlier the cost of computing it in memory is basically cost of computing it using at most R registers plus the store cost. Again we are going to follow this contiguous evaluation, but there is a small twist here. First what we will do is that we have to evaluate each sub tree completely before you move on to the other sub tree, but within each sub tree if some node has to be evaluated using memory, remember the memory cost is cost of computing it using R registers plus the store cost. That means that we must have all the registers available for that. Therefore, in each sub tree what we will do is that we will first compute that particular sub tree which requires it to be computed using memory. That is when you will have all the R registers available. So, you first compute evaluate the sub trees of T that need to be evaluated into memory using all the R registers and then after the computation you put the value into a temporary location or into memory. Then you can do the rest of the computation for T 1. Similarly, after you have finished this you can now go to T 2 and again within T 2 whichever computation which requires to be done within the memory you finish that then do the rest of T 2. Then you go to the operation. So, this is the order in which you are going to do the code generation. This is basically required again to ensure that you will be able to generate code with the minimum cost. This particular method generates code since it has to traverse each node exactly once. It has a cost which is proportional to the number of nodes in the tree. How many of you know about dynamic programming approach? What is the simplest example for dynamic programming approach? Simplest example? Dijkstra's algorithm. Fibonacci. Fibonacci is the simplest recursive evaluation of Fibonacci. It is a simplest example and what do you do in that thing? Essential idea of dynamic programming is that you memorize the Fibonacci values of the previous two numbers. Therefore, it needs to be computed exactly once for each number. That is why it has a computation cost which is... Now, let us see how we are going to do this dynamic. Again the dynamic programming approach is going to exactly follow the same thing. If I want to calculate the cost of this subtree that is going to in turn going to go into the cost of two subtrees there. Then that in turn is going to require cost of computing subtree there and so on and so forth. At each point in time I actually store the cost of right the minimum cost for generating code for that subtree using 1, 2, 3 up to R registers as well as using memory. Then I keep using this upward. That is how we memorize these values and then keep using it upward so that it traverses the tree exactly once to get the cost. Now let us see how that works. Essentially you are going to compute the cost bottom up manner starting from the leaf nodes. Let us assume that this is an array of n to R plus 1. It should have been R plus 1 because there is also 0 for each node where you have R registers and C n of i is the minimum cost of computing the complete subtree which is routed at node n using i registers. When you do this thing you also have to find out once you have found out which has the minimum cost you also remember what kind of gives you that minimum cost what combination gave you that minimum cost. So that when you generate code you can use that combination to generate that code. When I give you an example this will become clear. Now using this cost array you determine the subtree that must be computed into memory. If any subtree requires to be computed into memory then that subtree has to be then the code for that subtree has to be generated first. Then of course the rest of the subtree that is the order in which you are going to do. Let us see again we will take the same example and then start computing the cost for each of the nodes. Again computing the cost is going bottom up. Remember in the Shetty-Wulman algorithm when you are doing labeling, labeling was bottom up. That is exactly the same thing that you are going to do. And now let us look at the cost for each one of these leaf nodes to start with. If you know that each leaf node is going to be either a variable which is in memory or a constant. If it is a variable which is in memory then computing it with using memory is actually no cost because it is already in the memory. If it is a constant it is a constant we can actually use it directly in our this one as long as it is a small constant. Now let us look at this. So, this node a is basically a variable to compute this using memory it requires no cost. But to compute it using one register you need a move instruction. Therefore, that requires a cost of one. Computing it using two registers is same as one register because you do not need the second register. So, you can just not use it at all. So, the cost of computing any node right any leaf node which is actually in memory is basically 0 for memory and for on for the first register and any other register also it will be 1. So, here we are going to do this example again using two registers. That is why you have three elements for each node. So, that explains this 0 1 1 cost for all the leaf nodes. Now let us see how do we compute the cost for t 1. Now the cost for computing or generating code for t 1 using one register we will do that first. Now if you want to compute the code using one register one possibility is that you can give one register for t 1 and no register for b. Remember that the right operand can be memory left operand has to be a register. That means that using one register the cost of computing a is 1. Using 0 registers or using memory which is already there in the memory the cost of computing this is 0 right. Therefore, the cost of computing t 1 is basically 1 plus 0 plus 1. One for this a into memory sorry loading a into register another for b which is already I mean sorry nothing for b because b is already in memory and one for doing the add operation for t 1. So, that is the cost of evaluating or generating code for t 1 using one register for a and 0 registers for b. How about using one register for b and 0 register for a not possible because the left operand has to be in register right. Are there any other possibilities? a and b 1 a and t 1 you can use the same register remember this is the cost of generating code not the number of registers correct. So, cost of generating code with one register even this is with one register not with two registers right. I am basically including the number of instructions cost is here is the number of instruction not the number of registers ok correct. And we have to consider all possible instructions and operand modes or operands for this that is why we consider register operand for this memory operand for this memory operand for this register operand for b is not possible ok right. So, this is the cost of computing this element remember this sub tree and this sub tree are the same ok. So, whenever you fill the cost for t 1 you can also fill the cost for t 2 appropriately ok. Now, let us find out what is the cost of doing t 1 using two registers now there are several possibilities you can compute a in one register and b in one register. And when you do that the cost of computing a in one register is one cost of computing b in one register is one and the cost of computing t 1 is one more. So, there is one move instruction for this one move instruction for this and possibly an add instruction for this right that cost is three. Now, if I am given three registers I can give both registers to a and no register to b does not sound like a good idea, but let us see what is the cost of this right in this case since b is the right operand ok it can be given zero registers and it can be taken from memory and that actually gives me a lower cost right. Therefore, if I give two registers to a two registers to b and then no registers or two registers to a and no register for b then essentially I am computing this using two registers which is same as computing it using one register plus computing this in memory which is zero and then adding up these two things along with the cost of t 1. So, that cost will be two now let us look at this interesting possibility which we have not seen before correct remember when we did code generation for trees what did we say if the left sub tree has a particularly the labeling algorithm of a seti woolman what does it say that there are two sub trees ok what is the minimum number of registers required for the node let us say if the left sub tree requires r 1 registers minimum registers the right sub tree requires r 2 minimum registers what would be the cost of generating I mean what would be the minimum number of registers required for the root correct why did we say that if they are not equal what did we say because we can compute the result requiring both the registers first and then keep that register and use the other exactly right. So, now remember that I should not simply say that if I give two registers to a after computing a I can only to keep the result only in one register all other registers can be released for b ok. So, that is this possibility I give two registers to a I first compute a correct and then after finished computing a I can release all, but one register and that register can be used for b and I can evaluate the cost. So, I need to consider this possibility also saying computing a using two registers and computing b using one register do not treat this as three registers right it is not like three registers right if I have two here and one here then this will be only two if I have one here and one here this will be two that is true right. So, you have to remember that possibility and you also have to include that therefore, the cost of computing t 1 is the minimum cost of three three or two which is two right. So, when you do this thing what you really need to do is I will show you right. So, here what we have calculated is that for t 1 we said that the minimum cost is this one a in a register and b in memory right. So, what we need to do is that here we need to show a in register b in memory I am sorry let us do this not here. So, this is for a first for two registers correct. So, here we will say a in register b in memory ok this information is something that we need to save. So, that when you come to t 2 if you choose two registers ok it means that you have to use this particular option correct you need to remember that otherwise you would not know how you have arrived at that. Similarly, of course for this also you need to remember right here what you say here a in register b in memory correct. So, you need to remember these things right every time you store the minimum cost you say which pattern has cost this minimum cost in this case the pattern which has cost this minimum cost is this one right. Therefore, you save that information over here right ok make sense alright. Now, let us move forward and then see how do we compute this. So, moment I do ok now the last thing that we need to find out is what is the cost of evaluating t 1 in memory which is the third thing that we need to see right evaluating t t 1 in memory is the cost of evaluating t 1 using r registers plus storing it in memory right. So, that will be 2 plus 1 ok make sense. So, now, you have finished this 3 2 2 you also know that this will also be 3 2 2. Now, let us take one more example and then see how that works let us look at t 3 and then look at evaluating t 3 with 1 2 or 3 registers. See remember whenever you are evaluating the cost of generating code for a particular node you need to consider all possible combinations ok and you need to consider for all possible registers from 1 to r. I do not think that using r registers is going to be cheaper right than using is likely to be cheaper than using r minus 1 or r minus 2 registers there is no reason for that. For example, here you can see right using fewer registers right using only memory is actually expensive in some cases it could it could be I mean using sorry the other way around should have said the following thing using fewer registers may not necessarily be more expensive than using more registers ok that is really what it is ok. Now, let us look at this particular example shows you that right let us first find out cost of evaluating t 3 with 1 register. If I have 1 register right obviously the left child has to be in the register the right one has to be memory ok, but then what does it mean I could have actually done the following thing I could have computed the right child using memory and put it in sorry right child using 1 register and put it into memory that is also possible correct. Given that I have 1 register I could have first computed t 2 using that 1 register put the value into memory that means that eventually everything is in memory and then use that 1 register for this. So, when you say cost of evaluating this ok using 1 register you could have given that 1 register to e and then you could have calculated t 2 in memory right that means that this cost would be 1 register which is 1 calculating this in memory which is 3 plus cost of this instruction which is 1 which is 5 and that is this cost ok right I mean that actually we will find out that is it has to be the minimum are there other possibilities again there are no other possibilities I cannot calculate both of them in memory I cannot calculate this in register and this in memory that is not possible. So, among the possibilities this is the only other only possibility among this and that possibility gives me a cost of 5 ok. Therefore, this one is 5 and I have to remember that this has to be computed in 1 register and this has to be computed in memory that is this cost plus this cost ok. Now, let us find out cost of evaluating 3 t 3 using 2 registers right again 2 registers there are several possibilities let us find out which one is going to cost the minimum ok I have only 1 example done here maybe we can quickly work out the other. So, if I have 2 registers I could have given 1 register for this and 1 register for that correct now 1 register for this and 1 register for that would add up to 1 plus 2 3 plus 1 more which is 4 correct so, that is 1 possible value I could have given 2 registers for this and 0 registers for that that will add up to 1 plus 3 plus 1 which is 5 which is higher than 4 and there is no point looking at it any other possibility I could have given 2 registers for this and 1 register for that that is also a possibility remember when I put 2 1 right this still has 2 right if I put 2 here and 1 here then it is again 1 plus 2 plus 1 4 which is same as the minimum cost. So, here when I put this 4 right I could store that 1 register for this 1 register for that typically that is a better option than saying 2 registers for this and 1 register right both of them giving me the same minimum cost. So, I might as well put the first one ok now after having done this thing we have to calculate the cost of evaluating this in memory which is same as the cost of the minimum cost across 1 2 3 4 or registers plus 1 correct yeah 3 sorry we are calculating every node yeah that is because we have 2 registers absolutely right. So, this as you will see that it is dependent on the number of nodes and the number of registers correct right. So, it is going to be order n into r ok now let us look at t 4 correct. So, calculating t 4 with 1 register is calculating this with 1 register and this in memory right. So, that would be 5 sorry that would be 5 plus 2 7 plus 1 8 right if you have 1 register that is the only possibility because you cannot give the register to the right side. Now, let us look at if you have 2 registers then you could have given 2 registers to this and 1 register to that ok that is 2 plus 5 7 plus 1 8 or you could have given 1 register to this and 1 register to this ok that is also 8 right 2 register sorry 1 register to this 1 register to this that is also 8 ok let us look at how do we get 7 you give 2 registers to this and 1 register to this right and when you give 2 registers to this right you can first evaluate this particular sub tree and then release all, but 1 register and then use that register to evaluate this ok that can be done is not it and when you do that it is 4 plus 2 6 plus 1 7 that is the minimum cost again here you will save all the patterns for 8 what is the pattern right 1 here 1 here for 7 what is the pattern 2 here and 1 here not 2 here and 1 here right. So, we have to say for example for this one ok 2 2 2 registers to T 3 1 register to T 1 you have to store things like that right and when you do that thing if you have a 2 registers if you are going to generate code for this instruction correct what is the assumption or giving 2 registers here 1 register that and the moment you do that in code generation what do you have to do you have to generate code for this sub tree first before you generate code for that sub tree and just give me 1 minute I will take your question and within this sub tree if any of the nodes kind of keep a pattern saying that it has to be evaluated in memory then that has to be evaluated first except for leaf nodes because leaf nodes doing it in memory is actually nothing right for example here right you are going to do it in memory, but that is really nothing you do not generate any code for that, but for all other internal nodes if something needs to be done in memory then for that code needs to be generated yes sir question your question. 2 registers to T 1 right and 1 register to 0 registers okay 2 registers will give you this and 0 registers will give you what right it is actually not when you give 2 registers to here you can as well give 1 register, but that 1 register also could be including memory cost okay you can consider either 1 register cost or you should consider memory cost whichever is lower right in fact what you will do is that you will actually look at this entire array and then if you are looking at some k registers you will look at all values k minus 1 k minus 2 etcetera up to memory okay whatever is the minimum cost we can take because doing it in this in fact you would have done that already because this minimum cost itself would have worked out that way okay doing it using that many registers 1 k minus 1 register right is actually what it is so it is fine okay it would have effectively result in this case so in this case if you give 2 registers to T 1 and only 1 register to T 3 you are either going to choose this pattern or this pattern okay and unfortunately these 2 patterns are going to result in a higher cost whereas what you want is this and if you want that you should have given 2 registers to T 3 and 1 register to T 1 and that means that you have to evaluate this sub tree first before evaluating that sub right any questions okay So let us now so this process is basically computing the cost right for all the nodes now we still have to generate code remember computing the cost is bottom up and generating the code is going to be top down so you look at this for every node choose that particular value which has the minimum cost right and then for that particular minimum cost you also know how to generate code for example for this 7 we saw that you have to allocate 2 registers to T 3 and 1 register to T 1 and the moment you say 2 registers to T 3 you know that you have to evaluate this sub tree first correct therefore the moment you say that you have to I mean of course the code generated is going to be the other way around okay you will not generate code like this but here the code that has to be generated is something like this is going to be well let us actually do it the other way around right then you come down right and then you say that next I have to generate code for T 3 before generating code for T 1 right now how do we generate code for T 3 again you look at it 2 registers okay that is the minimum cost and you have to use right for that whatever is the pattern then you will follow that pattern might be 1 register here and 1 register there right and this 1 register mean move this to blah blah and then do this and then do this then you come to this side then here you will say that I have to use 1 register which will be move a comma into some register and do this again you will try to see whether you can evaluate this in the same way that the left sub tree value is evaluated in the same register of the destination register right the ordering that in way in which I have given is basically to remember the pattern not to generate the code obviously you have to generate the code from the leaf node to the not bottom up it is top down but it is a recursive procedure it will go to the leaf node generate code and then go to the parent node remember the code generation mechanism that we saw in the labeling and you are trying to do this swap registers and other things something very similar okay that is really what happens here okay so we are not going to go through the code generation process in any more details other than looking at this level of detail right all right any questions yeah. Two different approaches that is all. Complexity wise both are going to be more or less the same yes space meaning yes yes yes so whereas that is a labeling approach yes okay I am not really sure whether there are any other advantages of dynamic programming I do not recall but yeah they are somewhat similar approach yeah so that is also going to be stored in an array along with that so you have the C array which is the cost array and similarly a P array which is let us say the pattern array which will store how to distribute the registers for that particular cost right we did not explicitly talk about that but that cost is included which adds to his point more storage cost right any other questions right we will see one more mechanism for generating code right and that is the tree pattern matching approach this also allows you to select appropriate instructions remember when we talked about this code generation scheme the dynamic code generation scheme and the dynamic programming approach based code generation scheme for each node not only you consider these different possibilities of which register to be given to what you can also think in terms of what other instructions can possibly implement this that also needs to be looked at okay of course here we do not have an example which kind of meets that but for example let us say if this is A plus 1 right when I give you a example for tree pattern matching it will become more obvious but let us say for the time being that this is computing A plus 1 instead of A plus B right then in that case it would have been better to do an increment operation right and if the architecture allows you to do an increment operation even in memory then that is even better because it will actually have a cost of 1 for this entire sub tree correct otherwise you have to move it into a register increment 1 but if it allows you to increment it in memory then you could have actually done this using that so again it depends so you need to consider all possible combinations but it can still be done now let us see how tree pattern matching essentially does many of these things and allows you to do appropriate instruction selection as well okay so that is the next thing that you are going to talk about okay so there are many different possible ways by which we can select the instruction and choosing the appropriate one is a complex problem right and you do not want to kind of manually also write many of these code again different possible addressing modes are there that also complicates the matter and there are different possible instruction combinations that can also generate code for the same set of instruction and lastly we want to see whether this process of right writing the code generator itself can be automated right for example let us say you wrote a code generator for architecture a but tomorrow you want to write a code generator for architecture b do you have to go in and rewrite that entire code generator for architecture b or can architecture a and architecture b specified in some way and there is a code generator generator which generates the code generator for a and the code generator for b can we do that it is possible to do that also and this kind of an approach where you try to do instruction selection using tree pattern matching enables you to do that in fact we are going to talk briefly talk about two code generator generators which are very popular okay before we go into those details let us first look at how this tree pattern matching based code generation works for this we are going to use this intermediate representation which is called the tree intermediate code. Tree intermediate code is nothing but a DAG like structure or a tree like structure it is a tree like structure not a DAG it is a tree like structure okay and let us see an example to understand this so this is the statement intermediate statement that I want to for which I want to generate the code a of i is equal to b plus 1 right and let us try to understand this tree representation before we go to anything else and in this particular example let us also make sure that we understand what these variables are let us say a and i are local variables what do we mean by local variables where are they stored they are stored in the stack frame and when they are stored in the stack frame they are going to be referenced with reference to the stack frame address correct that is really what we need to understand and let us say that variable b is global that means it will be in the data segment okay okay now let us remember these things and then see how this tree pattern thing works right b plus 1 right 1 is a constant b is in the global memory right b sorry b is a global variable therefore it is in the data segment correct and if you want to load b either you need to have the address of b and then move it using some instruction into a register or you could take the address and then directly use that memory location right again you have to think in terms of what addressing modes can be done right if it is in the data segment then to access b first thing is that you need the address address is going to be 32 bits or more correct right okay as opposed to let us look at this i right here also i need the address of i but this i is a local variable it is in the stack frame so when it is in the stack frame this location is going to be relative to that stack pointer location so how do we specify the address now stack pointer plus minus some offset so what is that addressing mode it is called the displacement addressing mode correct so here i do not need the absolute address of i whereas here i need the absolute address of b if i want to load it correct whether i use the memory or i use it i mean or i move the contents to a register for me to access b i need the address of b and here the address of b can only be specified as an absolute quantity 32 bit number or higher whereas to specify the address of i it is much simpler it is going to be a small offset from the stack pointer so i can use it using a displacement addressing mode and in the displacement addressing mode my offset is going to be a small constant 4 8 maybe 32 maybe 48 whatever number it is but it is still less than a 12 bit or a 16 bit number and therefore i can actually use that index addressing mode correct having said that right so at this point in time of course we are not taking the decision we are saying that what is the offset of i right and that offset has to be added to the stack pointer in order for me to get the address and then i index that address that means that i dereference that memory location to get the value and that value would be i correct similarly if i want to find out a of i correct and remember this is the left hand side that means that we are interested in the address and we are going to store the value in that location how do i find a of i let us assume a is an array of characters to make things simpler right how do i find a of i i need to have address of a plus add the offset corresponding to i since it is a character each location requires only one if it is a short or an integer what should we have done sorry plus 4 what should be multiplied by 4 i should be multiplied by 4 correct so this value that i have dereference should have been multiplied by 2 or 4 depending on whether it is a short or an word and then that value should have been added to the address of a how do i get the address of a a is also a local variable it is also in the stack therefore it is going to be offset from the stack pointer by a small offset that offset needs to be added to the stack pointer and that gives me the value of address of a and to that address of a i take this offset value and then i add it i get the address of a of i correct right if i index it or dereference it and get the value then of course i would have got a of i but in this case what i need to do is that i have to dereference and then store so it is not a read it is a write but you are computing the left hand side of this expression okay so to that value to that particular location what am i going to write i am going to write b plus 1 okay so do we understand how this tree pattern thing working no sorry not the tree pattern the tree intermediate code working right any questions address of i why do we have this as two different leaf node why not we put this as one leaf node okay the first thing that would have happened is that this tree would have become a DAG okay second thing is since it is a leaf node the cost is not that something that you are going to worry about so it is okay to duplicate that you could have put that essentially you could have put this pointer over here nothing would have happened except that suddenly the tree has become a DAG and you are stuck with it okay we will see what happens when you have a DAG because in practice right when you generate either the tree intermediate code or when you generate the you know dependence graph they are going to be a graph rather than a tree okay and in those cases this optimal algorithm is not going to work because they are no longer tree right we will see what to do with that but for the time being we will just duplicate this thing because it is not really different so only a leaf node okay any questions we move forward okay now given this let us see how the tree pattern matching is going to use this tree intermediate code for generating code for this okay so the tree pattern matching starts off with a set of patterns which are defined and for each pattern it gives you what is the code to be generated and what is the cost for that particular pattern right for example if I have a pattern which says a constant has to be moved to a register right that pattern would cause the code generated to be like move constant to register I similarly if I have a pattern like a memory location has to be moved to a register then that is load A to RI if I have a pattern which says that memory location needs to be stored with the value of a register I right then that would look like that would generate a code store of RI in memory location A right let us look at more patterns here actually I have okay that has to be a store right okay we will come back to this little later I will try to find out what is the mistake in this was thinking it is a store but then you do not have if it is a store then this should not have been there okay this should not have been there okay so maybe without this you can actually think of this if you have this pattern right register J use the value of register J to index I will use this pointer here so for example right you have the value of registers J which is used to index that means that you are dereferencing and in that location you want to register I so that is basically store RI into indirect location or J now this is a simple thing where you are basically adding two registers okay and when you do this the result goes to register okay so this essentially says the value goes to register that memory that is really what it says okay yeah okay so yeah now there are more things here so for example if you have a register and you want to add a constant one to it then you can say that add hash one to RI or you could have actually replaced it by increment instruction if such a thing exists right and here if you want to do constant plus register then it is also increment and so on okay so like this for all the instructions and possible combinations you generate the patterns okay and all of these patterns can be expressed as grammars okay that is very important because later on you will use these grammars and then write these code generators okay now let us look at how these patterns are going to be used in order for us to evaluate this expression okay now let us first start off with this address here right now that address here okay remember that this is a offset value which has to be added to the stack pointer okay right so what I can do is that I can move this small offset into a register remember the left hand side has always has to be a register right so I can move this into a register so the pattern that I find here is that there is a pattern which is saying constant A to register if I apply that pattern right that matches with this okay and therefore I can say that the corresponding instruction for this is right load hash A remember hash A is the offset that we are talking about has to be moved into a register or not right this is already in register so I do not need to this is stack pointer register stack pointer so this is already a register now if I look at it this pattern is something like register 0 plus register stack pointer right so register register and that going to a register the corresponding pattern is add or not comma stack point right now the next step you are now replacing this by a register because that is how the code has been generated that value is available in or not now what about the code for this entire sub tree now right there are two possibilities here one possibility is to look at this sub tree first and that sub tree can be matched with this pattern which says that register I okay register I is equal to index of constant plus register J right so you can just see what that is okay let us look at this this address I is going to be a small constant that has to be added to a register stack pointer so that is essentially constant plus register J right and then that has to be indexed and that value going to a register okay so if I look at this particular sub tree then that sub tree can be matched by this pattern matcher to this pattern and you can generate code for this okay and there is a cost that is involved for that whereas you can actually look at this entire sub tree okay and you can match it with this pattern right again look at this part is very similar to this part okay but then this register I plus indexing of this right and going to a register is possible right why because my left operand is a register which is this value and my right operand is a memory location that memory location is actually expressed in the displacement addressing mode correct so small I small offset SP I mean small offset essentially tells you how far away is I from the stack pointer and then when I add this to the stack pointer correct I get the address of I I dereference it I get the value of I okay so if I look at this entire tree it can be matched using this pattern in other words what I have is that I have this pattern in my pattern matching table and the pattern matcher essentially look at the tree and then tries to find out how to find a pattern that fits with the various patterns that are described in that and then it tries to choose the maximum pattern or the pattern which gives you minimum cost typically maximum pattern gives you the minimum cost so if I can do that then the code for this entire thing is actually now this P okay so that essentially means that this whole sub tree can now be replaced by a register which is in R naught right so let us do that now what we have is that we have this sub tree for which we need to generate code now again look at this this is memory and this is a global location therefore first thing is that we need to move the address of B into a register right and then we have to increment that register right this has to be value B because you have to increment B not supposed to increment the address of B okay so again look at this what do we have we have mem of B right and in order for me to find out mem of B what I need to do is that I have to load the value of B into a register I do that using this instruction load B comma R1 right and then of course I have register plus 1 I can generate the increment instruction now that will replace this by a register this already is a register with an index right now what we can do is that this is equivalent to doing a store instruction that is store this value in the location pointed by this register so that completes the code generation for this right so essentially what you have here in the tree pattern matching based code generator is that the I mean the code generator has a set of patterns right and for each one of those patterns you also have this information about what is the code to be generated and how much cost it requires then the tree pattern matcher essentially walks through the tree and then tries to reduce each part of the tree or sub tree right to a pattern and then for that pattern what is the cost like that it tries to cover or complete this entire tree that is really how the tree pattern matching based algorithms work we are not going to go into the details of how to write that pattern matcher and how to specify the patterns and things just to give you an idea of what several of the code generators are based on pattern matching code generators okay that is the point that we need to any more questions okay now let us move forward okay as I mentioned earlier this is something that yeah okay oh sorry this is slightly different topic so now let us address this question of what happens if my basic block results in a DAG rather than a tree if it is a tree we have good solutions available but if it is a DAG what do we do right okay so for this optimal code generation is NP-Hard we may not be able to generate optimal code so we have to use some heuristic to how we have to use some heuristic to generate efficient code right so one possible way is to look at your DAG and then split some of these nodes so that your DAG becomes a tree right let me give you an example here right supposing let us say that we have something like this right it is a tree except that this particular node is shared right now one way to make this a DAG is to replicate this node so if I replicate that node then it becomes something like this with this removed correct then it becomes a tree right then I can generate code for this tree but when I replicate what happens is that I will generate code for this part and I will again generate code for this part which is redundant and it will increase the cost of my right code generator okay another way of doing this is not so much replicate but generate code for one part do not do this right generate code for this part store it into a memory location and use that memory location in the other one so that is the other way of doing it so instead of repeating the computation twice you kind of do the computation once and then store it in memory and in the other side you essentially use it okay that is the second part compute the shard tree once and then save it in memory and reuse okay this in general works for a class of machines but again you have to remember that this may not necessarily result in the optimal code again right okay now the next point is about code generator generators as I mentioned earlier writing code generator is fine but if you have to write code generator for machine A then code generator for machine B then code generator for machine C you do not want to repeat this exercise again and again so can we actually automate this code generators itself right so for that typically you use this tree pattern matching based approach and dynamic programming approach you kind of combine these two things using tree pattern matching you kind of find out what is the minimum cost for each sub tree and then using that you kind of apply it in the next higher level okay so essentially it accepts three patterns associated cost and the semantic action which is essentially the code generation and then using some kind of a grammar you express these patterns and then you kind of write you write the code for a tree matcher which kind of goes through the graph which kind of goes through the tree and then identifies what can be matched but you also have to cover this entire tree and you have to find the one which covers it using the minimum cost okay so the first pass is the bottom up pass which finds a set of patterns that cover the tree with the minimum cost and the second pass execute a semantic action which is basically generating the code and that is typically the top down part okay so there are a few code generator generators Twig, Iberg and Berg and Iberg okay these are kind of popular code generator generators unfortunately we are not going to go into the details of this in this lecture okay so you may want to look up what these things are so essentially the entire process of writing a code generator itself can be automated and if you have a code generator generator that will actually do similar to what you have seen in lexical analysis and right lex and yak so you know you no longer write these lexical analyzers right there are programs which can generate these things okay now let us look at the last part after having done these things you end up with the so-called machine code now is it guaranteed that this machine code is supposed to be very good or will it also have some opportunities for optimization okay let us look at it and then that kind of optimization opportunities can be addressed with what is called the peephole optimizer peephole essentially means a small window so what you do is that in this generated machine code you look at small windows of instructions and within that small windows of instructions if you identify certain patterns for doing optimization you apply those optimizations right so these optimizations are effectively local optimization because you are looking at a small window of instructions okay and this is typically carried out on the machine code but sometimes one could also apply this on the intermediate code okay as I mentioned earlier it is going to look at a small window but it is a sliding window of code which is what is called the peephole and then it tries to apply these optimizations okay each improvement can itself internally to additional improvement so you have to kind of repeatedly apply these things like in many of the other optimizations okay now these are some of the optimizations that are possible using peephole optimization okay for example eliminating redundant instructions eliminating unreachable code eliminating jump over jumps algebraic simplifications strength reduction and certain machine idioms okay we will see examples of some of these things in order for us to understand so for example let us say that the code generated has a load instruction and then subsequently a store instruction and between this load and store instruction let us assume that X was not sorry that R1 was not modified right that means that I am loading a value from memory into R1 I am using it multiple times and then again I am storing it into memory obviously this is a redundant instruction it can be eliminated right now let us look at this piece of code right I have condition equal to 1 if condition equal to 1 go to L1 do this right now will this code be ever executed in this situation no right because condition is 1 and then you are going to go to L1 so if you do constant propagation then this becomes 1 equal to 1 which is always true that means that you are going to go here so this is an unreachable code it can be eliminated and if this code happens to be just following this then all of this can be eliminated right this condition can be eliminated this add can be eliminated but if there are I mean whatever instructions that are here you can actually eliminate all of them as well because they are all dead code right so let me just since it is always going to jump from here to here any instruction that you see here right like the add or any additional instruction that you hear they are all redundant and means they are all dead code so they are never going to be reached and you can eliminate them and the moment you eliminate this your L1 is directly below this one correct therefore this condition is also redundant and can be eliminated right so that is why you apply these people optimization repeatedly right jump over jumps yeah sorry question in the intermediate code possibly it would have been done in the intermediate code but there are certain things that you do during code generation that would have caused some of these things to happen also it is to answer your question you try to do some of these optimizations in the intermediate code and then you take the optimized intermediate code and generate the machine code but in the process of generating the machine code right again these opportunities would possibly arise because of the way in which you are generating machine code see I can give you an example for this just saying that this let us say that we are trying to compute something right I mean so I will give you an example of this for example let us say that X is I mean let's say that we have a variable which we were spilling loading and then again spilling and then loading if you are doing that right it may be the case that I have been loading and again I am trying to spill in between there were no modifications that were done there are no modifications that were done then there is no reason to store it so this can be eliminated so there are these opportunities that do arise and typically a simple peephole optimizer pass which repeatedly goes through this code kind of cleans up this so here is another example where you have what is called a jump over jump okay so here you have a less than b go to L1 and then in L1 you say go to L2 right if you look at these two things together you could have replaced this and then said go to L2 strength reduction essentially says that instead of using some more expensive operations you could have used right other operations again you could ask this question wouldn't instruction selection have taken this care taken care of yes it could have taken care of this but then if that didn't consider it for whatever reason it is then these opportunities do arise see for example when you are generating code right maybe this 8 was not a constant right and then maybe you did some constant propagation like what you did over here and then that resulted in this value being 8 now you have an additional opportunity of doing this so whenever you have this multiplication you can replace multiplication of a number which is 2 power 8 2 power k then you can replace it by a shift operation similarly power operation can be I mean the power will not happen in the machine code level but yeah similar things like what you have seen in strength reduction right again machine idioms where you can actually replace certain things for example here we are loading x to r naught incrementing r naught by 1 and storing the value correct so we could have replaced this by a increment instruction if the machine supports an increment so these are opportunities that you get in code generation and you can actually exploit them right and you can eliminate some redundant code or optimize your code so this optimization is the last phase after I mean last in the sense of after code generation you do one more pass of peephole optimization and eliminate some of these redundant codes right that is something that you do okay that kind of completes our discussion on code generators so do you have any more questions on this yeah. They will have separate code generators for each one of them okay so why do not we actually defer this question for some time right and we will come back and answer this but important thing to know is that when you say something as a compiler right it includes some code generator how that code generator is generated is a different issue either it could have been written by some set of people or it could have been generated by a generator but then that module has to be a part of the compiler that is something that we need to understand Now this retarget ability to multiple target machines right you would have seen why that happens right why that happens meaning like so you have these different languages so this is language one language two and language n right and then you have these different machines machine one machine two and machine three right so the conventional approach is to kind of write from each language to the respective machine so that will be m cross m you do not do that you never do that thing right so it goes into some intermediate form right and then from there are separate code generators for this is the standard approach that is followed now this code generator here will simply put code generator but it involves code generator plus a number of other cases as well right this code generator which is specific for machine one correct your question is it generated by a generator or is it manually written you definitely have to have a CG for each okay the question is whether the CG is manually generated or is generated by a code generator right so code generators if you have a code generator which can generate effective code yes you have a single code generator and then specify these for each one of those machines and then the code generator would generate the CG for each one of them right obviously that that that is the purpose of code generator generator right okay I am not very sure about the way in which things are done in GCC I will suddenly flash some slide in the next discussion okay.