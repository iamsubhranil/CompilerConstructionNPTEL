 Get started. So, what we have seen so far is that we have seen code generation and instruction selection as well. Now, the next thing that you are going to see is register allocation right. This is an important problem in the compiler and we will see in great level of detail how to do register allocation right. Subsequently, we will talk about instruction scheduling although instruction scheduling pass might happen before the register allocation in many of the compilers okay. So, this module is going to be on register allocation and in register allocation after introducing the problem we will talk about a very simple register allocator using usage code. In fact, this is a high level way of explaining what is happening right and we will do something better than this, but quickly see an example of how to do register allocation just using register count. Subsequently, we will talk about register allocation using graph coloring. This is typically how register allocation is done in a compiler. We will also talk about the problem of doing register allocation within a basic block and when it is within a basic block the problem becomes a simpler problem and can be solved okay in near linear time kind of a algorithm and you can in fact do optimal register allocation using near linear time. That kind of inspires another allocator which is called the linear scan register allocator which is not optimal, but which is very efficient, very efficient in terms of the time it takes to generate the register allocation okay. So, we will also talk about that and it seems to perform close enough to the graph coloring allocator. Graph coloring allocator itself is a heuristic approach so that is also not going to generate optimal code right. So, generating optimal register allocation is again an NP hard problem. So, we will not try to solve it using I mean we will not try to get the optimal solution, but we will try to get a solution which is as good as possible that is really the up okay. So, this is roughly the organization for this module okay. Now, what is the register allocation problem? The register allocation problem essentially is to identify which variable should be allocated in registers okay. We also know that variables which do not overlap with each other can possibly share the same register, but we have to identify which variables can get these registers. It is quite possible that there are more number of variables than the registers available and therefore some may not necessarily stay in register. Particularly in a Sysc architecture we know that you can use memory operands in your arithmetic and logic instructions. Therefore, I mean if you cannot allocate registers for them you will continue to use them from memory. Whereas in Sysc sorry in Rysc architectures all arithmetic and logic instructions have to be in memory. So, what happens is that you will even for variables which you cannot allocate memory eventually when you perform certain operations from registers have to be used for that. So, they have a mechanism for generating code for those kinds of architecture. We will talk about that. We may not really talk about that in level of great level of detail, but we will see how to handle that. Maybe we will discuss that how to handle that okay. Again when you talk about register allocator, register allocator can be done as a global register allocator or as a local register allocator. When you talk about local register allocator it is register allocation within a basic block. Whereas global register allocation is beyond basic block or across basic block. Typically what is done is that a global register allocation pass first happens and registers are allocated globally. Typically at a function level is what register allocation happens right. Subsequently for certain optimizations you would do a local register allocation on top of that. So, this is essentially the register allocation problem, but it also has a sub problem which is the register assignment problem. Having decided which variables would reside in a register you will also have to decide on what registers. That is a subsequent problem, but that in today's context many registers right if they are all homogeneous it means that any register can hold any value right. Then this register assignment problem becomes a somewhat a trivial problem, but there are certain architectures in which you will say that this cannot be in that register or this has to be in odd even registers or this has to be only in these registers etc. In which case subsequent to doing this register allocation problem you also have to solve what is called a register assignment problem ok. So for example is accumulator is another example. There is a special register called accumulator and only certain things can be loaded in the accumulator right. So, if you have such situations then you will also have to mark those things and then say that these registers cannot be used for that purpose right. Together these two problems are always called referred to as register allocation problem although to be precise register allocation only refers to deciding which registers will be in which variables will be in register and which variables will be in memory ok. That is really what the problem is ok. Now every machine has a set of registers. The problem is that you are given an intermediate program ok some piece of code ok which has its control flow right control flow graph represented in the form of a control flow graph and the number of registers k that is available in the machine. The idea is to find out can this code can this code right be I mean can these registers let me put it this way can these registers be assigned to the variables in the code such that no two conflicting variables are assigned the same register and there is no extra spill ok there is no extra loads or stores for the spill. That is you are going to have a code in which all these variables ok will be assigned the registers such that two variables which are kind of conflicting with each other are not assigned the same register. We will see what is conflicting in a moment ok. This problem is NP hard ok and therefore trying to solve this optimally is going to be going to take a very long time. So, you use heuristic approaches the simplest heuristic that we use is what is called count based heuristic. You can also use the graph coloring approach and then I will also briefly talk about the linear scan allocator. Remember all of these are heuristic approaches right and they will end up generating codes which are not necessarily optimal you can say near optimal or sub optimal code and this one is supposed to generate code which is right closer to near optimal. This is supposed to generate code which is actually poorer than this one, but in terms of the time it takes to solve the problem it is faster. The time complexity of this is better than the time complexity of this right and then of course this is a very very simple approach and it generates very inefficient kind of an allocation. So, let us see all three of them in this lecture, but before we go into that let us first talk about what are conflicting variables ok. Two variables are said to be conflicting if they are live at the same time right and liveness is essentially defined as a variable is said to be live if its value is needed in the future if it holds a value and its value is needed in the future. And what does this really mean we will explain this by the following thing you take any program point P right there is a point ok P i in the program which is before this point right in which it is defined the variable is defined that means that given a program point there is a point prior to that where this variable has been defined and there is a point after that where the variable is used that means that you are in between the definition and the use of a variable. But of course you also want to say that in between the value is not redefined that means that you have a definition then some use then again another definition again another use then in between these use and the definition those points it is not live ok. Let me give that example here so let us say the temporary is defined here ok it is used here and then again subsequently defined here and used here. Now you can say this program point it is live this program point it is live but this program point in between these two right there is a definition before that there is an use after that however in between this point and this use there is a redefinition correct right. So we do not call this as live ok this is not whereas this is live and ok this is live right so that is really what we mean ok. Let us take an example right look at this code right now for each variable we say that the point in which it is defined till its last use is where it is live ok. So for example the variable S 1 which is defined here is only used in the next instruction similarly the variable S 2 which is defined is being used in the next two instructions right and a variable which is S 3 which is defined over here is being used in the next instruction and so on right. So the live range of each one of these variables is shown here and clearly we can see that S 1 and S 2 conflict with each other right if they are given the same register then obviously there is going to be a problem isn't it because they are live at this point together and therefore they cannot be using the same register whereas S 1 and S 4 can share the same register because they were never live together right at any of these program points if you look at it either S 1 is live or S 4 is live but not together therefore S 1 and S 4 can be assigned different registers right ok. Now the same thing will go a little bit more into the details as I mentioned earlier right whenever we say a variable is said to be live if there is a definition before that and there is an use after that including that point ok. So for example if you look at C and then talk about variable S 2 then there is a definition before that and there is an use after that and there is no redefinition from this point to the use point therefore this is what is called the live range of this variable ok. Now we essentially define what is called an interval ok so this interval between p i to p j is the live range of this variable right so S 2 is live between b to d for example from this point to this point. How do we compute the live variables live range of a variable? We have been talked about the diffuse change in the data flow analysis live variable analysis and diffuse change so using that we can calculate right we can calculate the live range of each variable is that ok have you people been discussed I mean has this been discussed as a part of the data flow analysis yeah yes and no liveness has been discussed ok so d u change have not been discussed is it ok that is fine you can kind of read up that quickly similar data flow I mean it basically uses live variable analysis to compute the d u change the next circle I will read to that ok. Now the question is when is register allocation done and on what code is register allocation done? Register allocation is typically done on the lower level intermediate code either intermediate code or machine code typically on the machine code more typically on the machine code ok that is where it is done it is done ok and often times what happens is that code generation happens assuming infinite registers and what it does is that it uses what are called temporary vary sorry temporary registers ok or what they call it as the let us call it as temporary register I do not want to call it logical. So, code generation happens with temporary registers which assumes infinite amount of registers now what you do in the register allocation phase is that you find out which one of them actually go to those registers and which one will be not registers or will be always access from the memory that is needed to be done during the register allocation phase and this is typically done after all the global optimizations are also done but it can be done either before or after instruction scheduling and towards the end of this lecture and possibly in the next lecture we will discuss what are the pros and cons of doing it before as well as after right both of them has some positive and some negative aspects of doing things and there is interaction between this instruction scheduling phase and the register allocation phase. So, one has to be one has to understand that in order to position them appropriately. Software pipelining is another instruction scheduling method when we talk about instruction scheduling we will also talk about software pipelining. Now, this again I do not understand too much of this so I copied this slide from this source right and this kind of shows in the LLVM where exactly is register allocation being done right. So, you can see that you do all these code generation instruction selection right instruction scheduling and further some SSA based optimization which Malai talked about yesterday and after that you have an SSA form of instructions on that you do register allocation this is how it happens in LLVM right whereas in GCC right it is little bit different. So, after the code generation phase right there are certain optimizations that are done and after that you do instruction scheduling and after that you do register allocation right. So, that is really how this happens in register allocation but for our purpose what we will assume is that we have some kind of a code where there are temporary registers the code already has some temporary registers and we need to decide how many of them will get actually the register that is really the problem that you are trying to look at okay. Now, first thing is that let us just simply explain register allocation using this usage accounts and why that is important just to get the intuition of that. We will try to do that using a simple example but before that let us find out what is the objective of register allocation why do we need to do register allocation. So, in the register allocation problem you are now trying to do register allocation for a specific target architecture correct. It is dependent on the architecture on which you are going to. Okay, right okay so I do not know whether I should have probably talked about this little bit but I did not okay. So, you can do this is the different passes in GCC right. Now, as I mentioned here these are the high level languages then you do your front end part of your compilation and then you generate different kinds of RTLs right this is like intermediate representation right. Then so you can think of this as some kind of an intermediate code alright and then this intermediate code takes certain machine description this is basically description about the target language this is what well I also talked about later earlier right. So, this specifies for x86 how many registers are there what kind of instruction set is there or whatever other information that you want to mention along with their cost blah blah blah etc. Then using that information reading that information when you do register allocation your register allocator is going to use this information and then generate code for that. In fact, even before you go to register allocation for generating machine code in fact GCC has a pass which is called machine MD RTL which is actually machine specific RTL right. That pass also takes the machine description in terms of generating code how do I generate code for let us say an x86 machine how do I generate code for a risk machine like let us say r 10000 or power 9 whatever it is each one is going to be different. So, you need to take the machine description and the code generator kind of understands that and then generates code based on that. Similarly, the register allocator is also going to look at the machine description and then understand how many registers are there are there any constraints on the register right. For example, when we talk about risk 5 right you know that there are 32 registers each one of them is 32 bit and r 0 is hardwired to 0. All of this information is available in the machine descriptor in some form which each one of these phases like the code generation phase or the register allocation phase or the instruction scheduling phase all of this remember this entire topic is machine dependent optimization. So, everything we do is specific to the machine so that information about machine has to be read from somewhere in the case of GCC it is read from a place which is called the machine description file in different compilers could have been called by different names but there is a place from where it has to read this from it is not that the compiler is intelligent enough to probe the processor to find out how many registers are there you specify that in the machine description file right does that answer your question okay thanks for bringing up the point I thought that people already knew about it I did not go into the details but it helped us to clarify okay. Any more questions on that right so the description of the machine is given to the compiler particularly the backend of the compiler particularly to the machine dependent optimizations of the compiler right and based on that it actually generates a code. So, the machine description for x86 is going to be different from the machine description for risk 5 which is different from the machine description for let us say power 9 or 10,000 or something right and the machine description has to specify all the constraints right machine description is the place where you specify what format of instructions is allowed what of addressing modes are allowed everything has to be specified there only right without which the code generator has no clue of generating code right forget about register allocator even code generator cannot do anything up to here the front end and generating the intermediate code you do not need to know anything about the machine right whereas this part there is a lot that you need to know about the machine in fact every one of the topics that I am going to talk about right remember the title of my presentation is machine dependent optimization so dependent machine dependent everything has to be dependent on that so we need to take those information from the machine description alright okay. So, let us move forward so let us quickly do this register allocation using usage accounts before the break right so here the idea is to okay before I talk about this particular method let us say what is the objective of doing register allocation why do we talk about it so much why cannot I just if my architecture allows things to be in memory why cannot I just take everything from memory right that way I can completely eliminate the register allocation exactly right so the access time of memory is going to be much more compared to the access time of registers so what should be the idea you should be able to put as many variables as possible in the registers and which variable do you actually put it into the registers the ones which are being used more often right and when you say the ones which are being used more often is it in the code the number of times that they appear so for example here in this code S2 appears three times right of course this is a basic block so really should not have mattered but let us look at it so do you count this as three times or do you look at whether this basic block is enclosed in a loop right and that loop might be executed hundred times as opposed to some other variables which are not inside that basic block or whatever right okay so we will come back to this point as soon as I give this example then you will realize this right so what we want to do is that we want to use these registers for variables which are being used more often right that what is how do we define how to get this count we will get it to that point little later okay of course we can use the same register for multiple variables as long as they do not overlap let us take this example right and for the purpose of discussion I have taken the high level code although I should have taken the intermediate code or the machine code of this the machine code is difficult for us to read and understand it also involves a lot of instruction so let us look at this particular code right this is the control flow graph for this right and let us say that we want to do register allocation for this entire function right all right now this is what I was asking let us look at the variable sum right sum is defined in this position sum is used here sum is also used in these locations right so if I look at sum the number of definitions right if I look at this as one one more right but then you know that is not really true sum is being used in this loop repeatedly right that means that whenever I take this definition this definition is actually hundred times not just once right so this will be hundred times plus once here and right a hundred times plus once there so it's basically 101 definitions how many uses of sum one here right which corresponds to hundred uses plus one here plus one more here now let's talk about this static versus dynamic counts right that's very important now if I look at the variable sum how many times does it appear in this program forget about def and use we combine them together how many times one two three four five six right this is a static count right this is what we call as the static count right because that's a number of times it appears in the code what is the dynamic count of the usage of sum right that's what we discussed earlier hundred plus hundred two hundred two hundred and one two three four right all right so that is the dynamic count since you are talking about cost saving in accessing the variable from register versus cost saving in accessing the variable from memory should we worry about dynamic count or should we worry about static count dynamic count no doubt about it right because this is when the program is being executed correct the more often a particular loop is executed the more benefit you are going to get by putting that register into that if I ask you the question right should C be in a register or should sum be in a register answer is obvious right C is never used within the loop so don't worry about giving it a register right so so that is why when we talk about this usage we are always talking about the so-called dynamic count how many times it being accessed in the program we may not have this count as hundred but we'll have this count as n or whatever it is and we can actually deal with that that's actually good enough for us right and we know that in some cases these loops are going to be executed more than ten times or more than hundred times that's actually good enough approximation for us you don't have to necessarily know the exact number okay so after having done this what we really find is that right both sum and i are used more number of times than corresponding to C and square right therefore if you have only two registers available to you then they should be allocated to sum and square sorry sum and i particularly within this loop those two registers should be assigned to sum and i outside the loop you may not necessarily worry too much but within the loop if you don't allocate registers for this they are going to end up coming from memory and that's not a good thing for the program right so we also know right that we can also reuse the same register right for another variable if their live ranges do not overlap so we can see that square and i do not overlap because when square is defined the last use of i is already over correct so if i can use the same register which was given to i also to square right i could have i could also save that cost even though it's only appearing once okay now what about C can i use either one of these register or could i have used this register which was allocated to i to C no because C is defined here and the last use of C is over here which overlaps with i's live range so i cannot be used right so what we can do in this example is that if you have two registers assign one to sum and another to i and then later to square so that's the kind of allocation so any usage based allocator is essentially going to do things at this level right and this is not going to be very efficient we have better methods of doing this so we will talk about the graph coloring based approach next.