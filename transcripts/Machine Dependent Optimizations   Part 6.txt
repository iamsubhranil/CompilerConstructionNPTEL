 Okay, I think we will get started, right. So, next we will see the graph coloring based register allocation, right. So, this is where we were. So, in doing global register allocation, the idea is to essentially make sure that two variables whose live ranges overlap, they are allocated different registers, right. So, this information about which live ranges are overlapping with which other live ranges can be captured in the form of a graph, right. So, you can actually graph with nodes representing these variables and two variables kind of conflict with each other or their live ranges overlap with each other, then you can actually between them, right. So, that is essentially what you are going to call this graph as the interference graph and in the interference graph, nodes represent the variables, right. That that have to be allocated registers and edges between these variables essentially represent whether there is a conflict between those two variables or not, okay. So, there is an edge between V 1 and V 2 if V 1 and V 2 conflict with each other. That means that the live ranges of these overlap or they are live at the same time. Then this register allocation problem itself will turn into what is called the graph coloring problem. Given a graph, we want to color all the nodes of the graph such that, right, two nodes do not have the same color if they have an edge between them, right. That is called the graph coloring problem, right. So, also chromatic number, right, what is the minimum number of colors that are required to color the graph, right. So, if you find the minimum number of colors that are required to color that graph or if you find out whether k colors can be used to color that graph, right, that is essentially a graph coloring problem, okay. Now, given a machine with k registers and given a program, if we can actually construct the interference graph for that program and then ask the question can this graph is k colorable, is this graph k colorable. And if it is yes, then we can actually allocate registers for all the variables in that particular graph. If the answer is no, then of course, not all variables can be allocated this, but some of them can be allocated and the remaining have to be used from the memory, right. So, if the k coloring is possible, then based on the color, those variables or those nodes which have the same color are assigned to the same register and all the variables are assigned these colors, okay. Now, let us see how, what is the complexity of this graph coloring algorithm, right. The complexity of coloring a graph with color greater than 3 is NP-hard, okay. And therefore, we have to use heuristic approach to solve this problem, okay. Now, before we go to the heuristic, we will also ask the question what if the graph is not k colorable or what if the graph is k colorable, but we are not able to find that coloring, right. What do we do in those cases? In those cases, of course, we have to spill some of the variables and those variables will be from memory and the remaining variables will be from the registers. So, essentially given a code, we want to construct the interference graph for that code and then see whether the graph can be colored using k colors. And if they can be colored using k colors, then what are the colors that need to be assigned for these different nodes? That essentially tells which registers are being assigned to what variables and which variables share the same register. All of this is basically obtained by doing the graph coloring problem, correct. That is really what we want to do. If it is not k colorable, then which registers or which variables, sorry, which variables are going to come from memory, which variables are actually going to be spilled, correct. And those variables which are spilled, how do we handle them, right. Okay. Now, let us take a bigger example than what we saw earlier, okay. Here I have a sequence of instructions and as you can see that this sequence of instruction has some conditional branches and labels and things like that. So, this is no longer a single basic block, correct. It is not a single basic block because there is a branch instruction here and there is a branch instruction here and there are jumps into this code, right, isn't it. So, this is basically a piece of code which is represented using this control flow graph, right. So, this set of instruction form one basic block. These two instructions form another basic block. This forms a basic block and this one forms a basic block, right. However, when you take this control flow graph and then write it as a linear sequence of instruction, right, it is going to be in one of these two forms. Either you put this instruction first and then branch to this and then subsequently this instruction and then code further or you go this way and then this and then this, right. So, you have to linearize it in some form, right. So, basic block B 1, B 2, B 3 and B 4 or basic block B 1, B 3, B 2 and B 4, correct. So, this is going to be the sequence of instructions and this is the corresponding control flow graph, okay. Now, let us see what happens in terms of live ranges, right. So, S 1, S 2, S 3, S 4 up to S 6 are the temporary variables that we are talking about to which registers need to be allocated, right. So, here are the live ranges for these variables and the important thing to look at is first let us look at S 1. S 1 is being defined here and is used by these instructions and this is the last use of S 1. After this in this code there is no use of S 1. So, the live range of S 1 is from this point to this point, correct. What about the live range of S 2? The live range of S 2, so live range of S 2 is from here, right, till this point, okay, till this point, okay. Well, let us take it live range of S 2 is up to here and then it is not being used anywhere in this basic block. It is not even used in any of these two basic blocks and only used here, right. In other words what happens is that S 2 starts its live range here, but its last use is at this point in time. So, if I consider let us say a point here, technically speaking there is a definition of S 2 prior to this and there is an use of S 2 after this. So, that means that the live range of S 2 is from here to here even though it is not being used in either of these basic blocks, right. So, technically speaking the live range of S 2 is something like this, but it goes I think the some coloring is kind of missing in my thing. So, let us come to that, okay. It is actually from here till here or you can think of this as having two live ranges, right, with a break in between, right, also another way of thinking about it. We will see what are the pros and cons of thinking in this way, what do we mean by the holes and other things, okay. Whereas S 3 is being defined here and is continuously being used in all of these basic blocks including up to this point. So, its live range is kind of continuous from here to here, similarly for S 4, S 5 and S 6, right, yeah. So, what we see here is that there is a hole in the use of S 2's live range in this point, right, because these two basic blocks do not use S 2. We can think of this as having a hole, but both of these variables are going to be recognized as S 2, right. So, let us stick with that for the time being and then see. Now, we can see that S 1 interferes with S 2, it interferes with S 3, it also interferes with S 4, right. That means that there will be an edge from S 1 to S 2, S 3 and S 4. S 1 does not interfere with S 5 or S 6, right. Like that you have to identify, right, for each variable with what all it interferes. So, for example, if I take S 5, it interferes with S 6, it also interferes with S 2, because this is actually a live range of S 2. The live range of S 2 is from this point to this point and again from this point to this point. You could have considered this as contiguous across all of these points, but then there is a disadvantage to that, okay. So, we will for the time being consider it like this, right. Now, given this interference graph, the question is we can now ask is this graph 3 colorable, right. Is this graph 3 colorable? The answer is no. I do not know how you got it, but let us say it is no, okay. Okay, there is a clique having four nodes, right. So, it has to be four colorable. It has to be at least four colorable or it has to have at least four colors to color it, right. Okay, now let us ask this question. Is it four colorable? No. No. Yeah, in this one I have not shown S 2, S 2 S 5, okay. Yeah, S 2 S 5 I have shown, right. S 2 S 5 there is an interference. S 2 S 6 there is an interference, yes. Is it four colorable or no? Yes. So, those who are saying no, those who are saying no are on this side and those who are on this side, is it? Okay, so let us see if it can be colored using four colors, right. Is that a valid coloring? For this interference graph, it is a valid coloring, right. You only need four colors. You do not need five, right, because these two nodes have to have colors which are other than red. This has to have color which is other than red, blue or yellow, right and I can actually give the same color to this because these two do not have a overlap, right. Problem? It is okay, right. So, this is four colorable. So, the moment I identify this as four colorable and if I have four registers then I will give register 1 to S 1, 2 to S 2, 3 to S 3, 4 to S 4 and again 1 to S 5 and then 3 to S 6. I have to be careful because I should not allocate the same register which was given to S 2 or I should not allocate this. Well, I could have allocated S 4 also for this, but for this I should not have allocated S 4 or S 3 or S 2. I should only allocate S 4, right. So, to identify this coloring that problem for K greater than or equal to 3 is NP hot, okay. Now, let us see how Chaitan's graph coloring algorithm works, right. Chaitan was the first one who have kind of formulated this as a graph coloring problem and proposed a solution to this. He made one key observation which is actually very simple. The sense that you take the interference graph and if there is any node with a degree less than K, strictly less than K, then you can remove that node and then color the rest of the graph, sorry, and you can remove that node and you can keep applying this rule again and again and if you are able to do this and then completely remove all the nodes from the graph then that particular graph is K colorable, right. So, what is the idea? Take the graph, find out if there is an edge, if there is a node with degree less than K, then remove that node along with all its edges, right. Keep doing this again and again and then if you are successful in removing all the nodes from the graph then that graph is K colorable, right. Let us see why this is true or why this helps, right. So, let us take, we take a graph G, right and then remove one node which has degree less than K. The resulting node, resulting graph let us call it as G prime, right. The question is if G prime is K colorable, then G is also K colorable. Why? Because the node that you have removed only has K minus 1 edge at most K minus 1 edges, correct. So, it will at least have one spare color other than this K minus 1. That color can be given to that node, right. So, I have the graph G prime and I have the node G, I mean I have the node N. This node has at most K minus 1 edges, right. That means that it is going to be adjacent only to K minus 1 nodes and even if all of these K minus 1 nodes have different colors, I have one more color to be given for this node, correct. Therefore, if I color this graph with K colors, I can color this entire graph also using K colors, got it, right. So, you can now eliminate this particular node and now you can apply this idea again and again and then keep removing nodes which are which have less than K edges, right. Why do we say strictly less than and not less than or equal to? Because if it is equal to, then if the adjacent nodes all have different colors, then there will be no color left for this, right. Therefore, in that case, if it is equal to K, we cannot guarantee that the entire G can be colored using K colors. But if it is less than K, then if G prime is K colorable, then G is also K colorable, right. So, this is the simple observation that Chai then made and then using this he proposed this graph coloring algorithm, right. So, let us see where this how this works and right. Essentially, the idea is that you take the graph repeatedly, remove nodes which have fewer than K colors, fewer than K edges, right. So, this step is what we are going to call as the simplified step. Keep removing the nodes which have less than K edges, right. If you end up with an empty graph, then we are done. The simplified step is over. If you end up with a graph in which all nodes have degree greater than or equal to K, then you cannot do simplify anymore, right. At that point in stamp, you have to take the decision to spill a variable because now you have a graph which has in which every node has K or more edges. That means that it cannot, it may not be K colorable. It may not be K colorable, right. So, you decide and pick one node and then say that this node we are going to spill. Then you remove that node with all the associated edges, right. Now, you have a reduced graph. Now, again start doing your simplify operation. If you can keep removing more nodes with you know edges a degree less than K, keep removing them. If you end up again in a graph in which all nodes have K or more edges, then make one more spill decision. Like this you iterate, right. You cannot, right. The processor does not have more than K registers, right. You remember it. You are doing it for a specific reason, right. Okay. So, yes. Not arbitrary. One of the nodes which has degree greater than K, yes. Possibly. Among the nodes which have degree greater than K, which one to pick? You are saying pick one with certain heuristics. Possibly. We will talk about that. We will come back to that point, right. Okay. So, essentially the algorithm works in the following way, right. Given a program, you compute all the live ranges, build the interference graph, right. After you have built the interference graph, do this simplify operation. What does simplify do? Keep removing nodes with degree less than or equal to, sorry less than K, not less than or equal to, degree less than K. If the simplify process is completely over, right. So, if you cannot simplify, then select a node and spill and then go back again and then try to do simplify. And if you cannot do again, do this process. After having done this, then what you are going to do is that we are once you have simplified the entire graph, right. After this entire process, you would have simplified and you would have got all the nodes being removed. We need to do the coloring part which is not described in this diagram. I will talk about that later and that is really what is called the reverse path. This figure has been wrongly drawn, okay. We will talk about that. So, here is the algorithm for doing this, okay. Before I go into that, maybe I can just talk about it here. So, what I do is that whenever I do simplify, what did I say? You can remove a node from the graph and if it has less than K edges, then we know that if the rest of the graph can be colored, then this can be colored, correct. So, that means that when I want to color this graph, first I should color this part and after having colored this part, I can come and color this node. Then I remove one more node and I have some other graph. What do I say? Color that remaining graph, color this node and then color this node. So, what we are going to do is that we are going to color the node in the reverse order in which they have been simplified. That means the first one which I have removed would be the last one to be assigned a color, correct. That means that I need to use some kind of a data structure to remember in what order I am removing the nodes. Since I am going to color them in the reverse order, the obvious data structure is a stack. So, as you keep removing the nodes, you keep pushing them into a stack with an annotation saying that whether this is removed because you have fewer than k edges or you have removed it because you decided as a spill candidate, correct. So, these are the two possibilities. Whenever you remove a node, you remove it because it has fewer than k edges. Therefore, there is no spill that is required for that. But if you have removed it because no other nodes can be removed, you chose this as a spill candidate, then it is going to be spilled. So with that information, you actually push it into a stack. Now, sorry, yeah, go ahead. Instead of removing from the graph, can you merge two nodes? You may not be able to merge two nodes, right, because these may be two different variables. They may be having different values, right. But hold on to your question of merging. It is actually a… It is the same register. Yeah, you cannot, yeah, okay. So, let me ask you the question in the following way. So, two nodes represent two different variables. When can you say that they will, they can be merged? They have all the same numbers and there is no less connecting there. No, no, no, do not think of this just as a graph, okay. The graph also has a meaning, right. One of them is S 1, variable S 1. Another is variable S 2. Can I say S 1 is equal to S 2? S 1 has computed something. S 1 maybe has computed i plus 4. S 2 has computed, let us say j times 4. Are these two variables the same? Temporary is the same. How can I merge them? I cannot. Strictly speaking, I cannot. But there is a point in what you said. If they have the same value, correct, then I can merge them. If they evaluate the same thing, then I can merge them, right. That is possible. That we will talk about it little later, right. So, that is why you cannot say that if node 1 and node 2 are connecting to the same set of edges, I can merge them. No, because these two are two different variables. They possibly hold different values, right. If I merge them, then my program is different, correct. Yes, sir. Okay. So, what we are going to do is that during the simplify phase as we keep removing the nodes, we are going to push them into the stack with the annotation whether they are removed because they have fewer edges or because they are spill candidates. Then when you want to color them, you pop these nodes from the stack and then color them. And as you color them, you keep adding these edges back into the graph and then see how new colors can be assigned. So, we will go through that process, right, using an example. But before that, here is this entire algorithm, okay. So, in the forward pass, what you do is that you after, so first step is of course building the interference graph. Then you keep doing this repeatedly. If G has a node V such that its degree is less than K, right, number of neighbors is less than K, then you can do the simplify step, remove this node, push it into the stack and say there is no spill for this node, right, that this is going to be allocated a register, right. After this step, you delete the node V along with all the edges, all the edges that are incident on V, right. And you keep doing this. As long as you can do simplify. If you end up in a sub graph in which all nodes have K or more edges, right, that means that G is non-empty and every node has a degree greater than or equal to K at this point in time. Then you choose a node for spilling. You can actually choose a node which is least profitable, right, not necessarily an arbitrary node, but the one which is, which incurs minimum cost. That can be decided using various heuristics, right. And then you say that that is a node which is going to be spilled. Push that node into the stack, right, and then say that this is a spill node, right, and then delete that node along with all its incident edges. And after you have done this, you go back here and then you start doing this. So, there is a, remember there is a repeat until loop here, okay. So, once you remove one node for spill, again you try to see if you can simplify. If you can simplify, keep doing that. If you cannot, come back and then spill one more node and keep doing this until the entire graph, all the nodes in the graphs are removed. As and when the nodes are being removed, they are being pushed into the stack, okay. In the reverse pass which is the coloring pass, which is what I have not indicated in the diagram, right. In the coloring pass what we are going to do is that we are going to pop each node from the stack and then see the tag. If the tag is no spill, then we have to allocate a register, right. We allocate a register by considering all the edges, right, that we have removed and then see to which nodes it is incident on, right. Obviously, since we have removed it and pushed it into the stack with a no spill, right, at this point in time it will only have fewer than k neighbors. Therefore, we can allocate the color which is not being assigned to any of its neighbors, right, at this point in time. It may eventually have more than k neighbors, but at this point in time as we have popped the node there is a sub graph that we have. It will only have fewer than k, so I can always assign a color for this, right. So, that is really what we are going to do, but if the tag says that it is spill, right, then it is a spill node. I will mark v as not being allocated a register and I will reintroduce all the edges, okay and I will continue to do this until the stack becomes empty, all right. Let us see how this works. Any questions before we go into the details, right. So, the coloring process is very simple. You pop the element from the stack, see if it has a tag spill or no spill. If it has a tag spill then of course, you are going to say that this is not going to be allocated a register, introduce the node and all its incident edges. If it says no spill then what you need to do is you introduce all the incident edges and then see which are the nodes to which this is a neighbor to, right and you are guaranteed that this will be less than k, right. That is why you have removed this node and then put into the stack saying no spill because it has only fewer than k nodes, right. At most only k minus 1 colors would have been used. So, you can assign the kth color to this or you can assign, yeah you can assign the kth color to it, right. That is really how you color this and you keep doing this and then rebuild this interference graph completely. By the time all the nodes would have been colored. So, let us see this in the form of an example, okay but before we go into that let us talk about the complexity. Since you are going to go through all the nodes one by one it is going to have a complexity which is proportional to the number of nodes, okay. And this is an algorithm which is actually used in many production compilers. Again there are some positives as well as some negatives which we will talk about it little later, right. We will take an example. So, in this particular case I am going to take this example, and these are the live ranges for these variables and let us not worry how I have constructed the interference graph but this is the interference graph, right because it will take you quite some time to figure out all the edges and other things but you can go back and check. For example if you want to look at B, right, node B interferes with M, E, C and D and also K, right. So, you can see that M, E, C, D, J and K, okay, J also, right, J also because I think J, yeah I think this is wrong. J should have been from here to here, sorry about that, right. And remember this also talks about which variables are live out. So, for live out variables we would like to keep them in the register so that live range is also being, I mean that is shown by this extra point over here, extra program point over here, okay, all fine. So, we have started off with this graph. Let us try to see if K colorable for K equal to 4, right. Now pick any node arbitrarily which has fewer than K edges, 4 edges, right. In this case I have picked H, I can remove that, I will push it into the stack. Next one G, I can remove that. Next one K, F, right, E, I could have removed M also because M has only 3 edges at this point in time, right. Then B, I can remove D, right. Then of course J and C have 0 edges, I can remove them one by one, right. So, as I keep removing them I have pushed them into my stack, right. So, you will see this, right. So, this is finally what I have. Now I have to start coloring them. Since J is the only node at this point in time I can give one color for this and then I will pop this node. I have given the yellow color for this. Now the next node is C. I see what are the incident edges on this. C and J originally did not have an edge between them. So, it can also be given the same color, right. I can remove that. Then I introduce node D. Node D has an edge to J as well as an edge to C. So, it has to be any color other than the color of J or C. Fortunately for us J and C share the same color. Therefore, it has to be any color other than yellow. So, let us say it was given red, right. Then the next one, right. So, D has been now removed from the stack. The next one is B. You put B, right and these are the edges. B has an edge to C, B has an edge to D and B has an edge to J. So, it cannot be yellow. It cannot be red. So, let us give it a color blue. We still have only used three colors. Then we remove B. We have the next node is M and M has edges to B, C and D. Something is wrong. My coloring scheme has gone bad. So, this cannot be red. This has to be green, okay. So, let us try to write it as green. Hopefully, that will not cause a problem, but that is the only color I can give, right. So, this has to be green because this cannot be yellow. It cannot be blue. It cannot be red. Those are the three colors. So, it has to be green, right. Now, what about the next node E? Bad, my bad, okay. But we will try to give a different color for E, okay. Let us see. Maybe you can suggest me what color to be given for this. Yes, yeah, red or orange, whatever we say, right. Remember, this is not red. This is green, right. That is why we are changing this. So, this is red, not green. I became color blind when I was doing this, okay, right, all right. Now, we can remove E also from our stack. Then the next one is F and as you introduce F, now there is no problem, okay. Now, F is adjacent to J, E and M. So, it cannot be green. It cannot be red. It cannot be yellow. So, we will give blue for that. The next one is K, right. K is adjacent to B, D and J. Therefore, we give a color which is other than blue, red or yellow. And then finally, we have G for which we can give red and then H for which we can give blue, correct. So, effectively we have colored this using four colors, right. This is how Chaitanya's algorithm works. Now let us see what happens if we have three colors, right. Four, it is four colorable. Let us see if it is three colorable, right. Of course, you only do for the number of registers that are available in your architecture. But let us say I have another architecture in which I have only three registers available. Then what happens in this example? We again go through the same way. Now you remove only nodes which have two or fewer edges, right because K is three. So, H can be removed, G can be removed, but then after this any node at least has three edges. For example, yeah, every node has three or four edges or even more. Nothing even has three. Everything has four edges. Well, F has three edges, correct. C also has three edges, but they cannot be removed. K also has three edges. They cannot be removed because we have only three registers. We have to take nodes which have fewer than three. That means two or one, right. So, none of these nodes can now be removed. So, now we have to take a call and spill. So, let us say somehow I pick node B for spilling, right. So, now I push B with the tag spill, right. Now what happens? B can be removed. Now do I have any node which has two edges? K. So, I can say K is no spill, remove K. Then C is no spill, I can remove that. Then D. Then almost every node has now M. So, now we have E, F, J, right. So, here we were trying to color this graph using three colors, but then we have ended up with one node tagged as spill. So, Chaitan's algorithm essentially says, you have a question? Do you have a question? Yeah. You have chosen some other node other than B. Yes, very good. Yes. Possibly, possibly, right. You can try with some spilling some other node and then, see I chose B because B had more neighbors. By removing that, I am removing so many edges from that, okay. But it may be the case that B may be required more often, in which case this may not be a good decision. That is why you remember you asked the question. Instead of arbitrarily spilling, now we may not necessarily arbitrarily pick a node. We may pick it slightly intelligently. So one cost that was used by Chaitan in his algorithm is the number of times it is used divided by the number of edges, okay. So, you are basically taking into account both the usage and the number of overlap that it is causing. By doing that, you are actually saying there is no guarantee that this will be optimal, but likely to be efficient. It is a heuristic. So, what you say is correct. If you. Again this is done arbitrarily in Chaitan's algorithm and that by itself can, well that can influence to only certain extent. It will not influence in terms of whether something becomes colorable or not colorable because that is decided by your thing, okay. So, it does not affect any other thing other than what color goes where, okay, all right. Now, let us start coloring this, right. Let us go through the reverse pass. Now, J has to be given a color, right. So, let us give J yellow color and we give blue color to F, although we could have, sorry, yeah, right, because there is an edge between J and F. Next, we remove E because E is connected to both J and F. It has to be given a color other than blue and yellow. So, these are the three colors that we have. We do not have green anymore. Remember that. Now, I know why that became red. Okay, now, now let us look at M next, okay. M is connected to E and F. So, it can be given the yellow color. D is connected to J and M and it can be given the red color. C which is connected to D and M and it can be given the blue color, right. Then K which is connected to J and D, right. These are the connections that we have removed. Very good point, yes. So, somehow you have to remember these edges that you have removed also or you can actually look at your original graph and only connect those edges for the nodes that are already present, correct. So, for example, B is not there. So, an edge between K and B need not have to be considered, right. So, it need not have to be stored. You can actually infer it from other, correct. Now, what, what is the next node? B. B is a spill node. So, it need not have to be allocated any color. So, it is not being colored, but now keep introducing all the edges, right. And of course, you have G which can be colored and H which can be colored, right. To go back to your question, what would have happened if I have chosen a different color? See for example, when I colored F instead of blue if I have chosen red, then the colors would have cyclically gone around somewhere else, not necessarily cyclically. Some change would have happened, but in terms of whether it is colorable or not colorable, no other change would have happened. No additional cost would have changed, right. So, that coloring decision can be pretty much arbitrary. Choose a color which is not used by any of the previous ones, right. So, this graph we have colored it using three colors, but then we have to spill one node, right. And we have chosen a node which possibly has the least cost, right. If B is being used more often, then you should have chosen some other node, maybe E or maybe something else, right at that point in time and then chose to spill that which might have caused more nodes to spill, right, which might have caused. We do not know. It is a heuristic algorithm, right. Yes. Sir, it is still possible, this is not optimal for this matrix. Definitely not optimal, yes. Because in this case, it is still optimal. But you cannot color this graph using three colors. That much is sure, right. I mean at least this graph. In general, you cannot guarantee that, okay. I will give you an example little later on, okay. A case where Chaitin's algorithm would say you need to spill, but you do not necessarily need to spill. That is also possible. I will give you an example for that, right. So, do you have a question Phil? Okay, it is not optimal. Definitely not. And depending on what node you choose to spill, right, like what you pointed out earlier, if I have not chosen B, but I have chosen something else like a E or a M, I may end up spilling more nodes, right. I may end up, okay. So, the spill heuristic which we talked about earlier is that you have to identify a node which gives you least cost. Chaitin actually defined this cost to be the number of times the node is being used, okay. So, the spill heuristics takes into account the cost which is the number of times the node is being, the variable is being used and the degree which is the number of adjacent or number of variables with which they interfere. It takes into account a combination of these two costs and from what I understand, it is actually cost of n divided by degree of n. So, the more degree you have, the fewer would be the overall cost or the fewer cost you have, then also it will be more. So, if the cost is higher, then spilling that node is not a good decision. If the degree is lower, spilling that node may not be a good decision, may not be, right. So, it basically uses this ratio of cost to degree as the overall metric by we saw, there you go. It is cost of n by degree of n and the one which has fewer cost is what is chosen for spill at that point in time, okay. Alright, any questions so far? Nan, right. How will you get the cost? How will you get the cost? Again, remember we talked about the usage based register allocation method where we counting the, where we are counting the number of times each variable is being used and where we are using the dynamic counts, something similar to that, right. Alright, okay. Now, let us see some extensions to this, right. There are three possible extensions that people have talked about. One is what is called the optimistic spill. The other one is coalescing which you talked about and the third one is live range splitting. We will introduce that also, right. So, optimistic spill is essentially that when the graph cannot be simplified further, we remove one node as a spill node and then tag it as spill. At that point in time we say that because I cannot simplify the graph, I have to necessarily spill this. Why do I say that? Because even if I remove the node, I cannot, sorry, I cannot simplify because in the reduced graph it has nodes which are adjacent to this. It has at least k nodes which are adjacent to this and therefore by removing this, I cannot guarantee that if the rest can be colored, this can be colored. So, I am assuming that because it has k neighbors at that point in time, I may not have a free color, but the k neighbors it has may not necessarily use k different colors. Some of them can possibly use the same color in which case I may still have a color left out, right. I will give you a very, very simple example where this becomes really obvious, right. So, this Chaitin's algorithm was subsequently improved by Briggs who said that do not take the decision of spill when you do the simplified step. Take the decision of spill when you do the coloring step, okay. That means that you say that this may spill, right, but when you are introducing the color, check all the neighbors. If you have, you know, k minus 1 different colors being used, then obviously this can be colored. But if you have k colors being used for the adjacent nodes, then this cannot be colored, right. So, that is the decision he says. So, that is Briggs algorithm, right. So, the actual spill decision is taken during the coloring process, during the coloring phase, right. And when you push it into the stack you say it may spill. Do not say it will spill, it may spill, right. So, here is a very, very simple example. Is this graph too colorable? Yes, right. So, now if you apply Chaitin's algorithm what happens? What is the simplified step? Can I simplify? Can I remove any nodes? Each node has two edges, correct. So, I cannot simplify. If I have applied Chaitin's algorithm, I would say spill a node, right. So, if I apply Briggs algorithm, I am going to say that, okay, I have, I may have to spill a node. I still do not know. So, let me pick a node, right. Maybe I have picked a in this case and then push it into the stack and then say a may spill, right. I have not done anything very different. Only thing is that instead of saying a spills, I am saying a may spill. Now, I have a graph which can be simplified, right. And thought I can simplify it, simplify it, simplify it, and remove all the nodes, right. Now, I start coloring it. When I color it using two colors, B can be given a color, right. C can be, my coloring is not working. I think animation will come later. Sorry about it. So, C can be given a color which is other than B. And now what about B? B can also be colored which is a color which is other than C. So, I can and that could be same as D, right. And now when you come to A, you see that A has two neighbors B and D, but both share the same color. So, you still have one color left for it. So, it can be colored. So, hopefully the colors know. Some of the coloring did not come. Sorry about that, right. So, here you have, you can, you could have colored this red, this would be green, this would be red, and this would be green. So, just because a graph has all nodes and each of which having K or more edges does not mean that it is not K colorable, right. It only says that it may be possible, it may be, it may happen that one node has to be spilled, correct. That is all it says. So, Briggs algorithm essentially says that take this decision of spilling not at the time of pushing it into the stack, but at the time of popping it out. Because at that point in time, you know which are the other edges which have already been colored and whether they have used K or fewer colors. If they have used fewer than K color, then you can still color it using one of the remaining colors. So, that is the change between the Briggs algorithm and the Chaitin's algorithm, right. So, next we will talk about a step called the coalescing, right. So, when we are coloring this graph, we are assuming that, okay, there are these different variables and these variables correspond to these nodes and I do not know anything about these nodes except about their coordinates. But it may so happen that in my code, right, I would have two nodes which are one is the copy of the other, right, something like this, right. For example, I have x is equal to something and then I have written y is equal to x, right. Now, assuming that these two are two different live ranges, I have one node for x and one node for y. If I so happen, if it so happens that I have one node as a copy of the other node, right, then in that case and only in that case, I can merge these two nodes, right. But then when I merge these two nodes, the nodes which are adjacent to x and the nodes which are adjacent to y will be adjacent to the union of that would be adjacent to x y. So, you may increase the number of adjacent nodes, but still it is okay, right, still it may give you better solution. So, this step is what is called the coalescing, right. So, at some point in time, you go back and look at your code and then see if you find code which is, that is when you generate your interference graph, you can actually say which of these nodes are coalescible and which of them are not, right. They call it as move or non-move nodes. For example, here y is basically called a move node because it is a move from move of x to y, right. So, they kind of annotate it this way and then use this information in coalescing node. And when you coalesce nodes, the number of interferences may increase, but still it may help you to find solutions or color the things without having to go for a spell. So, typically what they do is that they do the simplify pass, I think I have this slide there, okay. So, you keep doing the simplify pass, right, and then you simplify only non-move nodes, right. And then if you come to a situation where, okay, so, yes, so simplify by removing all the non-move related nodes and if you come to a situation where you cannot do simplify, but you have let us say move related nodes and if some of these move related nodes can be combined, then you merge them, right. And then on the resultant graph you try to apply simplify. If you can simplify, it is fine. If you cannot simplify, try to see if you can do more coalescing, right. Keep doing this, okay, until you cannot do any more coalescing or you cannot do any more simplify. If you cannot do simplify or coalescing, then of course you have no option other than spill and then you come back and then redo this whole thing again, right. So, that is how you can improve things, okay. Now let us talk about the last optimization which is live range splitting, okay. So, again I have a part of the example here. I did not do the full example for some reason, but let us just try to see what it is and maybe with that, well with that we will kind of close this graph coloring based allocation. So, every time you look at the live range and then you see that two different variables are conflicting with each other and then you take a decision of splitting, spilling a node, right. Whenever you cannot color, you take the decision of spilling the node. Whether you do the spill at a time of pushing it in the stack or you take the decision of spilling at a time of popping it from the stack, it does not matter. You are only saying that this cannot be colored, we will give it a different, I mean sorry, it cannot be colored, therefore it has to be spilled. One of them has to be spilled. So, you take that decision anyway. So, this live range splitting approach essentially instead of just choosing between, I mean instead of deciding it as spill, it now goes back and then say should I spill or should I split. That is the decision you try to take and wherever splitting incurs less cost, you will go ahead and do the splitting as opposed to spilling. I will show you examples of this and you will understand what that is, right. Again we will consider the same example that we saw earlier, okay and you see that there is this gap, okay, for S 2 which is what I called as the hole, right. Now, so this original graph is not three colorable, right, which we saw earlier. Now supposing I say that this S 3 variable that you are looking at, right, has some use here, sorry, it is being defined here but has no use here, correct, and has an use over here, right, until here. So, let me try to decide and then say that I will split this live range S 3 into two parts, one part which is this and another part which is this, right. But if I want to decide it to split here, what does it really mean? It means that at this point in time I have to somehow get the value of S 3 again. So, it has some cost of spill versus whatever it is, right, that cost is there. But let us try to think of that as a split, right, then what happens, right. And similarly I will think of my S 2 as not as one live range, right, going from here to here or this live range S 2 interfering with S 5 and so on. But think of this as a fresh live range. That means that I will reload this value or do something about it. Now when I do this, my interference graph changes to this. I have all the original nodes but because of these split live ranges I have an S 2 prime and S 3 prime. S 3 prime because I have split this live range into two parts and S 2 prime because I am now considering these two live ranges as two different live ranges, okay. In order for me to decide to do this there is a cost that I am incurring that I need to calculate and I need to kind of evaluate whether this cost is worse than the spill cost or better than the spill cost. If it is better than the spill cost then only I should do this, okay. So the splitting decision again is taken based on whether the split is going to be more, is less costly than the spill. Then only you do the split. So let us look at having decided that, right, it is less cost and we are going to do the split. How does it help to color? Okay, go ahead. Yes and no, okay. Splitting has certain advantages as well. We will not go into that right now, okay, right. So one thing is that, how do I put this? Yeah, it may appear to be somewhat similar but let us let differ the discussion some other point, okay. Yeah. S 2 prime and S 6 has two conflict, yes. I think that edge is missing. But hopefully they will be given different colors. Let us see what happens. They can be given different colors, right. Even though there is an edge they can still be given different colors. We can correct it, okay, no problem, right. So these are the optimizations or extensions that can be done to J. Tens algorithm. So think of doing this optimistic spilling, think of doing this coalescing, think of doing this live range splitting wherever it is possible, okay. Now let us just briefly talk about local register allocation. This is typically done, typically what is done is that it is global register allocation which is done and then in certain cases where it is required you do some local register allocation which is essentially allocation within a basic block. Let us see why this is useful or why this is simpler than the other allocation. Now in local register allocation we are only considering register allocation within a basic block, right. That means that within that basic block we are going to identify what are the variables and what are their live ranges, okay. Now the advantage here is that since it is a basic block there will be no notion of a whole, right, because there is nothing like control flow graphs, right, the variable not being used in this particular basic block which is kind of sequentially arranged and because of that it is appearing to be together, etc., etc., right. Okay, I will maybe come back and then talk about this point a little later but let us look at it in the following way. So I have these different variables S1 to S7 and their live ranges are shown here, right. Now if I have to color this graph or if I have to, yeah, color this, I have not built the interference graph because it may not be necessary to build the interference graph here, but let us say if I build the interference graph and then I try to color it, how many colors would I need, right. You can look at the graph and then say at what point in time is the graph really fat, how many, means where more number of live ranges are interfering, right. So you can see that at this point in time five live ranges are interfering. Again at this point in time also five live ranges are interfering. Any other interval it is only fewer than five. So if I have to color all of these variables without any spill, how many registers would I require? Five. Five because it says that at this point in time all these live ranges are interfering with each other. That means that I have a graph with a click, right, a sub graph S1, S2, S3, S4, S5 with a click, right. Similarly at this point in time I have a sub graph S2, S3, S4, S5, S6 with a click. So to color them I need at least five colors, right. So in this case you can actually color this entire graph without even constructing the interference graph because construction of the interference graph is also expensive, right. It is actually O n squared depending on the number of variables you set for which you want to construct the graph, okay. So how do you color this particular graph? We will see that. So this local register allocation is essentially within a basic block, right. And here as I mentioned earlier these live ranges do not have any holes, correct. The interference graph in this particular case if at all you construct they become what is called an interval graph. And these interval graphs can be optimally colored, okay. And that problem is not NP hot, okay. So optimal allocation can be done in linear time, right. And of course you can find out what is the minimum number of colors that you need and that is given by the fatness of the graph, alright. Okay, now let us see how do we go about coloring this graph. So we can actually do the coloring by starting going through these different points in time. And you only need to consider the point in time when a live range starts. You do not even have to consider all other points. So for example let us say I start with this live range S 1. So if all the live ranges are kind of arranged in the ascending order of their start time then I can go through each one of them at a time, right. So the first live range is S 1. I look at that start point, right. And I have the available number of registers in a data structure called free. So free has all the registers which are free at that point in time. So you start with the live range whose start time is the lowest and keep going this in the increasing order, right. And you only need to consider those points where a live range starts. Any point of course in this example you have a live range starting at each one of those points. So you will consider all the points. But in some other cases where you know a new live range does not start you do not have to worry about that particular point, okay. So we assume that when a live range ends its color can be free and that can even be decided at a later point in time. So let us start off at the first point in which all the registers are free. Here the fatness is 5. So if you want to color it you need 5 colors, right. So we can give color 1 to S 1. The free colors would be the remaining colors. Then after that when you come to S 2 you can give the second color to it, then the third color, then the fourth color, then the fifth color. So far there is no problem. Now you have no more free registers. But when you come to the next point you know that one is being freed because its live range has ended. So one can be freed and that can go into the free pool. Then you consider live range 6, variable S 6, it can be given the same color, right. And then you consider the next live range S 7. By that time S 2 has finished. So that register can be returned back and it can be assigned the color 2, right. So this is how you color this. The essential advantage here is that you have these live ranges which do not have pool, right. And because of that, right, you can actually go through and because of that your interval graph is essentially your interference graph becomes an interval graph and that makes your coloring process simple, okay. Now let us see how this is useful. In fact this idea is more useful not only in doing this local register allocation but this has also inspired one global register allocation mechanism which is what is called the linear scan register allocation mechanism. Let us talk about that next, right. So for global register allocation using graph coloring you have to construct the interference graph and that is an expensive step in the register allocation process, okay. And in many cases you may want to do this register allocation or you may want to do code generation, right, and the time for doing the code generation may matter. Okay let me give you one example, example of dynamic compilation just like you talk about just-in-time compilation, right. When you do just-in-time compilation or dynamic compilation what happens is that the compile time for compiling is actually a part of your execution time, right. Are you familiar with languages which require dynamic compilation? Yeah, one of them is Java. Java, anything else? . . . . . . . . . . . . Let me give you a little bit for that, right. . . Some Python implementations have that. That is what I was expecting you to say. Some R implementations have that, right. So these are all things which were normally interpreted languages but interpretation is very expensive. So during the execution you decide that you will compile some part of the code and then when you try to compile these part of the the code if you want to do register allocation for them you cannot be doing a very expensive register allocation right. So, that the compile time for compiling the code is also an important aspect right. So, that you need faster method for generating efficient code right. So, the linear scan allocator is one such method which was actually proposed in 1999 and it uses the notion of what is called the live interval ok. We will define what this live interval is and this is being used instead of what is called the live range ok. Now, we will explain this a little later on ok and because of this your register allocator your global register allocator is actually going to look like a local register allocator and it can be done in linear time or near linear time right that is the idea. So, let us see what this is, but before we go to that let us first define what is the live interval ok. So, for every variable we find the first point where it is defined and the last point where it is used and irrespective of whether there are other control blocks or otherwise we simply say that this variable is live from this point in the program to this point in the program right. So, a live interval may include multiple live ranges. Remember when we talked about the variable S 2 in the previous example it had a hole right and we said that that hole is because there are these control flow paths control flow there are these basic blocks in the control flow graph in which those variables are not being used right. So, we were talking about that now what happens is that we do not kind of consider these holes and consider this live interval as basically the combination of all of these live ranges right. So, it is an approximation right it is a conservative approximation of live ranges ok. Now, for the same example right now what happens is that S 2 which is first defined here and is being used here its live interval is from here to here whereas, when we talked about its live range we said that the live range is from here to here and then from here to here right. In between we were thinking that it is not live right because if I have taken this point sorry let us say if I have taken this point in program I could have said that there are points which are where it is need not have to be live right so that that was that ok. Now, having approximated the live range with regard to the live interval now what happens is that this graph now looks like your interval graph or looks like your interference graph for basic block because there are no holes right. So, the interference graph for this is something like this which is also what is called an interval graph ok. Now, this graph can be colored in linear time but you do not even need to do that you can actually go through the just like the way that you went through for the linear register allocator and you can color it. So, we will see that algorithm next. So, here since the fatness is 4 I have calculated it correctly right the fatness is 4 it requires 4 colors right and you see that it can be colored using 4 this is the click that we talked about and ok. Now, let us see how the linear scan allocator works ok. So, first thing is that you compute the live intervals for all the variables which is similar to computing the live range but then it is an approximation and this can be calculated even easier. Now, the interference among these live intervals ok if they interfere among this then you assume that they cannot be given the same register ok. Now, the number of overlapping intervals changes only at the start point and at the end points of the interval. So, if you go back and look at this graph right if at some point in time the number of overlapping intervals is 4 right it is going to be the same until either a live range finishes or a new live range starts right it value is going to remain the same as long as no new live range starts. For example, between this point and this point the number of live ranges which are interfering with each other is exactly the same. At this point it is different because this live range has ended at this point it is different because there is a new live range starting. So, what happens in the linear scan allocator is that we will start worrying about these points where the live ranges are starting that is really what this is saying ok. So, it changes only at the start and end point of the interval ok. So, the linear scan allocator uses the following data structures for doing this it uses what is called live intervals ok which are basically all the variables and their live intervals, but they are stored in the increasing order of the start point ok. It also maintains what is called an active list which is basically the set of variables which are interfering at that point in time to variables who have already been allocated registers ok. This is stored in the decreasing order of the end points sorry in the this is stored so the active list is stored in the again increasing order, but of the end points ok. So we have two data structures both of them are sorted in the increasing order the first one is started in the increasing order of the start point and the second one which is the active list which is the set of variables which are interfering with variables which have already been assigned a register right, but this is stored in the decreasing sorry in the increasing order of the end points ok we will see why that is important ok. So, the algorithm proceeds in the following way right you start with an initial active list which is 0 because no register no live no variable has been assigned a register so far so this is empty and in your live interval you have all the variables correct and those variables are arranged in the increasing order of the start point. So, you take the first interval in that thing that is the first live range ok. Now what you do here is that at this point in time you expire any old interval that has expired ok initially this may not kick in, but later on you will see that why this is useful right and then if you see the length of active active is the all the live intervals which are interfering with variables which have already been allocated registers right. So, for example if I have allocated registers to four variables right and if I have allocated active is four then it means that I have already used up four colors right and active will only have intervals which are currently active that is why the name active any variable for which a register has been assigned, but it interval is over will not be a part of active right. So, that is essentially what you try to do in expire interval we will talk about that little later on right. So, if you see that how many variables are currently active and have been assigned registers and if that is equal to or the number of registers that is available then at this point in time you have to do a spill right, but if it is less than or then you have a register which is available. So, this interval is going to be given that register by removing a register from the pool of free registers right because there is some free register which is available and now add i to the active because now i is an active interval and add it in the place. So, that it is the end time is always in the increasing order active is end times are always in the increasing order. So, this is how you go about this, but let us see what is expire interval expire interval is that you at some point in time you are now looking at and then you look at what all intervals have expired between the last time that you consider to now. So, for each interval j in the active in the increasing order of the end time you keep looking at it if the end point of j right is greater than the start point of i that means start of i is the current point that you are talking about. So, if its end point is greater that means that the interval is not is still live it is not over yet you do not do anything right, but if it is less than this then you remove j from active and then whatever register j was given you release it to the free pool. In fact, this need not even have to be continue because you can actually break because you have seen one interval whose end point is greater than the current time all other intervals will also be greater than the current time. So, you do not need to do continue you could have done right. So, I am talking about this. So, it is clear right what we are trying to do in expire intervals see remember in this algorithm what you do is that you go from one start point to the next start point to the next start point. So, when you go from one start point to another start point some intervals may have finished. So, those finished intervals you are trying to remove from active and we are trying to free that register and then put them back in the free register that is really what we are doing. Now, again look at it. So, that is what expire interval is about right. Now, what about this function spill at interval right you are going to come to this function whenever all the registers are being used and then you have one more live variable one more variable for which you want to see whether it should be allocated register or not right. So, at that point in time you take a decision whether this variable is going to be spilled or one of the variables which is in the active can be spilled right. See active is all the variables which have been allocated registers which is interfering with this particular time point right. If I decide that one of them can be now spilled right I can give that register to this variable i how do I decide between them I decide whichever interval which is shorter right sorry whichever interval which is longer is the one which will be spilled. So, I compare the end point of i and the end point of that register and then choose whichever one which is longer I will spill. So, this is how the spill interval works right. So, I start off with the last interval in the active because that has the highest end time if I check the end time of that with the end time of the variable for which I need to allocate register whichever one is longer I choose that as the spilling. So, if the end point of the last interval is greater than the end point then I going to take the register back from that particular variable and give it to i. So, I say register of i is register of spill and location of spill it gives you a new location in the stack and then we remove spill from the active and we add i to the active right. So, in this case what happens is that I will again give you an example. So, what happens is that we have already allocated registers right and we have now come to a new live range for sorry new variable for which we want to see whether a register has to be given or not. Now, for all the live variables for all the variables which are interfering with it find out whether the end point of this versus the end point of any of this if the end point of one of them is longer than the last one is longer than this then we decide to spill that one right or if the end point of this is greater than all of those then we decide to spill this one again this is a heuristic right if you decide to spill then if you decide to spill one of the existing active variables active live ranges then that register is given to this otherwise this is being that is essentially what this algorithm is. Let us again look at this this is what we have okay I have put all the intervals over here now again I will illustrate the point. What happens is that the algorithm the main part of the algorithm goes from this point to this point to this point to this point and then it will go to this point it will not consider these intermediate points because no new live range starts in those points right. So it will be at this point at this point at this point this point and then after it jumps to here and when it jumps to here it tries to see which live ranges have ended this live range has ended so it will try to free the register okay. So let us take this interval put it over here right and then see all the intervals are sorted in the increasing order live intervals are sorted in the increasing order so it is S 1 based on the start point so that is S 1 S 2 S 3 S 4 S 5 and S 6 because the start points are in the increasing order right you can see them to be in the increasing order. Now initially the active list is empty let us look at this particular point right and let us assume the case that we have three registers dollar 1 dollar 2 and dollar 3. Now S 1 can be assigned the register dollar 1 right then we come to the next point S 2 no interval has expired before this right now S 2 can be assigned the register because you have a free register right so dollar 2 can be assigned now that also has to be put into the active list and then you sort the active list in terms of the end time okay. So when you come to S 3 you have active list as S 1, S 2 right and when you come to S 3 no more live ranges have expired so that is fine have nothing else to do. Now you look at your free register pool you have one free register which is available that can be given to S 3 now the active is S 1, S 2, S 3 but if you arrange it in terms of the end point it will be S 1, S 3 and then S 2 correct so the active and the next point is S 1, S 3 and S 2. Now you do not have any more free registers and when you are at S 4 no live range is ending either so you have nothing to release right. So at this point in time you have to make a decision about spill right because you have no free registers you consider the end point so now you look at your active list which is the last one in that S 2 when does S 2 end point end yeah as opposed to this S 4 ends earlier correct. So now because S 4 end point is less than S 2 end point you decide to spill S 2 the idea here is that the one which has the longest live interval if you spill then you can accommodate several variables with that spill right. So you spill S 2 and assign that register to S 4 so when you come to point S 5 this is the first point where you see that one live interval has ended so you can say now you can remove S 1 from the active list and you can put back that register into free registers right so you have one free register which is available and that can be given to S 5 alright. So then you come to S 6 by that time S 3 and S 4 have ended so you can free those registers and then you can assign one register to S right. So this is essentially how this linear scan algorithm works jumps from one start point of an interval to the next start point and so on and at every point in time whenever it has to make a decision about spill it considers the live interval of the variable for which it wants to allocate the register with the live interval of the last variable which is in the active list which is S 2 whichever one is further that is spilled the other one is given the register. If S 2 had been smaller right or all of them are of the same distance then you would have decided to spill S 4 and S 4 would not have been allocated. So that kind of completes our discussion in register allocation that is really what we wanted to do. There is something that I will talk about as far as the interaction between register allocation and instruction scheduling that we will take it up later okay. So I think it is time to close so essentially what we have seen yeah have a question. Oh okay so I have not really talked about those kinds of things if S 2 appears to be a left operand of something or let us say if you are talking about doing this for a risk architecture eventually S 2 has to be loaded into a register so you will incur a cost for that right all right. So again you must understand that yesterday we talked about static single assignment right so when you do static single assignment that actually does a lot of things to live ranges and the interference graph sorry the interference essentially becomes much simpler to handle because again there will be no holes and things like that. So again that makes register allocation much faster but the traditional way of looking at it is this graph coloring based approach which is later on modified by this linear scan approach but the linear scan approach is inefficient in the sense that it does lot of approximation and therefore even though it does a faster allocation it may do inefficiently right that is really what we need to understand here.