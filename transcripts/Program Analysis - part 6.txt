 So, today we will look at lattice theory. So, we will look at more the lattice theory and fixed point theory. So, see we look at look at the mathematical foundations of why the analysis that we described yesterday really works. Why do you think it should really work? So, before we get into anything let us just start covering the basics. So, first is what is a set? So, what is a set? So, it is a collection of elements. The next thing is a notion of a binary relation. So, what is a binary relation? Relation between two elements of a relation between elements of a set. Can you describe the binary relation? What was it? Marriage. Marriage, okay nice. That was a good relation in all senses. So, other than mathematically what relation can you think of? Other than social relation. So, relations like greater than less than. So, essentially we will use this notation. So, you say if A and B are elements of some set then I can say that I use the notation A R B to say is A is related to B, right? Or we can also essentially describe the same thing in a slightly different way. I can think of the same business. I can think of this R the relation R as also a set and now it is a set of tuples A comma B, right? So, people keep on using these two notation interchangeably, right? So, I can say that A is less than equal to B. So, less than equal to being the binary relation or I can say the tuple A comma B is element of this set less than equal to, right? Both of them mean the same thing. So, this ordering you maintain this. So, it is a tuple. It is not so you have to that ordering does matter, right? So, now there are some properties of sets that we properties of relations we discuss. So, the first is reflexivity. So, what is reflexivity? When do we say relation is reflexive? When every element is related to itself, right? So, when A comma A is always a member of this relation, right? Then the next is symmetry. What is symmetry? Right. So, if A is related to B, it implies that B is related to A. The next is anti-symmetry. What is anti-symmetry? There is small difference between asymmetry and anti-symmetry. Yes, that is the right definition. So, you say that if A is related to B and you say that B is also related to A, then it implies that A must be equal to B, right? So, it is possible that these two happen, but if these two happen, it simply means that this must be the same element, right? And the next is transitivity. What is transitivity? Yeah. So, A is related to B and B is related to some C, then we simply say A must be related to C. Agreed? Okay. So, next we define the notion of a poset or a partially ordered set. So, we talked a little bit about that yesterday, but let us define it formally now. So, whenever I say, okay, there is a poset, you should ask me that what is the set here? What is the underlying set? And you have to ask me what is the underlying relation, right? So, I have a set S and a relation less than equal to. So, a poset, so what are the, anybody knows what are the properties that a poset satisfies? So, first is it, is it reflexive? So, it is reflexive. It means that every element in the poset must be related to itself by the less than equal to, that is why it is a less than equal to and not less than, right? So, the next is, is it symmetric? No, it is not symmetric, it is antisymmetric. And the third is, it is transitive. What is antisymmetric will be symmetric, not really, actually they are anti, the names is anti, right? Not belongs, related to. No, just see the if then else condition. So, this is the condition, if this condition holds, then this condition holds. It is not saying that for all elements this condition holds, right? So, this is implies, this is implies, right? So, this is given the left hand side is true, then the right hand side surely holds. Yes. Exactly, it is a very well put. And in fact, like you said that I am just speaking to elements, and saying there is a relation between them. And not even saying any two element will have to even be related, any two arbitrary elements have to be related, that is not even the case, right? So, these just say that how does this relation look like. So, this says that if it is the case that A is related to B and it is the case that B is related to A, then it is surely the case that A must be equal to B, right? So, now let us try to think of a way of representing posets, right? And they are, the posets are extremely important as mathematical structures as well as in computer science when we discuss algorithms and things like that. So, we, we, let us have a nice representation to describe a poset. So, that I, in graphically I can describe what my S is and how does the relation less than equal to hold on that set. So, let us try to use the properties of the poset, right? So, one property I know is that it is reflexive, it is anti-symmetric, it is transitive. So, think about this. Let us say I use this, I try to represent it using a graph where every point that I have is basically a member of this set. So, every member of this set, I represent by this graph, as a node in this graph, right? The second is I need to describe what are the edges. So, I say whenever A is related to B, I will have an edge going from A to B, it is a directed edge, right? So, I will, whenever A is related to B, I will create an edge between A and B. Whenever B is related to D, I will create an edge between, so this is the same relation, so I need not keep on putting this. So, when A is related to itself, what will I have? So, I will have a self-loop into this, right? What if this, so if this relation was transitive, what will it look like? I will also have this thing between B and if I had a, if this relation was reflexive, then what would I have? Self-loop on all nodes, right? So, do you agree that if I give you this diagram, you should be able to, this completely describes the set and the relation on this set, agreed? Okay. Now, this is looking really ugly, right? I mean forget my handwriting, but even otherwise it is looking ugly, right? So, now the question is that can I use the property of this poset to simplify this diagram? So, if I use this, if I tell you that this diagram is going to be a poset, this is, I am only using to represent a poset, then you already know that because it is a poset, this guy is going to be reflexive. It means that all nodes are surely going to have loops, self-loops. So, what is the point of showing them? I know it is going to be the case, so let us not, because that is not giving additional information, I know it is a poset, so they are going to be self-loop on everything. So, let us get rid of the self-loops, right? Okay, good. Second thing I know is that it is transitive. If it is transitive, if I see a continuous chain, like if I see a link from A to B and B to D, then I know that there is going to be a link between A and D, right? So, I can just follow a sequence of edges, I know that relation surely holds. Again, that extra edge is not giving any extra information, right? So, again I can simplify my diagram, I can get rid of this, right? The third thing I know that it is going to be antisymmetric, right? If it is antisymmetric, then I am sure that if there is a relation between A to B, then there cannot be a relation, there cannot be a line going the other direction, there cannot be a line going from B to A. If this happens, then they surely are the same point, they will collapse into the same point, right? So, it cannot happen that there is an edge going from A to B and there is also an edge going from B to A, that is not possible, right? So, then what I can do is, I know that my edges can only flow in one direction, they cannot flow in the other direction, this is not possible, right? So, now if my edges flow in one direction, I can always lay my edges in a way that they all go down or they all go up, I can do something like that, right? So, let us say I decide that all my arrows, I just line up my arrows in a way so that they all go down, right? So, in this case, or let us say I am trying to use this particular thing, so let us try to make that all of them, so which one will be the right direction? So, if I order them by less than equal to, so let us keep the lesser guy below, right? Just, I mean, just my way of putting it, it does not hurt anyway, right? So, because I want to, because there is semantic meaning to less than equal to, had it been some arbitrary relation, I would not have bothered, right? But if it, because it is less than equal to, let us keep the lower element downwards, so the arrows go up, right? So, if there is a, if A is less than equal to B, then I will put A below and I will put B upwards. So, all my arrows will only flow upwards, right? Something like this. If all my arrows flow upwards, then what is the point of putting these arrowheads, right? Now, from a directed graph, I can reduce this thing to an undirected graph. So, what have I done? I have used my reflexivity to get rid of self-loops, I have used asymmetry to get rid of direction, directed arrows and I have used transitivity to get rid of this rendered edges which I know sure exist because edges between sequence of nodes, right? So, this particular representation is known as a hash diagram, right? And now onwards, we will forget everything else, we will only stare at hash diagrams, right? So, are we clear? So, what does it, what will it look like? I will have elements from the set, then we will have edges between them and now can I say what the relation is? What is the relation on this set? If I use this diagram now, can you describe the relation? So, S is my set which is A, B, C, D, E and I have a relation less than equal to. So, then what is the relation? B is, A is less than equal to B, then C, A is less than equal to C, A is less than equal to D, A is less than equal to E, exactly very good, E is less than equal to B. So, this A is less than equal to D, I got through transitivity, that edge was not even there. Yes, and now the reflexive relations, A is less than equal to A, B is less than equal to B and all this business, right? Clear? Okay. Now, the next definition is a definition of a chain. So, now in your poset, so this what I had here was a partially ordered set because you can see that there is a relation between B and A, there is a relation between C and A, but there is no relation between B and C. I cannot say which one is less than which one, right? So, that is why it is referred to as a partially ordered set because the relation holds, does not hold for any two arbitrary elements in the set, may or may not hold for any two arbitrary elements in the set, right? So, now the thing is that, so remember the example that I gave yesterday, so what is a totally ordered set? If an element is related to every other element, right? And what is a partially ordered set? Of course, where it is not related, it may or may not be related to the other set. So, of course, a totally ordered set is a more constrained form of a partially ordered set. So, partial ordered set is a more general thing. If it so happens that in the partially ordered set, there is a relation between everything, then becomes a totally ordered set, right? Okay, so now the next notion is of a chain. So, a set of elements in a poset which are totally ordered forms a chain. So, if I have a poset, let me keep it as S only. So, let us say I have a poset S and let us say I extract out some subset X from it such that in X under the same relation less than equal to all my elements in X are ordered. So, X is totally ordered, then I will refer to X as a chain. Make sense? Some blank looks. If I am able to extract out, if I take a subset of elements from X from S and that subset turns out to be totally ordered under the same relation, then I will refer to this X as a chain. So, the next definition is an anti-chain. It is the other way round. If I pick a subset out of my set and none of them are related to each other, then it becomes an anti-chain, right? Now, let us try to pick our older diagram. Let us look at this particular diagram and let us try to see can you give me a chain on this? Tell me which one is a chain? AD is a chain. Anything else? AC is a chain. AB is a chain. So, see why it is called a chain? Because it is a chain. It is a sequence of elements, right? So, you can just follow the edges and whatever path you get, if you can able to get a path, that is going to be a chain because every line is basically telling your relation, right? But there is no other option. You will not be able to go in any other direction. So, if there is an edge from that, either it will go upwards or it will not be there at all, right? So, there cannot be an edge between like it. Ha, there can be an edge maybe. I should. Ha, you are right. Maybe that is a better thing to say. So, like for instance, if this was the case, I cannot come to D. I have to keep on going upwards only, right? So, like something like this. Now, I cannot say AC D is a chain, right? Why is that? Because in that set A and D are not related, right? I know that C is greater than A. I know that C is greater than D. But there is no relation between A and D. Oh, on this path, it becomes an alternative relation. Sorry, because there is a path like this. Right, right, right, right. So, I did not let us say, this edge is not even there, right? So, I cannot do this business. So, okay. The next thing is that is what is an anti-chain? Can I get an anti-chain here? Or BCD, right? So, there is no relation between B and C. There is, sorry, why did I take D? I am sorry. D was not there. BC and BFNE, okay. Yeah, so BFNE. BC and E, yeah, sure. Right. So, now, these are going to be anti-chains, right? So, it is slightly complicated. You have to make sure that some other relation does not creep in. So, the next thing is this notion of duality. Maybe I will come to it later, okay. So, now, then there is this notion of upper bound and lower bounds. So, if there are two elements, if there is a set of elements such that in this set of elements, maybe they look like this, right? So, let us say in this set of elements, if I can find one element which is greater than all of them, including itself of course, then I refer to this as the upper bound of this set, right? So, if I extract a subset out of my set and in that subset I am able to find one element which dominates everything else, which which is greater than everything else, then I say that element is the upper bound of that set. So, is it required that will always happen? Not really, right? Like for instance, you pick an anti-chain, nothing is related to anybody. So, there is not going to be an upper bound anyway because you do not have a relation between them. What about a chain? Yes, because it is always totally ordered. So, you can surely find somebody who is greater than everybody else, because it is in a line like it is all going upwards and in that sequence. So, that is what is referred to as a upper bound and similarly I can define my lower bound which says that it is the set of element, if there exists an element which is smaller than everything else, that is referred to as a lower bound. Then there is this notion of a lub or a least upper bound. What is the least upper bound? So, it can happen that in a set there are multiple upper bounds, there are multiple elements which are. So, the upper bound need or need not be part of the set. So, I will maybe I will take better examples little later. So, now let us say this is my poset and I consider only these elements. So, for these set of elements which are the upper bounds? This one is an upper bound. So, let us say a, b, c, d, e, f, g. So, b is an upper bound. So, for all these elements b, e, f, and g, b is an upper bound, because b is an element which dominates everything else, it is greater than everything else. What about a? a is also an upper bound, because a also is greater than d, greater than e, greater than f, greater than g. So, it is possible that you can end up having multiple upper bounds. So, if you have multiple upper bounds, the question is that which of them is the least upper bound. So, which is the closest upper bound to the rest of the elements. So, in this case though we have a choice between a and b, b is the least upper bound or lub. So, it also has a name called join. So, I will also refer to this as join or the lub, both of them are the same. It is denoted using this particular symbol, this cups. Yeah, it is the relation is greater than equal to. So, this b could have been in this set also, then also it would have been an upper bound. For instance, if this was the set, then also b is an upper bound. It need not be outside that set altogether, like outside the set of elements I am talking about. So, it may be possible that if you have a, so like I said anti chain, anti chain it may, the anti chain may also have an upper bound, but the upper bound will not lie in that set. So, it is not required that upper bound or lower bound have to lie in that set, but they may or may not lie in that set. There may be some upper bound lying in that set or may not be there. So, now the next thing is the notion of, similar notion of something called the greatest lower bound. So, similarly for these set of elements, like for D, E, B and G, does there exist a lower bound? Unfortunately, in this case there does not exist any lower bound, right? But I can join them and then I can say, let us say x and then x becomes the lower bound, but then I can also have y and z, right? Then x, y and z are all lower bounds of these set of elements. Right? And now there is a notion of something known as the greatest lower bound. So, among all these elements x is the greatest. So, then x is my greatest lower bound. Okay. So, consider this particular case. So, what are, what is the lower bounds of this set D, E, F and G? x and y are both lower bounds of this particular, of this set. So, does the greatest lower bound exist? No, because for the lower bounds these guys are not related in by themselves, right? Because these are not related, there does not exist a greatest lower bound. So, it is not necessary that you will surely the least upper bound or the greatest lower bound exist. Greatest, right? Or lowest. So, it has to be, two people cannot be greatest, so yeah, has to be one. So, now there is notion of something called top. Now, if I take my whole set S and if I am able to get an element which is greater than every element in this set, right? Now, consider the whole set of, not a subset of elements. Now, I consider the whole set of elements. In this set of elements I say that there exists an element which is greater than everybody else. That is referred to as the top element, top. Similarly, similarly there is bottom which says for this set if there is an element which is smaller than everybody else, then I refer to as bottom. So, this is denoted by t, this is denoted by, so upper bound is for an arbitrary set of elements. So, you have to say upper bound of which elements and top is the upper bound of all elements, rather the greatest upper bound for all elements, rather sorry not necessarily. It has to be, so essentially I am saying, so this is the element because it is the full set. There must be one element which is greater than all of them. That is my top. Top will be the greatest upper bound, but it is surely going to be an upper bound also because I am considering all elements now, right? So, no, like think about B and C. It can be an upper bound if, so if I considering these two can be candidates for upper bound for this set. If my set is the whole set of things, then B, I mean it cannot be B anymore because I am considering top also, top itself also. So, top is not outside the set, top is also part of the set. The top element is also part of the set. It is upper bound and that upper bound has to be unique because I am saying there is only one element. Greatest upper bound, so essentially top may not exist, that is a different matter. So, it can happen that there is like the whole set of elements are like this. Then there is no top, right? But the only way to get a top here is that if it is greater than everything else, right? So, in this case, if I take this whole set of things, then this is the upper bound. The upper bound itself is a singleton set and of course it is also greatest upper bound. The whole set, upper bound on the whole set. So, upper bounds we essentially needs a set, right? It needs a subset of this S and you say on this subset of this S, which is the least upper bound or greatest upper bound or whatever it is. Of course, of course, of course, because it is an upper bound for the whole set, of course it is an upper bound on all the subsets. No, so essentially you have this, so you have this set of elements, right? So, on this set of elements you decide to, so you are, all you know is this set of elements. There is nothing outside this set, right? You do not know what happens outside. You do not even care about what happens outside this. On this set, particular set, you can take a subset say X and then you can ask what is the upper bound of this subset X. Now, the upper bound of this subset X, there may exist an upper bound of this right here or they may exist other upper bounds here as well, right? But I will not go out of S itself, right? Yes, so you can ask what is the upper bound of this X which lies in S, right? So, S is all I care about. I do not care about anything outside S. Now, if my X becomes S, then my upper bound becomes my top and other, similarly my lower bound becomes my bottom. No, like for this particular case, so if I have A, B, C, D, right? So, for this set, subset, so my set is this whole thing. A, B, C, D is my set S and this is my set X on which I am querying for a upper bound. Do you see an upper bound for A, B? Yeah, it is C or D, right? So, the upper bound need not lie in X, but it surely must lie in S because I only know about S. I do not know anything outside S, right? So, C and D are upper bounds of A and B. Similarly, D is also an upper bound of A and B, but then there is no greatest upper bound, sorry least upper bound, right? Because I cannot say because these are not related. So, now I cannot say which of them is least, right? Least has to be unique element, right? It has to be singleton set. So, that is the issue, but it could be possible that this D is not there, but then I have something is top of, yeah, I have something related to C, right? So, maybe like this also E and F. So, had D not been there, let us say D is not there. So, let us say D is not there, the structure is like this, then my C, F and E are all upper bounds, right? And my C is my least upper bound. Upper bound can be a part of X as well. So, it can be the case that A and B were also related, right? In that case A becomes upper bound or whichever you see the, I do not know, what does it look like? So, which way the arrow goes? So, I see slight tilt towards A. So, in that case I will say A is a upper bound and also the least upper bound, yes. So, are we good? Any questions here? So, lot of definitions and sorry if tomorrow, today there will be lot of definitions, but we have to. Yes, yes, yes. So, first we can calculate the upper bounds and then I can just see is there a least element? If I find one, I will say that is the least upper bound. So, the next definition is for something known as a lattice. So, what is a lattice? A lattice is a poset, a partially ordered set where all the least upper bounds, so where there exists least upper bounds and greatest lower bounds for all non-empty finite subsets, right? So, now in my set S, if I select any non-empty finite subset X, I am sure I will be able to get one LUB and one GLB. It will surely exist. So, it basically constrains on the structure of my hash diagrams. My hash diagram will be such that that is no matter which particular subset of elements I pick, I will always be able to find a LUB and a GLB, right? So, does it also mean that there always will also be a top and bottom? Yeah, I can take the whole set S, right? And then I can ask what, because it is a whole set S, it is I can ask what is LUB and GLB for it and those will correspond to the top and bottom. So, my set of elements for which I will always be able to find the join and meet for any arbitrary subsets is referred to as a lattice, right? It is a pretty strict structure on the sets that you can have, right? Sets and the relation that you have. So, there is also notion of a complete lattice. A complete lattice says a lattice in which all subsets have both a meet and a join or a LUB and a GLB. So, here I do not even care about finiteness. It becomes little weird. So, I am saying if I even take an infinite subset of elements, even then I will be able to compute an upper bound and lower bound, right? Hey, you are cheating. That is actually a partially ordered set. So, show me a proper poset and then give me an answer. No, but yeah, so no, but there is a small problem, right? So, even in this particular set, all my let us say all my integers, then if I take the whole set of integers, then what is my greatest upper bound and least upper bound and greatest lower bound? Then? Then? It is a very good question actually. It is a very good point. So, he gave a very good example, but he is stuck now. I turned tables on him. Now, tell me. So, if you have an infinite set of elements, which is my let us say my set of integers, which is not even a poset. It is actually totally ordered set, but is it a lattice? Because now for any infinite subsets, I should be even for infinite subset, I should be able to take. So, if I take an infinite subset, that is all integers greater than 0. I should be able to consider. So, I can define it, right? Then I should be able to give you a least upper bound on it. I have a greatest lower bound 0, but I need a least upper bound. So, what do I do? Give up. We never give up. No, I want an infinite subset. I want an infinite set. I do not want the set of constraints. Yes, yes. So, you can now go back to definitions. You can say, oh, my subset also contains these two elements infinity and minus infinity. Nobody knows what they are. That is a different matter, but I say that they exist, right? That is cool thing about mathematics. Whenever you are stuck on a problem, define something and get out of it. So, then essentially you can say that there exist these elements infinity and minus infinity, and then you say that no matter what, there is nothing bigger than infinity, right? So, now no matter what infinite subset I give you, you surely know infinity is my, it is bounded by infinity. If I give you well-ordered set, if I say that all numbers greater than 2500 million, which is the greatest, the lowest upper bound, 2500 million, right? Not a problem, right? But if I give you an open end where I say all numbers greater than 0, then you say infinity. All numbers less than 0, minus infinity is the greatest lower bound, right? So, essentially that is what you do. So, you define these arbitrary elements, this minus infinity and plus infinity or something like that, to say that it is bounded by these guys. And they may not even mean anything very meaningful for you, but they are just definitions. They are just saying that these elements exist. With the element set of integers, I union these two extra elements, infinity and minus infinity, and I say this is the subset set S that I want to work with, right? Good you brought it up. And we will do that business, actually. So, okay. Is an empty lattice a complete lattice? Yeah, again a matter of definitions. I just say that, okay, my meat of empty is empty and I mean join of empty is also empty. Done. I define it and I am out of that problem. Okay. The next is a notion of something called a distributive lattice, right? So, a lattice which allows the meat and join operators to distribute among themselves is referred to as a distributive lattice. So, the meat can distribute over the join and the join can distribute over the meat. So, if this happens, then this is referred to as a distributive lattice. So, lattices, because of this nice symmetry, there is this very interesting notion of duality. So, duality says that if I consistently rename things, like for instance, I just invert my relation. So, like I just flip my lattice, right? So, my GLB becomes my LUB, my LUB becomes my upper bound become my lower bounds, right? All definitions would still stand. Maybe I should say in a slightly different way. So, I am saying any statement I make about say upper bounds or least upper bounds, if I consistently rename things like joins by meats and upper bounds by lower bounds, least by upper, if I consistently rename them, then whatever theorem works on the meats and the upper bounds and like meats and the lower bounds and the greatest lower bounds that will also work on the joins and the upper bounds and the lowest upper bounds, right? So, there is this like other side you get it for free essentially. It is saying the whole thing is symmetric. Whatever happens upwards, very similar thing happens downwards, right? So, here also this is simply distributivity, simply duality. So, what I did was I consistently, so this was a theorem. So, I say some lattice is a distributive lattice if this holds. So, I can simply rename all my meats I just replace by joins and join my meat and that gives me the distributivity for the meats over joins and joins over meats, ok? So, the next notion is the notion of something known as a semi-lattice. In many applications, I really do not need both the join and the meat. I do not care if there a meat exists or not. Let us say if I have a join, I am good enough. The whole application on which this thing is based on that works. So, then why bother about the other side, right? So, we define a upper semi-lattice or a lower semi-lattice depending on, I just defined the conditions on one side. I say that every finite subset of elements must have an lub. That is all I care about. Then I have a upper semi-lattice. I do not say that thing. It should have both an lub and a glb. I do not say that. I just say that every element should have a lub. I am happy with it. They have a glb or not, I do not care. Right? So, it is a relaxed definition. So, it will allow other things to become semi-lattices which were not actually lattices, right? And that the reason is because I do not really care what happens on the other side. Similarly, I can do things for meats and I can say I have lower semi-lattices. So, now essentially the structure is only on one side. The other side there may not be any structure. Okay. So, any questions on lattices? So, I am just doing whatever is required to talk about data flow analysis. I will not go anywhere outside that. Right? So, but it is a very interesting mathematical structure. So, I would really encourage you to go back and read more on lattices and see how they are used in many disciplines in computer science. Are we good? Are we good with all definitions? Any questions? Let us discuss things on lattice if anything. Sir, even lattice is not possible. What programming? Yeah, yeah. I am not so much aware of that, but surely it is very much possible that there are applications there. Your model. I see. Possible, possible. So, essentially this is used for modelling problems into mathematics. So, any problem that you think needs this particular structure, you can just say that, okay, I need to need it to be a lattice and all the theorems you prove on this mathematical structure will hold on that. So, you can use all those theorems directly to prove your applied thing, whatever you are applying it to. Right? Okay. So, now next we come to what are called come to functions on lattices. Now, basically we have we talk about functions which operate on the elements in the lattice. Right? So, the first definition is about something called a monotonic function or a order preserving function. So, I say that f a function f is an monotonic function. If I pick two arbitrary elements x and y in my set, which are related by the ordering relation, then I can surely say that the results of applying the function f on those two elements will also be related by the order that by the same ordering relation. Right? So, essentially it means that it looks something like this. So, if you have an x and if you have a y, I know that they are related. So, I have an edge between them. If I apply f to x and I apply f to y f to y and f to x, then whatever I get. So, this would be f of y and this is f of x. These elements must surely also have an edge between them. Right? So, if my for any such x and y arbitrary elements x and y in my set, if my function f hold this property holds for my function f, then I say my function f is a monotonic function or an order preserving function. Very simple definition, but yeah. No, we do not know that relation. No, so essentially what I all I am saying is I know the relation between x and y. I am saying if I apply f to it, I do not know what f does. f can get x to somewhere upper for y it can go it somewhere below. I do not know what happens. Just f x and f y will have a relation under the same relation under the same relation r. Right? So, I do not know what happens between these two guys, but I just say that if these two guys were related, these two guys are surely going to be related as well. Agreed? Done? Yes, yes. So, I can pick any two elements x and y from my set S. Right? So, it should hold for any such x and y in my set X. So, if it holds for any domain of a function is this set S. So, if it works for any two elements in this domain, only then will I say that it is a not a preserving function. No, no, no. f x and f y are also elements in this set. Right? So, I am assuming my function f is closed. I mean let us let that makes things easier. So, let my domain and range of this function is the same set S. That is a easier thing to understand. So, then essentially I take x and y they also go somewhere in this set, but they will also be related by the same ordering relation. Right? So, I can say can you give me an example of an order preserving function? Plus by any constant addition with any constant that gives me an order preserving function. Multiplication by positive number, multiplication by negative number. It change the order between the elements. So, that is not order preserving. Right? As simple as that. Log order preserving. Right? So, things can get skewed right badly, but it is still like as long as I the resultant elements the order is the same I am good. So, next is commutativity of functions. So, I will say the functions f and g commute if I can apply them in any order and the result is the same. So, if I compute f of g of some x or g of f of x for any x then I would say that f and g commute not so important actually. This is important. So, this is this is distributivity of functions over joints. Right? So, if I say my function distributes over my joint which means that I can take the joint of my elements first and then apply the function on it or I can do it the other way I just get the images of all my elements and then take their joint. Both of them will give me the same result. If that happens I would say that it is a distributive function. See I have already switched to my semi lattice thing. I did not even talk about meat. So, we will now start living in semi lattices. So, the next topic is about fixed points. So, remember what was the definition of fixed point? I say that if I have an element E. So, who remembers the definition? Yes. So, if I say x 0 is a fixed point of some function f it means that if I apply x 0 to f I would end up getting x 0. So, what it means is that like if I have this element x 0 then I would get x 0. I apply f to it. It will go back and f of x 0 will again come back to the same point. So, the next definition is something called a prefix point. Prefix point means that if I have an x 0, I would get x 0. So, I would get x 0. So, I would get x 0. So, if I apply f to it, it will always jump to an element higher. So, now here we have this relation between the element and its image. Here we are saying that if I apply my f to this x 0 then it will always give me something larger than f 0. Similarly, I can come up with something called a postfix point which means that if I have an x 0 and if I apply x 0 to this I will end up getting an element which is lower than x 0. So, any questions till all this business? Now is the question why now is the place where we will start at looking at why we did we do so many definitions. For the fix point. It is a different x 0. So, I am saying so see here what did I say? I said that x 0 is the fix point of f. So, it is a relation between its both x 0 and f. So, I say x 0 is a fix point of f if I apply x 0 to f it gives me x 0 back. If it gives me something for some other x 0 or some other let us say x 1 if I apply f 0 and I if I apply f to it if I get something bigger then x 1 is a prefix point. If there is some x 2 if I apply f to x 2 if I get something lower then x 2 is a postfix point. Now of course, any element in this set I can classify it as a fix point prefix point or postfix point. So, note that fix points are both prefix points and postfix points this is less than equal to. So, if you diagrammatically want to see it looks like this. So, you have your bottom here you have your top here and all these things let us say these are all prefix points and all these are my postfix points. So, it should cover it properly. So, this is f and these are the elements which are my fix points. So, here if I apply f to any element it should climb higher if I apply anything to this it climbs lower goes lower and if I apply anybody to this it just stays there. So, now let us come to back to our data flow analysis let us come to our reaching definitions problem. So, now with all these things think of your set of data flow facts what was the set of set of data flow facts in reaching definitions? What was it what was it? Remember the what was the solution look like? What is it? Set of all definitions and what is it? What did we want to compute? At every point I wanted to compute what are the what is the reaching definitions reaching a particular point? So, think about the solution at let us say to begin with I have a very simple problem say simple analysis which is trying to compute the reaching definitions only for one variable in the program just to make things simpler we will see what happens to extended case. To begin with let us assume that I have only one variable in the program that I am interested in for computing the reaching definitions for that particular variable at a program point what all can be can the solutions look like? So, that is going to be my set of like my set S over which I am doing my computation I am trying to figure out let us go back. So, I am given a program point I would like to find out what will the solution at this location for reaching definitions look like? What will it look like? It is going to be. So, it is going to be a set of definitions right. So, what is the possible set of solutions from which this solution has to be extracted? So, now think of a like think more mathematically think about that I have extracting this particular solution D1 D5 right. So, what is this possible space of solutions from which I am extracting this particular solution? Which are which is all the? Not. So, let us let us take a set if you are having problem explaining. So, let us say D1 D2 D3 this is the set of elements this set of definitions then what is the set from which this particular solution will come out? Yes the power set of this right. So, what will that look like? It can either be empty set there is no definition reaching here or it can be single ten set there is either D1 or D2 or D3 coming here or it can be sets of twos D1 D2 D2 D3 these guys coming in now there is only one remaining or it can be the whole set D1 D2 D3 all definitions reach here right. So, this is my space of solutions from this solution I will eventually get one element which will be the solution at this particular program this is going to be my S from which I will get a solution. Now we will we are switching to a very abstract very mathematical domain right now we are not even. So, now this is a possible solution to the set of equations that I came about next time last class right. Now can I so can I think about how to put it. So, how do I how do I think so let us say this particular ok. So, think about this particular case. So, this particular at in of a particular basic block I am trying to compute this solution to begin with how did I initialize it empty right to begin with it was empty then I would have maybe one element one arm became something came from one arm maybe D1 came from one arm right then maybe D2 came from the other arm maybe this also changed and brought in D3 also. So, the set of val the set of elements from this set that you see here can you see some relation among those elements just try to think about how the this thing is growing how the elements the how this particular solution is changing at every iteration of my fixed point iteration. What is increasing size is increasing, but anything more can you see about the elements. So, let us say in one first time I got a solution S0 second time I got a solution S1 these are all subsets of S surely right can I find some relation between let us say these are S1 and S2 are different iterations agreed agreed this is going to be the case right you will never be able to pull out a definition remember that is what we argued about yesterday right you only union you are just unioning new definitions you are putting in new definitions. So, what so now subset looks to be a interesting relation to describe this to describe this computation right because every solution that I get every sequence of solutions that I get at a point are related by the subsetting relation on this on this set of solutions. Then for this particular set for this relation subset equal to can I come up with can you describe the lattice. So, for I want the lattice for less than under the subset relation. So, how will the lattice look like can you give me the hash diagram of the lattice. So, what is the bottom element empty set is going to be the bottom element then the singleton elements D1 D2 D3 then sets of two D1 D2 D1 D3 D2 D3 D3 D3 D3 D3 D3 D3 D3 D3 D3 D3 D3 D3 D3 D3 D3 and D2 D3 right and then the top element which is D1 D2 D3 agreed yeah, yes. the top element which is d1, d2, d3 agreed. Yes, yes, yeah, but that is exactly what we did. Last time the proof we gave was exactly this. We did not really set up it as an inductive proof but the argument was exactly that. Excellent, exactly. That is the next question I was going to put. So essentially all my solutions would form a chain in this lattice. See how beautiful the structure is now. So we came up with an ad hoc algorithm which was supposed to be doing something. I do not even know. Then I defined some abstract mathematical concepts which none of you had a clue why we are doing all this business. And then the problem essentially boils down to computing, essentially computing along a chain in this lattice. Now I am going too far. Okay, now you are going too far. Look who. Okay, so this is nice, right? Okay, there is more to it. The drama is not over yet. Now think about the case. Now think about the case. Now we talked about the over approximate solutions. Remember we talked about something called over approximation. What is over approximation? Yes, we can miss out on optimizations but it is still safe. Can you give me a structure on the over approximations possible on that set here? So my solution can be any of these sets here, right? So let us say my solution is D2. That is a big deal. Let us say D2 was my actual solution that I got. Can you tell me what are the over approximations of this particular set? How do I get this from this lattice? Upwards means what? Can you define it in terms of lattice theory whatever we learnt? Need not be. Yes. The upper bounds of this particular solution are my over approximations. If there are elements which are some people are still quizzical. Are you convinced? So upper bounds means what? It has this element but maybe something more. I see a quizzical face. I do not like it. Tell me. Over approximation in this case meant that what happens if I let us say I have a set of definitions. What if I say that there is an extra definition in that set though it was not there? Like for instance let us say the definition was D2 but I simply put another definition D1 in this and though D1 was not actually in the set is not actually a reaching definition. Let us say put it and say okay take this solution. The solver has a bug and gives you the solution. What does it do? So first there are two questions we were talking about yesterday. One question was about safety. Safety was about can my optimization go wrong? Remember the constant propagation application we were talking about. If I put a new element D1 in this set the algorithm will not go wrong. It will not do a transformation that will. So what? So otherwise what was happening was because D2 was a singleton set maybe it would have enabled an optimization. Maybe D2 was a singleton set and maybe D2 was something like x equals 5. Then it could have just pulled in that value 5 into the set into that computation. But because now with D1 also being the set it is no more a singleton set I cannot do that optimization. So I will not be able to enable the optimization but I will not do something which makes the program wrong. So the other thing was accuracy. So essentially what is happening is my accuracy is getting compromised but it is still safe. Think about the other situation. If I had a set D1 D2 actual mass solution was D1 D2 but if I somehow my solver does not give me D1. What about this? This is dangerous because let us say D1 was of the form x equals 5 D2 was of the form x equals 2 and both the definitions were reaching me. That was the actual solution. So I could not have done the optimization but because I disallowed D1 I only see one reaching definition which is x equals 2 and I say do the optimization. Looks good to me. That will make my program wrong. So it is not safe anymore. So yes the bad solution is the inaccurate solution which is the larger set and bad because it is not able to let me do the optimization. It is stopping me from doing an optimization. But the unsafe solution is bad because it can make the program go wrong. So it is not even a solution to be very frank because I cannot even allow that. So now as you can see all the upper bounds of this actual solution will be a superset of that. That is my relation on which I am doing the construction of this lattice. It means that it will surely have the set of definitions that are in the actual solution plus maybe something more. So they are all going to be over approximate. They are all going to be inaccurate but all sound solutions, all safe solutions. So all safe solutions are my upper bounds of my optimal solution, my best solution. Now staring at you at this can you give me a constant time algorithm to compute the reaching definitions which gives me a safe solution. This is sort of half a joke but think about it. Upper bound but which one? But I need to know the solution first to get the least So how can I give you in constant time I can give you a solution. The top element. Say everything reaches everywhere, done. No optimization will be enabled anywhere but it is a safe solution and it is a solution. So I can always take the top element and say oh here is a solution. So now the other thing is that. So now let us look at the nature of this computation here. There are too many curves here. So now let us try to look at the nature of this what is happening at this basic block at this program point. So there are there is some solutions coming from here. There are some solutions coming from here and they are getting combined. Can you visualize that what is happening on this lattice? What is really going on? What am I doing? How do I combine? Join. So I take the join of the solutions from my left arm and my right arm. So this is how we like compute the next solution on my this set. That is the other question. So let us yeah I will just take that up now. So now essentially you can see that. So essentially to get the new solution I always take the join of these elements along these two points. So okay I kept on saying meet of elements but I am switching to saying join of elements now. Do not get confused. Duality. As long as I am consistent I say meet or I say join it is the same thing. Do not get confused. So actually in the data flow literature people were talking about computing in the other direction actually going starting with top and going down and slightly newer there is a framework of abstract interpretation where people do it sort of the other way. So I will use I will consistently use the other notation where we always go up as we compute solution. We will go up the chain. So I will talk about the I will only talk about the taking a join. I will not talk about taking a meet. So even if I say meet please rephrase it to join. It is just the same does not matter. I am only concerned with like one side of it. I am only concerned with the semi lattice. I do not bother about if it is a upper semi lattice or bottom semi lattice. So correspondingly I will use meet and join. So now so the next thing is that so every time what is happening is remember the nature of our computation. The nature of our computation was that I had this set of in and outs for each basic block and I had this function which was a function corresponding to each of these elements and every time I was computing the new element. So now so you guys said already said that we are we follow this particular chain. We follow a chain. So this guy will only see values in a certain chain. So why is that the case? Why is it happening that I will only take values in that chain under what? Solution set cannot be monotonically increasing. Something else has to be. How? Why? Why? Why are they lucky? Why are they on the chain? What is what is making them beyond the chain? Why is it the case? So let us try to write the solution here. The function that is coming here. What does this function look like? What is this function? This is the in of a basic block. So how do I compute the in of a basic block? I take a union of the predecessors of B and out of that. If I expand upon this then what is out of B? Out of P? It is nothing but gen of P minus kill of P sorry in of P minus kill of P plus gen of P. So if you think about the whole function that is happening is it is basically two functions. One is this function which come to my transfer function which essentially looks like out is equal to and my meet function or the join function which joins the values. So my computation is happening under this transfer function. Same with gen right? Gen also does not change. Only chain that changes is in and out. That is fine but what can you say about the nature of this function now? Yeah that any function should be always be the same on the same value. You are on the right track. Now think about in terms of whatever definition we learnt. What type of function is this? No, no, no. It is a order of assuming function. So if I add a new thing to in that is that can only be equal to or greater than the previous out that I got. Because my kill and my gen sets are constant for a given basic block they are constants. They do not change. So what can happen is if a new definition sneaks into in so either my out remains the same if that gets killed let us say right or it can increase because that new definition can also get inside this. So if the previous output without the with the old value of in was let us say less than out the same will be preserved even for the new values or the other way round whatever it is. And because there is a loop this whole thing is so the whole so the total function that is reaching here for this computation is sort of a you can think of that as a composition of these all the functions in the on that line. So compositions of order preserving functions that is what we are sort of computing. Number of loops into because every iteration of my while loop I do multiple updates of my basic blocks like multiple basic blocks can get updated. No are you assuming order on the iteration of the basic blocks the best order. So then what yes yes yes so no loop does not it should one shot it should get terminate it should terminate. So let us pull this question so now if there is no loop how many iterations of the while loop will be there. Two why two yes yes first move to compute the values the second to check the values do not change. So the last iteration is always going to the check loop which will just see that nothing changed okay I am good. So the flag will be set flag will not get set and it will come out right two iterations. What if there is a loop then as you said whatever got computed to the last that the bottom of the loop that will get propagated to the head of the loop again. So very very very good point so essentially what it depends on is something known as the loop depth. The loop depth looks like this so essentially it says that if you have back edges what if you have sequence of such back edges then the first iteration one of them will get fine but the second time whatever got propagated here will get propagated here and the again the same thing will happen. So it depends on the loop depth and interestingly in this case not on the size of the set of the definitions how many definitions are there. Assuming that we are assuming that the updates on those sets are constant like the transfer function I can apply in constant time right excellent really happy. So okay so now the business is that we are here and so it looks like our function is a order preserving function a monotonic function and we seem to be going along a chain right by that will happen right because you are so okay. So can you see the connection of why we did all this business why we talked about lattice theory because now you can put a lot more structure to the type of computation that is happening. It does not look like that insane some weird computation that is happening this actually has a lot of structure in it there is a very deep mathematical structure to how the solution is be computed right. So these all we have answered very busy expressions again you guys can figure it out so I will not bore you with this now. So what is the this thing here it is the very similar thing so the set is the power set of the expressions right and you have to think which ordering relation they are ordered now what is the bottom element. So one more small thing maybe that will help you think and what did I initialize my lattice with my solution with to begin with empty empty is what here the bottom of the lattice so looks like what we are doing is initializing our solution with the bottom of the lattice and applying some order preserving transfer function which looks to be giving me the best solution I do not know why it happens looks like that is happening is not it ok. So now let us talk about very busy expressions so very busy expressions just to make sure tell you that this was not a fluke looks to be the pattern looks to be consistent a very busy expression what was the lattice can you think about what the lattice would be. So very busy expression was doing what it was trying to compute the it was a all path or a any path solution all path so what should I initialize it with the universal set right and then every time my solution will happen what will happen to the solution decrease right because something will because of the intersection something will be thrown out right the transfer function will kill something and something will reduce an intersection will throw that part out in the for the next guy. So if I want to create a chain for this what would the chain look like yes so it will start with the set of expressions now so we have this set of all expressions then I will have the 3 3 yeah right something like this then I will have what this guy will be what which what will be this element yeah so intersection of these two is what e 2 e 3 then so on and finally you will have the empty set here so now can so now your set is the set of all expressions e 1 e 2 e n and what is my relation my ordering relation hey look at it right so now I am doing my computation is on this lot of people don't like this symbol actually I was little scared like writing it but you can and let us write it yes yes so now do I see the same pattern again we initialize our computation with the bottom of my lattice and keep on applying the transfer function which reaches a particular solution and are all my other candidates all the other possible solutions are they over approximations are my upper bound still in over approximations empty set is an over approximation so nothing is busy don't do that optimization fine right so see there is so much of structure in all these problems right so now it has become very simple matter of figuring out the lattice which means figuring out the set over which I am doing this computation what what does my space of solutions look like and how are they structured right by what operation are they structured and just by telling by by just knowing that and figuring out the nature of my transfer function is it a order preserving transfer function if that is the case I can simply say that the way I should do this computation is initialize my computation at the bottom of the lattice and keep on applying this order for the transfer function till you reach a solution any upper bound on that is going to be an over approximation which says which you can as well take I don't care so now there are few questions remaining one is that why does it happen that so first is that for such a lattice is it given guaranteed that a solution would exist all the questions we were posing yesterday the second is now you should not think about only these four problems we had talked about two other problems yesterday we have talked about constant propagation and we have talked about interval analysis right so we have even talked about other problems so for constant propagation what would the lattice look like no constant to all constant where are the constants the set was what what is the set of values I could have assigned to any location it could be either not constant or don't know or the set of all constants 1 2 whatever right this was a set of values I was working on right so how would what the lack what would the lattice for this look like I know I know so what should the lattice look like what should the computation on the lattice look like okay don't know people like don't know to be at the bottom because we initialize again to don't know again you should actually so don't know then what to non-constant then don't know to constant okay and constant to non-constant right but this is a hasher diagram right so we don't we get rid of transit dependencies do you see a transit dependency here don't know to non-constant right that is also represented by this particular relation right don't know to a constant to don't know not constant so that implies that don't know to not constant will be related so I can get rid of that right so my lattice essentially then looks like this I mean you guys are right but it is just that my hasher diagram does not allow me to keep transit dependencies this is my constant propagation lattice and remember we said we can make only two updates at most worst case was it in terms of the lattice what is it it is the height of this lattice so height of the lattice is the can you define it formally many on the lattice there is no operation it is the length of the longest chain excellent right the height is the length of the longest chain in the lattice right so looks to be that is the that is what was like telling me how long you have to go and good good good good good so okay but one thing is that this is a this is a constant propagation lattice for a single variable right so I will have this lattice for some variable x similarly I will have another lattice for y and so on what will the actual solution the lattice of the actual solution look like yeah so how do I get it so initial will be all don't knows right right so one of them one constant becomes one other don't knows remain this becomes can become two similarly some other guy can change so this is essentially the product lattice of the lattices of the single variables how do you construct the product lattice you basically take all possible combinations so you have you just lay down the lattices for each of the variables separately x y z w and then take all combinations right and when can you put a edge between two elements in that product lattice whenever there is a corresponding edge for each of these cases each of the elements in the tuple then only is that related like for instance like bottom bottom one bottom bottom and bottom one bottom bottom bottom I don't know how many I put here one two three four five looks like it I am done so so bottom is nothing but don't know I am just writing bottom so now are they related are these two related huh why no no no so now if you not think I just talking about that these elements in this forget the constant propagation problem now right think about the mathematical description of these points so this is a point this is also a point they are they are both of them belong to the set S right so these are two arbitrary points question is should we have a so this is what I got by taking the product of five such component lattices so now the question is are do these two elements relate can these two elements relate again again please don't think about the problem so the function also is not in the in the this thing now I mean we don't even have the I'm not even talking about the function right now what function what is the transform function I'm not even talking about it I'm just saying that this is the space of our solutions right this is a element of that solution solution space this is also an element of the solution space it's possible that you get either that as a solution or this as a solution so I'm I'm just picking a set I'm describing a lattice by describing a set and describing a relation on it right I'm not even talking about what function we are using both of these are points in that space both of them are elements of s now I want to say that this ordinate relation now what does that this order relation look like now this s itself looks like multiple like an element corresponding to multiple elements like whatever you would have got for s of x s of y s of z and so on right because it's a product lattice you are allowed to pick elements from each of these things what will this order relation look like this is a component by component ordering relation so this will say this is a ordering on x ordering on y ordering on z something like that and the final ordering is if there is a ordering established by all of them so here what is the problem that this one is larger than bottom for the second component but here this bottom is smaller than this one so one of the relation hits the other one misses so I cannot say that this is less than this right if all of them consistently are less then I can say this whole element is less than this whole element so just imagine this big lattice in your head I don't want to write it so the elements they look like this and the bottom element is all bottoms the top element is all not constants why is that because not constants to all of them will surely be bigger than not constant or any of them right so it will surely be a superset of an upper bound of that got it so now let's again revisit this look at this particular lattice this power lattice I got now this can be decomposed into lattices corresponding to each definitions and lattice corresponding to each definition will be what either it is true or it is false is given in the set or given is not in the set so this big lattice is nothing but the power lattice of this right okay so I think we are getting too abstract so what was a big vector a big vector was just represented that an element was there or the element was not there the big vector was either 0 or 1 right so 0 is lesser than 1 so my lattice is very simple my lattice is 0 and 1 that is my lattice for every definition di right now I can simply get the power of the product lattice by picking zeros or one for the corresponding definitions once I pick that that becomes one set that set will be part of this big lattice somewhere and I can exactly use the same thing and the ordering is the subset relation is nothing but that right key it has to be like either 0 or 1 of the corresponding elements like greater than the corresponding elements right so you would also start thinking about them as like component lattices what happens to them when they compose so on so there are some more interesting things about it actually so actually the computation just happens of because it is a separable problem the computation only happens on this component lattice almost in parallel for each of the component lattices almost in parallel so actually you are not computing directly on this big lattice you are actually computing on these binary lattices almost in parallel no almost in parallel because and it is possible because it is a separable problem what happens in case of constant propagation it was not a separable problem because it is not separable problem there will be interaction across the lattices and that is why this product it is actually computing on the product lattice and that is why the height of the lattice comes into the picture because it is the height of the lattice and the number of variables that can also affect it right so the so let us say there is a big dependence chain across a set of lot of variables so the there is a now the first variable to stabilize will take three steps two steps that can affect the second variable again it might take two steps might affect the third variable so it is a chain on how many variables are there and and this power lattice can construct I mean has all of them the height of the power lattice think about it it captures both of it so when we are doing constant propagation we are actually computing on this power lattice not power lattice product lattice okay so I think we will again go back to maths after this so but I see I hope you have seen some connection between why we did all this business so there is such a beautiful structure to the computation that we are doing right it has a completely beautiful mathematical description of what we are doing look like complete ad hoc algorithm but no that is not true so I think I can stop here