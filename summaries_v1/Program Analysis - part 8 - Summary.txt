 Dynamic Analysis:
Dynamic analysis is a method of testing and analyzing software by observing its behavior during runtime. Unlike static analysis, which examines the code without executing it, dynamic analysis involves executing the program and monitoring its activity. This allows analysts to identify issues such as security vulnerabilities, performance bottlenecks, and incorrect functionality.

Profiling:
Profiling is a type of dynamic analysis that measures various metrics of a program’s execution, such as CPU usage, memory consumption, and I/O activity. This information can be used to optimize the program’s performance, diagnose bugs, and evaluate its resource requirements. Control flow profiling is a specific type of profiling that counts how many times each basic block in the program is executed.

Histogram:
A histogram is a visual representation of data distribution, commonly used in statistics. In the context of dynamic analysis, a histogram can be used to display the frequency of basic block execution.

Control Flow Graph (CFG):
A CFG is a directed graph that describes the flow of control in a program. Each node in the graph represents a basic block, and each edge represents a possible control flow path between basic blocks.

Basic Block:
A basic block is a straight-line piece of code without any branches or jumps. It starts with a label and ends with a jump, branch, or fallthrough to the next basic block. Basic blocks are fundamental units of control flow in a program.

LLVM:
LLVM is an open-source compiler infrastructure project that includes a collection of modular and reusable compiler components. It supports multiple programming languages and targets various hardware platforms.

Bytecode:
Bytecode is a low-level, platform-independent code generated by a compiler. It is designed to be executed efficiently by a virtual machine.

GEP Instruction:
GEP stands for “Get Element Pointer.” It is an instruction in the LLVM intermediate representation that calculates the address of an object in memory based on its base address and an offset.

Buffer Overflow:
A buffer overflow occurs when a program attempts to write more data to a buffer than it can hold. This can cause nearby memory locations to be overwritten, potentially leading to security vulnerabilities or unexpected behavior.

Address Sanitizer:
Address Sanitizer is a fast memory error detector developed by Google. It helps developers find memory bugs such as buffer overflows, use-after-free, and memory leaks. Address Sanitizer instruments the program’s code to monitor memory access patterns and reports errors when it detects violations.

Aloka Instruction:
Aloka is an instruction in the LLVM intermediate representation that allocates memory on the stack or heap. It reserves space for a specified number of bytes and returns a pointer to the allocated memory.

GEP Instruction:
GEP stands for “Get Element Pointer.” It is an instruction in the LLVM intermediate representation that calculates the address of an object in memory based on its base address and an offset.

Store Instruction:
A store instruction writes a value to a specified memory location.

Trigger Fault:
Triggering a fault refers to intentionally causing an error condition during program execution to test how the software handles it. In this case, the instructor discusses triggering a fault when a buffer overflow occurs.

Heap:
The heap is a region of memory managed by the operating system where dynamic memory allocation takes place. Programs request memory from the heap as needed, and the memory manager tracks which portions are in use and which are free.

Malloc:
Malloc is a standard library function in C and C++ that allocates memory on the heap. Developers can use malloc to reserve a block of memory of a specified size and obtain a pointer to the newly allocated memory.

Free:
Free is a standard library function in C and C++ that releases memory previously allocated by malloc. Developers pass the pointer returned by malloc to the free function to deallocate the memory.

Modified Versions of Malloc and Free:
When performing dynamic analysis, analysts may choose to replace the default malloc and free functions with custom versions that provide additional functionality, such as tracking memory usage or checking for memory errors. These custom versions can be inserted into the program to enhance the analysis capabilities.